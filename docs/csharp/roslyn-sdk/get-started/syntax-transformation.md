---
title: Sözdizimi dönüştürme (Roslyn API) ile çalışmaya başlama
description: Çapraz geçiş yapma, sorgulama ve sözdizimi ağaçları taramasını giriş.
ms.date: 06/01/2018
ms.custom: mvc
ms.openlocfilehash: 04053645b91e8f74e890340fb9bba66a4efdce0c
ms.sourcegitcommit: 2ad7d06f4f469b5d8a5280ac0e0289a81867fc8e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/08/2018
ms.locfileid: "35231635"
---
# <a name="get-started-with-syntax-transformation"></a><span data-ttu-id="25c6d-103">Sözdizimi dönüştürme ile çalışmaya başlama</span><span class="sxs-lookup"><span data-stu-id="25c6d-103">Get started with syntax transformation</span></span>

<span data-ttu-id="25c6d-104">Bu öğretici kavramlara oluşturur ve teknikleri incelediniz [sözdizimi Analizi ile çalışmaya başlama](syntax-analysis.md) ve [semantik analizi ile çalışmaya başlama](semantic-analysis.md) quickstarts.</span><span class="sxs-lookup"><span data-stu-id="25c6d-104">This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts.</span></span> <span data-ttu-id="25c6d-105">Henüz yapmadıysanız, bunu başlamadan önce bu hızlı başlangıçların tamamlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="25c6d-105">If you haven't already, you should complete those quickstarts before beginning this one.</span></span>

<span data-ttu-id="25c6d-106">Bu hızlı başlangıç oluşturma ve sözdizimi ağaçları dönüştürme teknikleri keşfedin.</span><span class="sxs-lookup"><span data-stu-id="25c6d-106">In this quickstart, you explore techniques for creating and transforming syntax trees.</span></span> <span data-ttu-id="25c6d-107">İçinde önceki quickstarts öğrenilen teknikleri ile birlikte, ilk komut satırı yeniden düzenleme oluşturun!</span><span class="sxs-lookup"><span data-stu-id="25c6d-107">In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="immutability-and-the-net-compiler-platform"></a><span data-ttu-id="25c6d-108">Girişi ve .NET derleyici platformu</span><span class="sxs-lookup"><span data-stu-id="25c6d-108">Immutability and the .NET compiler platform</span></span>

<span data-ttu-id="25c6d-109">**Girişi** .NET derleyici platformu, temel bir ilkesidir.</span><span class="sxs-lookup"><span data-stu-id="25c6d-109">**Immutability** is a fundamental tenet of the .NET compiler platform.</span></span> <span data-ttu-id="25c6d-110">Sabit veri yapılarını bunlar oluşturduktan sonra değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="25c6d-110">Immutable data structures can't be changed after they're created.</span></span> <span data-ttu-id="25c6d-111">Sabit veri yapılarını güvenli bir şekilde paylaşılan ve aynı anda birden çok tüketiciler tarafından analiz.</span><span class="sxs-lookup"><span data-stu-id="25c6d-111">Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.</span></span> <span data-ttu-id="25c6d-112">Bu tek bir tüketici başka tahmin edilemeyen şekillerde etkiler tehlike yoktur.</span><span class="sxs-lookup"><span data-stu-id="25c6d-112">There's no danger that one consumer affects another in unpredictable ways.</span></span> <span data-ttu-id="25c6d-113">Çözümleyicisi kilitleri ya da diğer eşzamanlılık ölçüleri gerekmez.</span><span class="sxs-lookup"><span data-stu-id="25c6d-113">Your analyzer doesn't need locks or other concurrency measures.</span></span> <span data-ttu-id="25c6d-114">Bu kural sözdizimi ağaçları, derlemeleri, simgeler, anlam modellerine ve karşılaştığınız her veri yapısı için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="25c6d-114">This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.</span></span> <span data-ttu-id="25c6d-115">Varolan yapıları değiştirme yerine API'ler belirtilen farklar eski olanlara göre yeni nesneler oluşturur.</span><span class="sxs-lookup"><span data-stu-id="25c6d-115">Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.</span></span> <span data-ttu-id="25c6d-116">Bu kavram dönüştürmeleri kullanma yeni ağaçları oluşturmak için sözdizimi ağacı için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="25c6d-116">You apply this concept to syntax trees to create new trees using transformations.</span></span>

## <a name="create-and-transform-trees"></a><span data-ttu-id="25c6d-117">Oluşturma ve ağaçları dönüştürme</span><span class="sxs-lookup"><span data-stu-id="25c6d-117">Create and transform trees</span></span>

<span data-ttu-id="25c6d-118">Sözdizimi dönüştürmeleri için iki stratejiler birini seçin.</span><span class="sxs-lookup"><span data-stu-id="25c6d-118">You choose one of two strategies for syntax transformations.</span></span> <span data-ttu-id="25c6d-119">**Fabrika yöntemleri** değiştirmek için belirli düğümler veya yeni kod eklemek istediğiniz belirli konumlara aradığınız olduğunda en iyi şekilde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="25c6d-119">**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.</span></span> <span data-ttu-id="25c6d-120">**Yazıcılar** olan kodu, desenler için tüm proje tarama istediğinizde iyi değiştirmek ister.</span><span class="sxs-lookup"><span data-stu-id="25c6d-120">**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.</span></span>

### <a name="create-nodes-with-factory-methods"></a><span data-ttu-id="25c6d-121">Fabrika yöntemleriyle düğümleri oluşturma</span><span class="sxs-lookup"><span data-stu-id="25c6d-121">Create nodes with factory methods</span></span>

<span data-ttu-id="25c6d-122">İlk sözdizimi dönüştürme Fabrika yöntemleri gösterir.</span><span class="sxs-lookup"><span data-stu-id="25c6d-122">The first syntax transformation demonstrates the factory methods.</span></span> <span data-ttu-id="25c6d-123">Değiştir oluşturacağız bir `using System.Collections;` deyimiyle bir `using System.Collections.Generic;` deyimi.</span><span class="sxs-lookup"><span data-stu-id="25c6d-123">You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="25c6d-124">Bu örnek nasıl oluşturacağınızı gösterir <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> kullanarak nesneleri <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> Fabrika yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="25c6d-124">This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods.</span></span> <span data-ttu-id="25c6d-125">Her tür için **düğümü**, **belirteci**, veya **trivia** bu türünün bir örneği oluşturan bir Üreteç yöntemi yoktur.</span><span class="sxs-lookup"><span data-stu-id="25c6d-125">For each kind of **node**, **token**, or **trivia** there's a factory method that creates an instance of that type.</span></span> <span data-ttu-id="25c6d-126">Hiyerarşik olarak aşağıdan yukarıya çıktısından düğümler tarafından sözdizimi ağaçları oluşturun.</span><span class="sxs-lookup"><span data-stu-id="25c6d-126">You create syntax trees by composing nodes hierarchically in a bottom-up fashion.</span></span> <span data-ttu-id="25c6d-127">Ardından, var olan dönüştürme program varolan düğümleri oluşturduğunuz yeni bir ağacı ile değiştirerek.</span><span class="sxs-lookup"><span data-stu-id="25c6d-127">Then, you'll transform the existing program be replacing existing nodes with the new tree you've created.</span></span>

<span data-ttu-id="25c6d-128">Visual Studio'yu açın ve yeni C# oluşturma **tek başına kod analizi aracı** projesi.</span><span class="sxs-lookup"><span data-stu-id="25c6d-128">Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="25c6d-129">Visual Studio'da, **dosya** > \**yeni* > **proje** yeni proje iletişim kutusu görüntülemek için.</span><span class="sxs-lookup"><span data-stu-id="25c6d-129">In Visual Studio, choose **File** > \**New* > **Project** to display the New Project dialog.</span></span> <span data-ttu-id="25c6d-130">Altında **Visual C#** > **genişletilebilirlik** seçin bir **tek başına kod analizi aracı**.</span><span class="sxs-lookup"><span data-stu-id="25c6d-130">Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="25c6d-131">Bu hızlı başlangıç iki örnek proje yok, bu nedenle çözüm adı **SyntaxTransformationQuickStart**ve proje adı **ConstructionCS**.</span><span class="sxs-lookup"><span data-stu-id="25c6d-131">This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**.</span></span> <span data-ttu-id="25c6d-132">**Tamam**'ı tıklatın.</span><span class="sxs-lookup"><span data-stu-id="25c6d-132">Click **OK**.</span></span>

<span data-ttu-id="25c6d-133">Bu proje kullanıyor <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> sınıfı yöntemlerinin oluşturmak için bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> temsil eden `System.Collections.Generic` ad alanı.</span><span class="sxs-lookup"><span data-stu-id="25c6d-133">This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="25c6d-134">Aşağıdakileri ekleyin using yönergesi üstüne `Program.cs` Fabrika yöntemlerini içeri aktarmak için dosya <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> sınıfı ve yöntemlerinin <xref:System.Console> böylece bunları daha sonra uygun olmadan kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="25c6d-134">Add the following using directive to the top of the `Program.cs` file to import the factory methods of the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> class and the methods of <xref:System.Console> so that you can use them later without qualifying them:</span></span>

[!code-csharp[import the SyntaxFactory class](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings "import the Syntax Factory class and the System.Console class")]

<span data-ttu-id="25c6d-135">Oluşturacağınız **adı sözdizimi düğümleri** temsil eden ağaç oluşturmak için `using System.Collections.Generic;` deyimi.</span><span class="sxs-lookup"><span data-stu-id="25c6d-135">You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="25c6d-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> C# ' ta görünen adları dört tür için temel sınıftır.</span><span class="sxs-lookup"><span data-stu-id="25c6d-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#.</span></span> <span data-ttu-id="25c6d-137">Bu dört tür adları birlikte C# dilinde görünebilir herhangi bir ad oluşturmak için Oluştur:</span><span class="sxs-lookup"><span data-stu-id="25c6d-137">You compose these four types of names together to create any name that can appear in the C# language:</span></span>

* <span data-ttu-id="25c6d-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, basit tek tanımlayıcı adları gibi temsil eden `System` ve `Microsoft`.</span><span class="sxs-lookup"><span data-stu-id="25c6d-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.</span></span>
* <span data-ttu-id="25c6d-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, temsil eden bir genel türü veya yöntemi adı gibi `List<int>`.</span><span class="sxs-lookup"><span data-stu-id="25c6d-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.</span></span>
* <span data-ttu-id="25c6d-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, formun tam adını temsil eden `<left-name>.<right-identifier-or-generic-name>` gibi `System.IO`.</span><span class="sxs-lookup"><span data-stu-id="25c6d-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.</span></span>
* <span data-ttu-id="25c6d-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, diğer adı bu tür bir derleme extern kullanarak adı temsil eden bir `LibraryV2::Foo`.</span><span class="sxs-lookup"><span data-stu-id="25c6d-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.</span></span>

<span data-ttu-id="25c6d-142">Kullandığınız <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> yöntemi oluşturmak için bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> düğümü.</span><span class="sxs-lookup"><span data-stu-id="25c6d-142">You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node.</span></span> <span data-ttu-id="25c6d-143">Aşağıdaki kodu ekleyin, `Main` yönteminde `Program.cs`:</span><span class="sxs-lookup"><span data-stu-id="25c6d-143">Add the following code in your `Main` method in `Program.cs`:</span></span>

[!code-csharp[create the system identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName "Create and display the system name identifier")]

<span data-ttu-id="25c6d-144">Önceki kod oluşturur bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> nesne ve değişkenine atar `name`.</span><span class="sxs-lookup"><span data-stu-id="25c6d-144">The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`.</span></span> <span data-ttu-id="25c6d-145">Birçok Roslyn API'leri iş ile ilgili türleri kolaylaştırmak için temel sınıflar döndür.</span><span class="sxs-lookup"><span data-stu-id="25c6d-145">Many of the Roslyn APIs return base classes to make it easier to work with related types.</span></span> <span data-ttu-id="25c6d-146">Değişkeni `name`, bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, oluşturma gibi yeniden <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="25c6d-146">The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="25c6d-147">Tür çıkarımı örneği oluşturmak gibi kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="25c6d-147">Don't use type inference as you build the sample.</span></span> <span data-ttu-id="25c6d-148">Bu proje bu adımda otomatikleştirmek.</span><span class="sxs-lookup"><span data-stu-id="25c6d-148">You'll automate that step in this project.</span></span>

<span data-ttu-id="25c6d-149">Adı oluşturduğunuzu düşünün.</span><span class="sxs-lookup"><span data-stu-id="25c6d-149">You've created the name.</span></span> <span data-ttu-id="25c6d-150">Şimdi, daha fazla düğüm ağacına oluşturarak oluşturmak için zaman olan bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="25c6d-150">Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="25c6d-151">Yeni ağaç kullanan `name` adı ve yeni bir solundaki olarak <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> için `Collections` ad alanı sağ tarafındaki olarak <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span><span class="sxs-lookup"><span data-stu-id="25c6d-151">The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="25c6d-152">Aşağıdaki kodu ekleyin `program.cs`:</span><span class="sxs-lookup"><span data-stu-id="25c6d-152">Add the following code to `program.cs`:</span></span>

[!code-csharp[create the collections identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName "Build the System.Collections identifier")]

<span data-ttu-id="25c6d-153">Kodu yeniden çalıştırın ve sonuçlarını görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="25c6d-153">Run the code again, and see the results.</span></span> <span data-ttu-id="25c6d-154">Kodun temsil ettiği düğümler ağacı oluşturmakta olduğunuz.</span><span class="sxs-lookup"><span data-stu-id="25c6d-154">You're building a tree of nodes that represents code.</span></span> <span data-ttu-id="25c6d-155">Derleme için bu deseni devam edeceğiz <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> ad alanı için `System.Collections.Generic`.</span><span class="sxs-lookup"><span data-stu-id="25c6d-155">You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`.</span></span> <span data-ttu-id="25c6d-156">Aşağıdaki kodu ekleyin `Program.cs`:</span><span class="sxs-lookup"><span data-stu-id="25c6d-156">Add the following code to `Program.cs`:</span></span>

[!code-csharp[create the full identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace "Build the System.Collections.Generic identifier")]

<span data-ttu-id="25c6d-157">Yeniden, olduğunuz yapı eklemek için kodu için ağacı görmek için programını çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="25c6d-157">Run the program again to see that you've build the tree for the code to add.</span></span>

### <a name="create-a-modified-tree"></a><span data-ttu-id="25c6d-158">Değiştirilen ağacı oluşturma</span><span class="sxs-lookup"><span data-stu-id="25c6d-158">Create a modified tree</span></span>

<span data-ttu-id="25c6d-159">Bir ifade içeren bir kısa sözdizimi ağacı temel aldık.</span><span class="sxs-lookup"><span data-stu-id="25c6d-159">You've built a small syntax tree that contains one statement.</span></span> <span data-ttu-id="25c6d-160">Yeni bir düğüm oluşturmak için tek deyimleri veya diğer küçük kod blokları oluşturmak için doğru seçim apı'leridir.</span><span class="sxs-lookup"><span data-stu-id="25c6d-160">The APIs to create new nodes are the right choice to create single statements or other small code blocks.</span></span> <span data-ttu-id="25c6d-161">Ancak, daha büyük kod bloklarını oluşturmak için düğümleri değiştirin veya varolan bir ağacına düğümlerini eklemek yöntemleri kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="25c6d-161">However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.</span></span> <span data-ttu-id="25c6d-162">Sözdizimi ağacı değişmez olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="25c6d-162">Remember that syntax trees are immutable.</span></span> <span data-ttu-id="25c6d-163">**Sözdizimi API** yapım sonra varolan bir sözdizimi ağacında değiştirmek için herhangi bir mekanizma sağlamaz.</span><span class="sxs-lookup"><span data-stu-id="25c6d-163">The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction.</span></span> <span data-ttu-id="25c6d-164">Bunun yerine, yeni ağaçları var olanları değişikliklere göre üretmek yöntemleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="25c6d-164">Instead, it provides methods that produce new trees based on changes to existing ones.</span></span> <span data-ttu-id="25c6d-165">`With*` yöntemleri öğesinden türetilen somut sınıflar tanımlanmış <xref:Microsoft.CodeAnalysis.SyntaxNode> veya bildirilen genişletme yöntemleri <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="25c6d-165">`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class.</span></span> <span data-ttu-id="25c6d-166">Bu yöntemler, var olan bir düğümün alt özelliklerine değişiklikleri uygulayarak yeni bir düğüm oluşturun.</span><span class="sxs-lookup"><span data-stu-id="25c6d-166">These methods create a new node by applying changes to an existing node's child properties.</span></span> <span data-ttu-id="25c6d-167">Ayrıca, <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> genişletme yöntemi, bir alt ağacı alt düğümünde değiştirmek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="25c6d-167">Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree.</span></span> <span data-ttu-id="25c6d-168">Bu yöntem aynı zamanda yeni oluşturulan alt işaret edecek şekilde üst güncelleştirir ve bu işlem tüm ağacı - olarak da bilinen bir işlem yinelenir _re spining_ ağacı.</span><span class="sxs-lookup"><span data-stu-id="25c6d-168">This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spining_ the tree.</span></span>

<span data-ttu-id="25c6d-169">(Küçük) programının tamamını temsil eden bir ağaç oluşturmak ve sonra değiştirmek için sonraki adım olacaktır.</span><span class="sxs-lookup"><span data-stu-id="25c6d-169">The next step is to create a tree that represents an entire (small) program and then modify it.</span></span> <span data-ttu-id="25c6d-170">Aşağıdaki kodu başlangıcına ekleyin `Program` sınıfı:</span><span class="sxs-lookup"><span data-stu-id="25c6d-170">Add the following code to the beginning of the `Program` class:</span></span>

[!code-csharp[create a parse tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode "Create a tree that represents a small program")]

> [!NOTE]
> <span data-ttu-id="25c6d-171">Kod örneği kullanan `System.Collections` ad alanı ve `System.Collections.Generic` ad alanı.</span><span class="sxs-lookup"><span data-stu-id="25c6d-171">The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="25c6d-172">Ardından, altına aşağıdaki kodu ekleyin `Main` yöntemi metni ayrıştırma ve bir ağaç oluşturmak için:</span><span class="sxs-lookup"><span data-stu-id="25c6d-172">Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:</span></span>

[!code-csharp[create a parse tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree "Create a tree that represents a small program")]

<span data-ttu-id="25c6d-173">Bu örnekte <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> yöntemi adını değiştirmek için bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> önceki kodda oluşturulan bir düğümle.</span><span class="sxs-lookup"><span data-stu-id="25c6d-173">This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.</span></span>

<span data-ttu-id="25c6d-174">Yeni bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> düğümünü kullanarak <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> güncelleştirmek için yöntemi `System.Collections` önceki kodda oluşturulan adıyla adı.</span><span class="sxs-lookup"><span data-stu-id="25c6d-174">Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code.</span></span> <span data-ttu-id="25c6d-175">' In altına aşağıdaki kodu ekleyin `Main` yöntemi:</span><span class="sxs-lookup"><span data-stu-id="25c6d-175">Add the following code to the bottom of the `Main` method:</span></span>

[!code-csharp[create a new subtree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing "Create the subtree with the replaced namespace")]

<span data-ttu-id="25c6d-176">Programını çalıştırın ve çıktıyı dikkatle inceleyin.</span><span class="sxs-lookup"><span data-stu-id="25c6d-176">Run the program and look carefully at the output.</span></span> <span data-ttu-id="25c6d-177">`newusing` Kök ağacında yerleştirilen kurmadı.</span><span class="sxs-lookup"><span data-stu-id="25c6d-177">The `newusing` hasn't been placed in the root tree.</span></span> <span data-ttu-id="25c6d-178">Özgün ağaç değişmediğinden.</span><span class="sxs-lookup"><span data-stu-id="25c6d-178">The original tree hasn't been changed.</span></span>

<span data-ttu-id="25c6d-179">Aşağıdaki kodu kullanarak eklemek <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> yeni bir ağacı oluşturmak için genişletme yöntemi.</span><span class="sxs-lookup"><span data-stu-id="25c6d-179">Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree.</span></span> <span data-ttu-id="25c6d-180">Yeni ağaç varolan alma güncelleştirilmiş ile değiştirerek sonucudur `newUsing` düğümü.</span><span class="sxs-lookup"><span data-stu-id="25c6d-180">The new tree is the result of replacing the existing import with the updated `newUsing` node.</span></span> <span data-ttu-id="25c6d-181">Bu yeni ağaç varolan atamak `root` değişkeni:</span><span class="sxs-lookup"><span data-stu-id="25c6d-181">You assign this new tree to the existing `root` variable:</span></span>

[!code-csharp[create a new root tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree "Create the transformed root tree with the replaced namespace")]

<span data-ttu-id="25c6d-182">Programı yeniden çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="25c6d-182">Run the program again.</span></span> <span data-ttu-id="25c6d-183">Ağaç artık doğru şekilde içe aktarır bu kez `System.Collections.Generic` ad alanı.</span><span class="sxs-lookup"><span data-stu-id="25c6d-183">This time the tree now correctly imports the `System.Collections.Generic` namespace.</span></span>

### <a name="transform-trees-using-syntaxrewriters"></a><span data-ttu-id="25c6d-184">Ağaçları kullanarak dönüştürme `SyntaxRewriters`</span><span class="sxs-lookup"><span data-stu-id="25c6d-184">Transform trees using `SyntaxRewriters`</span></span>

<span data-ttu-id="25c6d-185">`With*` Ve <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> yöntemleri sağlayan bir sözdizimi ağacı tek tek dallarını dönüştürmek için uygun anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="25c6d-185">The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree.</span></span> <span data-ttu-id="25c6d-186"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> Sınıfı, bir sözdizimi ağacında birden çok dönüşümleri gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="25c6d-186">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree.</span></span> <span data-ttu-id="25c6d-187"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> Öğesinin bir alt sınıfıdır <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="25c6d-187">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="25c6d-188"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> Belirli bir türüne dönüştürme uygulanan <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span><span class="sxs-lookup"><span data-stu-id="25c6d-188">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span></span> <span data-ttu-id="25c6d-189">Birden çok tür dönüştürmeleri uygulayabilirsiniz <xref:Microsoft.CodeAnalysis.SyntaxNode> sözdizimi ağacında göründükleri her yerde nesneleri.</span><span class="sxs-lookup"><span data-stu-id="25c6d-189">You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree.</span></span> <span data-ttu-id="25c6d-190">Bu hızlı başlangıç ikinci projesinde, bir komut satırı açık türleri tür çıkarımı herhangi bir yerde kullanılabilir yerel değişken bildirimlerinde kaldıran yeniden düzenleme oluşturur.</span><span class="sxs-lookup"><span data-stu-id="25c6d-190">The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.</span></span>

<span data-ttu-id="25c6d-191">Yeni C# oluşturma **tek başına kod analizi aracı** projesi.</span><span class="sxs-lookup"><span data-stu-id="25c6d-191">Create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="25c6d-192">Visual Studio'da sağ `SyntaxTransformationQuickStart` çözüm düğümü.</span><span class="sxs-lookup"><span data-stu-id="25c6d-192">In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node.</span></span> <span data-ttu-id="25c6d-193">Seçin **Ekle** > **yeni proje** görüntülemek için **yeni proje iletişim kutusu**.</span><span class="sxs-lookup"><span data-stu-id="25c6d-193">Choose **Add** > **New Project** to display the **New Project dialog**.</span></span> <span data-ttu-id="25c6d-194">Altında **Visual C#** > **genişletilebilirlik**, seçin **tek başına kod analizi aracı**.</span><span class="sxs-lookup"><span data-stu-id="25c6d-194">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="25c6d-195">Projenizin adı `TransformationCS` ve Tamam'ı tıklatın.</span><span class="sxs-lookup"><span data-stu-id="25c6d-195">Name your project `TransformationCS` and click OK.</span></span>

<span data-ttu-id="25c6d-196">Öğesinden türeyen bir sınıf oluşturmak için ilk adımdır <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> , dönüşümleri gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="25c6d-196">The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations.</span></span> <span data-ttu-id="25c6d-197">Yeni bir sınıf dosyası projeye ekleyin.</span><span class="sxs-lookup"><span data-stu-id="25c6d-197">Add a new class file to the project.</span></span> <span data-ttu-id="25c6d-198">Visual Studio'da, **proje** > **sınıfı Ekle...** . İçinde **Yeni Öğe Ekle** iletişim türü `TypeInferenceRewriter.cs` dosya adı olarak.</span><span class="sxs-lookup"><span data-stu-id="25c6d-198">In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.</span></span>

<span data-ttu-id="25c6d-199">Aşağıdaki yönergeleri kullanarak `TypeInferenceRewriter.cs` dosyası:</span><span class="sxs-lookup"><span data-stu-id="25c6d-199">Add the following using directives to the `TypeInferenceRewriter.cs` file:</span></span>

[!code-csharp[add necessary usings](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings "Add required usings")]

<span data-ttu-id="25c6d-200">Ardından, olun `TypeInferenceRewriter` sınıfını genişleten <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> sınıfı:</span><span class="sxs-lookup"><span data-stu-id="25c6d-200">Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:</span></span>

[!code-csharp[add base class](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass "Add base class")]

<span data-ttu-id="25c6d-201">Tutmak için özel bir salt okunur alanı bildirmek için aşağıdaki kodu ekleyin bir <xref:Microsoft.CodeAnalysis.SemanticModel> ve oluşturucuda başlatma.</span><span class="sxs-lookup"><span data-stu-id="25c6d-201">Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor.</span></span> <span data-ttu-id="25c6d-202">Tür çıkarımı kullanıldığı daha sonra belirlemek için bu alanı gerekir:</span><span class="sxs-lookup"><span data-stu-id="25c6d-202">You will need this field later on to determine where type inference can be used:</span></span>

[!code-csharp[initialize members](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction "Declare and initialize member variables")]

<span data-ttu-id="25c6d-203">Geçersiz kılma <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> yöntemi:</span><span class="sxs-lookup"><span data-stu-id="25c6d-203">Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:</span></span>

```C#
public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{

}
```

> [!NOTE]
> <span data-ttu-id="25c6d-204">Birçok Roslyn API'leri döndürülen gerçek çalışma zamanı türlerinin temel sınıfları dönüş türleri bildirin.</span><span class="sxs-lookup"><span data-stu-id="25c6d-204">Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.</span></span> <span data-ttu-id="25c6d-205">n birçok senaryo, bir düğümü türü başka bir düğümü türü tarafından tamamen - değiştirilebilir veya bile kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="25c6d-205">n many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.</span></span> <span data-ttu-id="25c6d-206">Bu örnekte, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> yöntemi döndürür bir <xref:Microsoft.CodeAnalysis.SyntaxNode>, türetilen tür yerine <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span><span class="sxs-lookup"><span data-stu-id="25c6d-206">In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span></span> <span data-ttu-id="25c6d-207">Bu yeniden yazan yeni döndürür <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> düğümü var olan bir temel.</span><span class="sxs-lookup"><span data-stu-id="25c6d-207">This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.</span></span>

<span data-ttu-id="25c6d-208">Bu hızlı başlangıç yerel değişken bildirimleri işler.</span><span class="sxs-lookup"><span data-stu-id="25c6d-208">This quickstart handles local variable declarations.</span></span> <span data-ttu-id="25c6d-209">Bu diğer bildirimleri gibi genişletebilirsiniz `foreach` döngüler, `for` döngüler, LINQ ifadeleri ve lambda ifadeleri.</span><span class="sxs-lookup"><span data-stu-id="25c6d-209">You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions.</span></span> <span data-ttu-id="25c6d-210">Ayrıca bu yeniden yazan yalnızca basit form bildirimleri dönüştüren:</span><span class="sxs-lookup"><span data-stu-id="25c6d-210">Furthermore this rewriter will only transform declarations of the simplest form:</span></span>

```csharp
Type variable = expression;
```

<span data-ttu-id="25c6d-211">Kendi kendinize araştırmak istiyorsanız, bu tür bir değişken bildirimleri için tamamlanan örnek genişletme düşünün:</span><span class="sxs-lookup"><span data-stu-id="25c6d-211">If you want to explore on your own, consider extending the finished sample for these types of variable declarations:</span></span>

```csharp
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
```

<span data-ttu-id="25c6d-212">Gövdesi için aşağıdaki kodu ekleyin `VisitLocalDeclarationStatement` bu formların bildirimlerinin yeniden yazma işlemi atlamayı yöntemi:</span><span class="sxs-lookup"><span data-stu-id="25c6d-212">Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:</span></span>

[!code-csharp[exclude other declarations](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions "Exclude variables declarations not processed by this sample")]

<span data-ttu-id="25c6d-213">Hiçbir yeniden yazma işlemi döndürerek gerçekleşir, yöntemi gösterir `node` değiştirilmemiş parametresi.</span><span class="sxs-lookup"><span data-stu-id="25c6d-213">The method indicates that no rewriting takes place by returning the `node` parameter unmodified.</span></span> <span data-ttu-id="25c6d-214">Bu hiçbiri varsa `if` ifadesi true, başlatma olası bildirimiyle düğümünü temsil eder.</span><span class="sxs-lookup"><span data-stu-id="25c6d-214">If neither of those `if` expressions are true, the node represents a possible declaration with initialization.</span></span> <span data-ttu-id="25c6d-215">Bildiriminde belirtilen tür adı ayıklamak için bu deyimleri ekleyin ve kullanarak bağlamak <xref:Microsoft.CodeAnalysis.SemanticModel> alan bir tür simgesi almak için:</span><span class="sxs-lookup"><span data-stu-id="25c6d-215">Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:</span></span>

[!code-csharp[extract type name](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol "Extract the type name specified by the declaration")]

<span data-ttu-id="25c6d-216">Şimdi, başlatıcı ifade bağlamak için bu bildirimi ekleyin:</span><span class="sxs-lookup"><span data-stu-id="25c6d-216">Now, add this statement to bind the initializer expression:</span></span>

[!code-csharp[bind initializer](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Bind the initializer expressions")]

<span data-ttu-id="25c6d-217">Son olarak, aşağıdaki ekleyin `if` varolan tür adıyla değiştirdiğinizden deyimi `var` Başlatıcı ifade türü belirtilen tür eşleşirse anahtar sözcüğü:</span><span class="sxs-lookup"><span data-stu-id="25c6d-217">Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:</span></span>

[!code-csharp[ReplaceNode](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Replace the initializer node")]

<span data-ttu-id="25c6d-218">Koşullu gerekir çünkü bildirimi bir temel sınıf veya arabirim Başlatıcı ifadeyi dönüştürmek.</span><span class="sxs-lookup"><span data-stu-id="25c6d-218">The conditional is required because the declaration may cast the initializer expression to a base class or interface.</span></span> <span data-ttu-id="25c6d-219">İstenirse, sol ve sağ taraftaki atama türleri eşleşmiyor.</span><span class="sxs-lookup"><span data-stu-id="25c6d-219">If that's desired, the types on the left and right-hand side of the assignment don't match.</span></span> <span data-ttu-id="25c6d-220">Bu durumlarda açık tür kaldırma programı semantiği değiştirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="25c6d-220">Removing the explicit type in these cases would change the semantics of a program.</span></span> <span data-ttu-id="25c6d-221">`var` çünkü bir anahtar sözcük yerine bir tanımlayıcı olarak belirtilen `var` bağlamsal bir anahtardır.</span><span class="sxs-lookup"><span data-stu-id="25c6d-221">`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword.</span></span> <span data-ttu-id="25c6d-222">Eski tür adı baştaki ve sondaki trivia (boşluk) aktarıldığı `var` dikey boşluk ve girinti korumak için anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="25c6d-222">The leading and trailing trivia (whitespace) are transferred from the old type name to the `var` keyword to maintain vertical whitespace and indentation.</span></span> <span data-ttu-id="25c6d-223">Kullanmak daha basittir `ReplaceNode` yerine `With*` dönüştürmek için <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> tür adı gerçekte bildirimi deyiminin en alt olduğundan.</span><span class="sxs-lookup"><span data-stu-id="25c6d-223">It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.</span></span>

<span data-ttu-id="25c6d-224">Seçtiğiniz tamamlandı `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="25c6d-224">You've finished the `TypeInferenceRewriter`.</span></span> <span data-ttu-id="25c6d-225">Şimdi geri dönün, `Program.cs` örnek tamamlamak için dosya.</span><span class="sxs-lookup"><span data-stu-id="25c6d-225">Now return to your `Program.cs` file to finish the example.</span></span> <span data-ttu-id="25c6d-226">Bir test oluşturmak <xref:Microsoft.CodeAnalysis.Compilation> ve elde <xref:Microsoft.CodeAnalysis.SemanticModel> almaktır.</span><span class="sxs-lookup"><span data-stu-id="25c6d-226">Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it.</span></span> <span data-ttu-id="25c6d-227">Kullanan <xref:Microsoft.CodeAnalysis.SemanticModel> denemek için `TypeInferenceRewriter`.</span><span class="sxs-lookup"><span data-stu-id="25c6d-227">Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`.</span></span> <span data-ttu-id="25c6d-228">Bu adım son gerçekleştirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="25c6d-228">You'll do this step last.</span></span> <span data-ttu-id="25c6d-229">Bu sırada, test derleme temsil eden bir yer tutucu değişken bildirin:</span><span class="sxs-lookup"><span data-stu-id="25c6d-229">In the meantime declare a placeholder variable representing your test compilation:</span></span>

[!code-csharp[DeclareCompilation](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation "Declare the test compilation")]

<span data-ttu-id="25c6d-230">Biraz duraklatma sonra Raporlama görünür bir hata dalgalı görmelisiniz hiçbir `CreateTestCompilation` yöntem vardır.</span><span class="sxs-lookup"><span data-stu-id="25c6d-230">After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists.</span></span> <span data-ttu-id="25c6d-231">Basın **Ctrl + nokta** ampul açıp çağırmak için Enter tuşuna basın **Generate Method Stub** komutu.</span><span class="sxs-lookup"><span data-stu-id="25c6d-231">Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command.</span></span> <span data-ttu-id="25c6d-232">Bu komut için bir yöntem saplama oluşturacak `CreateTestCompilation` yönteminde `Program` sınıfı.</span><span class="sxs-lookup"><span data-stu-id="25c6d-232">This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class.</span></span> <span data-ttu-id="25c6d-233">Bu yöntemi, daha sonra doldurmak için geri alınması:</span><span class="sxs-lookup"><span data-stu-id="25c6d-233">You'll come back to fill in this method later:</span></span>

![Kullanımdan Oluştur C# yöntemi](./media/syntax-transformation/generate-from-usage.png)

<span data-ttu-id="25c6d-235">Her yineleme için aşağıdaki kodu yazma <xref:Microsoft.CodeAnalysis.SyntaxTree> test <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="25c6d-235">Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="25c6d-236">Her biri için yeni bir başlatma `TypeInferenceRewriter` ile <xref:Microsoft.CodeAnalysis.SemanticModel> o ağaç için:</span><span class="sxs-lookup"><span data-stu-id="25c6d-236">For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:</span></span>

[!code-csharp[IterateTrees](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees "Iterate all the source trees in the test compilation")]

<span data-ttu-id="25c6d-237">İçinde `foreach` deyimi, oluşturduğunuz her kaynak ağaçta dönüştürme gerçekleştirmek için aşağıdaki kodu ekleyin.</span><span class="sxs-lookup"><span data-stu-id="25c6d-237">Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree.</span></span> <span data-ttu-id="25c6d-238">Tüm düzenlemeleri yapılmışsa bu kodu yeni dönüştürülmüş ağacı koşullu olarak yazar.</span><span class="sxs-lookup"><span data-stu-id="25c6d-238">This code conditionally writes out the new transformed tree if any edits were made.</span></span> <span data-ttu-id="25c6d-239">Tür çıkarımı kullanarak basitleştirilmiş bir veya daha fazla yerel değişken bildirimleri karşılaşırsa, yeniden yazan yalnızca bir ağaç değiştirmeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="25c6d-239">Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:</span></span>

[!code-csharp[TransformTrees](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees "Transform and save any trees that are modified by the rewriter")]

<span data-ttu-id="25c6d-240">Dalgalı çizgiler altında görmelisiniz `File.WriteAllText` kodu.</span><span class="sxs-lookup"><span data-stu-id="25c6d-240">You should see squiggles under the `File.WriteAllText` code.</span></span> <span data-ttu-id="25c6d-241">Ampul seçin ve gerekli ekleyin `using System.IO;` deyimi.</span><span class="sxs-lookup"><span data-stu-id="25c6d-241">Select the light bulb, and add the necessary `using System.IO;` statement.</span></span>

<span data-ttu-id="25c6d-242">Bitmek üzere!</span><span class="sxs-lookup"><span data-stu-id="25c6d-242">You're almost done!</span></span> <span data-ttu-id="25c6d-243">Bir kez sol adım vardır: bir test oluşturma <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="25c6d-243">There's once step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="25c6d-244">Tür çıkarımı hiç bu hızlı başlangıç sırasında kullanmakta henüz olduğundan, mükemmel bir test çalışması yapmış.</span><span class="sxs-lookup"><span data-stu-id="25c6d-244">Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.</span></span> <span data-ttu-id="25c6d-245">Ne yazık ki, C# proje dosyasından bir derleme oluşturma, bu kılavuz kapsamında değildir.</span><span class="sxs-lookup"><span data-stu-id="25c6d-245">Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.</span></span> <span data-ttu-id="25c6d-246">Ancak Neyse ki, yönergeleri dikkatle takip, soluk var.</span><span class="sxs-lookup"><span data-stu-id="25c6d-246">But fortunately, if you've been following instructions carefully, there's hope.</span></span> <span data-ttu-id="25c6d-247">Değiştir `CreateTestCompilation` aşağıdaki kod ile yöntemi.</span><span class="sxs-lookup"><span data-stu-id="25c6d-247">Replace the contents of the `CreateTestCompilation` method with the following code.</span></span> <span data-ttu-id="25c6d-248">Bu hızlı başlangıç içinde açıklanan proje tesadüfen eşleşen bir test derleme oluşturur:</span><span class="sxs-lookup"><span data-stu-id="25c6d-248">It creates a test compilation that coincidentally matches the project described in this quickstart:</span></span>

[!code-csharp[CreateTestCompilation](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation "Create a test compilation using the code written for this quickstart.")]

<span data-ttu-id="25c6d-249">Parmakları arası ve projeyi çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="25c6d-249">Cross your fingers and run the project.</span></span> <span data-ttu-id="25c6d-250">Visual Studio'da, **hata ayıklama** > **hata ayıklamayı Başlat**.</span><span class="sxs-lookup"><span data-stu-id="25c6d-250">In Visual Studio, choose **Debug** > **Start Debugging**.</span></span> <span data-ttu-id="25c6d-251">Visual Studio tarafından projenizi dosyalarda değişen istenir.</span><span class="sxs-lookup"><span data-stu-id="25c6d-251">You should be prompted by Visual Studio that the files in your project have changed.</span></span> <span data-ttu-id="25c6d-252">Tıklayın "**Tümüne Evet**" değiştirilen dosyalar yeniden yüklemek için.</span><span class="sxs-lookup"><span data-stu-id="25c6d-252">Click "**Yes to All**" to reload the modified files.</span></span> <span data-ttu-id="25c6d-253">Bunları, awesomeness izlemek için inceleyin.</span><span class="sxs-lookup"><span data-stu-id="25c6d-253">Examine them to observe your awesomeness.</span></span> <span data-ttu-id="25c6d-254">Kod bu tüm açık ve yedek tür tanımlayıcıları görünür ne kadar temizleyici unutmayın.</span><span class="sxs-lookup"><span data-stu-id="25c6d-254">Note how much cleaner the code looks without all those explicit and redundant type specifiers.</span></span>

<span data-ttu-id="25c6d-255">Tebrikler!</span><span class="sxs-lookup"><span data-stu-id="25c6d-255">Congratulations!</span></span> <span data-ttu-id="25c6d-256">Kullandığınız **derleyici API'leri** kendi belirli söz dizimi desenler için C# projesinde tüm dosyaları arayan yeniden düzenleme yazmak için bu düzenlere eşleştiğinden ve bunu dönüştüren kaynak kodu semantiği analiz eder.</span><span class="sxs-lookup"><span data-stu-id="25c6d-256">You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.</span></span> <span data-ttu-id="25c6d-257">Artık resmi olarak yazar yeniden düzenleme!</span><span class="sxs-lookup"><span data-stu-id="25c6d-257">You're now officially refactoring author!</span></span>
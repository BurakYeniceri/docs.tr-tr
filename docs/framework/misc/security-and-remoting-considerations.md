---
title: "Güvenlik ve Uzaktan Yönetim Konuları"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- code security, remoting
- remoting, security
- security [.NET Framework], remoting
- secure coding, remoting
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
caps.latest.revision: "10"
author: mairaw
ms.author: mairaw
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 38b4f61b334a41cedf812a900265af95f1f52e61
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 12/22/2017
---
# <a name="security-and-remoting-considerations"></a><span data-ttu-id="03579-102">Güvenlik ve Uzaktan Yönetim Konuları</span><span class="sxs-lookup"><span data-stu-id="03579-102">Security and Remoting Considerations</span></span>
<span data-ttu-id="03579-103">Remoting uygulama etki alanları, işlemler veya bilgisayarlar arasında çağırma saydam ayarlamanıza olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="03579-103">Remoting allows you to set up transparent calling between application domains, processes, or computers.</span></span> <span data-ttu-id="03579-104">Bununla birlikte, kod erişim güvenliği yığın İlerlemesi (aynı işlem uygulama etki alanları arasında geçerli) işlem veya makine sınırları çapraz olamaz.</span><span class="sxs-lookup"><span data-stu-id="03579-104">However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).</span></span>  
  
 <span data-ttu-id="03579-105">Uzaktan erişilebilir herhangi bir sınıf (türetilmiş bir <xref:System.MarshalByRefObject> sınıfı) güvenlik sorumluluğunu yapması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="03579-105">Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security.</span></span> <span data-ttu-id="03579-106">Ya da kapalı ortamlarda yalnızca burada çağıran kodu örtük olarak güvenilir olabilir veya böylece bunlar korumalı kod kötü amaçlı olarak kullanılabilecek dış girişe edilmez remoting çağrıları tasarlanmalıdır kodu kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="03579-106">Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.</span></span>  
  
 <span data-ttu-id="03579-107">Genellikle, hiçbir zaman yöntemler, özellikler veya bildirim temelli tarafından korunan olayları açığa [LinkDemand](../../../docs/framework/misc/link-demands.md) ve <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> güvenlik denetimleri.</span><span class="sxs-lookup"><span data-stu-id="03579-107">Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](../../../docs/framework/misc/link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks.</span></span> <span data-ttu-id="03579-108">Remoting ile bu denetimleri zorunlu değildir.</span><span class="sxs-lookup"><span data-stu-id="03579-108">With remoting, these checks are not enforced.</span></span> <span data-ttu-id="03579-109">Gibi diğer güvenlik denetimlerini <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](../../../docs/framework/misc/using-the-assert-method.md)ve benzeri bir işlem içinde uygulama etki alanları arasında çalışır ancak işlem içi veya makineler arası senaryolarda çalışmaz.</span><span class="sxs-lookup"><span data-stu-id="03579-109">Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](../../../docs/framework/misc/using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.</span></span>  
  
## <a name="protected-objects"></a><span data-ttu-id="03579-110">Korunan nesneler</span><span class="sxs-lookup"><span data-stu-id="03579-110">Protected objects</span></span>  
 <span data-ttu-id="03579-111">Bazı nesneler kendilerini güvenlik durumda tutun.</span><span class="sxs-lookup"><span data-stu-id="03579-111">Some objects hold security state in themselves.</span></span> <span data-ttu-id="03579-112">Bu nesneler, sonra güvenlik yetkilendirme kendi izinlerini ötesinde almak güvenilmeyen koduna geçirilmemelidir.</span><span class="sxs-lookup"><span data-stu-id="03579-112">These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.</span></span>  
  
 <span data-ttu-id="03579-113">Bir örnek oluştururken bir <xref:System.IO.FileStream> nesnesi.</span><span class="sxs-lookup"><span data-stu-id="03579-113">One example is creating a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="03579-114"><xref:System.Security.Permissions.FileIOPermission> Oluşturma sırasında talep ve başarılı olursa, dosya nesnesi döndürülür.</span><span class="sxs-lookup"><span data-stu-id="03579-114">The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned.</span></span> <span data-ttu-id="03579-115">Ancak, bu nesne başvurusu kodu dosya izinleri olmadan geçirilir, nesne okuyabilmesini ve bu belirli bir dosyaya yazma olacaktır.</span><span class="sxs-lookup"><span data-stu-id="03579-115">However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.</span></span>  
  
 <span data-ttu-id="03579-116">Böyle bir nesnenin en basit savunma aynı talep vermektir **FileIOPermission** nesne başvurusu bir ortak API öğesi aracılığıyla almak için arama kod.</span><span class="sxs-lookup"><span data-stu-id="03579-116">The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element.</span></span>  
  
## <a name="application-domain-crossing-issues"></a><span data-ttu-id="03579-117">Uygulama etki alanı aşma sorunları</span><span class="sxs-lookup"><span data-stu-id="03579-117">Application domain crossing issues</span></span>  
 <span data-ttu-id="03579-118">Yönetilen barındırma ortamları kodda yalıtmak için çeşitli derlemeler için izin düzeylerinin azaltma açık ilkesiyle birden çok alt uygulama etki alanları oluşturmak için yaygındır.</span><span class="sxs-lookup"><span data-stu-id="03579-118">To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies.</span></span> <span data-ttu-id="03579-119">Ancak, varsayılan uygulama etki alanında bu derlemeler için ilke değişmeden kalır.</span><span class="sxs-lookup"><span data-stu-id="03579-119">However, the policy for those assemblies remains unchanged in the default application domain.</span></span> <span data-ttu-id="03579-120">Bir alt uygulama etki alanlarının bir derlemeyi yüklemeye varsayılan uygulama etki alanı zorlayabilirsiniz, kod yalıtım etkisini kaybolur ve zorla yüklenen derlemesindeki türler güven daha yüksek bir düzeyde kod çalıştırabilir.</span><span class="sxs-lookup"><span data-stu-id="03579-120">If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.</span></span>  
  
 <span data-ttu-id="03579-121">Uygulama etki alanı, burada bir uygulama etki alanında barındırılan bir nesne için bir proxy çağırarak yer alan kod bir derlemeyi yüklemek ve çalıştırmak için başka bir uygulama etki alanı zorlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="03579-121">An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain.</span></span> <span data-ttu-id="03579-122">Uygulama etki alanları arası proxy edinmek için nesneyi barındıran uygulama etki alanı aracılığıyla bir yöntem çağrısı parametresi ya da döndürme değeri dağıtmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="03579-122">To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value.</span></span> <span data-ttu-id="03579-123">Veya, uygulama etki alanı yalnızca oluşturulduysa oluşturan bir proxy <xref:System.AppDomain> varsayılan nesne.</span><span class="sxs-lookup"><span data-stu-id="03579-123">Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default.</span></span> <span data-ttu-id="03579-124">Bu nedenle, kod yalıtım çiğnemekten kaçının, daha yüksek bir güven düzeyi içeren bir uygulama etki alanı sıralanmış-by-reference nesnelerin referansları dağıtmanız değil (sınıfların örneklerini türetilen <xref:System.MarshalByRefObject>) alt ile uygulama etki alanları için kendi etki alanındaki güven düzeyleri.</span><span class="sxs-lookup"><span data-stu-id="03579-124">Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust.</span></span>  
  
 <span data-ttu-id="03579-125">Genellikle, varsayılan uygulama etki alanı her biri bir denetim nesnesiyle uygulama etki alanları alt oluşturur.</span><span class="sxs-lookup"><span data-stu-id="03579-125">Usually, the default application domain creates the child application domains with a control object in each one.</span></span> <span data-ttu-id="03579-126">Denetim nesnesi yeni uygulama etki alanı yönetir ve bazen siparişleri varsayılan uygulama etki alanından alır, ancak bunu gerçekten etki alanı doğrudan bağlanamazsınız.</span><span class="sxs-lookup"><span data-stu-id="03579-126">The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly.</span></span> <span data-ttu-id="03579-127">Bazen, varsayılan uygulama etki alanı kendi proxy denetim nesnesi ile çağırır.</span><span class="sxs-lookup"><span data-stu-id="03579-127">Occasionally, the default application domain calls its proxy to the control object.</span></span> <span data-ttu-id="03579-128">Ancak, varsayılan uygulama etki alanına geri çağırmaya denetim nesnesi için gerekli olduğu durumlar olabilir.</span><span class="sxs-lookup"><span data-stu-id="03579-128">However, there might be cases in which it is necessary for the control object to call back to the default application domain.</span></span> <span data-ttu-id="03579-129">Bu durumda, varsayılan uygulama etki alanı denetim nesnesi oluşturucuya başvuruya göre geri çağırma nesnesi geçirir.</span><span class="sxs-lookup"><span data-stu-id="03579-129">In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object.</span></span> <span data-ttu-id="03579-130">Bu proxy korumak için denetim nesnesi sorumluluğundadır.</span><span class="sxs-lookup"><span data-stu-id="03579-130">It is the responsibility of the control object to protect this proxy.</span></span> <span data-ttu-id="03579-131">Denetim nesnesi proxy bir ortak statik ortak sınıfının alana veya aksi halde proxy genel olarak kullanıma olsaydı, bu varsayılan uygulama etki alanına geri aramayı başka bir kod tehlikeli olabilecek bir mekanizma açılacaktır.</span><span class="sxs-lookup"><span data-stu-id="03579-131">If the control object were to place the proxy on a public static field of a public class, or otherwise publicly expose the proxy, this would open up a dangerous mechanism for other code to call back into the default application domain.</span></span> <span data-ttu-id="03579-132">Bu nedenle, Denetim nesneler her zaman proxy gizliliğini korumak için örtük olarak güvenilir.</span><span class="sxs-lookup"><span data-stu-id="03579-132">For this reason, control objects are always implicitly trusted to keep the proxy private.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="03579-133">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="03579-133">See Also</span></span>  
 [<span data-ttu-id="03579-134">Güvenli Kodlama Yönergeleri</span><span class="sxs-lookup"><span data-stu-id="03579-134">Secure Coding Guidelines</span></span>](../../../docs/standard/security/secure-coding-guidelines.md)

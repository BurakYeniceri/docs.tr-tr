---
title: "Bağımsız JSON Seri Hale Getirme"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
caps.latest.revision: "32"
author: Erikre
ms.author: erikre
manager: erikre
ms.openlocfilehash: 3b3e09af7491b57d0b318b88623343aaa6bfcf8b
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/18/2017
---
# <a name="stand-alone-json-serialization"></a><span data-ttu-id="d2a31-102">Bağımsız JSON Seri Hale Getirme</span><span class="sxs-lookup"><span data-stu-id="d2a31-102">Stand-Alone JSON Serialization</span></span>
<span data-ttu-id="d2a31-103">JSON (JavaScript nesne gösterimi) özellikle Web sayfalarında tarayıcı içinde çalışan JavaScript kodu tarafından kullanılmak üzere tasarlanmış bir veri biçimidir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-103">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="d2a31-104">Oluşturulan ASP.NET AJAX Hizmetleri tarafından kullanılan varsayılan veri biçimi olan [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d2a31-104">It is the default data format used by ASP.NET AJAX services created in [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)].</span></span>  
  
 <span data-ttu-id="d2a31-105">Bu biçim, ASP.NET ile - bu durumda, tümleştirme olmadan AJAX hizmetleri oluşturma XML varsayılandır ancak JSON seçilebilir olduğunda kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-105">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>  
  
 <span data-ttu-id="d2a31-106">Son olarak, JSON desteği gerektirir, ancak bir AJAX hizmeti oluşturmadığınızı <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> doğrudan JSON verilerinin .NET nesnelerini seri hale getirmek için ve bu tür veriler geri .NET türleri örneğine seri durumdan çıkarılacak mümkün kılar.</span><span class="sxs-lookup"><span data-stu-id="d2a31-106">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="d2a31-107">Bunun nasıl yapılacağı açıklaması için bkz: [nasıl yapılır: seri hale getirmek ve seri durumdan JSON verilerini](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="d2a31-107">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>  
  
 <span data-ttu-id="d2a31-108">JSON ile çalışırken aynı .NET türleri, birkaç istisna dışında tarafından desteklenen gibi desteklenen <xref:System.Runtime.Serialization.DataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="d2a31-108">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="d2a31-109">Desteklenen türlerinin bir listesi için bkz: [veri sözleşmesi seri hale getirici tarafından desteklenen türleri](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="d2a31-109">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="d2a31-110">En basit türler, çoğu dizi bu içerir ve koleksiyonu da kadar karmaşık türleri, kullanan <xref:System.Runtime.Serialization.DataContractAttribute> ve <xref:System.Runtime.Serialization.DataMemberAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d2a31-110">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>  
  
## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="d2a31-111">JSON türler için eşleme .NET türleri</span><span class="sxs-lookup"><span data-stu-id="d2a31-111">Mapping .NET types to JSON Types</span></span>  
 <span data-ttu-id="d2a31-112">Aşağıdaki tabloda .NET türleri ve seri hale getirme ve seri durumdan çıkarma yordamları tarafından eşlenen JSON/JavaScript türleri arasındaki ilişkiyi gösterir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-112">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>  
  
|<span data-ttu-id="d2a31-113">.NET türleri</span><span class="sxs-lookup"><span data-stu-id="d2a31-113">.NET Types</span></span>|<span data-ttu-id="d2a31-114">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="d2a31-114">JSON/JavaScript</span></span>|<span data-ttu-id="d2a31-115">Notlar</span><span class="sxs-lookup"><span data-stu-id="d2a31-115">Notes</span></span>|  
|----------------|----------------------|-----------|  
|<span data-ttu-id="d2a31-116">Örneğin tüm sayısal türler <xref:System.Int32>, <xref:System.Decimal> veya<xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="d2a31-116">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="d2a31-117">Sayı</span><span class="sxs-lookup"><span data-stu-id="d2a31-117">Number</span></span>|<span data-ttu-id="d2a31-118">Özel değerler gibi `Double.NaN`, `Double.PositiveInfinity` ve `Double.NegativeInfinity` desteklenmez ve neden geçersiz JSON'da.</span><span class="sxs-lookup"><span data-stu-id="d2a31-118">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|  
|<xref:System.Enum>|<span data-ttu-id="d2a31-119">Sayı</span><span class="sxs-lookup"><span data-stu-id="d2a31-119">Number</span></span>|<span data-ttu-id="d2a31-120">"Numaralandırmalar ve JSON" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="d2a31-120">See "Enumerations and JSON" later in this topic.</span></span>|  
|<xref:System.Boolean>|<span data-ttu-id="d2a31-121">Boole değeri</span><span class="sxs-lookup"><span data-stu-id="d2a31-121">Boolean</span></span>|--|  
|<span data-ttu-id="d2a31-122"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="d2a31-122"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="d2a31-123">Dize</span><span class="sxs-lookup"><span data-stu-id="d2a31-123">String</span></span>|--|  
|<span data-ttu-id="d2a31-124"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="d2a31-124"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="d2a31-125">Dize</span><span class="sxs-lookup"><span data-stu-id="d2a31-125">String</span></span>|<span data-ttu-id="d2a31-126">JSON içinde bu tür XML (esas olarak, TimeSpan ISO 8601 süre biçiminde, "12345678-ABCD-ABCD-ABCD-1234567890AB" biçiminde GUID ve URI doğal dize biçimde "http://www.example.com" gibi) ile aynı biçimidir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-126">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="d2a31-127">Kesin bilgi için bkz: [veri sözleşmesi şema başvurusu](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="d2a31-127">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|  
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="d2a31-128">Dize</span><span class="sxs-lookup"><span data-stu-id="d2a31-128">String</span></span>|<span data-ttu-id="d2a31-129">"Ad: ad alanı" (her şey ilk iki nokta üst üste adı önce) biçimidir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-129">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="d2a31-130">Adı veya ad alanı eksik olabilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-130">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="d2a31-131">Ad alanı yok ise iki nokta üst üste de atlanabilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-131">If there is no namespace the colon can be omitted as well.</span></span>|  
|<span data-ttu-id="d2a31-132"><xref:System.Array>türü<xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="d2a31-132"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="d2a31-133">Sayı dizisi</span><span class="sxs-lookup"><span data-stu-id="d2a31-133">Array of numbers</span></span>|<span data-ttu-id="d2a31-134">Her numarası bir bayt değeri temsil eder.</span><span class="sxs-lookup"><span data-stu-id="d2a31-134">Each number represents the value of one byte.</span></span>|  
|<xref:System.DateTime>|<span data-ttu-id="d2a31-135">DateTime veya dize</span><span class="sxs-lookup"><span data-stu-id="d2a31-135">DateTime or String</span></span>|<span data-ttu-id="d2a31-136">Tarih görmek / zamanları ve bu konunun ilerleyen bölümlerinde JSON.</span><span class="sxs-lookup"><span data-stu-id="d2a31-136">See Dates/Times and JSON later in this topic.</span></span>|  
|<xref:System.DateTimeOffset>|<span data-ttu-id="d2a31-137">karmaşık türü</span><span class="sxs-lookup"><span data-stu-id="d2a31-137">Complex type</span></span>|<span data-ttu-id="d2a31-138">Tarih görmek / zamanları ve bu konunun ilerleyen bölümlerinde JSON.</span><span class="sxs-lookup"><span data-stu-id="d2a31-138">See Dates/Times and JSON later in this topic.</span></span>|  
|<span data-ttu-id="d2a31-139">XML ve ADO.NET türleri (<xref:System.Xml.XmlElement>,</span><span class="sxs-lookup"><span data-stu-id="d2a31-139">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="d2a31-140"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="d2a31-140"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="d2a31-141">Dizileri <xref:System.Xml.XmlNode>,</span><span class="sxs-lookup"><span data-stu-id="d2a31-141">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="d2a31-142"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="d2a31-142"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="d2a31-143"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="d2a31-143"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="d2a31-144">Dize</span><span class="sxs-lookup"><span data-stu-id="d2a31-144">String</span></span>|<span data-ttu-id="d2a31-145">Bu konuda XML türleri ve JSON bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="d2a31-145">See the XML Types and JSON section of this topic.</span></span>|  
|<xref:System.DBNull>|<span data-ttu-id="d2a31-146">Boş karmaşık türü</span><span class="sxs-lookup"><span data-stu-id="d2a31-146">Empty complex type</span></span>|--|  
|<span data-ttu-id="d2a31-147">Koleksiyonlar, sözlükler ve diziler</span><span class="sxs-lookup"><span data-stu-id="d2a31-147">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="d2a31-148">Dizi</span><span class="sxs-lookup"><span data-stu-id="d2a31-148">Array</span></span>|<span data-ttu-id="d2a31-149">Bu konuda koleksiyonlar, sözlükler ve dizileri bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="d2a31-149">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|  
|<span data-ttu-id="d2a31-150">Karmaşık türler (ile <xref:System.Runtime.Serialization.DataContractAttribute> veya <xref:System.SerializableAttribute> uygulanır)</span><span class="sxs-lookup"><span data-stu-id="d2a31-150">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="d2a31-151">karmaşık türü</span><span class="sxs-lookup"><span data-stu-id="d2a31-151">Complex type</span></span>|<span data-ttu-id="d2a31-152">Veri üyeleri JavaScript karmaşık türün üyeleri haline gelir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-152">Data members become members of the JavaScript complex type.</span></span>|  
|<span data-ttu-id="d2a31-153">Uygulama karmaşık türler <xref:System.Runtime.Serialization.ISerializable> arabirimi)</span><span class="sxs-lookup"><span data-stu-id="d2a31-153">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="d2a31-154">karmaşık türü</span><span class="sxs-lookup"><span data-stu-id="d2a31-154">Complex type</span></span>|<span data-ttu-id="d2a31-155">Ancak bazı diğer karmaşık türleri aynı <xref:System.Runtime.Serialization.ISerializable> türler desteklenmez – gelişmiş bilgileri bölümüne ISerializable destek parçası bakın.</span><span class="sxs-lookup"><span data-stu-id="d2a31-155">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|  
|<span data-ttu-id="d2a31-156">`Null`herhangi bir tür için değer</span><span class="sxs-lookup"><span data-stu-id="d2a31-156">`Null` value for any type</span></span>|<span data-ttu-id="d2a31-157">Null</span><span class="sxs-lookup"><span data-stu-id="d2a31-157">Null</span></span>|<span data-ttu-id="d2a31-158">Boş değer atanabilir türler de desteklenir ve eşlemek için JSON null türleri aynı şekilde.</span><span class="sxs-lookup"><span data-stu-id="d2a31-158">Nullable types are also supported and map to JSON in the same way as non-nullable types.</span></span>|  
  
### <a name="enumerations-and-json"></a><span data-ttu-id="d2a31-159">Numaralandırmalar ve JSON</span><span class="sxs-lookup"><span data-stu-id="d2a31-159">Enumerations and JSON</span></span>  
 <span data-ttu-id="d2a31-160">Numaralandırma üye değerlerinin sayılar nasıl bunlar veri sözleşmelerinde davranılır öğesinden farklı üye adları dahil olduğu JSON olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-160">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="d2a31-161">veri işleme, sözleşme bkz [veri sözleşmelerinde Numaralandırma türleri](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="d2a31-161"> the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>  
  
-   <span data-ttu-id="d2a31-162">Örneğin, `public enum Color {red, green, blue, yellow, pink}`, biçimlendiricisi `yellow` 3 sayısını ve "Sarı" dize değil üretir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-162">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>  
  
-   <span data-ttu-id="d2a31-163">Tüm `enum` üyeleridir seri hale getirilebilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-163">All `enum` members are serializable.</span></span> <span data-ttu-id="d2a31-164"><xref:System.Runtime.Serialization.EnumMemberAttribute> Ve <xref:System.NonSerializedAttribute> öznitelikleri kullanılırsa yoksayılır.</span><span class="sxs-lookup"><span data-stu-id="d2a31-164">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>  
  
-   <span data-ttu-id="d2a31-165">Varolmayan bir seri durumdan mümkündür `enum` değer - Örneğin, değeri 87 olabilir ve önceki renk enum seri durumdan çıkarılmış karşılık gelen renk ad tanımlanmadı olsa bile.</span><span class="sxs-lookup"><span data-stu-id="d2a31-165">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>  
  
-   <span data-ttu-id="d2a31-166">Bir bayrakları `enum` özel değil ve aynı diğer kabul `enum`.</span><span class="sxs-lookup"><span data-stu-id="d2a31-166">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>  
  
### <a name="datestimes-and-json"></a><span data-ttu-id="d2a31-167">Tarih/zaman ve JSON</span><span class="sxs-lookup"><span data-stu-id="d2a31-167">Dates/Times and JSON</span></span>  
 <span data-ttu-id="d2a31-168">JSON biçimi, tarihler ve saatler doğrudan desteklemez.</span><span class="sxs-lookup"><span data-stu-id="d2a31-168">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="d2a31-169">Ancak, bunlar yaygın olarak kullanılan ve ASP.NET AJAX bu türleri için özel destek sağlar.</span><span class="sxs-lookup"><span data-stu-id="d2a31-169">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="d2a31-170">ASP.NET AJAX proxy'lerini kullanırken <xref:System.DateTime> .NET içinde tam olarak karşılık gelen türü için `DateTime` JavaScript türü.</span><span class="sxs-lookup"><span data-stu-id="d2a31-170">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>  
  
-   <span data-ttu-id="d2a31-171">ASP.NET, kullanmadığınızda bir <xref:System.DateTime> türü, bu konuda gelişmiş bilgileri bölümünde açıklanan özel bir biçime sahip bir dize olarak JSON'de gösterilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-171">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>  
  
-   <span data-ttu-id="d2a31-172"><xref:System.DateTimeOffset>JSON karmaşık tür olarak temsil edilir: {"DateTime": dateTime, "OffsetMinutes": offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="d2a31-172"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="d2a31-173">`offsetMinutes` Üyesidir gelen Greenwich saati (olarak Eşgüdümlü Evrensel Saat (olay ilgi konumuyla ilişkili UTC), artık başvurulan GMT), yerel saat konumu.</span><span class="sxs-lookup"><span data-stu-id="d2a31-173">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="d2a31-174">`dateTime` Üye ilgi olayın gerçekleştiği süre örneğini temsil eder (yeniden, bu duruma bir `DateTime` ASP.NET AJAX'ı kullanın ve bir dize olduğunda olmadığında JavaScript'te).</span><span class="sxs-lookup"><span data-stu-id="d2a31-174">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="d2a31-175">Seri hale getirme üzerinde `dateTime` üye her zaman GMT serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-175">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="d2a31-176">Bunu, New York saat 03: 00'da, açıklayan varsa `dateTime` 8: 00'da bir saat bileşeni vardır ve `offsetMinutes` olan 300 (eksi, 300 dakika veya GMT'den 5 saat).</span><span class="sxs-lookup"><span data-stu-id="d2a31-176">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d2a31-177"><xref:System.DateTime>ve <xref:System.DateTimeOffset> JSON olarak serileştirilmiş nesneleri, yalnızca milisaniyelik duyarlık bilgileri korumak.</span><span class="sxs-lookup"><span data-stu-id="d2a31-177"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="d2a31-178">Alt milisaniye değerleri (mikro/nanosaniye) serileştirme sırasında kaybolur.</span><span class="sxs-lookup"><span data-stu-id="d2a31-178">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>  
  
### <a name="xml-types-and-json"></a><span data-ttu-id="d2a31-179">XML türleri ve JSON</span><span class="sxs-lookup"><span data-stu-id="d2a31-179">XML Types and JSON</span></span>  
 <span data-ttu-id="d2a31-180">XML türleri JSON dizeler haline gelir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-180">XML types become JSON strings.</span></span>  
  
-   <span data-ttu-id="d2a31-181">Örneğin, veri üyesi "q" XElement yazarsanız içerir \<abc / >, JSON {"q": "\<abc / >"}.</span><span class="sxs-lookup"><span data-stu-id="d2a31-181">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>  
  
-   <span data-ttu-id="d2a31-182">Nasıl XML - daha fazla bilgi için kaydırılan belirtin, bu konunun ilerleyen bölümlerinde Gelişmiş bilgi bölümüne bakın özel bazı kurallar vardır.</span><span class="sxs-lookup"><span data-stu-id="d2a31-182">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>  
  
-   <span data-ttu-id="d2a31-183">ASP.NET AJAX kullanıyorsanız ve istemediğiniz JavaScript'te dizeleri kullanın ancak bunun yerine XML DOM istediğiniz ayarlamak <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> XML özelliğine <xref:System.ServiceModel.Web.WebGetAttribute> veya <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> XML özelliğine <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d2a31-183">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>  
  
### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="d2a31-184">Koleksiyonlar, sözlükler ve diziler</span><span class="sxs-lookup"><span data-stu-id="d2a31-184">Collections, Dictionaries and Arrays</span></span>  
 <span data-ttu-id="d2a31-185">Tüm koleksiyonlar, sözlükler ve diziler JSON'de dizi olarak temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-185">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>  
  
-   <span data-ttu-id="d2a31-186">Kullanan herhangi bir özelleştirme <xref:System.Runtime.Serialization.CollectionDataContractAttribute> JSON gösterimi göz ardı edilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-186">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>  
  
-   <span data-ttu-id="d2a31-187">Sözlük doğrudan JSON ile çözmenin bir yolu değildir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-187">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="d2a31-188">Sözlük\<dize, Nesne > aynı yolla da desteklenmeyebilir [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] diğer JSON teknolojileriyle çalışmasını beklendiği gibi.</span><span class="sxs-lookup"><span data-stu-id="d2a31-188">Dictionary\<string,object> may not be supported in the same way in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] as expected from working with other JSON technologies.</span></span> <span data-ttu-id="d2a31-189">Örneğin, "abc", "xyz" eşleştirilir ve "def" 42 sözlükteki eşlendiği, JSON temsili olmadığından {"abc": "xyz", "def": 42} ancak [{"Anahtarı": "Abc", "Değeri": "xyz"}, {"Anahtarı": "def", "Değeri": 42}] yerine.</span><span class="sxs-lookup"><span data-stu-id="d2a31-189">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>  
  
-   <span data-ttu-id="d2a31-190">JSON ile doğrudan çalışmak isterseniz (anahtarlar ve değerler dinamik olarak katı sözleşme önceden tanımlamadan erişme), birkaç seçeneğiniz vardır:</span><span class="sxs-lookup"><span data-stu-id="d2a31-190">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>  
  
    -   <span data-ttu-id="d2a31-191">Kullanmayı [zayıf yazılmış JSON seri hale getirme (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) örnek.</span><span class="sxs-lookup"><span data-stu-id="d2a31-191">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>  
  
    -   <span data-ttu-id="d2a31-192">Kullanmayı <xref:System.Runtime.Serialization.ISerializable> arabirimi ve seri durumdan çıkarma oluşturucular - bu iki mekanizma JSON anahtar/değer çiftleri serileştirme üzerinde erişim ve sırasıyla seri durumundan çıkarma olanak sağlar, ancak kısmi güven senaryolarında çalışmaz.</span><span class="sxs-lookup"><span data-stu-id="d2a31-192">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>  
  
    -   <span data-ttu-id="d2a31-193">İle çalışma göz önünde bulundurun [arasında eşleme JSON ve XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) seri hale getirici kullanmak yerine.</span><span class="sxs-lookup"><span data-stu-id="d2a31-193">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>  
  
    -   <span data-ttu-id="d2a31-194">*Çok biçimlilik* serileştirme bağlamında temel türü beklenirken türetilmiş bir tür serileştirmek için yeteneği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-194">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="d2a31-195">Özel JSON özel kurallar koleksiyonları polymorphically, örneğin, bir koleksiyona atarken kullanırken yoktur bir <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="d2a31-195">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="d2a31-196">Bu sorunu daha kapsamlı gelişmiş bilgileri bölümünde bu konunun ilerleyen bölümlerinde ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="d2a31-196">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>  
  
## <a name="additional-details"></a><span data-ttu-id="d2a31-197">Ek Ayrıntılar</span><span class="sxs-lookup"><span data-stu-id="d2a31-197">Additional Details</span></span>  
  
### <a name="order-of-data-members"></a><span data-ttu-id="d2a31-198">Veri üye sırası</span><span class="sxs-lookup"><span data-stu-id="d2a31-198">Order of Data Members</span></span>  
 <span data-ttu-id="d2a31-199">JSON kullanırken veri üye sırası önemli değildir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-199">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="d2a31-200">Özellikle, olsa bile <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> ayarlandığında, JSON verileri hala serisi kaldırılacak herhangi bir sırada.</span><span class="sxs-lookup"><span data-stu-id="d2a31-200">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>  
  
### <a name="json-types"></a><span data-ttu-id="d2a31-201">JSON türleri</span><span class="sxs-lookup"><span data-stu-id="d2a31-201">JSON Types</span></span>  
 <span data-ttu-id="d2a31-202">JSON türü seri durumdan çıkarma önceki tabloda eşleşmesi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="d2a31-202">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="d2a31-203">Örneğin, bir `Int` bu dizesi geçerli bir sayı içerdiği sürece normalde bir JSON sayı, ancak eşlenir de bir JSON dizeden başarıyla Serisi kaldırılan olabilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-203">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="d2a31-204">Diğer bir deyişle, her ikisini de {"q": 42} ve {"q": "42"} varsa geçerli bir `Int` "q" adlı veri üyesi.</span><span class="sxs-lookup"><span data-stu-id="d2a31-204">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>  
  
### <a name="polymorphism"></a><span data-ttu-id="d2a31-205">Çok Biçimlilik</span><span class="sxs-lookup"><span data-stu-id="d2a31-205">Polymorphism</span></span>  
 <span data-ttu-id="d2a31-206">Çok biçimli serileştirme temel türü beklenirken türetilmiş bir tür serileştirme yeteneğini oluşur.</span><span class="sxs-lookup"><span data-stu-id="d2a31-206">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="d2a31-207">Bu JSON serileştirmesi tarafından desteklenen [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] XML serileştirme karşılaştırılabilir şekilde desteklenir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-207">This is supported for JSON serialization by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="d2a31-208">Örneğin, serileştirebilen `MyDerivedType` nerede `MyBaseType` beklenen veya seri `Int` burada `Object` beklenir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-208">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>  
  
 <span data-ttu-id="d2a31-209">Tür bilgilerini temel türü bekleniyorsa, bir karmaşık türü seri durumdan çıkarılırken sürece türetilmiş bir tür çıkarılırken kaybolmuş olabilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-209">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="d2a31-210">Örneğin, varsa <xref:System.Uri> burada serileştirilmiş <xref:System.Object> beklenmektedir bir JSON dizesinde sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="d2a31-210">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="d2a31-211">Bu dize sonra uygulamasına geri serisi varsa <xref:System.Object>, bir .NET <xref:System.String> döndürülür.</span><span class="sxs-lookup"><span data-stu-id="d2a31-211">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="d2a31-212">Seri durumdan çıkarıcının dize başlangıçta türü olduğunu bilmez <xref:System.Uri>.</span><span class="sxs-lookup"><span data-stu-id="d2a31-212">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="d2a31-213">Genellikle, bekleniyor zaman <xref:System.Object>, tüm JSON dizeler .NET dize olarak serisi ve .NET koleksiyonları, sözcüklerine serileştirmek için kullanılan tüm JSON dizileri ve diziler .NET seri durumdan <xref:System.Array> türü <xref:System.Object>ne olursa olsun, ne Gerçek özgün türü eklenmiştir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-213">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="d2a31-214">Bir .NET JSON boolean eşlemeleri <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="d2a31-214">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="d2a31-215">Ancak beklediği zaman bir <xref:System.Object>, JSON sayılar ya da .NET seri durumdan <xref:System.Int32>, <xref:System.Decimal> veya <xref:System.Double>, burada en uygun türü otomatik olarak çekilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-215">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>  
  
 <span data-ttu-id="d2a31-216">Bir arabirim türü seri durumdan çıkarılırken <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> bildirilen bir türe nesne değilmiş gibi seri durumdan çıkarır.</span><span class="sxs-lookup"><span data-stu-id="d2a31-216">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>  
  
 <span data-ttu-id="d2a31-217">Kendi temel ve türetilen türlerin ile çalışırken, kullanarak <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> veya eşdeğer bir mekanizma normalde gereklidir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-217">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="d2a31-218">Sahip bir işlem varsa, örneğin, bir `Animal` değeri ve gerçekte bir örneğini döndürür dönmek `Cat` (türetilmiş `Animal`), ya da uygulamalıdır <xref:System.Runtime.Serialization.KnownTypeAttribute>, `Animal` türü veya <xref:System.ServiceModel.ServiceKnownTypeAttribute> için işlemi ve belirtin `Cat` bu özniteliklerin türü.</span><span class="sxs-lookup"><span data-stu-id="d2a31-218">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="d2a31-219">Daha fazla bilgi için bkz: [veri sözleşmesi bilinen türleri](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="d2a31-219">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="d2a31-220">Nasıl biçimli serileştirme works ayrıntılarını ve bu kullanırken dikkate alınması gereken sınırlamalar bazılarının bir tartışma için bu konunun ilerleyen bölümlerinde gelişmiş bilgileri bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="d2a31-220">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>  
  
### <a name="versioning"></a><span data-ttu-id="d2a31-221">Sürüm oluşturma</span><span class="sxs-lookup"><span data-stu-id="d2a31-221">Versioning</span></span>  
 <span data-ttu-id="d2a31-222">Veri sözleşmesi sürümü oluşturma özellikleri dahil olmak üzere, <xref:System.Runtime.Serialization.IExtensibleDataObject> arabirimi, JSON içinde tam olarak desteklenir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-222">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="d2a31-223">Ayrıca, çoğu durumda bir biçimde (örneğin, XML) türü seri durumdan ve başka bir biçime (örneğin, JSON) seri hale ve hala verileri korumak mümkündür <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="d2a31-223">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="d2a31-224">[İleri uyumlu veri sözleşmeleri](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="d2a31-224"> [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="d2a31-225">Herhangi bir sırada bilgi kaybolur JSON düzenlenmemiş olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="d2a31-225">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="d2a31-226">Ayrıca, JSON anahtar aynı ada sahip birden çok anahtar/değer çiftlerinin desteklemez.</span><span class="sxs-lookup"><span data-stu-id="d2a31-226">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="d2a31-227">Son olarak, tüm işlemler <xref:System.Runtime.Serialization.IExtensibleDataObject> kendi türetilmiş bir tür için atanan kendiliğinden çok biçimli - are <xref:System.Object>, tüm türleri için temel tür.</span><span class="sxs-lookup"><span data-stu-id="d2a31-227">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>  
  
## <a name="json-in-urls"></a><span data-ttu-id="d2a31-228">JSON URL'lerde</span><span class="sxs-lookup"><span data-stu-id="d2a31-228">JSON in URLs</span></span>  
 <span data-ttu-id="d2a31-229">ASP.NET AJAX uç noktaları ile HTTP GET fiili kullanırken (kullanarak <xref:System.ServiceModel.Web.WebGetAttribute> özniteliği), ileti gövdesi yerine istek URL'sindeki gelen parametreler görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-229">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="d2a31-230">JSON istek URL'si bile, desteklenen bunu alan bir işlem varsa bir `Int` "number" olarak adlandırılan ve `Person` URL "p" adlı karmaşık türü aşağıdaki URL'yi benzer.</span><span class="sxs-lookup"><span data-stu-id="d2a31-230">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>  
  
```  
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}  
```  
  
 <span data-ttu-id="d2a31-231">Hizmetini çağırmak için bir ASP.NET AJAX komut dosyası Manager denetim ve proxy kullanıyorsanız, bu URL proxy sunucu tarafından otomatik olarak oluşturulur ve değil görülür.</span><span class="sxs-lookup"><span data-stu-id="d2a31-231">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="d2a31-232">JSON, ASP.NET AJAX uç noktalarda URL'ler kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="d2a31-232">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>  
  
## <a name="advanced-information"></a><span data-ttu-id="d2a31-233">Gelişmiş bilgiler</span><span class="sxs-lookup"><span data-stu-id="d2a31-233">Advanced information</span></span>  
  
### <a name="iserializable-support"></a><span data-ttu-id="d2a31-234">ISerializable desteği</span><span class="sxs-lookup"><span data-stu-id="d2a31-234">ISerializable Support</span></span>  
  
#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="d2a31-235">Desteklenen ve desteklenmeyen ISerializable türleri</span><span class="sxs-lookup"><span data-stu-id="d2a31-235">Supported and Unsupported ISerializable Types</span></span>  
 <span data-ttu-id="d2a31-236">Genel olarak, bu uygulama türleri <xref:System.Runtime.Serialization.ISerializable> arabirimi tam olarak serileştirme/seri durumdan çıkarılırken desteklenen JSON.</span><span class="sxs-lookup"><span data-stu-id="d2a31-236">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="d2a31-237">Ancak, bazı (bazı .NET Framework türleri dahil) bu tür özel JSON seri hale getirme yönlerini bunları neden biçimde uygulanan doğru seri durumdan değil:</span><span class="sxs-lookup"><span data-stu-id="d2a31-237">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>  
  
-   <span data-ttu-id="d2a31-238">İle <xref:System.Runtime.Serialization.ISerializable>, tek tek veri üyeleri tür hiçbir zaman önceden denir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-238">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="d2a31-239">Bu, bir nesneye türleri seri durumdan çıkarmak için benzer bir polimorfik durum neden olmaktadır.</span><span class="sxs-lookup"><span data-stu-id="d2a31-239">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="d2a31-240">Önceden belirtildiği gibi JSON içinde türü bilgi kaybına yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-240">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="d2a31-241">Örneğin, serileştiren bir türü bir `enum` içinde kendi <xref:System.Runtime.Serialization.ISerializable> uygulama ve seri durumdan girişimleri geri doğrudan bir `enum` (olmadan uygun atamaları) başarısız olur, çünkü bir `enum` numaraları JSON ve JSON kullanılarak serileştirilmiş sayı yerleşik .NET sayısal türler (Int32, Decimal veya çift) seri durumdan çıkarır.</span><span class="sxs-lookup"><span data-stu-id="d2a31-241">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="d2a31-242">Bu nedenle olgu sayı olması için kullanılan bir `enum` değeri kaybolur.</span><span class="sxs-lookup"><span data-stu-id="d2a31-242">So the fact that the number used to be an `enum` value is lost.</span></span>  
  
-   <span data-ttu-id="d2a31-243">Bir <xref:System.Runtime.Serialization.ISerializable> seri durumdan çıkarma oluşturucusu içinde belirli bir sıraya bağlıdır türü de başarısız olabilir bazı JSON verilerini seri durumdan çıkarılacak çoğu JSON serileştiricileri belirli bir sıraya garanti değil çünkü.</span><span class="sxs-lookup"><span data-stu-id="d2a31-243">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>  
  
#### <a name="factory-types"></a><span data-ttu-id="d2a31-244">Fabrika türü</span><span class="sxs-lookup"><span data-stu-id="d2a31-244">Factory Types</span></span>  
 <span data-ttu-id="d2a31-245">Sırada <xref:System.Runtime.Serialization.IObjectReference> arabirimi genel, "Fabrika türü" özelliği gerektiren herhangi bir türünün JSON'desteklenir (farklı bir türden örneğini döndüren <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> arabirimini uygulayan türünden) desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="d2a31-245">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>  
  
### <a name="datetime-wire-format"></a><span data-ttu-id="d2a31-246">DateTime kablo biçimi</span><span class="sxs-lookup"><span data-stu-id="d2a31-246">DateTime Wire Format</span></span>  
 <span data-ttu-id="d2a31-247"><xref:System.DateTime>değerler "/ Date(700000+0500) /" biçiminde JSON dizeler görünür ilk numarasının (700000 sağlanan örnekte) olduğu (olmayan gün ışığından yararlanma) olan normal GMT saat dilimi milisaniye sayısını gece, 1 Ocak 1970'ten itibaren zaman.</span><span class="sxs-lookup"><span data-stu-id="d2a31-247"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="d2a31-248">Bu sayı önceki saatleri temsil etmek için negatif olabilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-248">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="d2a31-249">Örnekte "+0500" oluşan bölümü isteğe bağlıdır ve zaman, gösterir <xref:System.DateTimeKind.Local> türü - diğer bir deyişle, dönüştürülmesi gereken seri durumdan çıkarma işleminde yerel saat dilimi.</span><span class="sxs-lookup"><span data-stu-id="d2a31-249">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="d2a31-250">Olmazsa, saat olarak seri durumdan olan <xref:System.DateTimeKind.Utc>.</span><span class="sxs-lookup"><span data-stu-id="d2a31-250">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="d2a31-251">Gerçek sayı ("0500" Bu örnekte) ve onun işareti (+ veya -) göz ardı edilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-251">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>  
  
 <span data-ttu-id="d2a31-252">Serileştirilirken <xref:System.DateTime>, <xref:System.DateTimeKind.Local> ve <xref:System.DateTimeKind.Unspecified> kez bir uzaklık ile yazılır ve <xref:System.DateTimeKind.Utc> olmadan yazılır.</span><span class="sxs-lookup"><span data-stu-id="d2a31-252">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>  
  
 <span data-ttu-id="d2a31-253">ASP.NET AJAX istemci JavaScript kodu gibi dizeleri JavaScript ile otomatik olarak dönüştürür. `DateTime` örnekleri.</span><span class="sxs-lookup"><span data-stu-id="d2a31-253">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="d2a31-254">Türünde olmayan bir benzer bir form olan diğer dizeleri varsa <xref:System.DateTime> .NET, bunlar da dönüştürülür.</span><span class="sxs-lookup"><span data-stu-id="d2a31-254">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>  
  
 <span data-ttu-id="d2a31-255">Yalnızca gerçekleşir "/" karakterler atlanır varsa dönüştürme (JSON benzer diğer bir deyişle, "\\/Date(700000+0500)\\/") ve bu nedenle [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]'s JSON Kodlayıcısı (tarafından etkinleştirilen <xref:System.ServiceModel.WebHttpBinding>) her zaman çıkışları "/" karakter.</span><span class="sxs-lookup"><span data-stu-id="d2a31-255">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]'s JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>  
  
### <a name="xml-in-json-strings"></a><span data-ttu-id="d2a31-256">JSON dizeler XML'de</span><span class="sxs-lookup"><span data-stu-id="d2a31-256">XML in JSON Strings</span></span>  
  
#### <a name="xmlelement"></a><span data-ttu-id="d2a31-257">XmlElement</span><span class="sxs-lookup"><span data-stu-id="d2a31-257">XmlElement</span></span>  
 <span data-ttu-id="d2a31-258"><xref:System.Xml.XmlElement>, hiçbir kaydırma ile olduğu gibi serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-258"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="d2a31-259">Örneğin, veri üyesi "x" türü <xref:System.Xml.XmlElement> içeren \<abc / > şu şekilde temsil aynıdır.</span><span class="sxs-lookup"><span data-stu-id="d2a31-259">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is as represented as follows.</span></span>  
  
```json  
{"x":"<abc/>"}  
```  
  
#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="d2a31-260">XmlNode dizileri</span><span class="sxs-lookup"><span data-stu-id="d2a31-260">Arrays of XmlNode</span></span>  
 <span data-ttu-id="d2a31-261"><xref:System.Array>Nesne türü <xref:System.Xml.XmlNode> ArrayOfXmlNode türü için standart veri sözleşmesi ad alanına denilen bir elemana sarılır.</span><span class="sxs-lookup"><span data-stu-id="d2a31-261"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="d2a31-262">"X" özniteliği "N" "değeri" içeren "ns" ad alanında ve bir boş öğesini düğümlerini "M" içeren bir dizi ise, temsili aşağıdaki gibidir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-262">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>  
  
```  
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}  
```  
  
 <span data-ttu-id="d2a31-263">XmlNode diziler (önce diğer öğeleri) başındaki boş ad alanındaki öznitelikler desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="d2a31-263">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>  
  
#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="d2a31-264">IXmlSerializable XElement ve veri kümesi dahil türleri</span><span class="sxs-lookup"><span data-stu-id="d2a31-264">IXmlSerializable Types including XElement and DataSet</span></span>  
 <span data-ttu-id="d2a31-265"><xref:System.Runtime.Serialization.ISerializable>"içerik türleri", "Veri kümesi türleri" ve "öğe türleri" türleri ayırabilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-265"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="d2a31-266">Bu tür tanımları için bkz: [XML ve ADO.NET türleri veri sözleşmelerinde](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="d2a31-266">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>  
  
 <span data-ttu-id="d2a31-267">"İçerik" ve "Veri kümesi" türleri benzer serileştirilir <xref:System.Array> nesnelerin <xref:System.Xml.XmlNode> önceki bölümde tartışılan.</span><span class="sxs-lookup"><span data-stu-id="d2a31-267">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="d2a31-268">Bir öğe adı sarılır ve ad alanı veri sözleşme adına ve türünün ad alanını söz konusu karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-268">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>  
  
 <span data-ttu-id="d2a31-269">"Öğesi" türleri gibi <xref:System.Xml.Linq.XElement> , benzer olarak serileştirilmiş <xref:System.Xml.XmlElement> daha önce bu konuda tartışılan.</span><span class="sxs-lookup"><span data-stu-id="d2a31-269">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>  
  
### <a name="polymorphism"></a><span data-ttu-id="d2a31-270">Çok Biçimlilik</span><span class="sxs-lookup"><span data-stu-id="d2a31-270">Polymorphism</span></span>  
  
#### <a name="preserving-type-information"></a><span data-ttu-id="d2a31-271">Koruma türü bilgileri</span><span class="sxs-lookup"><span data-stu-id="d2a31-271">Preserving Type Information</span></span>  
 <span data-ttu-id="d2a31-272">Çok biçimlilik daha önce belirtildiği gibi bazı kısıtlamalarla JSON'desteklenir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-272">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="d2a31-273">JavaScript bir zayıf yazılmış bir dildir ve türü kimliği bir sorun değildir normalde.</span><span class="sxs-lookup"><span data-stu-id="d2a31-273">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="d2a31-274">Ancak, JSON kesin türü belirtilmiş bir sistem (.NET) ve bir zayıf yazılmış sistem (JavaScript) arasında iletişim kurmak için kullanırken türü kimlik korumak yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="d2a31-274">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="d2a31-275">Örneğin, adları "Kare" ve "Yuvarlak" bir türden "Şeklin" bir veri sözleşmesi adıyla türetilmesi veri türleriyle sözleşme.</span><span class="sxs-lookup"><span data-stu-id="d2a31-275">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="d2a31-276">"Daire".NET JavaScript gönderilir ve daha sonra "Şekil" bekliyor bir .NET yöntemi döndürülür, söz konusu nesne özgün olarak bir "daire" - Aksi durumda olduğunu bilmek için .NET tarafı yararlı olur (örneğin türetilmiş türüne özgü herhangi bir bilgi "Daire" üzerindeki "RADIUS" veri üyesi) kaybolmuş olabilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-276">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>  
  
 <span data-ttu-id="d2a31-277">JSON "türü ipucu" için karmaşık türleri serileştirmek eklenebilir ve seri durumdan çıkarıcının ipucu tanır ve uygun şekilde davranan türü kimlik korumak için.</span><span class="sxs-lookup"><span data-stu-id="d2a31-277">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="d2a31-278">"Türü ipucu", "__type" ("tür" sözcüğü ve ardından iki alt çizgi), JSON anahtar/değer çifti anahtar adlı olur.</span><span class="sxs-lookup"><span data-stu-id="d2a31-278">The "type hint" is a JSON key/value pair with the key name of "__type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="d2a31-279">"(İlk iki nokta üst üste kadar herhangi bir şey adıdır) DataContractName:DataContractNamespace" biçiminde bir JSON dizesi değeridir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-279">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="d2a31-280">Önceki örneği kullanarak, "Daire" gibi seri hale getirilebilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-280">Using the earlier example, "Circle" can be serialized as follows.</span></span>  
  
```json  
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}  
```  
  
 <span data-ttu-id="d2a31-281">Tür ipucu çok benzer `xsi:type` özniteliği XML Şeması örneği standardına göre tanımlanır ve ne zaman kullanılır seri hale getirme/XML seri durumdan çıkarılıyor.</span><span class="sxs-lookup"><span data-stu-id="d2a31-281">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>  
  
 <span data-ttu-id="d2a31-282">Veri üyeleri "__type" olarak adlandırılan türü İpucu ile olası çakışması nedeniyle yasaktır.</span><span class="sxs-lookup"><span data-stu-id="d2a31-282">Data members called "__type" are forbidden due to potential conflict with the type hint.</span></span>  
  
#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="d2a31-283">Türü ipuçları boyutunu azaltma</span><span class="sxs-lookup"><span data-stu-id="d2a31-283">Reducing the Size of Type Hints</span></span>  
 <span data-ttu-id="d2a31-284">JSON iletilerin boyutunu azaltmak için varsayılan veri sözleşmesi ad alanı öneki (http://schemas.datacontract.org/2004/07/) "#" karakteri ile değiştirilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-284">To reduce the size of JSON messages, the default data contract namespace prefix (http://schemas.datacontract.org/2004/07/) is replaced with the "#" character.</span></span> <span data-ttu-id="d2a31-285">(Escaping bir kural bu değiştirme ters çevrilebilir yapmak için kullanılır: ad "#" ile başlıyorsa veya "\\" karakterleri, fazladan ile eklenir "\\" karakter).</span><span class="sxs-lookup"><span data-stu-id="d2a31-285">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="d2a31-286">Bu nedenle, "Daire" "MyApp.Shapes".NET ad alanındaki bir türü ise, varsayılan veri sözleşmesi ad http://schemas.datacontract.org/2004/07/MyApp olur.</span><span class="sxs-lookup"><span data-stu-id="d2a31-286">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is http://schemas.datacontract.org/2004/07/MyApp.</span></span> <span data-ttu-id="d2a31-287">Şekiller ve JSON gösterimi aşağıdaki gibidir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-287">Shapes and the JSON representation is as follows.</span></span>  
  
```json  
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}  
```  
  
 <span data-ttu-id="d2a31-288">Kesilmiş (#MyApp.Shapes) ve tam (http://schemas.datacontract.org/2004/07/MyApp.Shapes) adlarını seri durumundan çıkarma işleminde anladım.</span><span class="sxs-lookup"><span data-stu-id="d2a31-288">Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.</span></span>  
  
#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="d2a31-289">JSON nesnelerinin türü ipucu konumu</span><span class="sxs-lookup"><span data-stu-id="d2a31-289">Type Hint Position in JSON Objects</span></span>  
 <span data-ttu-id="d2a31-290">Tür ipucu JSON gösterimi ilk olması gerektiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="d2a31-290">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="d2a31-291">Bu anahtar/değer çiftlerinin sırasını JSON işlenirken önemli olduğu tek bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="d2a31-291">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="d2a31-292">Örneğin, şu tür ipucu belirtmek için geçerli bir yol değil.</span><span class="sxs-lookup"><span data-stu-id="d2a31-292">For example, the following is not a valid way to specify the type hint.</span></span>  
  
```json  
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}  
```  
  
 <span data-ttu-id="d2a31-293">Her iki <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> tarafından kullanılan [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] ve ASP.NET AJAX istemci sayfaları her zaman yayma türü ipucu ilk.</span><span class="sxs-lookup"><span data-stu-id="d2a31-293">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] and ASP.NET AJAX client pages always emit the type hint first.</span></span>  
  
#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="d2a31-294">Türü ipuçları yalnızca karmaşık türleri için geçerlidir</span><span class="sxs-lookup"><span data-stu-id="d2a31-294">Type Hints Apply Only to Complex Types</span></span>  
 <span data-ttu-id="d2a31-295">Karmaşık olmayan türleri için tür ipucu yaymak üzere yolu yoktur.</span><span class="sxs-lookup"><span data-stu-id="d2a31-295">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="d2a31-296">Örneğin, bir işlem varsa bir <xref:System.Object> bir daire dönüş türü döndürür ancak, daha önce gösterildiği gibi JSON gösterimi olabilir ve tür bilgileri korunur.</span><span class="sxs-lookup"><span data-stu-id="d2a31-296">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="d2a31-297">Ancak, URI döndürülürse, JSON temsili bir dize ve bir URI temsil etmek için kullanılan dize kaybolur olgu gerekir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-297">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="d2a31-298">Bu, yalnızca ilkel türler için aynı zamanda koleksiyonlar ve diziler için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-298">This applies not only to primitive types but also to collections and arrays.</span></span>  
  
#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="d2a31-299">Türü ipuçları zaman gösterilen</span><span class="sxs-lookup"><span data-stu-id="d2a31-299">When Are Type Hints Emitted</span></span>  
 <span data-ttu-id="d2a31-300">Türü ipuçları artırabileceği ileti boyutu önemli ölçüde (azaltmak için tek yönlü kısa veri sözleşmesi ad alanları mümkünse kullanmak için budur).</span><span class="sxs-lookup"><span data-stu-id="d2a31-300">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="d2a31-301">Bu nedenle, türü ipuçları yayılan olup olmadığını aşağıdaki kurallar kapsar:</span><span class="sxs-lookup"><span data-stu-id="d2a31-301">Therefore, the following rules govern whether type hints are emitted:</span></span>  
  
-   <span data-ttu-id="d2a31-302">Olsa bile hiçbir temel ve türetilen atama - Örneğin, bir daire bir daire atanmış olsa bile ASP.NET AJAX'ı kullanırken, türü ipuçları her zaman mümkün olduğunda, gösterilen.</span><span class="sxs-lookup"><span data-stu-id="d2a31-302">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="d2a31-303">(Bu kesin türü belirtilmiş .NET ortamına zayıf yazılmış JSON ortamından arama işlemi şaşırtıcı hiçbir bilgi kaybı ile tam olarak etkinleştirmek için gereklidir.)</span><span class="sxs-lookup"><span data-stu-id="d2a31-303">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>  
  
-   <span data-ttu-id="d2a31-304">Daire şekle atandığında yayılan bir taban ve türetilmiş atamasını - olduğunda AJAX Hizmetleri ile tümleştirme yoktur ASP.NET kullanılırken türü ipuçları yalnızca gösterilen veya <xref:System.Object> ancak daireye atandığında değil.</span><span class="sxs-lookup"><span data-stu-id="d2a31-304">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="d2a31-305">Bu doğru böylece performansı, iyileştirme bir JavaScript istemci uygulamak için gereken en az bilgiyi sağlar ancak yanlış tasarlanan istemciler türü bilgi kaybına karşı koruma sağlamaz.</span><span class="sxs-lookup"><span data-stu-id="d2a31-305">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="d2a31-306">Bu sorunla istemcide önlemek istiyorsanız, temel ve türetilen atamaları sunucu üzerinde tamamen kaçının.</span><span class="sxs-lookup"><span data-stu-id="d2a31-306">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>  
  
-   <span data-ttu-id="d2a31-307">Kullanırken <xref:System.Runtime.Serialization.DataContractSerializer> türü, `alwaysEmitTypeInformation` Oluşturucusu parametresi, varsayılan olan ile önceki iki mod arasında seçim yapmanızı sağlar "`false`" (yalnızca gerekli olduğunda türü ipuçları yayma).</span><span class="sxs-lookup"><span data-stu-id="d2a31-307">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>  
  
#### <a name="duplicate-data-member-names"></a><span data-ttu-id="d2a31-308">Yinelenen veri üyesi adları</span><span class="sxs-lookup"><span data-stu-id="d2a31-308">Duplicate Data Member Names</span></span>  
 <span data-ttu-id="d2a31-309">Türetilmiş bir tür bilgiler temel türü bilgileriyle birlikte aynı JSON nesnesinde yok ve herhangi bir sırada ortaya çıkabilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-309">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="d2a31-310">Örneğin, `Shape` gibi temsil edilebilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-310">For example, `Shape` may be represented as follows.</span></span>  
  
```json  
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}  
```  
  
 <span data-ttu-id="d2a31-311">Daire gibi temsil edilebilir ise.</span><span class="sxs-lookup"><span data-stu-id="d2a31-311">Whereas Circle may be represented as follows.</span></span>  
  
```json  
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}  
```  
  
 <span data-ttu-id="d2a31-312">Varsa temel `Shape` türü olarak adlandırılan bir veri üyesi de yer alan "`radius`", (JSON nesnelerinin anahtar adları yinelenen olamayacağından) Bu bir çakışma üzerinde hem serileştirme müşteri adayları ve (, "RADIUS" için olupbaşvuruyorbelirsizolduğundanseridurumundançıkarma`Shape.radius` veya `Circle.radius`).</span><span class="sxs-lookup"><span data-stu-id="d2a31-312">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="d2a31-313">Bu nedenle, "özelliği gizleme" kavramı while (veri üyeleri aynı adına, temel ve türetilmiş sınıfları) genellikle önerilmez veri sözleşmesi sınıflarda, aslında yasaklandı JSON söz konusu olduğunda.</span><span class="sxs-lookup"><span data-stu-id="d2a31-313">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>  
  
#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="d2a31-314">Çok biçimlilik ve IXmlSerializable türleri</span><span class="sxs-lookup"><span data-stu-id="d2a31-314">Polymorphism and IXmlSerializable Types</span></span>  
 <span data-ttu-id="d2a31-315"><xref:System.Xml.Serialization.IXmlSerializable>Bilinen türleri gereksinimleri karşılandığında, normal veri sözleşmesi kurallara göre sürece türleri polymorphically birbirlerine her zamanki gibi atanmış olabilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-315"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="d2a31-316">Ancak, seri hale getirilirken bir <xref:System.Xml.Serialization.IXmlSerializable> yerine yazın <xref:System.Object> sonucu bir JSON dizesi olarak türü bilgi kaybına sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="d2a31-316">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>  
  
#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="d2a31-317">Çok biçimlilik ve belirli arabirimi türleri</span><span class="sxs-lookup"><span data-stu-id="d2a31-317">Polymorphism and Certain Interface Types</span></span>  
 <span data-ttu-id="d2a31-318">Koleksiyon türü veya uygulayan bir tür serileştirmek için Yasak <xref:System.Xml.Serialization.IXmlSerializable> değil bir koleksiyon olmayan tür burada <xref:System.Xml.Serialization.IXmlSerializable> (dışında <xref:System.Object>) bekleniyor.</span><span class="sxs-lookup"><span data-stu-id="d2a31-318">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="d2a31-319">Örneğin, özel bir arabirim adlı `IMyInterface` ve bir tür `MyType` da uygulayan her ikisi de <xref:System.Collections.Generic.IEnumerable%601> türü `int` ve `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="d2a31-319">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="d2a31-320">Döndürülecek Yasak `MyType` dönüş türü olan bir işlem `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="d2a31-320">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="d2a31-321">Bunun nedeni, `MyType` , önce belirtilen olarak içeremez yalnızca karmaşık türlerle diziler türü ipucuyla bir JSON dizisi olarak seri hale ve türü ipucu gerektirir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-321">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>  
  
#### <a name="known-types-and-configuration"></a><span data-ttu-id="d2a31-322">Bilinen türler ve yapılandırma</span><span class="sxs-lookup"><span data-stu-id="d2a31-322">Known Types and Configuration</span></span>  
 <span data-ttu-id="d2a31-323">Tarafından kullanılan bilinen türü mekanizmaları tümünün <xref:System.Runtime.Serialization.DataContractSerializer> da aynı şekilde tarafından desteklenen <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span><span class="sxs-lookup"><span data-stu-id="d2a31-323">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="d2a31-324">Aynı yapılandırma öğesinde hem serileştiricileri okuma [ \<dataContractSerializer >](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) içinde [ \<system.runtime.serialization >](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), eklenen bilinen türleri bulmak için bir yapılandırma dosyası.</span><span class="sxs-lookup"><span data-stu-id="d2a31-324">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>  
  
#### <a name="collections-assigned-to-object"></a><span data-ttu-id="d2a31-325">Nesne atanmış koleksiyonları</span><span class="sxs-lookup"><span data-stu-id="d2a31-325">Collections Assigned to Object</span></span>  
 <span data-ttu-id="d2a31-326">Nesnesine atanmış koleksiyonları uygulamak koleksiyonları varsa gibi serileştirilir <xref:System.Collections.Generic.IEnumerable%601>: karmaşık bir tür ise türü ipucu sahip her giriş ile JSON dizisi.</span><span class="sxs-lookup"><span data-stu-id="d2a31-326">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="d2a31-327">Örneğin, bir <xref:System.Collections.Generic.List%601> türü `Shape` atanan <xref:System.Object> aşağıdaki gibi görünür.</span><span class="sxs-lookup"><span data-stu-id="d2a31-327">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>  
  
```json  
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},  
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},  
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]  
```  
  
 <span data-ttu-id="d2a31-328">Uygulamasına geri seri zaman <xref:System.Object>:</span><span class="sxs-lookup"><span data-stu-id="d2a31-328">When deserialized back into <xref:System.Object>:</span></span>  
  
-   <span data-ttu-id="d2a31-329">`Shape`Bilinen türleri listesinde olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-329">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="d2a31-330">Sahip <xref:System.Collections.Generic.List%601> türü `Shape` bilinen türleri hiçbir etkisi olmaz.</span><span class="sxs-lookup"><span data-stu-id="d2a31-330">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="d2a31-331">Eklemek zorunda değilsiniz Not `Shape` için bilinen seri hale getirme türlerinde bu durumda - bu otomatik olarak yapılır.</span><span class="sxs-lookup"><span data-stu-id="d2a31-331">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>  
  
-   <span data-ttu-id="d2a31-332">Koleksiyon olarak seri durumdan bir <xref:System.Array> türü <xref:System.Object> içeren `Shape` örnekleri.</span><span class="sxs-lookup"><span data-stu-id="d2a31-332">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>  
  
#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="d2a31-333">Temel koleksiyonlara atanmış türetilmiş koleksiyonları</span><span class="sxs-lookup"><span data-stu-id="d2a31-333">Derived Collections Assigned to Base Collections</span></span>  
 <span data-ttu-id="d2a31-334">Türetilen bir koleksiyon temel bir koleksiyona atandığında, temel türünü birtakım boşmuş gibi koleksiyon genellikle seri değildir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-334">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="d2a31-335">Ancak, temel koleksiyonun öğe türü türetilen koleksiyonun öğe türü atanamıyorsa özel durum oluşur.</span><span class="sxs-lookup"><span data-stu-id="d2a31-335">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>  
  
#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="d2a31-336">Türü ipuçları ve sözlük</span><span class="sxs-lookup"><span data-stu-id="d2a31-336">Type Hints and Dictionaries</span></span>  
 <span data-ttu-id="d2a31-337">Ne zaman bir sözlük atanması bir <xref:System.Object>, atanmış gibi her anahtar ve değer giriş sözlükteki davranılır <xref:System.Object> ve türü ipucu alır.</span><span class="sxs-lookup"><span data-stu-id="d2a31-337">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>  
  
 <span data-ttu-id="d2a31-338">Sözlük türleri serileştirilirken "Anahtar" ve "Değeri" üyeleri içeren JSON nesnesi tarafından etkilenmez `alwaysEmitTypeInformation` ayarlama ve önceki toplama kuralları gerektirdiğinde türü İpucu yalnızca içerir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-338">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>  
  
### <a name="valid-json-key-names"></a><span data-ttu-id="d2a31-339">Geçerli bir JSON anahtar adları</span><span class="sxs-lookup"><span data-stu-id="d2a31-339">Valid JSON Key Names</span></span>  
 <span data-ttu-id="d2a31-340">Geçerli XML adları seri hale getirici XML kodlar anahtar adları.</span><span class="sxs-lookup"><span data-stu-id="d2a31-340">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="d2a31-341">Örneğin, bir veri üyesi "123" adı ile kodlanmış bir adı gibi gerekir "_x0031\__x0032\__x0033\_" "123" geçersiz bir XML öğesi adı (bir rakam ile başlayan) olduğundan.</span><span class="sxs-lookup"><span data-stu-id="d2a31-341">For example, a data member with the name of "123" would have an encoded name such as "_x0031\__x0032\__x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="d2a31-342">XML adlarında geçerli olmayan bazı uluslararası karakter kümeleri ile benzer bir durum ortaya çıkabilir.</span><span class="sxs-lookup"><span data-stu-id="d2a31-342">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="d2a31-343">Bu JSON işleme XML etkisini açıklaması için bkz: [arasında eşleme JSON ve XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="d2a31-343">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d2a31-344">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="d2a31-344">See Also</span></span>  
 [<span data-ttu-id="d2a31-345">JSON ve diğer veri aktarma biçimleri için destek</span><span class="sxs-lookup"><span data-stu-id="d2a31-345">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)

---
title: "İş Parçacığı Modeli"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
caps.latest.revision: "33"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: f0badceeb9ce085dc68fce2c59ec6c42877f2622
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/22/2017
---
# <a name="threading-model"></a><span data-ttu-id="546f1-102">İş Parçacığı Modeli</span><span class="sxs-lookup"><span data-stu-id="546f1-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="546f1-103">Geliştiriciler iş parçacığı kurtarmak için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="546f1-103"> is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="546f1-104">Sonuç olarak, çoğu [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] geliştiriciler birden çok iş parçacığı kullanan bir arabirim yazma zorunda kalmaz.</span><span class="sxs-lookup"><span data-stu-id="546f1-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="546f1-105">Birden çok iş parçacıklı programlar karmaşık ve hata ayıklama zor olduğundan, bunlar tek iş parçacıklı çözümleri bulunduğunda kaçınılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="546f1-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>  
  
 <span data-ttu-id="546f1-106">Geçtiğinden bağımsız ne kadar iyi, ancak Hayır tasarlanmış [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework hiç kurulamayacak sorun her tür için tek iş parçacıklı bir çözüm sağlar.</span><span class="sxs-lookup"><span data-stu-id="546f1-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="546f1-107">Kapat gelir ancak hala burada birden çok iş parçacığı artırmak durumlarda [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] yanıtlama hızı veya uygulama performans.</span><span class="sxs-lookup"><span data-stu-id="546f1-107"> comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="546f1-108">Bazı arka plan malzeme ele sonra bu kağıt bunlardan bazıları inceler ve bazı alt düzey ayrıntıların tartışması ile sonlanır.</span><span class="sxs-lookup"><span data-stu-id="546f1-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>  
  

  
> [!NOTE]
>  <span data-ttu-id="546f1-109">Bu konuda ele alınmıştır kullanarak iş parçacığı oluşturma <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> zaman uyumsuz çağrılar için yöntem.</span><span class="sxs-lookup"><span data-stu-id="546f1-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="546f1-110">Ayrıca zaman uyumsuz çağrılar çağırarak yapabileceğiniz <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> ele yöntemi bir <xref:System.Action> veya <xref:System.Func%601> bir parametre olarak.</span><span class="sxs-lookup"><span data-stu-id="546f1-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="546f1-111"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> Yöntemi döndürür bir <xref:System.Windows.Threading.DispatcherOperation> veya <xref:System.Windows.Threading.DispatcherOperation%601>, sahip olduğu bir <xref:System.Windows.Threading.DispatcherOperation.Task%2A> özelliği.</span><span class="sxs-lookup"><span data-stu-id="546f1-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="546f1-112">Kullanabileceğiniz `await` ya da anahtar sözcük <xref:System.Windows.Threading.DispatcherOperation> veya ilişkili <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="546f1-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="546f1-113">Zaman uyumlu olarak bekleyin gerekiyorsa <xref:System.Threading.Tasks.Task> tarafından döndürülen bir <xref:System.Windows.Threading.DispatcherOperation> veya <xref:System.Windows.Threading.DispatcherOperation%601>, çağrı <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> genişletme yöntemi.</span><span class="sxs-lookup"><span data-stu-id="546f1-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="546f1-114">Çağırma <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> bir kilitlenmeyle sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="546f1-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="546f1-115">Kullanma hakkında daha fazla bilgi için bir <xref:System.Threading.Tasks.Task> görev Paralelliği zaman uyumsuz işlemleri gerçekleştirmek için bkz.</span><span class="sxs-lookup"><span data-stu-id="546f1-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="546f1-116"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> Yöntemi de ele aşırı sahip bir <xref:System.Action> veya <xref:System.Func%601> bir parametre olarak.</span><span class="sxs-lookup"><span data-stu-id="546f1-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="546f1-117">Kullanabileceğiniz <xref:System.Windows.Threading.Dispatcher.Invoke%2A> zaman uyumlu yapma yöntemini çağıran bir temsilci geçirerek <xref:System.Action> veya <xref:System.Func%601>.</span><span class="sxs-lookup"><span data-stu-id="546f1-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>  
  
<a name="threading_overview"></a>   
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="546f1-118">Genel bakış ve dağıtıcı</span><span class="sxs-lookup"><span data-stu-id="546f1-118">Overview and the Dispatcher</span></span>  
 <span data-ttu-id="546f1-119">Genellikle, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uygulamalar iki iş parçacığı ile başlar: oluşturma ve yönetme için başka bir işleme için bir tane [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="546f1-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="546f1-120">İşleme iş parçacığı etkili bir şekilde arka planda gizli olarak çalıştırılır [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı Giriş alır, olaylarını işleme, ekran boyar ve uygulama kodu çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="546f1-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="546f1-121">Çoğu uygulama tek kullanımlık [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] bazı durumlarda birkaç en iyi yöntem olmasına rağmen iş parçacığı.</span><span class="sxs-lookup"><span data-stu-id="546f1-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="546f1-122">Biz bu örnek ile daha sonra ele alacağız.</span><span class="sxs-lookup"><span data-stu-id="546f1-122">We’ll discuss this with an example later.</span></span>  
  
 <span data-ttu-id="546f1-123">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] İş parçacığı sıraları çalışma öğeleri adlı bir nesne içinde bir <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="546f1-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="546f1-124"><xref:System.Windows.Threading.Dispatcher> Öncelik temelinde iş öğeleri seçer ve her birinin tamamlanma çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="546f1-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="546f1-125">Her [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı en az bir olmalıdır <xref:System.Windows.Threading.Dispatcher>ve her <xref:System.Windows.Threading.Dispatcher> tam olarak bir iş parçacığında iş öğelerini yürütebilir.</span><span class="sxs-lookup"><span data-stu-id="546f1-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>  
  
 <span data-ttu-id="546f1-126">En üst düzeye çıkarmak için esnek ve kullanımı kolay uygulamaları oluşturmak için yeterli olan <xref:System.Windows.Threading.Dispatcher> keserek iş öğeleri küçük üretilen iş.</span><span class="sxs-lookup"><span data-stu-id="546f1-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="546f1-127">Bu şekilde öğeler hiçbir zaman eskimez <xref:System.Windows.Threading.Dispatcher> işlenmek üzere beklerken sırası.</span><span class="sxs-lookup"><span data-stu-id="546f1-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="546f1-128">Bir kullanıcı girdisi ve yanıt arasındaki fark edilebilir gecikme rahatsız edebilir.</span><span class="sxs-lookup"><span data-stu-id="546f1-128">Any perceivable delay between input and response can frustrate a user.</span></span>  
  
 <span data-ttu-id="546f1-129">Nasıl daha sonra [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uygulamaları olması büyük işlemlerini işlemek için?</span><span class="sxs-lookup"><span data-stu-id="546f1-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="546f1-130">Ne kodunuz büyük hesaplama içerir veya bazı uzak sunucudaki veritabanını sorgulama gerekiyor?</span><span class="sxs-lookup"><span data-stu-id="546f1-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="546f1-131">Genellikle, yanıt bırakarak ayrı bir iş parçacığı büyük işlemi yönetmektir [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] öğelerde eğilimindedir boş iş parçacığı <xref:System.Windows.Threading.Dispatcher> sırası.</span><span class="sxs-lookup"><span data-stu-id="546f1-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="546f1-132">Büyük işlemi tamamlandıktan sonra sonuç raporlayabilirsiniz geri [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] görüntülemek için iş parçacığı.</span><span class="sxs-lookup"><span data-stu-id="546f1-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>  
  
 <span data-ttu-id="546f1-133">Geçmişte, [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] sağlayan [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] yalnızca oluşturuldukları iş parçacığı tarafından erişilecek öğeleri.</span><span class="sxs-lookup"><span data-stu-id="546f1-133">Historically, [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="546f1-134">Bu tamamlandığında bir arka plan iş parçacığı bazı uzun süre çalışan görev sorumlu bir metin kutusu güncelleştirilemiyor anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="546f1-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="546f1-135">Bu bütünlüğünü sağlamak için [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] bileşenleri.</span><span class="sxs-lookup"><span data-stu-id="546f1-135"> does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="546f1-136">Liste kutusu içeriğinin boyama sırasında bir arka plan iş parçacığı tarafından güncelleştirildiyse garip görünebilir.</span><span class="sxs-lookup"><span data-stu-id="546f1-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="546f1-137">Bu koordinasyonu zorlayan bir yerleşik karşılıklı dışlama mekanizması vardır.</span><span class="sxs-lookup"><span data-stu-id="546f1-137"> has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="546f1-138">Çoğu sınıflarda [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] öğesinden türetilen <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="546f1-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="546f1-139">Yapım, adresindeki bir <xref:System.Windows.Threading.DispatcherObject> başvuru depolar <xref:System.Windows.Threading.Dispatcher> şu anda çalışan iş parçacığına bağlı.</span><span class="sxs-lookup"><span data-stu-id="546f1-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="546f1-140">Uygulamada <xref:System.Windows.Threading.DispatcherObject> oluşturduğu iş parçacığı ile ilişkilendirir.</span><span class="sxs-lookup"><span data-stu-id="546f1-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="546f1-141">Program yürütme sırasında bir <xref:System.Windows.Threading.DispatcherObject> kendi ortak çağırabilirsiniz <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="546f1-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="546f1-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>inceler <xref:System.Windows.Threading.Dispatcher> geçerli iş parçacığı ile ilişkili olan ve kendisine karşılaştırır <xref:System.Windows.Threading.Dispatcher> oluşturma sırasında depolanan başvuru.</span><span class="sxs-lookup"><span data-stu-id="546f1-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="546f1-143">Bunlar eşleşmiyorsa, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> bir özel durum oluşturur.</span><span class="sxs-lookup"><span data-stu-id="546f1-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="546f1-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>ait her yöntemi başındaki çağrılmaya yönelik bir <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="546f1-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>  
  
 <span data-ttu-id="546f1-145">Bir iş parçacığı değiştirebilirsiniz yalnızca [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], nasıl arka plan iş parçacıkları etkileşim kullanıcıyla?</span><span class="sxs-lookup"><span data-stu-id="546f1-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="546f1-146">Arka plan iş parçacığı sorabilirsiniz [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] adına üzerinde bir işlemi gerçekleştirmek için iş parçacığı.</span><span class="sxs-lookup"><span data-stu-id="546f1-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="546f1-147">Bunu bir iş öğesi ile kaydederek yapar <xref:System.Windows.Threading.Dispatcher> , [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı.</span><span class="sxs-lookup"><span data-stu-id="546f1-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="546f1-148"><xref:System.Windows.Threading.Dispatcher> Sınıfı, iş öğelerini kaydetme için iki yöntem sağlar: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ve <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="546f1-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="546f1-149">Her iki yöntem yürütme için temsilci zamanlayın.</span><span class="sxs-lookup"><span data-stu-id="546f1-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="546f1-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>zaman uyumlu bir çağrı – başka bir deyişle, kadar döndürmez [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı gerçekten bittikten temsilci yürütülüyor.</span><span class="sxs-lookup"><span data-stu-id="546f1-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="546f1-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>zaman uyumsuz olarak çağrılır ve hemen döndürür.</span><span class="sxs-lookup"><span data-stu-id="546f1-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>  
  
 <span data-ttu-id="546f1-152"><xref:System.Windows.Threading.Dispatcher> Öğeleri sırasındaki önceliğe göre sıralar.</span><span class="sxs-lookup"><span data-stu-id="546f1-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="546f1-153">Bir öğe olarak eklerken belirtilen on düzeyi vardır <xref:System.Windows.Threading.Dispatcher> sırası.</span><span class="sxs-lookup"><span data-stu-id="546f1-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="546f1-154">Bu öncelikleri içinde korunur <xref:System.Windows.Threading.DispatcherPriority> numaralandırması.</span><span class="sxs-lookup"><span data-stu-id="546f1-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="546f1-155">Hakkında ayrıntılı bilgi <xref:System.Windows.Threading.DispatcherPriority> düzeyleri bulunabilir [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] belgeleri.</span><span class="sxs-lookup"><span data-stu-id="546f1-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] documentation.</span></span>  
  
<a name="samples"></a>   
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="546f1-156">Eylem iş parçacıklarında: örnekler</span><span class="sxs-lookup"><span data-stu-id="546f1-156">Threads in Action: The Samples</span></span>  
  
<a name="prime_number"></a>   
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="546f1-157">Uzun süre çalışan hesaplama tek iş parçacıklı bir uygulamayla</span><span class="sxs-lookup"><span data-stu-id="546f1-157">A Single-Threaded Application with a Long-Running Calculation</span></span>  
 <span data-ttu-id="546f1-158">Çoğu [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] yanıt kullanıcı etkileşimleri olarak oluşturulan olaylar beklenirken boşta kalma zaman büyük bir kısmını harcamanız.</span><span class="sxs-lookup"><span data-stu-id="546f1-158">Most [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="546f1-159">Dikkatli programlamayla bu boşta kalma süresi constructively, yanıtlama hızını etkilemeden kullanılabilir [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="546f1-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="546f1-160">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Modeli iş parçacığı içinde yapılmazsa bir işlemi kesmek giriş izin vermez [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı.</span><span class="sxs-lookup"><span data-stu-id="546f1-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="546f1-161">Bu geri dönmek emin olmalısınız anlamına gelir <xref:System.Windows.Threading.Dispatcher> düzenli aralıklarla eski ulaşmadan giriş olaylarını bekleyen işleyemedi.</span><span class="sxs-lookup"><span data-stu-id="546f1-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>  
  
 <span data-ttu-id="546f1-162">Aşağıdaki örnek göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="546f1-162">Consider the following example:</span></span>  
  
 <span data-ttu-id="546f1-163">![Asal sayılar ekran görüntüsü](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG "ThreadingPrimeNumberScreenShot")</span><span class="sxs-lookup"><span data-stu-id="546f1-163">![Prime numbers screen shot](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG "ThreadingPrimeNumberScreenShot")</span></span>  
  
 <span data-ttu-id="546f1-164">Bu basit uygulama, üç, aramasını asal sayılar için yukarı doğru sayar.</span><span class="sxs-lookup"><span data-stu-id="546f1-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="546f1-165">Kullanıcı tıkladığında **Başlat** arama düğmesini başlar.</span><span class="sxs-lookup"><span data-stu-id="546f1-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="546f1-166">Program bir asal bulduğunda, kullanıcı arabirimini keşfi ile güncelleştirir.</span><span class="sxs-lookup"><span data-stu-id="546f1-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="546f1-167">Herhangi bir noktada kullanıcı arama durdurabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="546f1-167">At any point, the user can stop the search.</span></span>  
  
 <span data-ttu-id="546f1-168">Basit olmasına rağmen asal sayı araması bazı sorunlar sunan sonsuza kadar gidebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="546f1-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="546f1-169">Biz düğmenin click olay işleyicisi içinde tüm arama işleniyorsa biz hiçbir zaman verirsiniz [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] diğer olayları işlemek için bir fırsat iş parçacığı.</span><span class="sxs-lookup"><span data-stu-id="546f1-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="546f1-170">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] Giriş veya işlem yanıt verip vermediğini olacaktır iletileri.</span><span class="sxs-lookup"><span data-stu-id="546f1-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="546f1-171">Hiçbir zaman yeniden çizilmez ve hiçbir zaman düğme tıklamalarına yanıt.</span><span class="sxs-lookup"><span data-stu-id="546f1-171">It would never repaint and never respond to button clicks.</span></span>  
  
 <span data-ttu-id="546f1-172">Ayrı bir iş parçacığı asal sayı araması gerçekleştir, ancak daha sonra eşitleme sorunlarının üstesinden gelmek için ihtiyacımız.</span><span class="sxs-lookup"><span data-stu-id="546f1-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="546f1-173">Tek iş parçacıklı bir yaklaşım ile biz bulunan büyük asal listeler etiketi doğrudan güncelleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="546f1-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>  
  
 <span data-ttu-id="546f1-174">Biz yönetilebilir yığınlar halinde hesaplamanın görev bölmeniz, biz düzenli aralıklarla geri dönebilirsiniz <xref:System.Windows.Threading.Dispatcher> ve işlem olayları.</span><span class="sxs-lookup"><span data-stu-id="546f1-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="546f1-175">Biz verebilirsiniz [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] yeniden çizilmez ve girişini işlemek için bir fırsat.</span><span class="sxs-lookup"><span data-stu-id="546f1-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>  
  
 <span data-ttu-id="546f1-176">İşleme süresini hesaplama ve olay işleme arasında bölmek için en iyi yolu hesaplama yönetmektir <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="546f1-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="546f1-177">Kullanarak <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> yöntemi, biz asal sayı denetimlerini zamanlayabilir aynı sıraya [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] olayları gelen çizilir.</span><span class="sxs-lookup"><span data-stu-id="546f1-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="546f1-178">Bizim örneğimizde, aynı anda yalnızca bir tek asal sayı denetimi zamanlayın.</span><span class="sxs-lookup"><span data-stu-id="546f1-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="546f1-179">Asal sayı kontrolü tamamlandıktan sonra biz sonraki onay hemen zamanlayın.</span><span class="sxs-lookup"><span data-stu-id="546f1-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="546f1-180">Bu onay bekleyen yalnızca sonra ilerler [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] olayları işlenmiş.</span><span class="sxs-lookup"><span data-stu-id="546f1-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>  
  
 <span data-ttu-id="546f1-181">![Dağıtıcı sırası çizimi](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG "ThreadingDispatcherQueue")</span><span class="sxs-lookup"><span data-stu-id="546f1-181">![Dispatcher queue illustration](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG "ThreadingDispatcherQueue")</span></span>  
  
 [!INCLUDE[TLA#tla_word](../../../../includes/tlasharptla-word-md.md)]<span data-ttu-id="546f1-182">Bu mekanizmayı kullanarak yazım denetimi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="546f1-182"> accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="546f1-183">Yazım denetimi boşta kalma süresi kullanarak arka planda gerçekleştirilir [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı.</span><span class="sxs-lookup"><span data-stu-id="546f1-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="546f1-184">Kod bir göz atalım.</span><span class="sxs-lookup"><span data-stu-id="546f1-184">Let's take a look at the code.</span></span>  
  
 <span data-ttu-id="546f1-185">Aşağıdaki örnekte kullanıcı arabirimi oluşturan XAML gösterir.</span><span class="sxs-lookup"><span data-stu-id="546f1-185">The following example shows the XAML that creates the user interface.</span></span>  
  
 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]  
  
 <span data-ttu-id="546f1-186">Aşağıdaki örnek, arka plan kodu gösterir.</span><span class="sxs-lookup"><span data-stu-id="546f1-186">The following example shows the code-behind.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]  
  
 <span data-ttu-id="546f1-187">Aşağıdaki örnek, olay işleyicisi gösterir <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="546f1-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]  
  
 <span data-ttu-id="546f1-188">Üzerinde metnini güncelleştirme yanı sıra <xref:System.Windows.Controls.Button>, bu işleyici, bir temsilci ekleyerek ilk asal sayı onay zamanlama için sorumludur <xref:System.Windows.Threading.Dispatcher> sırası.</span><span class="sxs-lookup"><span data-stu-id="546f1-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="546f1-189">Bu olay işleyicisi kendi iş tamamlandıktan sonra süre <xref:System.Windows.Threading.Dispatcher> yürütme için bu temsilciyi seçer.</span><span class="sxs-lookup"><span data-stu-id="546f1-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>  
  
 <span data-ttu-id="546f1-190">Daha önce belirtildiği gibi <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> olan <xref:System.Windows.Threading.Dispatcher> üye yürütme için temsilci zamanlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="546f1-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="546f1-191">Bu durumda, biz seçin <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> öncelik.</span><span class="sxs-lookup"><span data-stu-id="546f1-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="546f1-192"><xref:System.Windows.Threading.Dispatcher> Yalnızca işlemek için hiçbir önemli olayları olduğunda bu temsilciyi çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="546f1-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]<span data-ttu-id="546f1-193">yanıt hızını numarası denetleniyor değerinden daha önemlidir.</span><span class="sxs-lookup"><span data-stu-id="546f1-193"> responsiveness is more important than number checking.</span></span> <span data-ttu-id="546f1-194">Biz de numarası denetleniyor yordamı temsil eden yeni bir temsilci geçirin.</span><span class="sxs-lookup"><span data-stu-id="546f1-194">We also pass a new delegate representing the number-checking routine.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]  
  
 <span data-ttu-id="546f1-195">Bu yöntem, sonraki tek sayı asal olup olmadığını denetler.</span><span class="sxs-lookup"><span data-stu-id="546f1-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="546f1-196">Asal ise, yöntem doğrudan güncelleştirmeleri `bigPrime` <xref:System.Windows.Controls.TextBlock> keşfi yansıtacak şekilde.</span><span class="sxs-lookup"><span data-stu-id="546f1-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="546f1-197">Hesaplama bileşeni oluşturmak için kullanılan aynı iş parçacığında oluşturduğumuzdan bunu yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="546f1-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="546f1-198">Biz seçilen hesaplama için ayrı bir iş parçacığı kullanmak, biz daha karmaşık bir eşitleme mekanizması kullanmanız ve güncelleştirme yürütme gerekirdi [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı.</span><span class="sxs-lookup"><span data-stu-id="546f1-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="546f1-199">Biz bu durum sonraki gösterir.</span><span class="sxs-lookup"><span data-stu-id="546f1-199">We’ll demonstrate this situation next.</span></span>  
  
 <span data-ttu-id="546f1-200">Bu örnek için tam kaynak kodunu için bkz: [Single-Threaded uygulama uzun süre çalışan hesaplama örnek ile](http://go.microsoft.com/fwlink/?LinkID=160038)</span><span class="sxs-lookup"><span data-stu-id="546f1-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038)</span></span>  
  
<a name="weather_sim"></a>   
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="546f1-201">Bir engelleme işlemi arka plan iş parçacığı ile işleme</span><span class="sxs-lookup"><span data-stu-id="546f1-201">Handling a Blocking Operation with a Background Thread</span></span>  
 <span data-ttu-id="546f1-202">Grafik uygulamalarında engelleyen işlemlerin işlenmesi zor olabilir.</span><span class="sxs-lookup"><span data-stu-id="546f1-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="546f1-203">Uygulama Dondur görüneceğinden olay işleyicilerini engelleme yöntemlerini çağıran istemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="546f1-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="546f1-204">Biz bu işlemleri işlemek için ayrı bir iş parçacığı kullanabilirsiniz, ancak biz bittiğinde, ile eşitlemek sahibiz [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] biz doğrudan değiştirilemiyor çünkü iş parçacığı [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] bizim çalışan iş parçacığı gelen.</span><span class="sxs-lookup"><span data-stu-id="546f1-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] from our worker thread.</span></span> <span data-ttu-id="546f1-205">Biz kullanabilirsiniz <xref:System.Windows.Threading.Dispatcher.Invoke%2A> veya <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> temsilciler içine eklemek için <xref:System.Windows.Threading.Dispatcher> , [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı.</span><span class="sxs-lookup"><span data-stu-id="546f1-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="546f1-206">Sonuç olarak, bu temsilciler değiştirme izni ile yürütülür [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] öğeleri.</span><span class="sxs-lookup"><span data-stu-id="546f1-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>  
  
 <span data-ttu-id="546f1-207">Bu örnekte, hava durumu tahmini alan uzaktan yordam çağrısı taklit.</span><span class="sxs-lookup"><span data-stu-id="546f1-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="546f1-208">Bu çağrıyı yürütmek için ayrı çalışan iş parçacığı kullanırız ve biz bir güncelleştirme yöntemi zamanlama <xref:System.Windows.Threading.Dispatcher> , [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] tamamlandığında iş parçacığı.</span><span class="sxs-lookup"><span data-stu-id="546f1-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>  
  
 <span data-ttu-id="546f1-209">![Kullanıcı Arabirimi ekran görüntüsü hava durumu](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG "ThreadingWeatherUIScreenShot")</span><span class="sxs-lookup"><span data-stu-id="546f1-209">![Weather UI screen shot](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG "ThreadingWeatherUIScreenShot")</span></span>  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]  
  
 <span data-ttu-id="546f1-210">Bazı kaydedilmelidir Ayrıntılar verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="546f1-210">The following are some of the details to be noted.</span></span>  
  
-   <span data-ttu-id="546f1-211">Düğme işleyicisi oluşturma</span><span class="sxs-lookup"><span data-stu-id="546f1-211">Creating the Button Handler</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]  
  
 <span data-ttu-id="546f1-212">Düğmesine tıklandığında, biz saat çizimi görüntülenir ve animasyon başlar.</span><span class="sxs-lookup"><span data-stu-id="546f1-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="546f1-213">Düğme devre dışı bırakın.</span><span class="sxs-lookup"><span data-stu-id="546f1-213">We disable the button.</span></span> <span data-ttu-id="546f1-214">Biz çağırma `FetchWeatherFromServer` yeni bir iş parçacığı ve ardından yönteminde dönüş, izin verme <xref:System.Windows.Threading.Dispatcher> hava tahmini toplamak için beklerken olayları işlemek için.</span><span class="sxs-lookup"><span data-stu-id="546f1-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>  
  
-   <span data-ttu-id="546f1-215">Hava getirme</span><span class="sxs-lookup"><span data-stu-id="546f1-215">Fetching the Weather</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]  
  
 <span data-ttu-id="546f1-216">Örneği basit tutmak için biz gerçekte Ağ bir kodu bu örnekte yok.</span><span class="sxs-lookup"><span data-stu-id="546f1-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="546f1-217">Bunun yerine, şu dört saniye için uyku moduna yeni iş parçacığını koyarak ağ erişim gecikmesi benzetimi.</span><span class="sxs-lookup"><span data-stu-id="546f1-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="546f1-218">Bu süre, orijinal olarak [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı hala çalıştıran ve olaylara yanıt verme.</span><span class="sxs-lookup"><span data-stu-id="546f1-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="546f1-219">Bu, size bir animasyonu çalışır ve simge durumuna küçült sol göstermek ve en üst düzeye çıkarmak için düğmeler de çalışmaya devam eder.</span><span class="sxs-lookup"><span data-stu-id="546f1-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>  
  
 <span data-ttu-id="546f1-220">Gecikme tamamlandı ve biz rastgele bizim hava tahmini seçtiyseniz, yeniden rapor zamanı geldi [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı.</span><span class="sxs-lookup"><span data-stu-id="546f1-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="546f1-221">Çağrı zamanlayarak bunu `UpdateUserInterface` içinde [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] parçacığının kullanarak iş parçacığı <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="546f1-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="546f1-222">Biz bu zamanlanmış yöntem çağrısının hava tanımlayan bir dize geçirin.</span><span class="sxs-lookup"><span data-stu-id="546f1-222">We pass a string describing the weather to this scheduled method call.</span></span>  
  
-   <span data-ttu-id="546f1-223">Güncelleştirme[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="546f1-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]  
  
 <span data-ttu-id="546f1-224">Zaman <xref:System.Windows.Threading.Dispatcher> içinde [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığına sahip zaman, zamanlanmış çağrısı yürütür `UpdateUserInterface`.</span><span class="sxs-lookup"><span data-stu-id="546f1-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="546f1-225">Bu yöntem, saat animasyonu durdurur ve hava durumu tanımlamak için görüntüyü seçer.</span><span class="sxs-lookup"><span data-stu-id="546f1-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="546f1-226">Bu görüntü görüntüler ve "fetch tahmin" düğmesine geri yükler.</span><span class="sxs-lookup"><span data-stu-id="546f1-226">It displays this image and restores the "fetch forecast" button.</span></span>  
  
<a name="multi_browser"></a>   
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="546f1-227">Birden çok Windows, çoklu iş parçacıkları</span><span class="sxs-lookup"><span data-stu-id="546f1-227">Multiple Windows, Multiple Threads</span></span>  
 <span data-ttu-id="546f1-228">Bazı [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uygulamaları birden çok üst düzey windows gerektirir.</span><span class="sxs-lookup"><span data-stu-id="546f1-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="546f1-229">Tek bir iş parçacığı edilebilir /<xref:System.Windows.Threading.Dispatcher> birleşimi birden çok windows ancak bazen birkaç iş parçacığı yönetmek için daha iyi iş yapın.</span><span class="sxs-lookup"><span data-stu-id="546f1-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="546f1-230">Bu özellikle ihtimali varsa, Windows'un bir iş parçacığı kullanmasını geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="546f1-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>  
  
 [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="546f1-231">Explorer bu şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="546f1-231"> Explorer works in this fashion.</span></span> <span data-ttu-id="546f1-232">Her yeni Explorer penceresi özgün işleme ait olduğu, ancak bağımsız bir iş parçacığı denetimi altında oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="546f1-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>  
  
 <span data-ttu-id="546f1-233">Kullanarak bir [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Controls.Frame> denetim, biz Web sayfalarını görüntüleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="546f1-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="546f1-234">Basit bir kolayca oluşturabilir [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] değiştirin.</span><span class="sxs-lookup"><span data-stu-id="546f1-234">We can easily create a simple [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] substitute.</span></span> <span data-ttu-id="546f1-235">Biz önemli özellik ile Başlat: özelliği yeni bir explorer penceresi açın.</span><span class="sxs-lookup"><span data-stu-id="546f1-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="546f1-236">Kullanıcı, "Yeni Pencere" tıkladığında düğmesi, size bir kopyasını ayrı bir iş parçacığı bizim penceresi başlatın.</span><span class="sxs-lookup"><span data-stu-id="546f1-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="546f1-237">Bu şekilde, diğer tüm windows uzun süre çalışan veya engelleyici işlemlerinde windows birini kilit olmaz.</span><span class="sxs-lookup"><span data-stu-id="546f1-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>  
  
 <span data-ttu-id="546f1-238">Gerçekte, Web tarayıcısı modeli kendi karmaşık iş parçacığı modeli vardır.</span><span class="sxs-lookup"><span data-stu-id="546f1-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="546f1-239">Çoğu okuyucuları bilgi sahibi olmanız gerekir çünkü bunu seçtik.</span><span class="sxs-lookup"><span data-stu-id="546f1-239">We’ve chosen it because it should be familiar to most readers.</span></span>  
  
 <span data-ttu-id="546f1-240">Aşağıdaki örnek kod gösterir.</span><span class="sxs-lookup"><span data-stu-id="546f1-240">The following example shows the code.</span></span>  
  
 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]  
  
 <span data-ttu-id="546f1-241">Bu kod aşağıdaki iş parçacığı kesimleri en ilginç bize bu bağlamda şunlardır:</span><span class="sxs-lookup"><span data-stu-id="546f1-241">The following threading segments of this code are the most interesting to us in this context:</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]  
  
 <span data-ttu-id="546f1-242">Bu yöntem aldığında çağrılan "Yeni Pencere" düğmesine tıklandığında.</span><span class="sxs-lookup"><span data-stu-id="546f1-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="546f1-243">Yeni bir iş parçacığı oluşturur ve zaman uyumsuz olarak başlatır.</span><span class="sxs-lookup"><span data-stu-id="546f1-243">It creates a new thread and starts it asynchronously.</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]  
  
 <span data-ttu-id="546f1-244">Bu yöntem, yeni bir iş parçacığı için başlangıç noktasıdır.</span><span class="sxs-lookup"><span data-stu-id="546f1-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="546f1-245">Bu iş parçacığı denetimi altında yeni bir pencere oluşturuyoruz.</span><span class="sxs-lookup"><span data-stu-id="546f1-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="546f1-246">otomatik olarak yeni bir oluşturur <xref:System.Windows.Threading.Dispatcher> yeni bir iş parçacığı yönetmek için.</span><span class="sxs-lookup"><span data-stu-id="546f1-246"> automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="546f1-247">Pencerenin işlevsel sağlamak için yapmanız sahip olduğumuz tümüdür başlatmak için <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="546f1-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>  
  
<a name="stumbling_points"></a>   
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="546f1-248">Teknik Ayrıntılar ve bazı noktalar</span><span class="sxs-lookup"><span data-stu-id="546f1-248">Technical Details and Stumbling Points</span></span>  
  
### <a name="writing-components-using-threading"></a><span data-ttu-id="546f1-249">İş parçacığı kullanarak bileşen yazma</span><span class="sxs-lookup"><span data-stu-id="546f1-249">Writing Components Using Threading</span></span>  
 <span data-ttu-id="546f1-250">[!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] Geliştirici Kılavuzu bir bileşen istemcilerine zaman uyumsuz davranışı nasıl getirebilir için bir desen açıklar (bkz [olay tabanlı zaman uyumsuz desene genel bakış](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="546f1-250">The [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="546f1-251">Örneğin, biz istediğinizi paketlemek varsayın `FetchWeatherFromServer` yeniden kullanılabilir bir bileşenin yönteme.</span><span class="sxs-lookup"><span data-stu-id="546f1-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="546f1-252">Standart aşağıdaki [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] düzeni, bu aşağıdakine benzer görünecektir.</span><span class="sxs-lookup"><span data-stu-id="546f1-252">Following the standard [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] pattern, this would look something like the following.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]  
  
 <span data-ttu-id="546f1-253">`GetWeatherAsync`bir arka plan iş parçacığı oluşturma gibi daha önce açıklanan teknikleri birini işi zaman uyumsuz olarak yapmak için çağıran iş parçacığı engellemediğini kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="546f1-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>  
  
 <span data-ttu-id="546f1-254">Bu desenin en önemli parçalarından çağırma *MethodName* `Completed` yöntemini çağıran iş parçacığında *MethodName* `Async` yöntemi ile başlar.</span><span class="sxs-lookup"><span data-stu-id="546f1-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="546f1-255">Kullanarak bunu yapabilirsiniz [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] depolayarak oldukça kolaylıkla <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>— ancak ardından grafik olmayan bileşeni yalnızca kullanılabilen [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uygulamaları değil, [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] veya [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programlar.</span><span class="sxs-lookup"><span data-stu-id="546f1-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programs.</span></span>  
  
 <span data-ttu-id="546f1-256"><xref:System.Windows.Threading.DispatcherSynchronizationContext> Sınıfı bu adresleri — basitleştirilmiş bir sürümünü olarak düşünün <xref:System.Windows.Threading.Dispatcher> diğer çalışan [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] de çerçeveleri.</span><span class="sxs-lookup"><span data-stu-id="546f1-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]  
  
### <a name="nested-pumping"></a><span data-ttu-id="546f1-257">Pompalama iç içe geçmiş</span><span class="sxs-lookup"><span data-stu-id="546f1-257">Nested Pumping</span></span>  
 <span data-ttu-id="546f1-258">Bazen tamamen kilitlemek için uygun olmadığı [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı.</span><span class="sxs-lookup"><span data-stu-id="546f1-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="546f1-259">Şimdi göz önünde bulundurun <xref:System.Windows.MessageBox.Show%2A> yöntemi <xref:System.Windows.MessageBox> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="546f1-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="546f1-260"><xref:System.Windows.MessageBox.Show%2A>Kullanıcı Tamam düğmesine tıklar kadar döndürmez.</span><span class="sxs-lookup"><span data-stu-id="546f1-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="546f1-261">Ancak, bir ileti döngüsü etkileşimli için sahip bir pencere oluşturmaz.</span><span class="sxs-lookup"><span data-stu-id="546f1-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="546f1-262">Biz kullanıcının Tamam'ı beklerken, özgün uygulama penceresi kullanıcı girişine yanıt vermez.</span><span class="sxs-lookup"><span data-stu-id="546f1-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="546f1-263">Boyama iletileri işlemek üzere ancak devam eder.</span><span class="sxs-lookup"><span data-stu-id="546f1-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="546f1-264">Özgün pencere kendisini kapsamdaki ve ortaya yeniden çizer.</span><span class="sxs-lookup"><span data-stu-id="546f1-264">The original window redraws itself when covered and revealed.</span></span>  
  
 <span data-ttu-id="546f1-265">!["Tamam" düğmesini kullanarak MessageBox](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png "ThreadingNestedPumping")</span><span class="sxs-lookup"><span data-stu-id="546f1-265">![MessageBox with an "OK" button](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png "ThreadingNestedPumping")</span></span>  
  
 <span data-ttu-id="546f1-266">Bazı iş parçacığı sorumlu ileti kutusu penceresi olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="546f1-266">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="546f1-267">ileti kutusu penceresi yalnızca için yeni bir iş parçacığı oluşturabilir, ancak bu iş parçacığı devre dışı bırakılan öğeleri özgün penceresinde boyamak alamadı (karşılıklı dışlama önceki tartışmayı unutmayın).</span><span class="sxs-lookup"><span data-stu-id="546f1-267"> could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="546f1-268">Bunun yerine, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] iç içe geçmiş bir ileti sistemi işleme kullanır.</span><span class="sxs-lookup"><span data-stu-id="546f1-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="546f1-269"><xref:System.Windows.Threading.Dispatcher> Sınıfı içerir adlı özel bir yöntem <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, yeni bir ileti döngüsü başlar, ardından uygulamanın geçerli yürütme noktası depolar.</span><span class="sxs-lookup"><span data-stu-id="546f1-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="546f1-270">İç içe ileti döngüsü sona erdiğinde, yürütme sonra özgün sürdürür <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> çağırın.</span><span class="sxs-lookup"><span data-stu-id="546f1-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>  
  
 <span data-ttu-id="546f1-271">Bu durumda, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> çağrısı konumundaki program bağlamda tutar <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, ve arka plan penceresi yeniden çizilmez ve ileti kutusu penceresine girişini işlemek için yeni bir ileti döngüsü başlatır.</span><span class="sxs-lookup"><span data-stu-id="546f1-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="546f1-272">Kullanıcı Tamam tıklar ve açılır pencereyi temizlediğinde, iç içe döngü çıkar ve denetim sürdürür çağrısından sonra <xref:System.Windows.MessageBox.Show%2A>.</span><span class="sxs-lookup"><span data-stu-id="546f1-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>  
  
### <a name="stale-routed-events"></a><span data-ttu-id="546f1-273">Eski yönlendirilmiş olaylar</span><span class="sxs-lookup"><span data-stu-id="546f1-273">Stale Routed Events</span></span>  
 <span data-ttu-id="546f1-274">Yönlendirilmiş olay sistemde [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] olayları ortaya çıktığında tüm ağaçları bildirir.</span><span class="sxs-lookup"><span data-stu-id="546f1-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>  
  
 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]  
  
 <span data-ttu-id="546f1-275">Sol fare düğmesini elips basıldığında `handler2` yürütülür.</span><span class="sxs-lookup"><span data-stu-id="546f1-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="546f1-276">Sonra `handler2` sonlandığında olay iletilir boyunca <xref:System.Windows.Controls.Canvas> kullanan nesne `handler1` işlemesi için.</span><span class="sxs-lookup"><span data-stu-id="546f1-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="546f1-277">Bu yalnızca olur `handler2` mu açıkça işareti olay nesnesini işlenmiş olarak.</span><span class="sxs-lookup"><span data-stu-id="546f1-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>  
  
 <span data-ttu-id="546f1-278">Mümkünse, `handler2` bu olay işleme süresinin büyük bir bölümünü sürer.</span><span class="sxs-lookup"><span data-stu-id="546f1-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="546f1-279">`handler2`kullanabilir <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> saat döndürmez bir iç içe ileti döngüsü başlatmak için.</span><span class="sxs-lookup"><span data-stu-id="546f1-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="546f1-280">Varsa `handler2` bu ileti döngüsü olduğunda işlenmiş olarak olay tamamlamak işareti yok, çok eski olsa da olay ağaca geçirilir.</span><span class="sxs-lookup"><span data-stu-id="546f1-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>  
  
### <a name="reentrancy-and-locking"></a><span data-ttu-id="546f1-281">Yeniden giriş ve kilitleme</span><span class="sxs-lookup"><span data-stu-id="546f1-281">Reentrancy and Locking</span></span>  
 <span data-ttu-id="546f1-282">Kilitleme mekanizması [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] tam olarak davranır olmayan bir düşünün; bir işlemi tamamen kilit isterken sona için bir iş parçacığı beklediğiniz.</span><span class="sxs-lookup"><span data-stu-id="546f1-282">The locking mechanism of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="546f1-283">Çünkü, yüksek öncelikli iletileri almak ve işlemek iş parçacığı devam eder.</span><span class="sxs-lookup"><span data-stu-id="546f1-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="546f1-284">Bu kilitlenmeler önlemek ve arabirimleri en düşük düzeyde iyi yanıt vermesi yardımcı olur, ancak Zarif hataları olasılığını tanıtır.</span><span class="sxs-lookup"><span data-stu-id="546f1-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="546f1-285">Olmayan herhangi bir şey bu konuda, ancak nadir durumlarda bilmeniz gereken süre büyük çoğunluğu (genellikle içeren [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] pencere iletileri veya COM STA bileşenleri) bu bilerek değer olabilir.</span><span class="sxs-lookup"><span data-stu-id="546f1-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window messages or COM STA components) this can be worth knowing.</span></span>  
  
 <span data-ttu-id="546f1-286">Geliştiriciler varsayımına altında çalışması nedeniyle, çoğu arabirimleri aklınızda iş parçacığı güvenliği ile oluşturulan değil, bir [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] hiçbir zaman birden çok iş parçacığı tarafından erişilir.</span><span class="sxs-lookup"><span data-stu-id="546f1-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="546f1-287">Bu durumda, tek iş parçacığı beklenmeyen zamanlarda ortam değişiklikleri yapabilir, bu hatalı neden, efektler <xref:System.Windows.Threading.DispatcherObject> karşılıklı dışlama mekanizması çözmek bekleniyor.</span><span class="sxs-lookup"><span data-stu-id="546f1-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="546f1-288">Aşağıdaki yarı kodu göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="546f1-288">Consider the following pseudocode:</span></span>  
  
 <span data-ttu-id="546f1-289">![Yeniden giriş diyagramı iş parçacığı oluşturma](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="546f1-289">![Threading reentrancy diagram](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png "ThreadingReentrancy")</span></span>  
  
 <span data-ttu-id="546f1-290">Çoğu zaman, en doğru şey, ancak mevcuttur kez [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] olduğu gibi beklenmeyen yeniden giriş gerçekten sorunlara neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="546f1-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="546f1-291">Bu nedenle, belirli bir anahtar zaman [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] çağrıları <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, hangi değişiklikleri kullanmak bu iş parçacığı için kilit yönerge [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] normal yerine yeniden giriş serbest kilit [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] kilit.</span><span class="sxs-lookup"><span data-stu-id="546f1-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] lock.</span></span>  
  
 <span data-ttu-id="546f1-292">Bunu neden oldu [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] takım seçin Bu davranış?</span><span class="sxs-lookup"><span data-stu-id="546f1-292">So why did the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team choose this behavior?</span></span> <span data-ttu-id="546f1-293">COM STA nesneler ve sonlandırma iş parçacığı ile yapmak vardı.</span><span class="sxs-lookup"><span data-stu-id="546f1-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="546f1-294">Bir nesne, çöp toplama olduğunda kendi `Finalize` yöntemi çalıştırılır ayrılmış sonlandırıcıyı iş parçacığı üzerinde değil [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı.</span><span class="sxs-lookup"><span data-stu-id="546f1-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="546f1-295">Okuduğunuzu, sorun, COM STA nesne çünkü oluşturulduğu [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı yalnızca atıldı üzerinde [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı.</span><span class="sxs-lookup"><span data-stu-id="546f1-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="546f1-296">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] Denk mu bir <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (Bu durumda Win32'in kullanarak `SendMessage`).</span><span class="sxs-lookup"><span data-stu-id="546f1-296">The [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="546f1-297">Ancak [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı meşgul, sonlandırıcıyı iş parçacığı durduruldu ve ciddi bellek sızıntısı oluşturan COM STA nesne atılamaz.</span><span class="sxs-lookup"><span data-stu-id="546f1-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="546f1-298">Bu nedenle [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] takım yapılan yaptıkları gibi çalışmasına kilitleri yapmak için sağlam çağrısı.</span><span class="sxs-lookup"><span data-stu-id="546f1-298">So the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team made the tough call to make locks work the way they do.</span></span>  
  
 <span data-ttu-id="546f1-299">Görev için [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] biz her yerde yeniden giriş engelleme neden olan bellek sızıntısı yeniden eklenmesiyle olmadan beklenmeyen yeniden giriş önlemek için gerekir.</span><span class="sxs-lookup"><span data-stu-id="546f1-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="546f1-300">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="546f1-300">See Also</span></span>  
 [<span data-ttu-id="546f1-301">Uzun süre çalışan hesaplama örnek tek iş parçacıklı uygulamayla</span><span class="sxs-lookup"><span data-stu-id="546f1-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](http://go.microsoft.com/fwlink/?LinkID=160038)

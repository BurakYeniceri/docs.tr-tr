---
title: Ortak web uygulama mimariler
description: "ASP.NET Core ve Microsoft Azure ile modern web uygulamaları mimari | Ortak web uygulama mimariler"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: b6236cfab290211f930d6a1987075abeade4fd6d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/21/2017
---
#<a name="common-web-application-architectures"></a><span data-ttu-id="7c7e1-103">Ortak Web uygulama mimariler</span><span class="sxs-lookup"><span data-stu-id="7c7e1-103">Common Web Application Architectures</span></span>

> <span data-ttu-id="7c7e1-104">"İyi mimarisi pahalı olduğunu düşünüyorsanız, hatalı mimarisi deneyin."</span><span class="sxs-lookup"><span data-stu-id="7c7e1-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="7c7e1-105">_-Brian altbilgi ve Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="7c7e1-105">_- Brian Foote and Joseph Yoder_</span></span>

## <a name="summary"></a><span data-ttu-id="7c7e1-106">Özet</span><span class="sxs-lookup"><span data-stu-id="7c7e1-106">Summary</span></span>

<span data-ttu-id="7c7e1-107">Çoğu geleneksel .NET uygulamaları, yürütülebilir bir dosya ya da tek bir IIS appdomain içinde çalışan bir tek bir web uygulaması için karşılık gelen tek birim olarak dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-107">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="7c7e1-108">Bu basit dağıtım modeli ve birçok dahili ve daha küçük ortak uygulama çok iyi işlevi görür.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-108">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="7c7e1-109">Ancak, bile bu tek birim dağıtımının verildiğinde, en Önemsiz olmayan iş uygulamaları birkaç katmanlara mantıksal bazı ayrılması yararlanır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-109">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="7c7e1-110">Tek yapılı bir uygulaması nedir?</span><span class="sxs-lookup"><span data-stu-id="7c7e1-110">What is a monolithic application?</span></span>

<span data-ttu-id="7c7e1-111">Tek yapılı bir uygulama açısından davranışını tamamen kendi içinde yer alan, biridir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-111">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="7c7e1-112">Kendi işlemleri sırasında diğer hizmetleri ya da veri depoları ile etkileşimde bulunabilir, ancak davranışını çekirdek kendi işlemi içinde çalıştırılan ve tüm uygulama genellikle tek bir birim olarak dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-112">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="7c7e1-113">Genellikle bu tür bir uygulama yatay ölçek gerekirse, tüm uygulama birden fazla sunucu veya sanal makineler arasında çoğaltılır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-113">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="7c7e1-114">Hepsi bir arada uygulamaları</span><span class="sxs-lookup"><span data-stu-id="7c7e1-114">All-in-One applications</span></span>

<span data-ttu-id="7c7e1-115">Bir uygulama mimarisi projelerde olabildiğince az sayıda biridir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-115">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="7c7e1-116">Bu mimaride, uygulamanın tüm mantığı tek bir projede yer, tek bir derleme derlenmiş ve tek bir birim olarak dağıtılabilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-116">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="7c7e1-117">Yeni bir ASP.NET Core projesi Visual Studio'da veya komut satırından oluşturulan olup olmadığını basit bir "hepsi bir arada" monolith başlar.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-117">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="7c7e1-118">Sunu, iş ve veri erişim mantığı dahil uygulamanın davranışını hepsini içerir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-118">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="7c7e1-119">Şekil 5-1 tek proje uygulama dosya yapısını gösterir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-119">Figure 5-1 shows the file structure of a single-project app.</span></span>

<span data-ttu-id="7c7e1-120">**Şekil 5-1.**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-120">**Figure 5-1.**</span></span> <span data-ttu-id="7c7e1-121">Tek bir proje ASP.NET Core uygulama</span><span class="sxs-lookup"><span data-stu-id="7c7e1-121">A single project ASP.NET Core app</span></span>

![](./media/image5-1.png)

<span data-ttu-id="7c7e1-122">Bir tek proje senaryosunda, sorunları ayrılması klasörleri kullanımı ile elde edilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="7c7e1-123">Veri ve hizmetler için MVC düzeni sorumluluklarını modeller, görünümler ve denetleyiciler ayrı klasörlerini yanı sıra, ek klasörler varsayılan şablonu içerir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="7c7e1-124">Bu düzenlemenin sunu ayrıntıları görünümleri klasörüne mümkün olduğunca çok sınırlı ve veri erişim uygulama ayrıntılarını sınıfları veri klasöründe tutulan sınırlı olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="7c7e1-125">İş mantığı, hizmetleri ve sınıfları modeller klasörü içinde bulunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="7c7e1-126">Basit rağmen proje tek tek yapılı çözüm bazı dezavantajları vardır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="7c7e1-127">Proje boyutu ve karmaşıklığı büyüdükçe, dosya ve klasörleri sayısı da büyümeye devam edecek.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="7c7e1-128">Kullanıcı Arabirimi sorunları (modeller, görünümler, denetleyicileri) birlikte alfabetik olarak gruplandırılmaz, birden çok klasörlerde bulunur.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-128">UI concerns (models, views, controllers) reside in multiple folders, which are not grouped together alphabetically.</span></span> <span data-ttu-id="7c7e1-129">Bu sorunu daha zayıf için filtreleri veya ModelBinders, gibi ek kullanıcı Arabirimi düzeyi yapıları kendi klasörlerinde eklenen alır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="7c7e1-130">İş mantığı arasında modelleri ve Hizmetleri klasörleri dağılmış ve hangisinin hangi klasörlerin sınıflarda hangi diğerlerine bağlı NET bir belirti yok.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-130">Business logic is scattered between the Models and Services folders, and there is no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="7c7e1-131">İçin proje düzeyinde kuruluş bu eksiklik sık müşteri adayları [spaghetti kod](http://deviq.com/spaghetti-code/).</span><span class="sxs-lookup"><span data-stu-id="7c7e1-131">This lack of organization at the project level frequently leads to [spaghetti code](http://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="7c7e1-132">Bu sorunları gidermek için uygulamalar genellikle birden çok proje çözümü, burada her proje olarak kabul belirli bir bulunması halinde gelişmesi *katman* uygulamanın.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-132">In order to address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular *layer* of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="7c7e1-133">Katmanları nelerdir?</span><span class="sxs-lookup"><span data-stu-id="7c7e1-133">What are layers?</span></span>

<span data-ttu-id="7c7e1-134">Uygulamaları karmaşıklığı arttıkça, bu karmaşıklık yönetmek için bir uygulamanın kendi sorumluluklarını veya kaygılarınız göre ayırmak için yoludur.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-134">As applications grow in complexity, one way to manage that complexity is to break the application up according to its responsibilities or concerns.</span></span> <span data-ttu-id="7c7e1-135">Bu sorunları ilkesine ayrılması izler ve geliştiricilerin kolayca bazı işlevleri burada uygulanan bulabilmesi için düzenlenmiş büyüyen bir codebase korunmasına yardımcı olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-135">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="7c7e1-136">Katmanlı mimarisi, çok sayıda avantaj yalnızca kodu kuruluş dışına yine de sunar.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="7c7e1-137">Kod katmanlara düzenleyerek, ortak bir alt düzey işlevselliği uygulama genelinde yeniden kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="7c7e1-138">Bu yeniden daha az kod yazılması gereken gösterdiğinden ve KURU ilkesini izleyen tek bir uygulama üzerinde standart hale getirmek uygulama izin vermek için faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the DRY principle.</span></span>

<span data-ttu-id="7c7e1-139">Bir katmanlı mimarisiyle uygulamaları Katmanlar diğer katmanları ile iletişim kurabilen kısıtlamaları zorunlu kılabilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="7c7e1-140">Bu kapsülleme elde etmek için yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="7c7e1-141">Bir katman değiştirilmiş ya da değiştirilen ile çalışan katmanları etkilenmiş.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="7c7e1-142">Hangi sınırlayarak, böylece tek bir değişiklik tüm uygulama etkilemez diğer katmanları değişikliklerin etkisini azaltılabilir Katmanlar bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="7c7e1-143">Katmanlar (ve saklama) çok uygulamadaki işlevin yerini kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="7c7e1-144">Örneğin, uygulamanın kendi SQL Server veritabanı kalıcılığını başlangıçta kullanabilir, ancak daha sonra bir bulut tabanlı Kalıcılık stratejisi veya web API'si arkasında kullanmayı tercih edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="7c7e1-145">Uygulamanın düzgün mantıksal katman içinde Kalıcılık uygulaması kapsüllenmiş, bu SQL Server belirli katmanı aynı Ortak arabirimi uygulama yeni bir tane tarafından değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="7c7e1-146">Gereksinimleri gelecekteki değişikliklere yanıt uygulamalarında çıkışı takas olası ek olarak, uygulama katmanları Ayrıca, test amacıyla uygulamaları takas etmek kolaylaştırabilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="7c7e1-147">Gerçek veri katmanı veya uygulamanın UI katmanı karşı çalışan testleri yazmak yerine, bu Katmanlar test zaman isteklerine bilinen yanıtlar sağlayan sahte uygulamalarıyla birlikte değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="7c7e1-148">Bu genellikle testleri yazmak çok daha kolay ve çok daha hızlı hale getirir çalışması için karşılaştırıldığında testlerinin yeniden uygulamanın gerçek altyapı.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-148">This typically makes tests much easier to write and much faster to run when compared to running tests again the application's real infrastructure.</span></span>

<span data-ttu-id="7c7e1-149">Mantıksal katmanlama Kurumsal yazılım uygulamaları kodda organizasyonu geliştirmek için ortak bir tekniktir ve kod katmanlara düzenlenebilir birkaç yolu vardır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
> <span data-ttu-id="7c7e1-150">*Katmanlar* mantıksal ayırma uygulama içinde temsil eder.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-150">*Layers* represent logical separation within the application.</span></span> <span data-ttu-id="7c7e1-151">Uygulama mantığını fiziksel sunucuları veya işlemler ayırmak için Dağıtılmış gelmesi durumunda, bu ayrı fiziksel dağıtım hedefleri olarak adlandırılır *katmanları*.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as *tiers*.</span></span> <span data-ttu-id="7c7e1-152">Bu olası ve oldukça yaygın, tek bir katman için Dağıtılmış bir N katmanlı uygulamalara sahip olur.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="7c7e1-153">Geleneksel "N katmanlı" mimarisi uygulamaları</span><span class="sxs-lookup"><span data-stu-id="7c7e1-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="7c7e1-154">Uygulama mantığını en yaygın organizasyonu, Şekil 5-2'de gösterilen Katmanlar.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-154">The most common organization of application logic into layers it shown in Figure 5-2.</span></span>

<span data-ttu-id="7c7e1-155">**Şekil 5-2.**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-155">**Figure 5-2.**</span></span> <span data-ttu-id="7c7e1-156">Genel uygulama katmanları.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-156">Typical application layers.</span></span>

![](./media/image5-2.png)

<span data-ttu-id="7c7e1-157">Bu katmanlar sık UI kısaltılır BLL (iş mantığı katmanı) ve DAL (veri erişim katmanı).</span><span class="sxs-lookup"><span data-stu-id="7c7e1-157">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="7c7e1-158">Bu mimarisi kullanarak, kullanıcılar yalnızca BLL ile etkileşime giren UI katmanında isteklerini olun.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-158">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="7c7e1-159">BLL, buna karşılık, veri erişim istekleri için DAL çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-159">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="7c7e1-160">UI katmanında tüm istekler DAL ile doğrudan yapmamanız gerekir ya da kalıcılığı doğrudan arasında başka yollarla ile etkileşim.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-160">The UI layer should not make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="7c7e1-161">Benzer şekilde, BLL yalnızca ile kalıcılığı DAL giderek etkileşim.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-161">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="7c7e1-162">Bu şekilde, iyi bilinen sorumluluğunu her katman vardır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-162">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="7c7e1-163">Bu geleneksel katmanlama yaklaşımın bir dezavantajı, derleme zamanı bağımlılıkları üstten alta çalıştırın olabilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-163">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="7c7e1-164">Diğer bir deyişle, kullanıcı Arabirimi katman üzerinde DAL bağlıdır BLL bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-164">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="7c7e1-165">Bu, genellikle en önemli mantığı uygulamada tutan BLL veri erişim uygulama ayrıntıları (ve genellikle bir veritabanı varlığını) bağımlı olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-165">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="7c7e1-166">İş mantığı bu tür bir mimaride sınama genellikle bir test veritabanı gerektiren zor olabilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-166">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="7c7e1-167">Sonraki bölümde göreceğiniz gibi bağımlılık ters çevirmeyi ilkesini bu sorunu gidermek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-167">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="7c7e1-168">Şekil 5-3 uygulama üç projelere sorumluluk (veya katman) yeni bir örnek çözümü gösterir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-168">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

<span data-ttu-id="7c7e1-169">**Şekil 5-3.**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-169">**Figure 5-3.**</span></span> <span data-ttu-id="7c7e1-170">Üç projeleri ile basit bir tek yapılı uygulamasının.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-170">A simple monolithic application with three projects.</span></span>

![](./media/image5-3.png)

<span data-ttu-id="7c7e1-171">Bu uygulamayı Kurumsal amaçlara yönelik birkaç proje kullansa da, tek bir birim olarak hala dağıtılır ve istemcileri ile bir tek bir web uygulaması gibi etkileşim.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-171">Although this application uses several projects for organizational purposes, it is still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="7c7e1-172">Bu, çok basit dağıtım işlemine izin verir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-172">This allows for very simple deployment process.</span></span> <span data-ttu-id="7c7e1-173">Şekil 5-4 gösterir bu tür bir uygulama nasıl olabileceği Windows azure'da barındırılan.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-173">Figure 5-4 shows how such an app might be hosted using Windows Azure.</span></span>

![](./media/image5-4.png)

<span data-ttu-id="7c7e1-174">**Şekil 5-4.**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-174">**Figure 5-4.**</span></span> <span data-ttu-id="7c7e1-175">Azure Web uygulaması, basit dağıtım</span><span class="sxs-lookup"><span data-stu-id="7c7e1-175">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="7c7e1-176">Uygulama büyüme gereksinimlerine göre daha karmaşık ve güçlü dağıtım çözümleri gerekli olabilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-176">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="7c7e1-177">Şekil 5-5 ek özellikleri desteklemektedir daha karmaşık bir dağıtım planı örneği gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-177">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

<span data-ttu-id="7c7e1-178">**Şekil 5-5.**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-178">**Figure 5-5.**</span></span> <span data-ttu-id="7c7e1-179">Bir Azure App Service'e bir web uygulaması dağıtma</span><span class="sxs-lookup"><span data-stu-id="7c7e1-179">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="7c7e1-180">Dahili olarak, birden çok proje üzerinde sorumluluk göre bu projenin kuruluşunuzun Uygulama Bakımı artırır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-180">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="7c7e1-181">Bu birim veya bulut tabanlı isteğe bağlı ölçeklenebilirlik yararlanmak için genişletilebilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-181">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="7c7e1-182">Ölçeklendirmeyi ek CPU, bellek, disk alanı veya diğer kaynakları uygulamanızı barındırma sunucuları ekleme anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-182">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="7c7e1-183">Bu fiziksel sunucularda veya sanal makinelerde olup ölçeğini ek örneklerini bu sunucular ekleme anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-183">Scaling out means adding additional instances of such servers, whether these are physical servers or virtual machines.</span></span> <span data-ttu-id="7c7e1-184">Uygulamanız birden çok örneklerinde barındırıldığında, bir yük dengeleyici isteklerinin tek tek uygulama örneklerine atamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-184">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="7c7e1-185">Azure üzerinde bir web uygulaması Ölçeklendirmesi en kolay yaklaşım, uygulamanın uygulama hizmeti planı'nda el ile ölçeklendirme yapılandırmaktır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-185">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="7c7e1-186">Şekil 5-6 kaç tane örnek bir uygulama hizmet yapılandırmak için uygun Azure Pano ekranı gösterir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-186">Figure 5-6 show the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

<span data-ttu-id="7c7e1-187">**Şekil 5-6.**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-187">**Figure 5-6.**</span></span> <span data-ttu-id="7c7e1-188">App Service, Azure içinde ölçeklendirme planı.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-188">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="7c7e1-189">Temiz mimarisi</span><span class="sxs-lookup"><span data-stu-id="7c7e1-189">Clean architecture</span></span>

<span data-ttu-id="7c7e1-190">Bağımlılık ters çevirmeyi ilkesine yanı sıra Domain-Driven tasarım (DDD) İlkeleri izleyin uygulamalar benzer bir mimariye gelmesini eğilimindedir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-190">Applications that follow the Dependency Inversion Principle as well as Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="7c7e1-191">Bu mimari yıllar içinde birçok adlarıyla geçti.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-191">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="7c7e1-192">İlk adlarından birini Altıgen bağlantı noktaları-ve-bağdaştırıcıları tarafından izlenen, mimarisidir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-192">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="7c7e1-193">Daha kısa süre önce onu olarak alıntı olarak [çoklu kare mimarisi](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) veya [temiz mimarisi](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="7c7e1-193">More recently, it's been cited as the [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="7c7e1-194">Bu e-kitap mimarisinde açıklamak için temel olarak kullanılan temiz mimari, son bu adı var.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-194">It is this last name, Clean Architecture, that is used as the basis for describing the architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="7c7e1-195">Temiz mimarisi olmayan olanlar için DDD ilkeleri kullanılarak oluşturulan uygulamaların uygulanabilir terim DDD kullanılarak oluşturulmuştur.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-195">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="7c7e1-196">Eski olması durumunda bu birleşimi için "Temiz DDD mimari" adlandırılabilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-196">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="7c7e1-197">Temiz mimarisi uygulama Merkezi'nde iş mantığı ve uygulama modeli koyar.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-197">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="7c7e1-198">Veri erişimi veya diğer altyapı sorunları bağımlı iş mantığı sahip olmak yerine bu bağımlılığı ters: altyapı ve uygulama ayrıntıları uygulama Çekirdeğinde bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-198">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="7c7e1-199">Bu altyapı katmanında tanımlanan türleri tarafından uygulanan uygulama çekirdek soyutlamalar veya arabirimlerini tanımlayarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-199">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="7c7e1-200">Bu mimari görselleştirme en yaygın yolu eşmerkezli daireler, bir çoklu kare benzer bir dizi kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-200">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="7c7e1-201">Şekil 5-X mimari gösteriminin bu stili örneği gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-201">Figure 5-X shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

<span data-ttu-id="7c7e1-202">**Şekil 5-7.**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-202">**Figure 5-7.**</span></span> <span data-ttu-id="7c7e1-203">Temiz mimarisi; Çoklu kare görünümü</span><span class="sxs-lookup"><span data-stu-id="7c7e1-203">Clean Architecture; onion view</span></span>

<span data-ttu-id="7c7e1-204">Bu diyagramda, bağımlılıklar doğru içteki daire akışı.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-204">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="7c7e1-205">Bu nedenle, (hangi adını konumundan Bu diyagramda, çekirdek alır) uygulama çekirdek diğer uygulama katmanları bağımlılık olduğunu görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-205">Thus, you can see that the Application Core (which takes its name from its position at the core of this diagram) has no dependencies on other application layers.</span></span> <span data-ttu-id="7c7e1-206">Çok merkezinde uygulamanın varlıkları ve arabirimleri ' dir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-206">At the very center are the application's entities and interfaces.</span></span> <span data-ttu-id="7c7e1-207">Yalnızca dışında ancak yine de uygulama çekirdek, iç daire içinde tanımlanan arabirimleri genellikle uygulama etki alanı Hizmetleri değildir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="7c7e1-208">Uygulama çekirdek dışında kullanıcı arabirimi ve altyapı Katmanlar uygulama çekirdeği üzerinde ancak bir diğer (zorunlu) bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-208">Outside of the Application Core, both the User Interface and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="7c7e1-209">Şekil 5-X daha iyi kullanıcı Arabirimi ve diğer katmanları arasındaki bağımlılığı yansıtan daha geleneksel yatay katman diyagramını gösterir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-209">Figure 5-X shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

<span data-ttu-id="7c7e1-210">**Şekil 5-8.**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-210">**Figure 5-8.**</span></span> <span data-ttu-id="7c7e1-211">Temiz mimarisi; Yatay Katman görünümü</span><span class="sxs-lookup"><span data-stu-id="7c7e1-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="7c7e1-212">Not yalnızca çalışma zamanı bağımlılık kesikli oku temsil ederken, düz okları derleme zamanı bağımlılıkları temsil eder.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="7c7e1-213">Temiz mimarisi kullanarak, uygulama çekirdek derleme zamanında tanımlanan arabirimlerle UI katmanında çalışır ve ideal olarak uygulama türleri bilgisi altyapı katmanda tanımlamadığınız.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-213">Using the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally should not have any knowledge of the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="7c7e1-214">Mevcut ve bağımlılık ekleme aracılığıyla uygulama çekirdek arabirimleri kadar kablolu olması gerekir böylece çalışma zamanında, ancak, bu uygulama türleri uygulamanın yürütmek için gerekli olacaktır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-214">At runtime, however, these implementation types will be required for the app to execute, so they will need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="7c7e1-215">Şekil 5-9 bu önerileri yapılandırıldığında ASP.NET Core uygulamanın mimarisinin ayrıntılı görünümünü gösterir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![ASPNET çekirdek mimarisi](./media/image5-9.png)

<span data-ttu-id="7c7e1-217">**Şekil 5-9.**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-217">**Figure 5-9.**</span></span> <span data-ttu-id="7c7e1-218">Temiz mimarisi aşağıdaki ASP.NET Core mimarisi diyagramı.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="7c7e1-219">Uygulama çekirdek altyapısına bağımlı değil çünkü bu katman için otomatik birim testleri yazma çok kolaydır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-219">Because the Application Core doesn't depend on Infrastructure, it is very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="7c7e1-220">Şekil 5-10 ve 5-11 testleri bu mimariye nasıl uyduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="7c7e1-222">**Şekil 5-10.**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-222">**Figure 5-10.**</span></span> <span data-ttu-id="7c7e1-223">Birim yalıtım modunda uygulama çekirdek testi.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="7c7e1-225">**Şekil 5-11.**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-225">**Figure 5-11.**</span></span> <span data-ttu-id="7c7e1-226">Dış bağımlılıkları altyapı uygulamaları sınama tümleştirme.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="7c7e1-227">UI katmanında altyapı proje tanımlanan türlerinde doğrudan herhangi bir bağımlılığı olmadığından benzer şekilde test kolaylaştırmak için ya da uygulamaları veya uygulama gereksinimleri değiştirme yanıt değiştirilecek çok kolaydır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it is likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="7c7e1-228">ASP.NET Core'nın yerleşik kullanımını ve bağımlılık ekleme desteği yapısı Önemsiz olmayan tek yapılı uygulamalar için en uygun şekilde bu mimari sağlar.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="7c7e1-229">Tek yapılı uygulamalar için uygulama çekirdek, altyapı ve kullanıcı arabirimi projeleri tümü tek bir uygulama olarak çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-229">For monolithic applications the Application Core, Infrastructure, and User Interface projects are all run as a single application.</span></span> <span data-ttu-id="7c7e1-230">Çalışma zamanı uygulama mimarisi şey Şekil 5-12'gibi görünebilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASPNET çekirdek mimarisi 2](./media/image5-12.png)

<span data-ttu-id="7c7e1-232">**Şekil 5-12.**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-232">**Figure 5-12.**</span></span> <span data-ttu-id="7c7e1-233">Bir örnek ASP.NET Core uygulamanın çalışma zamanı mimarisi.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="7c7e1-234">Temiz mimarisinde kod düzenleme</span><span class="sxs-lookup"><span data-stu-id="7c7e1-234">Organizing Code in Clean Architecture</span></span>

<span data-ttu-id="7c7e1-235">Bir temiz mimarisi çözümü her proje Temizle sorumlulukları vardır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="7c7e1-236">Bu nedenle, belirli türleri her projeye ait ve bu tür uygun projesinde karşılık gelen klasörleri sık bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-236">As such, certain types will belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="7c7e1-237">Uygulama çekirdek varlıklar, hizmet ve arabirimi içerir iş modeli tutar.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="7c7e1-238">Bu arabirimleri altyapısı, veri erişimi, dosya sistemi erişimi, ağ çağrıları, vb. gibi kullanılarak gerçekleştirilen işlemleri için soyutlamalar içerir. Bazen Hizmetleri veya bu katmanda tanımlanan arabirimleri hiçbir kullanıcı Arabirimi veya altyapı bağımlı varlık olmayan türleriyle çalışmak gerekir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="7c7e1-239">Bu basit veri aktarım nesneleri (DTOs) tanımlanabilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

> ### <a name="application-core-types"></a><span data-ttu-id="7c7e1-240">Uygulama çekirdek türleri</span><span class="sxs-lookup"><span data-stu-id="7c7e1-240">Application Core Types</span></span>
> -   <span data-ttu-id="7c7e1-241">Varlıkları (kalıcı iş modeli sınıflar)</span><span class="sxs-lookup"><span data-stu-id="7c7e1-241">Entities (business model classes that are persisted)</span></span>
> -   <span data-ttu-id="7c7e1-242">Arabirimler</span><span class="sxs-lookup"><span data-stu-id="7c7e1-242">Interfaces</span></span>
> -   <span data-ttu-id="7c7e1-243">Hizmetler</span><span class="sxs-lookup"><span data-stu-id="7c7e1-243">Services</span></span>
> -   <span data-ttu-id="7c7e1-244">DTOs</span><span class="sxs-lookup"><span data-stu-id="7c7e1-244">DTOs</span></span>

<span data-ttu-id="7c7e1-245">Altyapı proje genellikle veri erişimi uygulamaları içerir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-245">The Infrastructure project will typically include data access implementations.</span></span> <span data-ttu-id="7c7e1-246">Tipik bir ASP.NET Core web uygulamasında bu Entity Framework DbContext, tanımlanmış herhangi EF çekirdek geçişler ve veri erişim uygulama sınıfları içerir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-246">In a typical ASP.NET Core web application, this will include the Entity Framework DbContext, any EF Core Migrations that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="7c7e1-247">Veri erişim uygulama kodu soyut en yaygın kullanım yoluyla yoludur [depo tasarım desenini](http://deviq.com/repository-pattern/).</span><span class="sxs-lookup"><span data-stu-id="7c7e1-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](http://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="7c7e1-248">Veri erişimi uygulamaları yanı sıra uygulamaları altyapı sorunları ile etkileşimde hizmetleri altyapısı projesi içermelidir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="7c7e1-249">Hizmetlerin uygulama çekirdek tanımlanan arabirimleri uygulamanız gerekir ve bu nedenle altyapı uygulama çekirdek projesine bir başvuru sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

> ### <a name="infrastructure-types"></a><span data-ttu-id="7c7e1-250">Altyapı türleri</span><span class="sxs-lookup"><span data-stu-id="7c7e1-250">Infrastructure Types</span></span>
> -   <span data-ttu-id="7c7e1-251">EF çekirdek türleri (DbContext, geçiş)</span><span class="sxs-lookup"><span data-stu-id="7c7e1-251">EF Core types (DbContext, Migrations)</span></span>
> -   <span data-ttu-id="7c7e1-252">Veri erişim uygulama türleri (depoları)</span><span class="sxs-lookup"><span data-stu-id="7c7e1-252">Data access implementation types (Repositories)</span></span>
> -   <span data-ttu-id="7c7e1-253">Altyapı özgü hizmetler (FileLogger, SmtpNotifier, vb.)</span><span class="sxs-lookup"><span data-stu-id="7c7e1-253">Infrastructure-specific services (FileLogger, SmtpNotifier, etc.)</span></span>

<span data-ttu-id="7c7e1-254">ASP.NET Core MVC uygulamasındaki kullanıcı arabirimi katmanı uygulaması için giriş noktası olacaktır ve ASP.NET Core MVC projesinde olacaktır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-254">The user interface layer in an ASP.NET Core MVC application will be the entry point for the application, and will be an ASP.NET Core MVC project.</span></span> <span data-ttu-id="7c7e1-255">Bu proje uygulama çekirdek projeye başvuruda bulunmalıdır ve türlerinden kesinlikle uygulama çekirdek tanımlanan arabirimleri aracılığıyla altyapısıyla etkileşim.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="7c7e1-256">Hiçbir sayısı doğrudan örneklemesi (veya statik çağrıları) altyapısı katman türleri UI katmanda izin.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-256">No direct instantiation of (or static calls to) Infrastructure layer types should be permitted in the UI layer.</span></span>

> ### <a name="ui-layer-types"></a><span data-ttu-id="7c7e1-257">UI katman türleri</span><span class="sxs-lookup"><span data-stu-id="7c7e1-257">UI Layer Types</span></span>
> -   <span data-ttu-id="7c7e1-258">Denetleyiciler</span><span class="sxs-lookup"><span data-stu-id="7c7e1-258">Controllers</span></span>
> -   <span data-ttu-id="7c7e1-259">FilTReleri</span><span class="sxs-lookup"><span data-stu-id="7c7e1-259">Filters</span></span>
> -   <span data-ttu-id="7c7e1-260">Görünümler</span><span class="sxs-lookup"><span data-stu-id="7c7e1-260">Views</span></span>
> -   <span data-ttu-id="7c7e1-261">ViewModels</span><span class="sxs-lookup"><span data-stu-id="7c7e1-261">ViewModels</span></span>
> -   <span data-ttu-id="7c7e1-262">Başlangıç</span><span class="sxs-lookup"><span data-stu-id="7c7e1-262">Startup</span></span>

<span data-ttu-id="7c7e1-263">Başlangıç sınıfı ve kablolama uygulama türleri yukarı uygulamayı yapılandırma için çalışma zamanında düzgün çalışması bağımlılık ekleme izin vererek arabirimlerine sorumludur.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="7c7e1-264">Bağımlılık yerleştirmeye UI projesinin ConfigureServices haline dosyasındaki wire için proje altyapısı projesi başvurmanız gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="7c7e1-265">Bu bağımlılık, en kolay özel dı kapsayıcısını kullanarak ortadan kaldırılabilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="7c7e1-266">Bu örnek amaçları doğrultusunda, en kolay yaklaşım altyapısı projesi başvurmak kullanıcı Arabirimi proje izin vermektir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="7c7e1-267">Tek yapılı uygulamaları ve kapsayıcıları</span><span class="sxs-lookup"><span data-stu-id="7c7e1-267">Monolithic Applications and Containers</span></span> 

<span data-ttu-id="7c7e1-268">Bir tek ve dağıtım tek yapılı tabanlı Web uygulaması veya hizmeti oluşturmak ve bir kapsayıcı olarak dağıtın.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="7c7e1-269">Uygulama içinde bu tek yapılı ancak birkaç kitaplıkları, bileşenler veya katmanlar halinde düzenlenmiş olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-269">Within the application, it might not be monolithic but organized into several libraries, components or layers.</span></span> <span data-ttu-id="7c7e1-270">Harici olarak bunu bir tek tek bir işlem, tek bir web uygulaması veya tek bir hizmet gibi kapsayıcıdır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-270">Externally it is a single container like a single process, single web application or single service.</span></span>

<span data-ttu-id="7c7e1-271">Bu model yönetmek için uygulamayı temsil etmek için tek bir kapsayıcı dağıtın.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="7c7e1-272">Ölçeklendirmek için önde bir yük dengeleyici ile ek kopyalar eklemeniz yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="7c7e1-273">Basitlik, tek bir dağıtım bir tek kapsayıcı veya VM yönetme gelir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="7c7e1-274">Şekil 5-X gösterildiği gibi birden çok bileşenleri/kitaplıklarına veya her kapsayıcı içindeki iç katmanları içerebilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-X.</span></span> <span data-ttu-id="7c7e1-275">Ancak, kapsayıcı asıl, aşağıdaki *"bir kapsayıcı bir şeyi yapar ve tek bir işlemde mu*", tek yapılı desen bir çakışma olabilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-275">But, following the container principal of *"a container does one thing, and does it in one process*", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="7c7e1-276">Bu yaklaşımın bir dezavantajı olursa/uygulama büyürken ölçeklendirmek için gerektiren gelir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="7c7e1-277">Tüm uygulama ölçeklendirilmiş, onu gerçekten bir sorun değildir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-277">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="7c7e1-278">Bununla birlikte, çoğu durumda, birkaç uygulama ölçeklendirme, diğer bileşenler durumdayken gerektiren sıkıştırma noktaları daha az kullanılan bölümlerdir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="7c7e1-279">Tipik bir e-ticaret örneğinde; büyük olasılıkla ölçeklendirmek gerekenler ürün bilgi bileşendir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-279">Using the typical eCommerce example; what you likely need to scale is the product information component.</span></span> <span data-ttu-id="7c7e1-280">Birçok daha fazla müşteri ürünleri bunları satın daha göz atın.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="7c7e1-281">Daha fazla müşteriler kendi Sepeti ödeme işlem hattını kullanma daha kullanın.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="7c7e1-282">Daha az müşteriler, yorum eklemek veya satın alma geçmişlerini görüntüleyin.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="7c7e1-283">Ve büyük olasılıkla, içerik ve pazarlama kampanyaları yönetmek için gerekli olan tek bir bölgedeki çalışanlar sayıda yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="7c7e1-284">Tek yapılı tasarım ölçeklendirme tarafından tüm kod birden çok kez dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="7c7e1-285">Ölçeğin ek olarak, tüm uygulama ve tüm örnekleri tam çözümünüzün yeniden dağıtımını tam retesting sorun, her şeyi tek bir bileşen değişiklikler gerektirir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-285">In addition to the scale everything problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="7c7e1-286">Tek yapılı bir yaklaşım yaygındır ve birçok kuruluş bu mimari yaklaşımda geliştirme.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="7c7e1-287">Başkalarının sınırları devreyi sırada çok iyi yeterli sonuçları yaşıyor.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="7c7e1-288">Birçok uygulamalarını bu modelde, çünkü araçları ve altyapısı hizmet odaklı mimari (SOA) oluşturmak çok zor ve uygulama büyüdü kadar gereken - bkz kaydetmedi tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service oriented architectures (SOA), and they didn't see the need - until the app grew.</span></span> <span data-ttu-id="7c7e1-289">Tek yapılı bir yaklaşım sınırları basarsa bulursanız, daha iyi kapsayıcıları ve mikro yararlanan etkinleştirmek için uygulama ayırma sonraki mantıklı adım olabilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-289">If you find you're hitting the limits of the monolithic approach, breaking the app up to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="7c7e1-290">Microsoft azure'da tek yapılı uygulamaları dağıtma, özel VM'ler için her bir örneği kullanılarak gerçekleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="7c7e1-291">Kullanarak [Azure VM ölçek kümesi](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), sanal makineleri kolayca ölçeklendirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-291">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="7c7e1-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) tek yapılı uygulamaları çalıştırabilir ve sanal makineleri yönetmek zorunda kalmadan örnekleri kolayca ölçeklendirin.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="7c7e1-293">Azure App Services Dağıtımı basitleştirme Docker kapsayıcıları de, tek tek örneklerini çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="7c7e1-294">Docker kullanarak, Docker ana bilgisayar olarak tek bir VM'yi dağıtmak ve birden çok örneği çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="7c7e1-295">Şekil 5-14'te gösterildiği gibi Azure dengeleyici kullanarak ölçeklendirme yönetebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="7c7e1-296">Çeşitli konakları dağıtımına geleneksel dağıtım teknikleri ile yönetilebilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="7c7e1-297">Docker ana bilgisayarları gibi komutlarla yönetilebilir **çalıştırmak docker** sürekli teslim (CD) ardışık düzenleri gibi el ile veya Otomasyon aracılığıyla gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="7c7e1-298">Bir kapsayıcı olarak dağıtılan tek yapılı uygulaması</span><span class="sxs-lookup"><span data-stu-id="7c7e1-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="7c7e1-299">Tek yapılı uygulama dağıtımlarını yönetmek için kapsayıcıları kullanmanın yararları vardır.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="7c7e1-300">Kapsayıcıları örneklerini ölçeklendirme çok daha hızlı ve ek sanal makineleri dağıtma daha kolay olur.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="7c7e1-301">VM ölçek kümesi VM ölçeklendirme kullanırken bile, örneğine zaman ayırın.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-301">Even when using VM Scale Sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="7c7e1-302">Uygulama örnekleri dağıtıldığında, uygulama yapılandırmasını VM bir parçası olarak yönetilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="7c7e1-303">Şu ana kadar daha hızlı Docker görüntüleri olarak güncelleştirmeleri dağıtmak ve ağ verimli.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="7c7e1-304">Docker görüntüleri genellikle piyasa sürümlerini hızlandırma saniye cinsinden başlatın.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="7c7e1-305">Docker örneği hattının kaldırılması veren olarak kadar kolay bir **docker Dur** genellikle değerinden bir saniyede Tamamlanıyor komutu.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-305">Tearing down a Docker instance is as easy as issuing a **docker stop** command, typically completing in less than a second.</span></span>

<span data-ttu-id="7c7e1-306">Kapsayıcıları tasarım gereği kendiliğinden değişmez, güncelleştirme kodları bazı belirli yapılandırma veya dosya soldan için diskte hesap unuttunuz ancak hiçbir zaman bozuk VM'ler hakkında endişelenmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="7c7e1-307">Tek yapılı uygulamaları Docker, ölçeklendirilebilir, alt sistemlerini tek yapılı uygulamasına çiğnemekten yararlanabilir geliştirilen ve tek tek dağıtılan giriş noktanızdır mikro, bölge olabilir.</span><span class="sxs-lookup"><span data-stu-id="7c7e1-307">While monolithic apps can benefit from Docker, breaking up the monolithic application into sub systems which can be scaled, developed and deployed individually may be your entry point into the realm of microservices.</span></span>

> ### <a name="references--common-web-architectures"></a><span data-ttu-id="7c7e1-308">Başvuruları – ortak Web mimariler</span><span class="sxs-lookup"><span data-stu-id="7c7e1-308">References – Common Web Architectures</span></span>
> - <span data-ttu-id="7c7e1-309">**Temiz mimarisi**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-309">**The Clean Architecture**</span></span>  
> <span data-ttu-id="7c7e1-310"><https://8thlight.com/blog/Uncle-Bob/2012/08/13/the-Clean-Architecture.HTML></span><span class="sxs-lookup"><span data-stu-id="7c7e1-310"><https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html></span></span>
> - <span data-ttu-id="7c7e1-311">**Çoklu kare mimarisi**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-311">**The Onion Architecture**</span></span>  
> <span data-ttu-id="7c7e1-312"><http://jeffreypalermo.com/blog/the-onion-Architecture-Part-1/></span><span class="sxs-lookup"><span data-stu-id="7c7e1-312"><http://jeffreypalermo.com/blog/the-onion-architecture-part-1/></span></span>
> - <span data-ttu-id="7c7e1-313">**Depo düzeni**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-313">**The Repository Pattern**</span></span>  
> <span data-ttu-id="7c7e1-314"><http://deviq.com/Repository-pattern/></span><span class="sxs-lookup"><span data-stu-id="7c7e1-314"><http://deviq.com/repository-pattern/></span></span>
> - <span data-ttu-id="7c7e1-315">**Temiz mimarisi çözümü örneği**</span><span class="sxs-lookup"><span data-stu-id="7c7e1-315">**Clean Architecture Solution Sample**</span></span>  
> <span data-ttu-id="7c7e1-316"><https://github.com/ardalis/cleanarchitecture></span><span class="sxs-lookup"><span data-stu-id="7c7e1-316"><https://github.com/ardalis/cleanarchitecture></span></span>
> - <span data-ttu-id="7c7e1-317">**Mikro e-kitap mimariden** <http://aka.ms/MicroservicesEbook></span><span class="sxs-lookup"><span data-stu-id="7c7e1-317">**Architecting Microservices e-book** <http://aka.ms/MicroservicesEbook></span></span>

>[!div class="step-by-step"]
<span data-ttu-id="7c7e1-318">[Önceki] (Mimari-principles.md) [sonraki] (ortak-istemci-tarafı-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="7c7e1-318">[Previous] (architectural-principles.md) [Next] (common-client-side-web-technologies.md)</span></span>

---
title: "Veri Sözleşmelerinde Koleksiyon Türleri"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
caps.latest.revision: "19"
author: Erikre
ms.author: erikre
manager: erikre
ms.openlocfilehash: ca3bbb4b88bf4355d3c487196672636e6b77d419
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/18/2017
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="ba300-102">Veri Sözleşmelerinde Koleksiyon Türleri</span><span class="sxs-lookup"><span data-stu-id="ba300-102">Collection Types in Data Contracts</span></span>
<span data-ttu-id="ba300-103">A *koleksiyonu* belirli bir türdeki öğeleri listesini içerir.</span><span class="sxs-lookup"><span data-stu-id="ba300-103">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="ba300-104">İçinde [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], böyle listeleri dizileri veya diğer türleri çeşitli kullanarak temsil edilebilir (genel listesi, genel <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, veya <xref:System.Collections.ArrayList>).</span><span class="sxs-lookup"><span data-stu-id="ba300-104">In the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="ba300-105">Örneğin, bir koleksiyon için belirli bir müşteri adresleri listesi tutabilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-105">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="ba300-106">Bu koleksiyon adı verilen *listesinde koleksiyonları*kendi gerçek türü ne olursa olsun.</span><span class="sxs-lookup"><span data-stu-id="ba300-106">These collections are called *list collections*, regardless of their actual type.</span></span>  
  
 <span data-ttu-id="ba300-107">Özel bir form koleksiyonu bir öğe ("anahtarı") ve başka bir ("değeri") arasındaki bir ilişkiyi temsil eden bulunmaktadır.</span><span class="sxs-lookup"><span data-stu-id="ba300-107">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="ba300-108">İçinde [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], bunlar türlerine göre aşağıdaki gibi gösterilir <xref:System.Collections.Hashtable> ve genel bir sözlük.</span><span class="sxs-lookup"><span data-stu-id="ba300-108">In the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)], these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="ba300-109">Örneğin, bir ilişki koleksiyonu Şehir ("anahtarı"), popülasyon ("değeri") eşleyebilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-109">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="ba300-110">Bu koleksiyon adı verilen *sözlük koleksiyonları*kendi gerçek türü ne olursa olsun.</span><span class="sxs-lookup"><span data-stu-id="ba300-110">These collections are called *dictionary collections*, regardless of their actual type.</span></span>  
  
 <span data-ttu-id="ba300-111">Koleksiyonları veri sözleşmesi modelinde özel işleme alırsınız.</span><span class="sxs-lookup"><span data-stu-id="ba300-111">Collections receive special treatment in the data contract model.</span></span>  
  
 <span data-ttu-id="ba300-112">Türleri uygulayan <xref:System.Collections.IEnumerable> arabirimi dizileri ve genel koleksiyonlar dahil olmak üzere, koleksiyon olarak tanınmıyor.</span><span class="sxs-lookup"><span data-stu-id="ba300-112">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="ba300-113">Bu, bu uygulama türleri <xref:System.Collections.IDictionary> veya genel <xref:System.Collections.Generic.IDictionary%602> arabirimleri sözlük koleksiyonları; diğerleri listesine koleksiyonlarıdır.</span><span class="sxs-lookup"><span data-stu-id="ba300-113">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>  
  
 <span data-ttu-id="ba300-114">Koleksiyon türleri'adlı bir yöntemi olması gibi ek gereksinimleri `Add` ve varsayılan bir oluşturucu, aşağıdaki bölümlerde ayrıntılı olarak ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="ba300-114">Additional requirements on collection types, such as having a method called `Add` and a default constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="ba300-115">Bu koleksiyon türleri hem seri durumdan ve sağlar.</span><span class="sxs-lookup"><span data-stu-id="ba300-115">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="ba300-116">Bazı koleksiyonlar doğrudan, gibi genel desteklenmediğini yani <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (varsayılan oluşturucu yok olduğundan).</span><span class="sxs-lookup"><span data-stu-id="ba300-116">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no default constructor).</span></span> <span data-ttu-id="ba300-117">Ancak, bu kısıtlamalar atlamak hakkında daha fazla bilgi için bu konunun devamındaki "Kullanarak koleksiyon arabirimi türleri ve salt okunur koleksiyonları" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="ba300-117">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>  
  
 <span data-ttu-id="ba300-118">Koleksiyonlarda yer alan türleri veri sözleşme türleri veya aksi halde seri hale getirilebilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-118">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="ba300-119">[Veri sözleşmesi seri hale getirici tarafından desteklenen türleri](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="ba300-119"> [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span>  
  
 [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="ba300-120">nedir ve ne nasıl koleksiyonları serileştirilir, geçerli bir koleksiyon, yaklaşık de olarak kabul edilmez, bu konunun "Gelişmiş toplama kuralları" bölümünde seri hale getirilmesi hakkında bilgi bakın.</span><span class="sxs-lookup"><span data-stu-id="ba300-120"> what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>  
  
## <a name="interchangeable-collections"></a><span data-ttu-id="ba300-121">Birbirinin yerine koleksiyonları</span><span class="sxs-lookup"><span data-stu-id="ba300-121">Interchangeable Collections</span></span>  
 <span data-ttu-id="ba300-122">Tüm liste koleksiyonları aynı türde aynı verilere sahip düşünülür Sözleşme (kullanarak özelleştirilen sürece <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliği, bu konunun ilerleyen bölümlerinde açıklandığı gibi).</span><span class="sxs-lookup"><span data-stu-id="ba300-122">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="ba300-123">Bu nedenle, örneğin, aşağıdaki veri sözleşmeleri eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="ba300-123">Thus, for example, the following data contracts are equivalent.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
 [!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]  
  
 <span data-ttu-id="ba300-124">Her iki veri sözleşmeleri XML aşağıdaki kodu benzer sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="ba300-124">Both data contracts result in XML similar to the following code.</span></span>  
  
```xml  
<PurchaseOrder>  
    <customerName>...</customerName>  
    <items>  
        <Item>...</Item>  
        <Item>...</Item>  
        <Item>...</Item>  
        ...  
    </items>  
    <comments>  
        <string>...</string>  
        <string>...</string>  
        <string>...</string>  
        ...  
    </comments>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="ba300-125">Koleksiyon interchangeability kullanmanızı, örneğin, sunucudaki performansı en iyi hale getirilmiş bir koleksiyon türü ve kullanıcı arabirimi bileşenlerini istemcide bağlanması için tasarlanmış bir koleksiyon türü sağlar.</span><span class="sxs-lookup"><span data-stu-id="ba300-125">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>  
  
 <span data-ttu-id="ba300-126">Benzer şekilde listesi koleksiyonları, aynı anahtar ve değer türleri olan tüm sözlük koleksiyonları aynı verilere sahip kabul edilir Sözleşme (tarafından özelleştirmediyseniz <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliği).</span><span class="sxs-lookup"><span data-stu-id="ba300-126">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>  
  
 <span data-ttu-id="ba300-127">Yalnızca veri sözleşmesi türü koleksiyonu eşdeğer ilgili olarak çok önemlidir, .NET türleri değil.</span><span class="sxs-lookup"><span data-stu-id="ba300-127">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="ba300-128">Diğer bir deyişle, type1 ve Type2 eşdeğer veri sözleşmeleri varsa Type1 koleksiyonu Type2 koleksiyona eşdeğer olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-128">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>  
  
 <span data-ttu-id="ba300-129">Genel olmayan koleksiyonları aynı verileri olarak kabul edilir sözleşme genel koleksiyonlar türü olarak `Object`.</span><span class="sxs-lookup"><span data-stu-id="ba300-129">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="ba300-130">(Örneğin, için veri sözleşmeleri <xref:System.Collections.ArrayList> ve genel <xref:System.Collections.Generic.List%601> , `Object` aynıdır.)</span><span class="sxs-lookup"><span data-stu-id="ba300-130">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>  
  
## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="ba300-131">Koleksiyon arabirimi türleri ve salt okunur koleksiyonları kullanma</span><span class="sxs-lookup"><span data-stu-id="ba300-131">Using Collection Interface Types and Read-Only Collections</span></span>  
 <span data-ttu-id="ba300-132">Koleksiyon arabirimi türleri (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>genel <xref:System.Collections.Generic.IDictionary%602>, veya arabirimleri türetilmiş bu arabirimlerinden) koleksiyonu veri sözleşmeleri, gerçek koleksiyon türleri için koleksiyon veri sözleşmeleri eşdeğer sahip olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-132">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="ba300-133">Bu nedenle, koleksiyon arabirimi türü olarak serileştirilen türünü bildirmesine mümkündür ve gerçek koleksiyon türü kullanılan sanki sonuçları aynıdır.</span><span class="sxs-lookup"><span data-stu-id="ba300-133">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="ba300-134">Örneğin, aşağıdaki veri sözleşmeleri eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="ba300-134">For example, the following data contracts are equivalent.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
 [!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]  
  
 <span data-ttu-id="ba300-135">Bildirilen türü bir arabirim olduğunda seri hale getirme sırasında kullanılan gerçek örneği türü arabirimi uygulayan herhangi bir türü olabilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-135">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="ba300-136">Kısıtlamaları daha önce ele alınan (varsayılan bir oluşturucu sahip ve bir `Add` yöntemi) geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="ba300-136">Restrictions discussed previously (having a default constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="ba300-137">Örneğin, genel bir örneğine Customer2 içinde adresleri ayarlayabilirsiniz <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> doğrudan veri üyesi bildiremezsiniz olsa bile, adresini genel yazın <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="ba300-137">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>  
  
 <span data-ttu-id="ba300-138">Arabirim türü olduğunda, serileştirme motoruna bildirilen arabirimini uygulayan bir türünü seçer ve türü örneği seri durumdan çıkarma sırasında.</span><span class="sxs-lookup"><span data-stu-id="ba300-138">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="ba300-139">Bilinen türleri mekanizması (açıklanan [veri sözleşmesi bilinen türleri](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)) etkisizdir içinde türü seçimi burada; yerleşik [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span><span class="sxs-lookup"><span data-stu-id="ba300-139">The known types mechanism (described in [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)) has no effect here; the choice of type is built into [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span></span>  
  
## <a name="customizing-collection-types"></a><span data-ttu-id="ba300-140">Koleksiyon türleri özelleştirme</span><span class="sxs-lookup"><span data-stu-id="ba300-140">Customizing Collection Types</span></span>  
 <span data-ttu-id="ba300-141">Koleksiyon türleri kullanarak özelleştirebileceğiniz <xref:System.Runtime.Serialization.CollectionDataContractAttribute> birkaç kullanımı vardır özniteliği.</span><span class="sxs-lookup"><span data-stu-id="ba300-141">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>  
  
 <span data-ttu-id="ba300-142">Genellikle bu öznitelik mümkün olduğunca uygulanmasını önlemek için önerilir, özelleştirme koleksiyon türleri güvenlik ihlalleri koleksiyonu interchangeability, unutmayın.</span><span class="sxs-lookup"><span data-stu-id="ba300-142">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="ba300-143">Bu sorun, bu konunun devamındaki "Toplama kuralları Gelişmiş" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="ba300-143"> this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>  
  
### <a name="collection-data-contract-naming"></a><span data-ttu-id="ba300-144">Koleksiyon veri sözleşmesi adlandırma</span><span class="sxs-lookup"><span data-stu-id="ba300-144">Collection Data Contract Naming</span></span>  
 <span data-ttu-id="ba300-145">Koleksiyon türleri adlandırma kuralları bölümünde açıklandığı gibi normal veri sözleşme türleri, adlandırma benzerdir [veri sözleşmesi adları](../../../../docs/framework/wcf/feature-details/data-contract-names.md), önemli bazı farklar olsa da:</span><span class="sxs-lookup"><span data-stu-id="ba300-145">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), although some important differences exist:</span></span>  
  
-   <span data-ttu-id="ba300-146"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> Yerine adını özelleştirmek için kullanılan öznitelik <xref:System.Runtime.Serialization.DataContractAttribute> özniteliği.</span><span class="sxs-lookup"><span data-stu-id="ba300-146">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="ba300-147"><xref:System.Runtime.Serialization.CollectionDataContractAttribute> Özniteliği de sahip `Name` ve `Namespace` özellikleri.</span><span class="sxs-lookup"><span data-stu-id="ba300-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>  
  
-   <span data-ttu-id="ba300-148">Zaman <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliği uygulanmamış, varsayılan adı ve koleksiyon türleri için ad alanı adları ve ad alanları koleksiyonundaki türlerinin bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="ba300-148">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="ba300-149">Bunlar, koleksiyon türünün ad alanını ve ad etkilenmez.</span><span class="sxs-lookup"><span data-stu-id="ba300-149">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="ba300-150">Örneğin, aşağıdaki türlerden bakın.</span><span class="sxs-lookup"><span data-stu-id="ba300-150">For an example, see the following types.</span></span>  
  
    ```  
    public CustomerList1 : Collection<string> {}  
    public StringList1 : Collection<string> {}  
    ```  
  
 <span data-ttu-id="ba300-151">Her iki tür veri sözleşme adına "ArrayOfstring" ve değil "CustomerList1" veya "StringList1" dir.</span><span class="sxs-lookup"><span data-stu-id="ba300-151">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="ba300-152">Bu, herhangi bir kök düzeyinde bu tür serileştirme XML aşağıdaki kodu benzer oluşturduğunda anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="ba300-152">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>  
  
```xml  
<ArrayOfstring>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</ArrayOfstring>  
```  
  
 <span data-ttu-id="ba300-153">Bu adlandırma kuralı dizelerinin listesini gösteren özelleştirilmiş olmayan türü XML gösterimi ve aynı veri sözleşmesi olduğundan emin olmak için seçildi.</span><span class="sxs-lookup"><span data-stu-id="ba300-153">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="ba300-154">Bu koleksiyon interchangeability mümkün kılar.</span><span class="sxs-lookup"><span data-stu-id="ba300-154">This makes collection interchangeability possible.</span></span> <span data-ttu-id="ba300-155">Bu örnekte, CustomerList1 ve StringList1 tamamen birbirinin yerine kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-155">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>  
  
 <span data-ttu-id="ba300-156">Ancak, ne zaman <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliği uygulanır, hiçbir özellik özniteliği ayarlanmış olsa bile, koleksiyon özelleştirilmiş koleksiyon veri sözleşmesi olur.</span><span class="sxs-lookup"><span data-stu-id="ba300-156">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="ba300-157">Ad ve ad alanı koleksiyonu veri sözleşme ardından koleksiyon türü kendisi bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="ba300-157">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="ba300-158">Örneğin, aşağıdaki tür bakın.</span><span class="sxs-lookup"><span data-stu-id="ba300-158">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
 [!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]  
  
 <span data-ttu-id="ba300-159">Seri hale getirilmiş sonuç XML aşağıdakine benzer tutulduğunda.</span><span class="sxs-lookup"><span data-stu-id="ba300-159">When serialized, the resulting XML is similar to the following.</span></span>  
  
```xml  
<CustomerList2>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</CustomerList2>  
```  
  
 <span data-ttu-id="ba300-160">Bu artık özelleştirilmiş olmayan türleri XML gösterimini eşdeğer olduğuna dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="ba300-160">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>  
  
-   <span data-ttu-id="ba300-161">Kullanabileceğiniz `Name` ve `Namespace` daha da fazla özelliklerini özelleştirme adlandırma.</span><span class="sxs-lookup"><span data-stu-id="ba300-161">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="ba300-162">Aşağıdaki sınıf bakın.</span><span class="sxs-lookup"><span data-stu-id="ba300-162">See the following class.</span></span>  
  
     [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
     [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]  
  
 <span data-ttu-id="ba300-163">Sonuçta elde edilen XML aşağıdakine benzer.</span><span class="sxs-lookup"><span data-stu-id="ba300-163">The resulting XML is similar to the following.</span></span>  
  
```xml  
<cust_list>  
    <string>...</string>  
    <string>...</string>  
    <string>...</string>  
    ...  
</cust_list>  
```  
  
 [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="ba300-164">Bu konunun devamındaki "Toplama kuralları Gelişmiş" bölümü.</span><span class="sxs-lookup"><span data-stu-id="ba300-164"> the "Advanced Collection Rules" section later in this topic.</span></span>  
  
### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="ba300-165">Yinelenen öğe adı listesi koleksiyonlarda özelleştirme</span><span class="sxs-lookup"><span data-stu-id="ba300-165">Customizing the Repeating Element Name in List Collections</span></span>  
 <span data-ttu-id="ba300-166">Liste koleksiyonları yinelenen girişler içerir.</span><span class="sxs-lookup"><span data-stu-id="ba300-166">List collections contain repeating entries.</span></span> <span data-ttu-id="ba300-167">Normalde, her yinelenen giriş derlemesinde türü veri sözleşme adına göre adlı bir öğe olarak temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-167">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>  
  
 <span data-ttu-id="ba300-168">İçinde `CustomerList` örnekler, içerdiği koleksiyonları dizeleri.</span><span class="sxs-lookup"><span data-stu-id="ba300-168">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="ba300-169">Yinelenen öğe şekilde dize ilkel tür için veri sözleşme adı "dize" olan "\<dize >".</span><span class="sxs-lookup"><span data-stu-id="ba300-169">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>  
  
 <span data-ttu-id="ba300-170">Ancak, kullanarak <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> özellikte <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliği, bu yinelenen öğe adı özelleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-170">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="ba300-171">Örneğin, aşağıdaki tür bakın.</span><span class="sxs-lookup"><span data-stu-id="ba300-171">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
 [!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]  
  
 <span data-ttu-id="ba300-172">Sonuçta elde edilen XML aşağıdakine benzer.</span><span class="sxs-lookup"><span data-stu-id="ba300-172">The resulting XML is similar to the following.</span></span>  
  
```xml  
<CustomerList4>  
    <customer>...</ customer>  
    <customer>...</customer>  
    <customer>...</customer>  
    ...  
</CustomerList4>  
```  
  
 <span data-ttu-id="ba300-173">Yinelenen öğe ad alanı her zaman kullanılarak özelleştirilebilir koleksiyon veri sözleşmesi ad alanı ile aynı olan `Namespace` özelliği, daha önce açıklandığı gibi.</span><span class="sxs-lookup"><span data-stu-id="ba300-173">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>  
  
### <a name="customizing-dictionary-collections"></a><span data-ttu-id="ba300-174">Sözlük koleksiyonları özelleştirme</span><span class="sxs-lookup"><span data-stu-id="ba300-174">Customizing Dictionary Collections</span></span>  
 <span data-ttu-id="ba300-175">Sözlük koleksiyonlarıdır temelde her girişin bir değer tarafından izlenen bir anahtar bulunduğu girişlerinin listeler.</span><span class="sxs-lookup"><span data-stu-id="ba300-175">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="ba300-176">Yalnızca normal listeleriyle karşılık gelen öğe adı için yinelenen öğe kullanarak değiştirebileceğiniz gibi <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> özelliği.</span><span class="sxs-lookup"><span data-stu-id="ba300-176">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>  
  
 <span data-ttu-id="ba300-177">Ayrıca, anahtarı ve değeri kullanarak temsil eden öğe adları değiştirebilirsiniz <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> ve <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> özellikleri.</span><span class="sxs-lookup"><span data-stu-id="ba300-177">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="ba300-178">Ad alanları bu öğeler için koleksiyon veri sözleşmesi ad alanı ile aynı olur.</span><span class="sxs-lookup"><span data-stu-id="ba300-178">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>  
  
 <span data-ttu-id="ba300-179">Örneğin, aşağıdaki tür bakın.</span><span class="sxs-lookup"><span data-stu-id="ba300-179">For an example, see the following type.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
 [!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]  
  
 <span data-ttu-id="ba300-180">Seri hale getirilmiş sonuç XML aşağıdakine benzer tutulduğunda.</span><span class="sxs-lookup"><span data-stu-id="ba300-180">When serialized, the resulting XML is similar to the following.</span></span>  
  
```xml  
<CountriesOrRegionsWithCapitals>  
    <entry>  
        <countryorregion>USA</countryorregion>  
        <capital>Washington</capital>  
    </entry>  
    <entry>  
        <countryorregion>France</countryorregion>  
        <capital>Paris</capital>  
    </entry>  
    ...  
</CountriesOrRegionsWithCapitals>  
```  
  
 [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="ba300-181">Sözlük koleksiyonlar, bu konunun devamındaki "Toplama kuralları Gelişmiş" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="ba300-181"> dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>  
  
## <a name="collections-and-known-types"></a><span data-ttu-id="ba300-182">Koleksiyonlar ve bilinen türler</span><span class="sxs-lookup"><span data-stu-id="ba300-182">Collections and Known Types</span></span>  
 <span data-ttu-id="ba300-183">Diğer koleksiyonları veya koleksiyon arabirimleri yerine polymorphically kullanıldığında bilinen türleri koleksiyon türleri eklemeniz gerekmez.</span><span class="sxs-lookup"><span data-stu-id="ba300-183">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="ba300-184">Örneğin, bir veri üyesi türü bildirirseniz <xref:System.Collections.IEnumerable> ve örneği göndermek için kullanmak <xref:System.Collections.ArrayList>, eklemek gerekmez <xref:System.Collections.ArrayList> bilinen türleri için.</span><span class="sxs-lookup"><span data-stu-id="ba300-184">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>  
  
 <span data-ttu-id="ba300-185">Koleksiyon olmayan türleri yerine polymorphically koleksiyonları kullandığınızda, bilinen türleri eklenmelidir.</span><span class="sxs-lookup"><span data-stu-id="ba300-185">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="ba300-186">Örneğin, bir veri üyesi türü bildirirseniz `Object` ve örneği göndermek için kullanmak <xref:System.Collections.ArrayList>, ekleme <xref:System.Collections.ArrayList> bilinen türleri için.</span><span class="sxs-lookup"><span data-stu-id="ba300-186">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>  
  
 <span data-ttu-id="ba300-187">Bu, herhangi bir eşdeğer koleksiyonu polymorphically serileştirmek izin vermiyor.</span><span class="sxs-lookup"><span data-stu-id="ba300-187">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="ba300-188">Örneğin, eklerseniz <xref:System.Collections.ArrayList> önceki örnekte bilinen türleri listesine bu atamanıza izin vermez `Array of Object` eşdeğer veri sözleşmesi olmasına rağmen sınıf.</span><span class="sxs-lookup"><span data-stu-id="ba300-188">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="ba300-189">Bu seri hale getirme koleksiyon olmayan türleri için normal bilinen türleri davranışı öğesinden farklı değildir, ancak eşdeğer olarak koleksiyonlar için yaygın olduğu için söz konusu olduğunda koleksiyonları anlamak özellikle önemlidir.</span><span class="sxs-lookup"><span data-stu-id="ba300-189">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>  
  
 <span data-ttu-id="ba300-190">Seri hale getirme sırasında verilen veri sözleşmesi için verilen tüm kapsam içinde yalnızca bir türü bilinen ve aynı veri sözleşmeleri sahip tüm eşdeğer koleksiyonların.</span><span class="sxs-lookup"><span data-stu-id="ba300-190">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="ba300-191">Önceki örnekte, her ikisi de ekleyemezsiniz, yani <xref:System.Collections.ArrayList> ve `Array of Object` aynı kapsamda bilinen türleri için.</span><span class="sxs-lookup"><span data-stu-id="ba300-191">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="ba300-192">Yeniden, bu koleksiyon olmayan türleri için bilinen türler davranışı eşdeğer olan, ancak koleksiyonlar için anlamak özellikle önemlidir.</span><span class="sxs-lookup"><span data-stu-id="ba300-192">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>  
  
 <span data-ttu-id="ba300-193">Bilinen türler de koleksiyonları içeriği için gerekli olabilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-193">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="ba300-194">Örneğin, bir <xref:System.Collections.ArrayList> gerçekten örneklerini içeren `Type1` ve `Type2`, bu iki türü için bilinen türler eklenmelidir.</span><span class="sxs-lookup"><span data-stu-id="ba300-194">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>  
  
 <span data-ttu-id="ba300-195">Aşağıdaki örnek, koleksiyonlar ve bilinen türleri kullanarak doğru şekilde oluşturulmuş bir grafiğinin gösterir.</span><span class="sxs-lookup"><span data-stu-id="ba300-195">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="ba300-196">Gerçek bir uygulamada, aşağıdaki veri üye olarak tanımlarsınız normalde çünkü örnek biraz, contrived `Object`ve bu nedenle herhangi bir bilinen türü/çok biçimlilik sorun yoktur.</span><span class="sxs-lookup"><span data-stu-id="ba300-196">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
 [!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]  
  
 <span data-ttu-id="ba300-197">Bildirilen bir koleksiyon türü ise seri durumundan çıkarma işleminde gerçekten gönderilip gönderilmediğini türü ne olursa olsun türü örneği.</span><span class="sxs-lookup"><span data-stu-id="ba300-197">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="ba300-198">Bildirilen koleksiyonu arabirimi ise, bilinen türler için hiçbir şekilde ile örneğinin oluşturulması için bir türü seri durumdan çıkarıcının seçer.</span><span class="sxs-lookup"><span data-stu-id="ba300-198">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>  
  
 <span data-ttu-id="ba300-199">Ayrıca seri durumundan çıkarma işleminde türü koleksiyon türü değil, ancak bir koleksiyon türü gönderilen, eşleşen bir koleksiyon türü bilinen türleri listesi dışında çekilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-199">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="ba300-200">Koleksiyon arabirimi türleri seri durumdan çıkarma işleminde bilinen türleri listesine eklemek mümkündür.</span><span class="sxs-lookup"><span data-stu-id="ba300-200">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="ba300-201">Bu durumda, seri durumdan çıkarma altyapısı yeniden örneğinin oluşturulması için türünü seçer.</span><span class="sxs-lookup"><span data-stu-id="ba300-201">In this case, the deserialization engine again picks a type to be instantiated.</span></span>  
  
## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="ba300-202">Koleksiyonlar ve NetDataContractSerializer sınıfı</span><span class="sxs-lookup"><span data-stu-id="ba300-202">Collections and the NetDataContractSerializer Class</span></span>  
 <span data-ttu-id="ba300-203">Zaman <xref:System.Runtime.Serialization.NetDataContractSerializer> sınıfı kullanılıyor, özelleştirilmiş koleksiyon türleri (olmadan <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliği) olan değil diziler kaybeder, kendi özel bir anlamı.</span><span class="sxs-lookup"><span data-stu-id="ba300-203">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>  
  
 <span data-ttu-id="ba300-204">İle işaretli olmayan özelleştirilmiş koleksiyon türleri <xref:System.SerializableAttribute> özniteliği hala hale getirilebilir tarafından <xref:System.Runtime.Serialization.NetDataContractSerializer> göre sınıf <xref:System.SerializableAttribute> özniteliği veya <xref:System.Runtime.Serialization.ISerializable> arabirim kuralları.</span><span class="sxs-lookup"><span data-stu-id="ba300-204">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>  
  
 <span data-ttu-id="ba300-205">Özelleştirilmiş koleksiyon türleri, koleksiyon arabirimleri ve diziler hala kabul edilir koleksiyon olarak ayarlansa bile <xref:System.Runtime.Serialization.NetDataContractSerializer> sınıfı kullanılıyor.</span><span class="sxs-lookup"><span data-stu-id="ba300-205">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>  
  
## <a name="collections-and-schema"></a><span data-ttu-id="ba300-206">Koleksiyonlar ve şema</span><span class="sxs-lookup"><span data-stu-id="ba300-206">Collections and Schema</span></span>  
 <span data-ttu-id="ba300-207">Tüm eşdeğer koleksiyonları aynı gösterimi XML Şeması Tanım Dili (XSD) şemasında sahiptir.</span><span class="sxs-lookup"><span data-stu-id="ba300-207">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="ba300-208">Bu nedenle, normalde aynı koleksiyon türü oluşturulan istemci kodu sunucuda olarak aldığınız değil.</span><span class="sxs-lookup"><span data-stu-id="ba300-208">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="ba300-209">Örneğin, bir veri sözleşmesi ile genel sunucu kullanabilir <xref:System.Collections.Generic.List%601> tamsayı veri üyesi, ancak oluşturulan istemci kodu aynı veri üyesi dizisi duruma gelebilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-209">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>  
  
 <span data-ttu-id="ba300-210">Sözlük koleksiyonları ile işaretlenmiş bir [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-belirtmek belirli Şeması ek açıklama sözlükler oldukları; Aksi halde, bir anahtar ve değer girişleri basit listelerinden ayırt.</span><span class="sxs-lookup"><span data-stu-id="ba300-210">Dictionary collections are marked with a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="ba300-211">Veri sözleşmesi şema içinde koleksiyonları nasıl temsil edildiğini bir tam açıklama için bkz: [veri sözleşmesi şema başvurusu](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="ba300-211">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>  
  
 <span data-ttu-id="ba300-212">Varsayılan olarak, özelleştirilmiş olmayan koleksiyonları içeri aktarılan kodda türleri oluşturulmaz.</span><span class="sxs-lookup"><span data-stu-id="ba300-212">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="ba300-213">Veri üyeleri liste koleksiyon türleri dizileri olarak içe aktarılır ve sözlük koleksiyon türleri veri üyeleri genel bir sözlük aktarılır.</span><span class="sxs-lookup"><span data-stu-id="ba300-213">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>  
  
 <span data-ttu-id="ba300-214">Ancak, özelleştirilmiş koleksiyonlar için ayrı türleri, işaretlenmiş oluşturulan <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliği.</span><span class="sxs-lookup"><span data-stu-id="ba300-214">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="ba300-215">(Varsayılan ad alanı adı, yinelenen öğe adı veya anahtar/değer kullanmayan şemada özelleştirilmiş koleksiyon türü biridir öğe adları.) Bu tür genel türetilen boş türleridir <xref:System.Collections.Generic.List%601> liste türleri ve sözlük türleri için genel bir sözlük.</span><span class="sxs-lookup"><span data-stu-id="ba300-215">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>  
  
 <span data-ttu-id="ba300-216">Örneğin, aşağıdaki türlerden sunucuda olabilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-216">For example, you may have the following types on the server.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
 [!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]  
  
 <span data-ttu-id="ba300-217">Ne zaman şemayı dışarı ve içeri aktarılan geri yeniden oluşturulan istemci kodu aşağıdakine benzer (Okuma Kolaylığı için özellikleri yerine alanları gösterilir).</span><span class="sxs-lookup"><span data-stu-id="ba300-217">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
 [!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]  
  
 <span data-ttu-id="ba300-218">Oluşturulan kod olanları varsayılandan farklı kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ba300-218">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="ba300-219">Örneğin, genel kullanmak isteyebilirsiniz <xref:System.ComponentModel.BindingList%601> normal diziler için kullanıcı arabirimi bileşenlerini bağlamak kolaylaştırmak, veri üyeleri için yerine.</span><span class="sxs-lookup"><span data-stu-id="ba300-219">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>  
  
 <span data-ttu-id="ba300-220">İçine kullanmak istediğiniz koleksiyon türleri listesini oluşturmak için koleksiyon türleri seçin geçmesini <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> özelliği <xref:System.Runtime.Serialization.ImportOptions> şema içe aktarma sırasında nesne.</span><span class="sxs-lookup"><span data-stu-id="ba300-220">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="ba300-221">Bu tür adlı *koleksiyon türleri başvurulan*.</span><span class="sxs-lookup"><span data-stu-id="ba300-221">These types are called *referenced collection types*.</span></span>  
  
 <span data-ttu-id="ba300-222">Genel türler başvurulan olduğunda ya da tam olarak açık genel türler veya genel türler tamamen kapalı olmaları gerekir.</span><span class="sxs-lookup"><span data-stu-id="ba300-222">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba300-223">Svcutil.exe aracını kullanırken, bu başvuru kullanılarak gerçekleştirilebilir **/collectionType** komut satırı anahtarını (kısa form: **/ct**).</span><span class="sxs-lookup"><span data-stu-id="ba300-223">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="ba300-224">Derleme kullanarak başvurulan koleksiyon türleri için de belirtmeniz gerekir göz önünde bulundurmanız **/reference** geçiş (kısa form: **/r**).</span><span class="sxs-lookup"><span data-stu-id="ba300-224">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="ba300-225">Tür genel ise, geri teklif ve genel parametre sayısı tarafından izlenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="ba300-225">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="ba300-226">Geri (') tek tırnak işareti (') karakteri ile karıştırılmamalıdır tekliftir.</span><span class="sxs-lookup"><span data-stu-id="ba300-226">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="ba300-227">Kullanarak birden çok başvurulan koleksiyon türleri belirtebilirsiniz **/collectionType** birden çok kez geçin.</span><span class="sxs-lookup"><span data-stu-id="ba300-227">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>  
  
 <span data-ttu-id="ba300-228">Örneğin, genel içeri aktarılacak tüm listeleri neden <xref:System.Collections.Generic.List%601>.</span><span class="sxs-lookup"><span data-stu-id="ba300-228">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>  
  
```  
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1  
```  
  
 <span data-ttu-id="ba300-229">Başvurulan koleksiyon türleri bu listesi herhangi bir koleksiyonu içeri aktarırken taranır ve en iyi eşleşen koleksiyon, bir veri türü (özelleştirilmiş olmayan koleksiyonları için) veya (özelleştirilmiş koleksiyonları için) türetilen bir taban türü olarak bulunması durumunda kullanılır.</span><span class="sxs-lookup"><span data-stu-id="ba300-229">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="ba300-230">Listeleri listeleri karşı eşleştirilir sırada sözlükler yalnızca sözlükler karşı eşleştirilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-230">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>  
  
 <span data-ttu-id="ba300-231">Örneğin, genel eklerseniz <xref:System.ComponentModel.BindingList%601> ve <xref:System.Collections.Hashtable> başvurulan türleri listesi için önceki örnekte oluşturulan istemci kodunu aşağıdakine benzer.</span><span class="sxs-lookup"><span data-stu-id="ba300-231">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
 [!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]  
  
 <span data-ttu-id="ba300-232">Koleksiyon arabirimi türleri, başvurulan koleksiyon türleri bir parçası olarak belirtebilirsiniz, ancak geçersiz koleksiyon türleri belirtilemez (olanları hiçbir gibi `Add` yöntemi veya ortak oluşturucu).</span><span class="sxs-lookup"><span data-stu-id="ba300-232">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>  
  
 <span data-ttu-id="ba300-233">Kapalı bir genel en iyi eşleşme olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-233">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="ba300-234">(Olmayan genel türleri olarak kabul edilir kapalı genel türler için eşdeğer `Object`).</span><span class="sxs-lookup"><span data-stu-id="ba300-234">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="ba300-235">Örneğin, genel türleri <xref:System.Collections.Generic.List%601> , <xref:System.DateTime>genel <xref:System.ComponentModel.BindingList%601> (açık genel), ve <xref:System.Collections.ArrayList> olan aşağıdaki başvurulan koleksiyon türleri oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="ba300-235">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
 [!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]  
  
 <span data-ttu-id="ba300-236">Liste koleksiyonlar için aşağıdaki tabloda yalnızca durumlarda desteklenir.</span><span class="sxs-lookup"><span data-stu-id="ba300-236">For list collections, only the cases in the following table are supported.</span></span>  
  
|<span data-ttu-id="ba300-237">Başvurulan türü</span><span class="sxs-lookup"><span data-stu-id="ba300-237">Referenced type</span></span>|<span data-ttu-id="ba300-238">Başvurulan türü tarafından uygulanan arabirimi</span><span class="sxs-lookup"><span data-stu-id="ba300-238">Interface implemented by referenced type</span></span>|<span data-ttu-id="ba300-239">Örnek</span><span class="sxs-lookup"><span data-stu-id="ba300-239">Example</span></span>|<span data-ttu-id="ba300-240">Tür kabul edilir:</span><span class="sxs-lookup"><span data-stu-id="ba300-240">Type treated as:</span></span>|  
|---------------------|----------------------------------------------|-------------|----------------------|  
|<span data-ttu-id="ba300-241">Genel olmayan ya da kapalı genel (parametreleri herhangi sayısı)</span><span class="sxs-lookup"><span data-stu-id="ba300-241">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="ba300-242">Non-genel</span><span class="sxs-lookup"><span data-stu-id="ba300-242">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="ba300-243">veya</span><span class="sxs-lookup"><span data-stu-id="ba300-243">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="ba300-244">Burada T =`int`</span><span class="sxs-lookup"><span data-stu-id="ba300-244">where T= `int`</span></span>|<span data-ttu-id="ba300-245">Genel olarak kapalı `Object` (örneğin, `IList<object>`)</span><span class="sxs-lookup"><span data-stu-id="ba300-245">Closed generic of `Object` (for example, `IList<object>`)</span></span>|  
|<span data-ttu-id="ba300-246">Genel olmayan ya da kapalı genel (mutlaka koleksiyon türü ile eşleşmiyor parametre herhangi sayısı)</span><span class="sxs-lookup"><span data-stu-id="ba300-246">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="ba300-247">Genel kapalı</span><span class="sxs-lookup"><span data-stu-id="ba300-247">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="ba300-248">veya</span><span class="sxs-lookup"><span data-stu-id="ba300-248">or</span></span><br /><br /> <span data-ttu-id="ba300-249">`MyType<T> : IList<string>`Burada T =`int`</span><span class="sxs-lookup"><span data-stu-id="ba300-249">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="ba300-250">Kapalı genel (örneğin, `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="ba300-250">Closed generic (for example, `IList<string>`)</span></span>|  
|<span data-ttu-id="ba300-251">Herhangi bir sayıda parametreyle genel kapalı</span><span class="sxs-lookup"><span data-stu-id="ba300-251">Closed generic with any number of parameters</span></span>|<span data-ttu-id="ba300-252">Açık genel tür parametreleri herhangi birini kullanarak</span><span class="sxs-lookup"><span data-stu-id="ba300-252">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="ba300-253">Burada T =`int`, U =`string`, V =`bool`</span><span class="sxs-lookup"><span data-stu-id="ba300-253">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="ba300-254">Kapalı genel (örneğin, `IList<string>`)</span><span class="sxs-lookup"><span data-stu-id="ba300-254">Closed generic (for example, `IList<string>`)</span></span>|  
|<span data-ttu-id="ba300-255">Açık genel bir parametre ile</span><span class="sxs-lookup"><span data-stu-id="ba300-255">Open generic with one parameter</span></span>|<span data-ttu-id="ba300-256">Açık genel tür parametresi kullanılarak</span><span class="sxs-lookup"><span data-stu-id="ba300-256">Open generic using the type’s parameter</span></span>|<span data-ttu-id="ba300-257">`MyType<T> : IList<T>`, T, açık</span><span class="sxs-lookup"><span data-stu-id="ba300-257">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="ba300-258">Açık genel (örneğin, `IList<T>`)</span><span class="sxs-lookup"><span data-stu-id="ba300-258">Open generic (for example, `IList<T>`)</span></span>|  
  
 <span data-ttu-id="ba300-259">Bir türü birden fazla liste koleksiyonu arabirimini uygulayan durumunda aşağıdaki kısıtlamalar geçerlidir:</span><span class="sxs-lookup"><span data-stu-id="ba300-259">If a type implements more than one list collection interface, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="ba300-260">Genel tür uyguluyorsa <xref:System.Collections.Generic.IEnumerable%601> (veya türetilmiş arabirimlerinden) türü birden çok kez farklı türleri için geçerli başvurulan koleksiyon türü olarak kabul edilmez ve yok sayılır.</span><span class="sxs-lookup"><span data-stu-id="ba300-260">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="ba300-261">Bazı uygulamaları geçersiz veya açık genel türler kullanın olsa bile bu geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="ba300-261">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="ba300-262">Örneğin, genel uygulayan bir tür <xref:System.Collections.Generic.IEnumerable%601> , `int` ve genel <xref:System.Collections.Generic.IEnumerable%601> T hiçbir zaman başvurulan koleksiyonu olarak kullanılacak `int` veya türü olup bağımsız olarak herhangi bir türü, bir `Add` kabul yöntemi `int` veya bir `Add` T ya da her ikisini de parametre olarak kabul yöntemi yazın.</span><span class="sxs-lookup"><span data-stu-id="ba300-262">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>  
  
-   <span data-ttu-id="ba300-263">Türü bir genel koleksiyon arabirimi uyguluyorsa yanı <xref:System.Collections.IList>, genel koleksiyon arabirim türünün kapalı bir genel olmadıkça türü hiçbir zaman başvurulan koleksiyon türü olarak kullanılan <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="ba300-263">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="ba300-264">Sözlük koleksiyonlar için aşağıdaki tabloda yalnızca durumlarda desteklenir.</span><span class="sxs-lookup"><span data-stu-id="ba300-264">For dictionary collections, only the cases in the following table are supported.</span></span>  
  
|<span data-ttu-id="ba300-265">Başvurulan türü</span><span class="sxs-lookup"><span data-stu-id="ba300-265">Referenced type</span></span>|<span data-ttu-id="ba300-266">Başvurulan türü tarafından uygulanan arabirimi</span><span class="sxs-lookup"><span data-stu-id="ba300-266">Interface implemented by referenced type</span></span>|<span data-ttu-id="ba300-267">Örnek</span><span class="sxs-lookup"><span data-stu-id="ba300-267">Example</span></span>|<span data-ttu-id="ba300-268">Kabul türü</span><span class="sxs-lookup"><span data-stu-id="ba300-268">Type treated as</span></span>|  
|---------------------|----------------------------------------------|-------------|---------------------|  
|<span data-ttu-id="ba300-269">Genel olmayan ya da kapalı genel (parametreleri herhangi sayısı)</span><span class="sxs-lookup"><span data-stu-id="ba300-269">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="ba300-270">veya</span><span class="sxs-lookup"><span data-stu-id="ba300-270">or</span></span><br /><br /> <span data-ttu-id="ba300-271">`MyType<T> : IDictionary`Burada T =`int`</span><span class="sxs-lookup"><span data-stu-id="ba300-271">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="ba300-272">Genel kapalı`IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="ba300-272">Closed generic `IDictionary<object,object>`</span></span>|  
|<span data-ttu-id="ba300-273">Kapalı genel (parametreleri herhangi sayısı)</span><span class="sxs-lookup"><span data-stu-id="ba300-273">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="ba300-274"><xref:System.Collections.Generic.IDictionary%602>, kapalı</span><span class="sxs-lookup"><span data-stu-id="ba300-274"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="ba300-275">`MyType<T> : IDictionary\<string, bool>`Burada T =`int`</span><span class="sxs-lookup"><span data-stu-id="ba300-275">`MyType<T> : IDictionary\<string, bool>` where T=`int`</span></span>|<span data-ttu-id="ba300-276">Kapalı genel (örneğin, `IDIctionary\<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="ba300-276">Closed generic (for example, `IDIctionary\<string,bool>`)</span></span>|  
|<span data-ttu-id="ba300-277">Kapalı genel (parametreleri herhangi sayısı)</span><span class="sxs-lookup"><span data-stu-id="ba300-277">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="ba300-278">Genel <xref:System.Collections.Generic.IDictionary%602>, bir anahtar veya değer kapalı, diğer açık olduğundan ve tür parametrelerden birini kullanır</span><span class="sxs-lookup"><span data-stu-id="ba300-278">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="ba300-279">`MyType\<T,U,V> : IDictionary\<string,V>`Burada T =`int`, U =`float`, V =`bool`</span><span class="sxs-lookup"><span data-stu-id="ba300-279">`MyType\<T,U,V> : IDictionary\<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="ba300-280">veya</span><span class="sxs-lookup"><span data-stu-id="ba300-280">or</span></span><br /><br /> <span data-ttu-id="ba300-281">`MyType<Z> : IDictionary\<Z,bool>`Burada Z =`string`</span><span class="sxs-lookup"><span data-stu-id="ba300-281">`MyType<Z> : IDictionary\<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="ba300-282">Kapalı genel (örneğin, `IDictionary\<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="ba300-282">Closed generic (For example, `IDictionary\<string,bool>`)</span></span>|  
|<span data-ttu-id="ba300-283">Kapalı genel (parametreleri herhangi sayısı)</span><span class="sxs-lookup"><span data-stu-id="ba300-283">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="ba300-284">Genel <xref:System.Collections.Generic.IDictionary%602>, anahtar ve değer açık ve her tür parametrelerden birini kullanır</span><span class="sxs-lookup"><span data-stu-id="ba300-284">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="ba300-285">`MyType\<T,U,V> : IDictionary\<V,U>`Burada T =`int`, U =`bool`, V =`string`</span><span class="sxs-lookup"><span data-stu-id="ba300-285">`MyType\<T,U,V> : IDictionary\<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="ba300-286">Kapalı genel (örneğin, `IDictionary\<string,bool>`)</span><span class="sxs-lookup"><span data-stu-id="ba300-286">Closed generic (for example, `IDictionary\<string,bool>`)</span></span>|  
|<span data-ttu-id="ba300-287">Açık genel (iki parametre)</span><span class="sxs-lookup"><span data-stu-id="ba300-287">Open generic (two parameters)</span></span>|<span data-ttu-id="ba300-288">Genel <xref:System.Collections.Generic.IDictionary%602>, açın, her iki tür genel parametreler göründükleri sırada kullanır</span><span class="sxs-lookup"><span data-stu-id="ba300-288">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="ba300-289">`MyType\<K,V> : IDictionary\<K,V>`, K ve V hem açın</span><span class="sxs-lookup"><span data-stu-id="ba300-289">`MyType\<K,V> : IDictionary\<K,V>`, K and V both open</span></span>|<span data-ttu-id="ba300-290">Açık genel (örneğin, `IDictionary\<K,V>`)</span><span class="sxs-lookup"><span data-stu-id="ba300-290">Open generic (for example, `IDictionary\<K,V>`)</span></span>|  
  
 <span data-ttu-id="ba300-291">Türü hem de uyguluyorsa <xref:System.Collections.IDictionary> ve genel <xref:System.Collections.Generic.IDictionary%602>, yalnızca genel <xref:System.Collections.Generic.IDictionary%602> olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-291">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>  
  
 <span data-ttu-id="ba300-292">Kısmi genel türlerine başvurma desteklenmiyor.</span><span class="sxs-lookup"><span data-stu-id="ba300-292">Referencing partial generic types is not supported.</span></span>  
  
 <span data-ttu-id="ba300-293">Çoğaltmaları izin verilmez, örneğin, her iki genel ekleyemezsiniz <xref:System.Collections.Generic.List%601> , `Integer` ve genel koleksiyonunu `Integer` için <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, bu hangi tamsayı listesi yapılırken kullanılacak bulunması belirlemek mümkün kılar şemada.</span><span class="sxs-lookup"><span data-stu-id="ba300-293">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="ba300-294">Yalnızca yinelenen sorun gösteren şemada bir türü varsa yinelenenleri algılanır.</span><span class="sxs-lookup"><span data-stu-id="ba300-294">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="ba300-295">Alınan şema tamsayılar listesi içermiyorsa, örneğin, bu iki genel sağlamak için izin <xref:System.Collections.Generic.List%601> , `Integer` ve genel koleksiyonunu `Integer` içinde <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, ancak, herhangi bir etkisi olmaz.</span><span class="sxs-lookup"><span data-stu-id="ba300-295">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>  
  
## <a name="advanced-collection-rules"></a><span data-ttu-id="ba300-296">Gelişmiş toplama kuralları</span><span class="sxs-lookup"><span data-stu-id="ba300-296">Advanced Collection Rules</span></span>  
  
### <a name="serializing-collections"></a><span data-ttu-id="ba300-297">Seri hale getirilmesi</span><span class="sxs-lookup"><span data-stu-id="ba300-297">Serializing Collections</span></span>  
 <span data-ttu-id="ba300-298">Serileştirme için toplama kuralları listesi verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="ba300-298">The following is a list of collection rules for serialization:</span></span>  
  
-   <span data-ttu-id="ba300-299">Koleksiyon türleri (koleksiyonların koleksiyon sahip) birleştirerek izin verilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-299">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="ba300-300">Basit diziler koleksiyonların koleksiyon olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-300">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="ba300-301">Çok boyutlu diziler desteklenmiyor.</span><span class="sxs-lookup"><span data-stu-id="ba300-301">Multidimensional arrays are not supported.</span></span>  
  
-   <span data-ttu-id="ba300-302">Bayt ve dizilerin dizilerini <xref:System.Xml.XmlNode> değil koleksiyonları temel olarak davranılır özel dizi türleridir.</span><span class="sxs-lookup"><span data-stu-id="ba300-302">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="ba300-303">Her bayt için ayrı bir öğe yerine Base64 olarak kodlanmış veri yığınını içeren tek bir XML öğesi sonuçlarında bayt dizisi seri hale getirme.</span><span class="sxs-lookup"><span data-stu-id="ba300-303">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="ba300-304">bir dizi nasıl <xref:System.Xml.XmlNode> olduğu kabul edilir, bkz: [XML ve ADO.NET türleri veri sözleşmelerinde](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="ba300-304"> how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="ba300-305">Elbette, bu özel türleri kendilerini koleksiyonlarda katılabilir: bir dizi içeren her veri Base64 ile kodlanmış bir Öbek ile birden çok XML öğeleri sonuçlarında bayt dizisi.</span><span class="sxs-lookup"><span data-stu-id="ba300-305">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>  
  
-   <span data-ttu-id="ba300-306">Varsa <xref:System.Runtime.Serialization.DataContractAttribute> özniteliği bir koleksiyon türü uygulanır, türü normal veri sözleşmesi türü, bir koleksiyon olarak değil olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-306">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>  
  
-   <span data-ttu-id="ba300-307">Koleksiyon türü uyguluyorsa <xref:System.Xml.Serialization.IXmlSerializable> arabirimi, aşağıdaki kurallar geçerlidir, verilen bir türdeki `myType:IList<string>, IXmlSerializable`:</span><span class="sxs-lookup"><span data-stu-id="ba300-307">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>  
  
    -   <span data-ttu-id="ba300-308">Bildirilen türü ise `IList<string>`, türü bir liste olarak seri.</span><span class="sxs-lookup"><span data-stu-id="ba300-308">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>  
  
    -   <span data-ttu-id="ba300-309">Bildirilen türü ise `myType`, olarak serileştirilmiş `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="ba300-309">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>  
  
    -   <span data-ttu-id="ba300-310">Bildirilen türü ise `IXmlSerializable`, olarak serileştirilmiş `IXmlSerializable`, ancak yalnızca eklerseniz `myType` bilinen türleri listesi.</span><span class="sxs-lookup"><span data-stu-id="ba300-310">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>  
  
-   <span data-ttu-id="ba300-311">Koleksiyonlar, serileştirilen ve aşağıdaki tabloda gösterilen yöntem kullanılarak seri durumdan.</span><span class="sxs-lookup"><span data-stu-id="ba300-311">Collections are serialized and deserialized using the methods shown in the following table.</span></span>  
  
|<span data-ttu-id="ba300-312">Koleksiyon türü uygular</span><span class="sxs-lookup"><span data-stu-id="ba300-312">Collection type implements</span></span>|<span data-ttu-id="ba300-313">Yöntem serileştirme üzerinde çağrılır</span><span class="sxs-lookup"><span data-stu-id="ba300-313">Method(s) called on serialization</span></span>|<span data-ttu-id="ba300-314">Seri durumundan çıkarma işleminde adlı yöntemleri</span><span class="sxs-lookup"><span data-stu-id="ba300-314">Method(s) called on deserialization</span></span>|  
|--------------------------------|-----------------------------------------|-------------------------------------------|  
|<span data-ttu-id="ba300-315">Genel<xref:System.Collections.Generic.IDictionary%602></span><span class="sxs-lookup"><span data-stu-id="ba300-315">Generic <xref:System.Collections.Generic.IDictionary%602></span></span>|<span data-ttu-id="ba300-316">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="ba300-316">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="ba300-317">Genel ekleme</span><span class="sxs-lookup"><span data-stu-id="ba300-317">Generic Add</span></span>|  
|<xref:System.Collections.IDictionary>|<span data-ttu-id="ba300-318">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="ba300-318">`get_Keys`, `get_Values`</span></span>|`Add`|  
|<span data-ttu-id="ba300-319">Genel<xref:System.Collections.Generic.IList%601></span><span class="sxs-lookup"><span data-stu-id="ba300-319">Generic <xref:System.Collections.Generic.IList%601></span></span>|<span data-ttu-id="ba300-320">Genel <xref:System.Collections.Generic.IList%601> dizin oluşturucu</span><span class="sxs-lookup"><span data-stu-id="ba300-320">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="ba300-321">Genel ekleme</span><span class="sxs-lookup"><span data-stu-id="ba300-321">Generic Add</span></span>|  
|<span data-ttu-id="ba300-322">Genel<xref:System.Collections.Generic.ICollection%601></span><span class="sxs-lookup"><span data-stu-id="ba300-322">Generic <xref:System.Collections.Generic.ICollection%601></span></span>|<span data-ttu-id="ba300-323">Numaralandırıcı</span><span class="sxs-lookup"><span data-stu-id="ba300-323">Enumerator</span></span>|<span data-ttu-id="ba300-324">Genel ekleme</span><span class="sxs-lookup"><span data-stu-id="ba300-324">Generic Add</span></span>|  
|<xref:System.Collections.IList>|<span data-ttu-id="ba300-325"><xref:System.Collections.IList>Dizin Oluşturucu</span><span class="sxs-lookup"><span data-stu-id="ba300-325"><xref:System.Collections.IList> Indexer</span></span>|`Add`|  
|<span data-ttu-id="ba300-326">Genel<xref:System.Collections.Generic.IEnumerable%601></span><span class="sxs-lookup"><span data-stu-id="ba300-326">Generic <xref:System.Collections.Generic.IEnumerable%601></span></span>|`GetEnumerator`|<span data-ttu-id="ba300-327">Statik olmayan yöntemi `Add` (genel parametre türü) veya temel türlerinden biri uygun türde bir parametre alır.</span><span class="sxs-lookup"><span data-stu-id="ba300-327">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="ba300-328">Bu tür bir yöntem bir koleksiyon türü seri hale getirme ve seri durumdan çıkarma sırasında bir koleksiyon olarak işlemek seri hale getirici için mevcut olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="ba300-328">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|  
|<span data-ttu-id="ba300-329"><xref:System.Collections.IEnumerable>(ve bu nedenle <xref:System.Collections.ICollection>, ondan türetilen)</span><span class="sxs-lookup"><span data-stu-id="ba300-329"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="ba300-330">Statik olmayan yöntemi `Add` türünde bir parametre alan `Object`.</span><span class="sxs-lookup"><span data-stu-id="ba300-330">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="ba300-331">Bu tür bir yöntem bir koleksiyon türü seri hale getirme ve seri durumdan çıkarma sırasında bir koleksiyon olarak işlemek seri hale getirici için mevcut olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="ba300-331">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|  
  
 <span data-ttu-id="ba300-332">Önceki tabloda azalan sırada öncelik koleksiyon arabirimleri listeler.</span><span class="sxs-lookup"><span data-stu-id="ba300-332">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="ba300-333">Bir türü hem de uyguluyorsa, örneğin, yani <xref:System.Collections.IList> ve genel <xref:System.Collections.Generic.IEnumerable%601>, koleksiyon serileştirilmiş ve göre seri <xref:System.Collections.IList> kuralları:</span><span class="sxs-lookup"><span data-stu-id="ba300-333">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>  
  
-   <span data-ttu-id="ba300-334">Seri durumdan çıkarma sırasında tüm koleksiyonlar ilk türünün bir örneği için bir koleksiyon türü seri hale getirme ve seri durumdan çıkarma sırasında bir koleksiyon olarak işlemek seri hale getirici mevcut olmalıdır varsayılan oluşturucu çağırarak oluşturarak serisi.</span><span class="sxs-lookup"><span data-stu-id="ba300-334">At deserialization, all collections are deserialized by first creating an instance of the type by calling the default constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>  
  
-   <span data-ttu-id="ba300-335">Aynı genel koleksiyon arabirimi birden çok kez uygulanmışsa (örneğin, bir tür hem genel uyguluyorsa <xref:System.Collections.Generic.ICollection%601> , `Integer` ve genel <xref:System.Collections.Generic.ICollection%601> , <xref:System.String>) ve daha yüksek önceliği arabirim bulundu, koleksiyonu Geçerli bir koleksiyon olarak kabul değil.</span><span class="sxs-lookup"><span data-stu-id="ba300-335">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>  
  
-   <span data-ttu-id="ba300-336">Koleksiyon türleri olabilir <xref:System.SerializableAttribute> özniteliği uygulanmış ve uygulayabilirsiniz <xref:System.Runtime.Serialization.ISerializable> arabirimi.</span><span class="sxs-lookup"><span data-stu-id="ba300-336">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="ba300-337">Bunların her ikisi de göz ardı edilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-337">Both of these are ignored.</span></span> <span data-ttu-id="ba300-338">Ancak, türü tam olarak koleksiyon türü gereksinimlerini karşılamıyor varsa (örneğin, `Add` yöntemi eksik), türü bir koleksiyon türü olarak kabul edilmez ve bu nedenle <xref:System.SerializableAttribute> özniteliği ve <xref:System.Runtime.Serialization.ISerializable> arabirimi belirlemek için kullanılır türü seri hale getirilebilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-338">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>  
  
-   <span data-ttu-id="ba300-339">Uygulama <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliği kaldırır özelleştirmek için bir koleksiyona <xref:System.SerializableAttribute> geri dönüş mekanizması önceki.</span><span class="sxs-lookup"><span data-stu-id="ba300-339">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="ba300-340">Bunun yerine, özelleştirilmiş bir koleksiyon değil karşılayan koleksiyonu gereksinimleri çalışamazsa mu bir <xref:System.Runtime.Serialization.InvalidDataContractException> özel durumu oluşur.</span><span class="sxs-lookup"><span data-stu-id="ba300-340">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="ba300-341">Özel durum dizesi genellikle neden belirli bir türde geçerli bir koleksiyon olarak kabul edilmez açıklayan bilgi içerir (hiçbir `Add` yöntemi, varsayılan oluşturucu yok vb.), genellikle uygulamak yararlı olacak şekilde <xref:System.Runtime.Serialization.CollectionDataContractAttribute> hata ayıklama amacıyla özniteliği.</span><span class="sxs-lookup"><span data-stu-id="ba300-341">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no default constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>  
  
### <a name="collection-naming"></a><span data-ttu-id="ba300-342">Koleksiyon adlandırma</span><span class="sxs-lookup"><span data-stu-id="ba300-342">Collection Naming</span></span>  
 <span data-ttu-id="ba300-343">Koleksiyon adlandırma kurallarının bir listesi verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="ba300-343">The following is a list of collection naming rules:</span></span>  
  
-   <span data-ttu-id="ba300-344">İlkel türler içeren liste koleksiyonu veri sözleşmeleri yanı sıra, tüm sözlük koleksiyonu veri sözleşmeleri için varsayılan ad, Namespace kullanılarak geçersiz kılınmadığı sürece http://schemas.microsoft.com/2003/10/Serialization/Arrays alanıdır.</span><span class="sxs-lookup"><span data-stu-id="ba300-344">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is http://schemas.microsoft.com/2003/10/Serialization/Arrays unless overridden using Namespace.</span></span> <span data-ttu-id="ba300-345">Yerleşik XSD türlerine eşlenir türleri yanı `char`, `Timespan`, ve `Guid` türleri, bu amaçla temelleri değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-345">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>  
  
-   <span data-ttu-id="ba300-346">Namespace, kullanarak kılınmadığı sürece, olmayan ilkel türler içeren koleksiyon türleri için varsayılan ad alanını veri sözleşmesi türünün ad alanını derlemesinde ile aynıdır.</span><span class="sxs-lookup"><span data-stu-id="ba300-346">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>  
  
-   <span data-ttu-id="ba300-347">Liste koleksiyonu veri sözleşmeleri için varsayılan adı adını kullanarak geçersiz kılınmadığı sürece derlemesinde türü veri sözleşme adı "ArrayOf" birlikte dizedir.</span><span class="sxs-lookup"><span data-stu-id="ba300-347">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="ba300-348">Örneğin, veri sözleşmesi genel olarak tamsayılar listesi "ArrayOfint" adıdır.</span><span class="sxs-lookup"><span data-stu-id="ba300-348">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="ba300-349">Adını veri sözleşmesi göz önünde bulundurmanız `Object` genel olmayan listeleri veri sözleşmesi adını ister "anyType" olduğundan <xref:System.Collections.ArrayList> "ArrayOfanyType" değil.</span><span class="sxs-lookup"><span data-stu-id="ba300-349">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>  
  
 <span data-ttu-id="ba300-350">Sözlük koleksiyonu veriler için varsayılan ad sözleşmeler, kullanarak geçersiz kılınmadığı sürece `Name`, "ArrayOfKeyValueOf" birleştirilmiş değer türü veri sözleşmesi adını yazarak ve ardından anahtar türü veri sözleşme adı dizesi.</span><span class="sxs-lookup"><span data-stu-id="ba300-350">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="ba300-351">Örneğin, veri sözleşmesi adı bir dize genel bir sözlük ve tamsayı olan "ArrayOfKeyValueOfstringint".</span><span class="sxs-lookup"><span data-stu-id="ba300-351">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="ba300-352">Ayrıca, anahtar veya değer türleri ilkel türler emin değilseniz, anahtar ve değer türleri veri sözleşmesi ad alanları bir ad alanı karma ada eklenir.</span><span class="sxs-lookup"><span data-stu-id="ba300-352">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="ba300-353">ad alanı karmaları bkz [veri sözleşmesi adları](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="ba300-353"> namespace hashes, see [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md).</span></span>  
  
 <span data-ttu-id="ba300-354">Her sözlük koleksiyon veri sözleşmesi sözlükteki bir girişini temsil eden bir yardımcı veri sözleşmesi sahiptir.</span><span class="sxs-lookup"><span data-stu-id="ba300-354">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="ba300-355">Adı "ArrayOf" öneki dışında sözlük veri sözleşmesi ile aynıdır ve kendi ad sözlük veri sözleşmesi ile aynıdır.</span><span class="sxs-lookup"><span data-stu-id="ba300-355">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="ba300-356">Örneğin, "ArrayOfKeyValueOfstringint" sözlük veri sözleşmesi için bir giriş sözlükteki "KeyValueofstringint" veri sözleşmesi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="ba300-356">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="ba300-357">Bu veri sözleşmesi adını kullanarak özelleştirebileceğiniz `ItemName` sonraki bölümde açıklandığı gibi özelliği.</span><span class="sxs-lookup"><span data-stu-id="ba300-357">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>  
  
 <span data-ttu-id="ba300-358">Genel tür adlandırma kuralları bölümünde açıklandığı gibi [veri sözleşmesi adları](../../../../docs/framework/wcf/feature-details/data-contract-names.md)olan koleksiyon türleri için; tam olarak uygulamak, ad içinde süslü ayraçlar genel tür parametreleri belirtmek için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ba300-358">Generic type naming rules, as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="ba300-359">Ancak, küme ayraçları içinde numaraları genel parametreler ve koleksiyonundaki türleri bakın.</span><span class="sxs-lookup"><span data-stu-id="ba300-359">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>  
  
## <a name="collection-customization"></a><span data-ttu-id="ba300-360">Koleksiyon özelleştirme</span><span class="sxs-lookup"><span data-stu-id="ba300-360">Collection Customization</span></span>  
 <span data-ttu-id="ba300-361">Aşağıdaki kullanır <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliği yasaklanmış olduğuna ve neden bir <xref:System.Runtime.Serialization.InvalidDataContractException> özel durum:</span><span class="sxs-lookup"><span data-stu-id="ba300-361">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>  
  
-   <span data-ttu-id="ba300-362">Uygulama <xref:System.Runtime.Serialization.DataContractAttribute> bir türün özniteliği <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliği uygulanan, veya türetilmiş türlerinden biri için açıldı.</span><span class="sxs-lookup"><span data-stu-id="ba300-362">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>  
  
-   <span data-ttu-id="ba300-363">Uygulama <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliği uygulayan bir tür <xref:System.Xml.Serialization.IXmlSerializable> arabirimi.</span><span class="sxs-lookup"><span data-stu-id="ba300-363">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>  
  
-   <span data-ttu-id="ba300-364">Uygulama <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliği bir koleksiyon olmayan tür.</span><span class="sxs-lookup"><span data-stu-id="ba300-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>  
  
-   <span data-ttu-id="ba300-365">Ayarlama girişimi <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> veya <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> üzerinde bir <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliği için bir sözlük olmayan türü uygulanmıştır.</span><span class="sxs-lookup"><span data-stu-id="ba300-365">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>  
  
### <a name="polymorphism-rules"></a><span data-ttu-id="ba300-366">Çok biçimlilik kuralları</span><span class="sxs-lookup"><span data-stu-id="ba300-366">Polymorphism Rules</span></span>  
 <span data-ttu-id="ba300-367">Daha önce belirtildiği, koleksiyonlar kullanarak özelleştirme <xref:System.Runtime.Serialization.CollectionDataContractAttribute> öznitelik koleksiyonu interchangeability ile engel.</span><span class="sxs-lookup"><span data-stu-id="ba300-367">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="ba300-368">İki özelleştirilmiş koleksiyon türleri yalnızca kendi ad, ad alanı, öğe adı yanı sıra (bunlar sözlük koleksiyonları varsa) anahtar ve değer adlarını eşleşiyorsa eşdeğer kabul edilebilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-368">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>  
  
 <span data-ttu-id="ba300-369">Özelleştirmeler nedeniyle, başka bir beklenirken yanlışlıkla kullanımı bir koleksiyon veri sözleşmesi için mümkündür.</span><span class="sxs-lookup"><span data-stu-id="ba300-369">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="ba300-370">Bu kaçınılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ba300-370">This should be avoided.</span></span> <span data-ttu-id="ba300-371">Aşağıdaki türleri bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="ba300-371">See the following types.</span></span>  
  
 [!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
 [!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]  
  
 <span data-ttu-id="ba300-372">Bu durumda örneğindeki `Marks1` atanabilir `testMarks`.</span><span class="sxs-lookup"><span data-stu-id="ba300-372">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="ba300-373">Ancak, `Marks2` veri sözleşmesi eşdeğer olarak kabul edilmez çünkü kullanılmamalıdır `IList<int>` veri sözleşme.</span><span class="sxs-lookup"><span data-stu-id="ba300-373">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="ba300-374">Veri sözleşmesi adı "Marks2" değil "ArrayOfint" ise ve yinelenen öğe adı "\<işaretlemek >" ve "\<int >".</span><span class="sxs-lookup"><span data-stu-id="ba300-374">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>  
  
 <span data-ttu-id="ba300-375">Aşağıdaki tabloda kurallar koleksiyonları biçimli atama için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="ba300-375">The rules in the following table apply to polymorphic assignment of collections.</span></span>  
  
|<span data-ttu-id="ba300-376">Bildirilen türü</span><span class="sxs-lookup"><span data-stu-id="ba300-376">Declared type</span></span>|<span data-ttu-id="ba300-377">Özelleştirilmiş olmayan bir toplama atama</span><span class="sxs-lookup"><span data-stu-id="ba300-377">Assigning a non-customized collection</span></span>|<span data-ttu-id="ba300-378">Özelleştirilmiş bir koleksiyon atama</span><span class="sxs-lookup"><span data-stu-id="ba300-378">Assigning a customized collection</span></span>|  
|-------------------|--------------------------------------------|---------------------------------------|  
|<span data-ttu-id="ba300-379">Nesne</span><span class="sxs-lookup"><span data-stu-id="ba300-379">Object</span></span>|<span data-ttu-id="ba300-380">Sözleşme adı serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-380">Contract name is serialized.</span></span>|<span data-ttu-id="ba300-381">Sözleşme adı serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-381">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="ba300-382">Özelleştirme kullanılır.</span><span class="sxs-lookup"><span data-stu-id="ba300-382">Customization is used.</span></span>|  
|<span data-ttu-id="ba300-383">Koleksiyon arabirimi</span><span class="sxs-lookup"><span data-stu-id="ba300-383">Collection interface</span></span>|<span data-ttu-id="ba300-384">Sözleşme adı serileştirilmemiş.</span><span class="sxs-lookup"><span data-stu-id="ba300-384">Contract name is not serialized.</span></span>|<span data-ttu-id="ba300-385">Sözleşme adı serileştirilmemiş.</span><span class="sxs-lookup"><span data-stu-id="ba300-385">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="ba300-386">Özelleştirme used.* değil</span><span class="sxs-lookup"><span data-stu-id="ba300-386">Customization is not used.*</span></span>|  
|<span data-ttu-id="ba300-387">Koleksiyon olmayan özelleştirilmiş</span><span class="sxs-lookup"><span data-stu-id="ba300-387">Non-customized collection</span></span>|<span data-ttu-id="ba300-388">Sözleşme adı serileştirilmemiş.</span><span class="sxs-lookup"><span data-stu-id="ba300-388">Contract name is not serialized.</span></span>|<span data-ttu-id="ba300-389">Sözleşme adı serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-389">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="ba300-390">Özelleştirme used.* * bulunur</span><span class="sxs-lookup"><span data-stu-id="ba300-390">Customization is used.**</span></span>|  
|<span data-ttu-id="ba300-391">Özelleştirilmiş koleksiyonu</span><span class="sxs-lookup"><span data-stu-id="ba300-391">Customized collection</span></span>|<span data-ttu-id="ba300-392">Sözleşme adı serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-392">Contract name is serialized.</span></span> <span data-ttu-id="ba300-393">Özelleştirme used.* * değil</span><span class="sxs-lookup"><span data-stu-id="ba300-393">Customization is not used.**</span></span>|<span data-ttu-id="ba300-394">Sözleşme adı serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-394">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="ba300-395">Atanan türü özelleştirme used.* * bulunur</span><span class="sxs-lookup"><span data-stu-id="ba300-395">Customization of the assigned type is used.**</span></span>|  
  
 <span data-ttu-id="ba300-396">* İle <xref:System.Runtime.Serialization.NetDataContractSerializer> sınıfı, özelleştirme, bu durumda kullanılır.</span><span class="sxs-lookup"><span data-stu-id="ba300-396">*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="ba300-397"><xref:System.Runtime.Serialization.NetDataContractSerializer> Sınıfı ayrıca serileştiren gerçek tür adı bu durumda, bu nedenle beklendiği gibi çalıştığını seri durumundan çıkarma.</span><span class="sxs-lookup"><span data-stu-id="ba300-397">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>  
  
 <span data-ttu-id="ba300-398">** Bu gibi durumlarda şema geçersiz durumlarda neden ve bu nedenle kaçınılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ba300-398">**These cases result in schema-invalid instances and thus should be avoided.</span></span>  
  
 <span data-ttu-id="ba300-399">Sözleşme adı burada seri durumda atanan koleksiyon türü bilinen türleri listesinde olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ba300-399">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="ba300-400">Bunun tersi de geçerlidir: Burada adı sıralanmış değildir durumlarda türü bilinen türleri listesine ekleme gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="ba300-400">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>  
  
 <span data-ttu-id="ba300-401">Bir dizi türetilmiş bir tür için bir taban türü dizisi atanabilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-401">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="ba300-402">Bu durumda, türetilmiş bir tür sözleşme adı yinelenen her öğe için serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="ba300-402">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="ba300-403">Örneğin, bir tür değilse `Book` türünden `LibraryItem`, bir dizi atayabilirsiniz `Book` dizisi olarak `LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="ba300-403">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="ba300-404">Bu diğer koleksiyon türleri için geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="ba300-404">This does not apply to other collection types.</span></span> <span data-ttu-id="ba300-405">Örneğin, atayamazsınız bir `Generic List of Book` için bir `Generic List of LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="ba300-405">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="ba300-406">Ancak, atamak için bir `Generic List of LibraryItem` içeren `Book` örnekleri.</span><span class="sxs-lookup"><span data-stu-id="ba300-406">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="ba300-407">Dizi ve dizi olmayan durumda `Book` bilinen türleri listesinde olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ba300-407">In both the array and the non-array case, `Book` should be in the known types list.</span></span>  
  
## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="ba300-408">Koleksiyonlar ve nesne başvurusu koruma</span><span class="sxs-lookup"><span data-stu-id="ba300-408">Collections and Object Reference Preservation</span></span>  
 <span data-ttu-id="ba300-409">Seri hale getirici işlevleri, burada nesne başvuruları korur modunda nesne başvurusu korunması koleksiyonlar için de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="ba300-409">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="ba300-410">Özellikle, nesne kimliği, tüm koleksiyonlar ve koleksiyonlarında bulunan bireysel öğeleri korunur.</span><span class="sxs-lookup"><span data-stu-id="ba300-410">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="ba300-411">Sözlük için nesne kimliği hem de anahtar/değer çifti nesneleri ve ayrı anahtar ve değer nesneleri korunur.</span><span class="sxs-lookup"><span data-stu-id="ba300-411">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ba300-412">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="ba300-412">See Also</span></span>  
 <xref:System.Runtime.Serialization.CollectionDataContractAttribute>

---
title: Eşitleme Temellerine Genel Bakış
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET Framework],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 37abcb6b3a8fdf4ef91d5e946a97db7ca1428ce8
ms.sourcegitcommit: a885cc8c3e444ca6471348893d5373c6e9e49a47
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/06/2018
ms.locfileid: "43884347"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="995b4-102">Eşitleme Temellerine Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="995b4-102">Overview of Synchronization Primitives</span></span>
<a name="top"></a> <span data-ttu-id="995b4-103">.NET Framework eşitleme temellerine çeşitli iş parçacıklarının etkileşimler denetleme ve yarış durumları önleme sağlar.</span><span class="sxs-lookup"><span data-stu-id="995b4-103">The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions.</span></span> <span data-ttu-id="995b4-104">Bu kabaca üç kategoriye ayrılabilir: kilitleme, sinyal ve birbirine kenetlenmiş işlemler.</span><span class="sxs-lookup"><span data-stu-id="995b4-104">These can be roughly divided into three categories: locking, signaling, and interlocked operations.</span></span>  
  
 <span data-ttu-id="995b4-105">Kategorileri derleyin veya açıkça tanımlanmış değildir: Bazı eşitleme mekanizmaları birden çok kategori; özelliklerine sahip bir kerede tek bir iş parçacığı yayın olayları gibi işlevsel olarak kilitleri; herhangi bir kilidi sürümü, bir sinyal düşünülebilir; ve birbirine kenetlenmiş işlemler kilit oluşturmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="995b4-105">The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks.</span></span> <span data-ttu-id="995b4-106">Ancak, kategorileri hala faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="995b4-106">However, the categories are still useful.</span></span>  
  
 <span data-ttu-id="995b4-107">İş parçacığı eşitleme işbirlikçi olduğunu unutmamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="995b4-107">It is important to remember that thread synchronization is cooperative.</span></span> <span data-ttu-id="995b4-108">Tek iş parçacığı eşitleme mekanizması atlar ve doğrudan korumalı kaynağa erişir, bu eşitleme mekanizması etkin olamaz.</span><span class="sxs-lookup"><span data-stu-id="995b4-108">If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.</span></span>  
  
 <span data-ttu-id="995b4-109">Bu genel bakış aşağıdaki bölümleri içerir:</span><span class="sxs-lookup"><span data-stu-id="995b4-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="995b4-110">Kilitleme</span><span class="sxs-lookup"><span data-stu-id="995b4-110">Locking</span></span>](#locking)  
  
-   [<span data-ttu-id="995b4-111">Sinyal</span><span class="sxs-lookup"><span data-stu-id="995b4-111">Signaling</span></span>](#signaling)  
  
-   [<span data-ttu-id="995b4-112">Hafif eşitleme türleri</span><span class="sxs-lookup"><span data-stu-id="995b4-112">Lightweight Synchronization Types</span></span>](#lightweight_synchronization_types)  
  
-   [<span data-ttu-id="995b4-113">SpinWait</span><span class="sxs-lookup"><span data-stu-id="995b4-113">SpinWait</span></span>](#spinwait)  
  
-   [<span data-ttu-id="995b4-114">Birbirine Kenetlenmiş İşlemler</span><span class="sxs-lookup"><span data-stu-id="995b4-114">Interlocked Operations</span></span>](#interlocked_operations)  
  
<a name="locking"></a>   
## <a name="locking"></a><span data-ttu-id="995b4-115">Kilitleme</span><span class="sxs-lookup"><span data-stu-id="995b4-115">Locking</span></span>  
 <span data-ttu-id="995b4-116">Kilitleri, aynı anda tek bir iş parçacığı veya belirtilen bir iş parçacığı sayısı için bir kaynak denetim verir.</span><span class="sxs-lookup"><span data-stu-id="995b4-116">Locks give control of a resource to one thread at a time, or to a specified number of threads.</span></span> <span data-ttu-id="995b4-117">Kilit olduğunda, özel bir kilit isteyen bir iş parçacığı kilit kullanılabilir oluncaya kadar blokları kullanın.</span><span class="sxs-lookup"><span data-stu-id="995b4-117">A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.</span></span>  
  
### <a name="exclusive-locks"></a><span data-ttu-id="995b4-118">Özel kilit</span><span class="sxs-lookup"><span data-stu-id="995b4-118">Exclusive Locks</span></span>  
 <span data-ttu-id="995b4-119">Kilitleme en basit biçimidir `lock` C# deyimi ve `SyncLock` deyimi Visual Basic'te, bir kod bloğu erişimi denetler.</span><span class="sxs-lookup"><span data-stu-id="995b4-119">The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code.</span></span> <span data-ttu-id="995b4-120">Böyle bir blok, genellikle önemli bir bölümü da bilinir.</span><span class="sxs-lookup"><span data-stu-id="995b4-120">Such a block is frequently referred to as a critical section.</span></span> <span data-ttu-id="995b4-121">`lock` Deyimi kullanılarak gerçekleştirilen <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> ve <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> yöntemleri ve onu kullanan bir `try…finally` kilidi serbest bırakılır emin olmak için blok.</span><span class="sxs-lookup"><span data-stu-id="995b4-121">The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods, and it uses a `try…finally` block to ensure that the lock is released.</span></span>  
  
 <span data-ttu-id="995b4-122">Genel olarak, kullanarak `lock` veya `SyncLock` deyimi küçük kod, hiçbir zaman kapsayan birden fazla tek bir yöntem bloklarını korumak için kullanılacak en iyi yolu <xref:System.Threading.Monitor> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="995b4-122">In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="995b4-123">Güçlü ancak <xref:System.Threading.Monitor> sınıftır sahipsiz kilit ve kilitlenmeleri eğilimlidir.</span><span class="sxs-lookup"><span data-stu-id="995b4-123">Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks.</span></span>  
  
#### <a name="monitor-class"></a><span data-ttu-id="995b4-124">İzleme sınıfı</span><span class="sxs-lookup"><span data-stu-id="995b4-124">Monitor Class</span></span>  
 <span data-ttu-id="995b4-125"><xref:System.Threading.Monitor> Sınıfı ile birlikte kullanılan ek işlevsellik sağlar `lock` deyimi:</span><span class="sxs-lookup"><span data-stu-id="995b4-125">The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:</span></span>  
  
-   <span data-ttu-id="995b4-126"><xref:System.Threading.Monitor.TryEnter%2A> Yöntemi için belirtilen bir süre sonra vermek kaynak bekleyerek engellenen bir iş parçacığı sağlar.</span><span class="sxs-lookup"><span data-stu-id="995b4-126">The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval.</span></span> <span data-ttu-id="995b4-127">Başarı veya başarısızlık, algılamak ve olası kilitlenmeleri önlemek için kullanılabilecek gösteren bir Boole değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="995b4-127">It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.</span></span>  
  
-   <span data-ttu-id="995b4-128"><xref:System.Threading.Monitor.Wait%2A> Yöntemi bir iş parçacığı, kritik bölüm tarafından çağrılır.</span><span class="sxs-lookup"><span data-stu-id="995b4-128">The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section.</span></span> <span data-ttu-id="995b4-129">Kaynağı yeniden kullanılabilir olana kadar blokları ve kaynak denetimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="995b4-129">It gives up control of the resource and blocks until the resource is available again.</span></span>  
  
-   <span data-ttu-id="995b4-130"><xref:System.Threading.Monitor.Pulse%2A> Ve <xref:System.Threading.Monitor.PulseAll%2A> yöntemleri hakkında kilidi veya çağırmak için bir iş parçacığı izin <xref:System.Threading.Monitor.Wait%2A> kilidi almak hazır kuyruğa bir veya daha fazla iş parçacığı yerleştirmek için.</span><span class="sxs-lookup"><span data-stu-id="995b4-130">The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock.</span></span>  
  
 <span data-ttu-id="995b4-131">Zaman aşımlarını <xref:System.Threading.Monitor.Wait%2A> yöntemi aşırı yüklemeleri hazır kuyruğa atlamak bekleyen iş parçacıklarının izin verin.</span><span class="sxs-lookup"><span data-stu-id="995b4-131">Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue.</span></span>  
  
 <span data-ttu-id="995b4-132"><xref:System.Threading.Monitor> Sınıfı, birden çok uygulama etki alanlarında kilit için kullanılan nesne öğesinden türer, kilitleme sağlayabilir <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="995b4-132">The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
 <span data-ttu-id="995b4-133"><xref:System.Threading.Monitor> iş parçacığı benzeşimini sahiptir.</span><span class="sxs-lookup"><span data-stu-id="995b4-133"><xref:System.Threading.Monitor> has thread affinity.</span></span> <span data-ttu-id="995b4-134">Diğer bir deyişle, İzleyici girilen bir iş parçacığı çağırarak çıkmalı <xref:System.Threading.Monitor.Exit%2A> veya <xref:System.Threading.Monitor.Wait%2A>.</span><span class="sxs-lookup"><span data-stu-id="995b4-134">That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>.</span></span>  
  
 <span data-ttu-id="995b4-135"><xref:System.Threading.Monitor> Sınıf instantiable değil.</span><span class="sxs-lookup"><span data-stu-id="995b4-135">The <xref:System.Threading.Monitor> class is not instantiable.</span></span> <span data-ttu-id="995b4-136">Yöntemleri statik (`Shared` Visual Basic'te) ve instantiable kilit nesne üzerinde işlem yapma.</span><span class="sxs-lookup"><span data-stu-id="995b4-136">Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object.</span></span>  
  
 <span data-ttu-id="995b4-137">Kavramsal bir genel bakış için bkz. [izleyiciler](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span><span class="sxs-lookup"><span data-stu-id="995b4-137">For a conceptual overview, see [Monitors](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span></span>  
  
#### <a name="mutex-class"></a><span data-ttu-id="995b4-138">Mutex Sınıfı</span><span class="sxs-lookup"><span data-stu-id="995b4-138">Mutex Class</span></span>  
 <span data-ttu-id="995b4-139">İş parçacıkları isteği bir <xref:System.Threading.Mutex> bir aşırı yüklemesini çağırarak kendi <xref:System.Threading.WaitHandle.WaitOne%2A> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="995b4-139">Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="995b4-140">Aşırı yüklemeler zaman aşımı ile bekleme vermek iş parçacığı olanak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="995b4-140">Overloads with timeouts are provided, to allow threads to give up the wait.</span></span> <span data-ttu-id="995b4-141">Farklı <xref:System.Threading.Monitor> sınıfı, bir mutex yerel veya genel olabilir.</span><span class="sxs-lookup"><span data-stu-id="995b4-141">Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global.</span></span> <span data-ttu-id="995b4-142">Adlandırılmış mutex'leri olarak da bilinen genel mutex'leri boyunca işletim sistemi tarafından görülebilir ve birden çok uygulama etki alanları veya işlem iş parçacıklarının eşitlemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="995b4-142">Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes.</span></span> <span data-ttu-id="995b4-143">Yerel mutex'leri türetilen <xref:System.MarshalByRefObject>ve uygulama etki alanı sınırlarında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="995b4-143">Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="995b4-144">Ayrıca, <xref:System.Threading.Mutex> türetildiği <xref:System.Threading.WaitHandle>, yani bu sinyal tarafından sağlanan mekanizmaları ile kullanılabilir <xref:System.Threading.WaitHandle>, gibi <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, ve <xref:System.Threading.WaitHandle.SignalAndWait%2A> yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="995b4-144">In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods.</span></span>  
  
 <span data-ttu-id="995b4-145">Gibi <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> iş parçacığı benzeşimini sahiptir.</span><span class="sxs-lookup"><span data-stu-id="995b4-145">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity.</span></span> <span data-ttu-id="995b4-146">Farklı <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> instantiable bir nesnedir.</span><span class="sxs-lookup"><span data-stu-id="995b4-146">Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object.</span></span>  
  
 <span data-ttu-id="995b4-147">Kavramsal bir genel bakış için bkz. [mutex'ler](../../../docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="995b4-147">For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md).</span></span>  
  
#### <a name="spinlock-class"></a><span data-ttu-id="995b4-148">SpinLock sınıfı</span><span class="sxs-lookup"><span data-stu-id="995b4-148">SpinLock Class</span></span>  
 <span data-ttu-id="995b4-149">İle başlayarak [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], kullanabileceğiniz <xref:System.Threading.SpinLock> sınıf ek yükü tarafından istendiğinde <xref:System.Threading.Monitor> performansı düşürür.</span><span class="sxs-lookup"><span data-stu-id="995b4-149">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance.</span></span> <span data-ttu-id="995b4-150">Zaman <xref:System.Threading.SpinLock> kilitli kritik bölümü karşılaştığında kilit kullanılabilir oluncaya kadar yalnızca bir döngüde döner.</span><span class="sxs-lookup"><span data-stu-id="995b4-150">When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available.</span></span> <span data-ttu-id="995b4-151">Kilit çok kısa bir süre tutulursa, dönen engelleme daha iyi performans sağlar.</span><span class="sxs-lookup"><span data-stu-id="995b4-151">If the lock is held for a very short time, spinning can provide better performance than blocking.</span></span> <span data-ttu-id="995b4-152">Ancak, döngü, fazla sayıda onlarca kilidi açık tutulduğu <xref:System.Threading.SpinLock> ekleyebiliyorsa gerçekleştirir olarak <xref:System.Threading.Monitor>, ancak daha fazla CPU döngüsü kullanır ve bu nedenle diğer iş parçacıkları veya işlemlerdeki performansını düşürebilir.</span><span class="sxs-lookup"><span data-stu-id="995b4-152">However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.</span></span>  
  
### <a name="other-locks"></a><span data-ttu-id="995b4-153">Diğer kilitleri</span><span class="sxs-lookup"><span data-stu-id="995b4-153">Other Locks</span></span>  
 <span data-ttu-id="995b4-154">Kilitleri özel olması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="995b4-154">Locks need not be exclusive.</span></span> <span data-ttu-id="995b4-155">Genellikle, sınırlı sayıda iş parçacığının bir kaynağa eş zamanlı erişim izni vermek kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="995b4-155">It is often useful to allow a limited number of threads concurrent access to a resource.</span></span> <span data-ttu-id="995b4-156">Semafor ve Okuyucu-Yazıcı kilitleri, bu tür bir havuza alınmış kaynak erişimi denetlemek için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="995b4-156">Semaphores and reader-writer locks are designed to control this kind of pooled resource access.</span></span>  
  
#### <a name="readerwriterlock-class"></a><span data-ttu-id="995b4-157">ReaderWriterLock Sınıfı</span><span class="sxs-lookup"><span data-stu-id="995b4-157">ReaderWriterLock Class</span></span>  
 <span data-ttu-id="995b4-158"><xref:System.Threading.ReaderWriterLockSlim> Sınıfı adresleri veri yazıcısı değiştiren bir iş parçacığı gerekir sahip olduğu bir kaynağa özel erişim durumu.</span><span class="sxs-lookup"><span data-stu-id="995b4-158">The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource.</span></span> <span data-ttu-id="995b4-159">Yazıcı etkin değilken okuyucular herhangi bir sayıda kaynağa erişmek için (örneğin, arama tarafından <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> yöntemi).</span><span class="sxs-lookup"><span data-stu-id="995b4-159">When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method).</span></span> <span data-ttu-id="995b4-160">Bir iş parçacığı özel erişim istediğinde (çağırarak gibi <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> yöntemi), tüm mevcut okuyucular kilit çıkılana ve yazıcı girdi ve çıktı kilit kadar sonraki okuyucu istekleri blok.</span><span class="sxs-lookup"><span data-stu-id="995b4-160">When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>  
  
 <span data-ttu-id="995b4-161"><xref:System.Threading.ReaderWriterLockSlim> iş parçacığı benzeşimini sahiptir.</span><span class="sxs-lookup"><span data-stu-id="995b4-161"><xref:System.Threading.ReaderWriterLockSlim> has thread affinity.</span></span>  
  
 <span data-ttu-id="995b4-162">Kavramsal bir genel bakış için bkz. [Okuyucu-Yazıcı kilitleri](../../../docs/standard/threading/reader-writer-locks.md).</span><span class="sxs-lookup"><span data-stu-id="995b4-162">For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md).</span></span>  
  
#### <a name="semaphore-class"></a><span data-ttu-id="995b4-163">Semafor Sınıfı</span><span class="sxs-lookup"><span data-stu-id="995b4-163">Semaphore Class</span></span>  
 <span data-ttu-id="995b4-164"><xref:System.Threading.Semaphore> Sınıfı, belirtilen sayıda iş parçacığı bir kaynağa erişmeye olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="995b4-164">The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource.</span></span> <span data-ttu-id="995b4-165">Bir iş parçacığı semafor serbest kadar kaynak blok isteyen ek iş parçacıkları.</span><span class="sxs-lookup"><span data-stu-id="995b4-165">Additional threads requesting the resource block until a thread releases the semaphore.</span></span>  
  
 <span data-ttu-id="995b4-166">Gibi <xref:System.Threading.Mutex> sınıfı <xref:System.Threading.Semaphore> türetildiği <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="995b4-166">Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="995b4-167">Ayrıca <xref:System.Threading.Mutex>, <xref:System.Threading.Semaphore> yerel veya genel olabilir.</span><span class="sxs-lookup"><span data-stu-id="995b4-167">Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global.</span></span> <span data-ttu-id="995b4-168">Uygulama etki alanı sınırlarında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="995b4-168">It can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="995b4-169">Farklı <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, ve <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> iş parçacığı benzeşimini sahip değil.</span><span class="sxs-lookup"><span data-stu-id="995b4-169">Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity.</span></span> <span data-ttu-id="995b4-170">Başka bir deyişle, burada tek bir iş parçacığı semafor devralır ve başka bir serbest senaryolarda kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="995b4-170">This means it can be used in scenarios where one thread acquires the semaphore and another releases it.</span></span>  
  
 <span data-ttu-id="995b4-171">Kavramsal bir genel bakış için bkz. [semafor ve SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="995b4-171">For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="995b4-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> tek bir işlem sınırları içinde eşitleme için basit bir semafor olur.</span><span class="sxs-lookup"><span data-stu-id="995b4-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight semaphore for synchronization within a single process boundary.</span></span>  
  
 [<span data-ttu-id="995b4-173">Başa dön</span><span class="sxs-lookup"><span data-stu-id="995b4-173">Back to top</span></span>](#top)  
  
<a name="signaling"></a>   
## <a name="signaling"></a><span data-ttu-id="995b4-174">Sinyal</span><span class="sxs-lookup"><span data-stu-id="995b4-174">Signaling</span></span>  
 <span data-ttu-id="995b4-175">Çağırmak için başka bir iş parçacığından bir sinyal için beklenecek en basit yolu <xref:System.Threading.Thread.Join%2A> başka bir iş parçacığı tamamlanıncaya kadar engeller yöntemi.</span><span class="sxs-lookup"><span data-stu-id="995b4-175">The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes.</span></span> <span data-ttu-id="995b4-176"><xref:System.Threading.Thread.Join%2A> Belirtilen bir zaman aralığı geçtikten sonra dışı beklemeyi ayırmak engellenen iş parçacığına izin veren iki aşırı yüklemesi vardır.</span><span class="sxs-lookup"><span data-stu-id="995b4-176"><xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.</span></span>  
  
 <span data-ttu-id="995b4-177">Bekleme tanıtıcıları bekleyen ve özellikleri sinyal çok daha zengin sağlar.</span><span class="sxs-lookup"><span data-stu-id="995b4-177">Wait handles provide a much richer set of waiting and signaling capabilities.</span></span>  
  
### <a name="wait-handles"></a><span data-ttu-id="995b4-178">Bekleme Tanıtıcıları</span><span class="sxs-lookup"><span data-stu-id="995b4-178">Wait Handles</span></span>  
 <span data-ttu-id="995b4-179">Bekleme tanıtıcıları türetilen <xref:System.Threading.WaitHandle> sırayla türetilen sınıf <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="995b4-179">Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="995b4-180">Bu nedenle, bekleme tanıtıcıları, uygulama etki alanı sınırları arasında iş parçacıklarının etkinlikleri eşitlemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="995b4-180">Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="995b4-181">İş parçacıklarını bekleme blok işleme örnek yöntemini çağırarak <xref:System.Threading.WaitHandle.WaitOne%2A> veya statik yöntemleri <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, veya <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="995b4-181">Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span></span> <span data-ttu-id="995b4-182">Nasıl yayımlanan hangi yöntemi çağrıldı ve bekleme tanıtıcıları türüne bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="995b4-182">How they are released depends on which method was called, and on the kind of wait handles.</span></span>  
  
 <span data-ttu-id="995b4-183">Kavramsal bir genel bakış için bkz. [bekleyin işler](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span><span class="sxs-lookup"><span data-stu-id="995b4-183">For a conceptual overview, see [Wait Handles](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span></span>  
  
#### <a name="event-wait-handles"></a><span data-ttu-id="995b4-184">Olay bekleme tanıtıcıları</span><span class="sxs-lookup"><span data-stu-id="995b4-184">Event Wait Handles</span></span>  
 <span data-ttu-id="995b4-185">Olay bekleme tanıtıcıları içeren <xref:System.Threading.EventWaitHandle> sınıfı ve türetilmiş sınıflarının <xref:System.Threading.AutoResetEvent> ve <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="995b4-185">Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="995b4-186">Olay bekleme tanıtıcısı çağırarak sinyal olduğunda bir olay bekleme tanıtıcısı iş parçacığı yayımlandığında, <xref:System.Threading.EventWaitHandle.Set%2A> yöntemi kullanarak veya <xref:System.Threading.WaitHandle.SignalAndWait%2A> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="995b4-186">Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span>  
  
 <span data-ttu-id="995b4-187">Olay ya da kendilerini otomatik olarak yalnızca tek bir iş parçacığı aracılığıyla işareti verilen veya el ile sıfırlama sinyal ve birisi kapatana kadar açın kadar kapalı bir ağ geçidi gibi her zaman izin veren bir Turnike gibi sıfırlama tanıtıcıları bekleyin.</span><span class="sxs-lookup"><span data-stu-id="995b4-187">Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it.</span></span> <span data-ttu-id="995b4-188">Adlarını da ifade ettiği şekilde <xref:System.Threading.AutoResetEvent> ve <xref:System.Threading.ManualResetEvent> eski ve ikinci olarak, sırasıyla temsil eder.</span><span class="sxs-lookup"><span data-stu-id="995b4-188">As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively.</span></span> <span data-ttu-id="995b4-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> tek bir işlem sınırları içinde eşitleme için basit bir olaydır.</span><span class="sxs-lookup"><span data-stu-id="995b4-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight event for synchronization within a single process boundary.</span></span>  
  
 <span data-ttu-id="995b4-190">Bir <xref:System.Threading.EventWaitHandle> ya da olay türünü temsil edebilir ve yerel veya genel olabilir.</span><span class="sxs-lookup"><span data-stu-id="995b4-190">An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global.</span></span> <span data-ttu-id="995b4-191">Türetilen sınıfların <xref:System.Threading.AutoResetEvent> ve <xref:System.Threading.ManualResetEvent> her zaman yereldir.</span><span class="sxs-lookup"><span data-stu-id="995b4-191">The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local.</span></span>  
  
 <span data-ttu-id="995b4-192">Olay bekleme tanıtıcıları iş parçacığı benzeşimini yok.</span><span class="sxs-lookup"><span data-stu-id="995b4-192">Event wait handles do not have thread affinity.</span></span> <span data-ttu-id="995b4-193">Herhangi bir iş parçacığı, bir olay bekleme tanıtıcısının sinyal verebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="995b4-193">Any thread can signal an event wait handle.</span></span>  
  
 <span data-ttu-id="995b4-194">Kavramsal bir genel bakış için bkz. [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="995b4-194">For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
#### <a name="mutex-and-semaphore-classes"></a><span data-ttu-id="995b4-195">Mutex ve semafor sınıfları</span><span class="sxs-lookup"><span data-stu-id="995b4-195">Mutex and Semaphore Classes</span></span>  
 <span data-ttu-id="995b4-196">Çünkü <xref:System.Threading.Mutex> ve <xref:System.Threading.Semaphore> sınıflar türetilen <xref:System.Threading.WaitHandle>, statik yöntemleriyle kullanılabilir <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="995b4-196">Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="995b4-197">Örneğin, bir iş parçacığı kullanabilirsiniz <xref:System.Threading.WaitHandle.WaitAll%2A> Aşağıdakilerden üçü true olana kadar beklenecek yöntemi: bir <xref:System.Threading.EventWaitHandle> işareti verilen bir <xref:System.Threading.Mutex> yayımlandığı ve <xref:System.Threading.Semaphore> serbest bırakılır.</span><span class="sxs-lookup"><span data-stu-id="995b4-197">For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released.</span></span> <span data-ttu-id="995b4-198">Benzer şekilde, bir iş parçacığı kullanabilirsiniz <xref:System.Threading.WaitHandle.WaitAny%2A> yöntemi Bu koşullardan herhangi biri true olana kadar bekleyin.</span><span class="sxs-lookup"><span data-stu-id="995b4-198">Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true.</span></span>  
  
 <span data-ttu-id="995b4-199">İçin bir <xref:System.Threading.Mutex> veya <xref:System.Threading.Semaphore>, sinyal yayımlanan anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="995b4-199">For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released.</span></span> <span data-ttu-id="995b4-200">Her iki türü ilk bağımsız değişken olarak kullanılıp kullanılmadığını <xref:System.Threading.WaitHandle.SignalAndWait%2A> yöntemi serbest kalır.</span><span class="sxs-lookup"><span data-stu-id="995b4-200">If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released.</span></span> <span data-ttu-id="995b4-201">Durumunda, bir <xref:System.Threading.Mutex>, iş parçacığı benzeşimini olan, çağıran iş parçacığını mutex sahip değilse bir özel durum oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="995b4-201">In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex.</span></span> <span data-ttu-id="995b4-202">Daha önce belirtildiği gibi iş parçacığı benzeşimini parçacıklarıyla yok.</span><span class="sxs-lookup"><span data-stu-id="995b4-202">As noted previously, semaphores do not have thread affinity.</span></span>  
  
#### <a name="barrier"></a><span data-ttu-id="995b4-203">Engel</span><span class="sxs-lookup"><span data-stu-id="995b4-203">Barrier</span></span>  
 <span data-ttu-id="995b4-204"><xref:System.Threading.Barrier> Sınıfı, böylece bunlar aynı anda tüm blok gelin ve tamamlamak tüm diğer iş parçacıkları için bekleyin periyodik olarak birden çok iş parçacığı eşitlemek için bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="995b4-204">The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete.</span></span> <span data-ttu-id="995b4-205">Bir engel bir algoritma sonraki aşamaya devam etmeden önce bir veya daha fazla iş parçacığı başka bir iş parçacığı sonuçlarını gerektiğinde yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="995b4-205">A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm.</span></span> <span data-ttu-id="995b4-206">Daha fazla bilgi için [engel](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="995b4-206">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>  
  
 [<span data-ttu-id="995b4-207">Başa dön</span><span class="sxs-lookup"><span data-stu-id="995b4-207">Back to top</span></span>](#top)  
  
<a name="lightweight_synchronization_types"></a>   
## <a name="lightweight-synchronization-types"></a><span data-ttu-id="995b4-208">Hafif eşitleme türleri</span><span class="sxs-lookup"><span data-stu-id="995b4-208">Lightweight Synchronization Types</span></span>  
 <span data-ttu-id="995b4-209">İle başlayarak [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], Win32 çekirdek pahalı güvenme önleme hızlı performansı bekleme tanıtıcıları mümkün olduğunca gibi nesneleri sağlayan eşitleme temellerine kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="995b4-209">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.</span></span> <span data-ttu-id="995b4-210">Genel olarak, bu tür bekleme süresini kısa olduğunda ve yalnızca özgün eşitleme türleri çalıştı ve yetersiz olduğu tespit kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="995b4-210">In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory.</span></span> <span data-ttu-id="995b4-211">Basit türler çapraz proses haberleşmesi gerektiren senaryolar içinde kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="995b4-211">The lightweight types cannot be used in scenarios that require cross-process communication.</span></span>  
  
-   <span data-ttu-id="995b4-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> hafif bir sürümüdür <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="995b4-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="995b4-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> hafif bir sürümüdür <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="995b4-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="995b4-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> kendi sayısı sıfır olduğunda, sinyal haline gelir bir olayı temsil eder.</span><span class="sxs-lookup"><span data-stu-id="995b4-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> represents an event that becomes signaled when its count is zero.</span></span>  
  
-   <span data-ttu-id="995b4-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> Ana iş parçacığı tarafından denetim gerektirmeden birbirleriyle eşitlemek birden çok iş parçacığı sağlar.</span><span class="sxs-lookup"><span data-stu-id="995b4-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> enables multiple threads to synchronize with one another without requiring control by a master thread.</span></span> <span data-ttu-id="995b4-216">Tüm iş parçacıklarının belirli bir noktaya ulaşıncaya kadar bir engel her iş parçacığı devam etmesini engeller.</span><span class="sxs-lookup"><span data-stu-id="995b4-216">A barrier prevents each thread from continuing until all threads have reached a specified point.</span></span>  
  
 [<span data-ttu-id="995b4-217">Başa dön</span><span class="sxs-lookup"><span data-stu-id="995b4-217">Back to top</span></span>](#top)  
  
<a name="spinwait"></a>   
## <a name="spinwait"></a><span data-ttu-id="995b4-218">SpinWait</span><span class="sxs-lookup"><span data-stu-id="995b4-218">SpinWait</span></span>  
 <span data-ttu-id="995b4-219">İle başlayarak [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], kullanabileceğiniz <xref:System.Threading.SpinWait?displayProperty=nameWithType> sinyal bir olay ya da karşılanması gereken bir koşul için beklenecek bir iş parçacığı sahip olduğunda, ancak gerçek bir bekleme süresi bir bekleme tanıtıcısı kullanarak veya otherwi gereken bekleme süresi değerinden küçük olması bekleniyorsa yapısı Geçerli iş parçacığını engelleyip se.</span><span class="sxs-lookup"><span data-stu-id="995b4-219">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread.</span></span> <span data-ttu-id="995b4-220">Kullanarak <xref:System.Threading.SpinWait>, bekleme sırasında çalıştırın ve koşul belirtilen süre içinde yalnızca aşıldığı değil durumunda (örneğin, bekleyen veya uyku) verim için kısa bir süre belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="995b4-220">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>  
  
 [<span data-ttu-id="995b4-221">Başa dön</span><span class="sxs-lookup"><span data-stu-id="995b4-221">Back to top</span></span>](#top)  
  
<a name="interlocked_operations"></a>   
## <a name="interlocked-operations"></a><span data-ttu-id="995b4-222">Birbirine Kenetlenmiş İşlemler</span><span class="sxs-lookup"><span data-stu-id="995b4-222">Interlocked Operations</span></span>  
 <span data-ttu-id="995b4-223">Birbirine kenetlenmiş işlemler olan bir bellek konumuna statik yöntemleri tarafından gerçekleştirilen basit atomik işlemler <xref:System.Threading.Interlocked> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="995b4-223">Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="995b4-224">Atomik işlemleri ekleme dahil, artırmak ve azaltma, exchange, bir karşılaştırma bağlı olarak koşullu exchange okuma işlemleri ve 64-bit değerleri için 32-bit platformlarda.</span><span class="sxs-lookup"><span data-stu-id="995b4-224">Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="995b4-225">Kararlılık garanti tek işlemler için sınırlıdır; bir birim olarak birden çok işlemi gerçekleştirilmesi gerekir, daha parçalı bir eşitleme mekanizması kullanılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="995b4-225">The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.</span></span>  
  
 <span data-ttu-id="995b4-226">Bu işlemlerin hiçbiri kilitler veya sinyalleri olmasına rağmen kilitler ve sinyaller oluşturmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="995b4-226">Although none of these operations are locks or signals, they can be used to construct locks and signals.</span></span> <span data-ttu-id="995b4-227">Birbirine kenetlenmiş işlemler, Windows işletim sisteminde yerel oldukları için son derece hızlı.</span><span class="sxs-lookup"><span data-stu-id="995b4-227">Because they are native to the Windows operating system, interlocked operations are extremely fast.</span></span>  
  
 <span data-ttu-id="995b4-228">Birbirine kenetlenmiş işlemler, güçlü engelleyici olmayan eşzamanlılık sergileyen uygulamalar yazmak üzere geçici bir bellek Garantisi ile kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="995b4-228">Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency.</span></span> <span data-ttu-id="995b4-229">Ancak, bunlar ciddi bir şekilde daha iyi bir seçenek birçok amaç için basit kilit şekilde karmaşık, düşük düzeydeki programlama, gerektirir.</span><span class="sxs-lookup"><span data-stu-id="995b4-229">However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.</span></span>  
  
 <span data-ttu-id="995b4-230">Kavramsal bir genel bakış için bkz. [birbirine geçmiş Operations](../../../docs/standard/threading/interlocked-operations.md).</span><span class="sxs-lookup"><span data-stu-id="995b4-230">For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="995b4-231">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="995b4-231">See also</span></span>

- [<span data-ttu-id="995b4-232">Çoklu İş Parçacığı Kullanımı için Veri Eşitleme</span><span class="sxs-lookup"><span data-stu-id="995b4-232">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
- [<span data-ttu-id="995b4-233">İzleyiciler</span><span class="sxs-lookup"><span data-stu-id="995b4-233">Monitors</span></span>](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)  
- [<span data-ttu-id="995b4-234">Karşılıklı dışlamalar</span><span class="sxs-lookup"><span data-stu-id="995b4-234">Mutexes</span></span>](../../../docs/standard/threading/mutexes.md)  
- [<span data-ttu-id="995b4-235">Semaphore ve SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="995b4-235">Semaphore and SemaphoreSlim</span></span>](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)  
- [<span data-ttu-id="995b4-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="995b4-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)  
- [<span data-ttu-id="995b4-237">Bekleme tanıtıcıları</span><span class="sxs-lookup"><span data-stu-id="995b4-237">Wait Handles</span></span>](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)  
- [<span data-ttu-id="995b4-238">Birbirine Kenetlenmiş İşlemler</span><span class="sxs-lookup"><span data-stu-id="995b4-238">Interlocked Operations</span></span>](../../../docs/standard/threading/interlocked-operations.md)  
- [<span data-ttu-id="995b4-239">Okuyucu-Yazıcı Kilitleri</span><span class="sxs-lookup"><span data-stu-id="995b4-239">Reader-Writer Locks</span></span>](../../../docs/standard/threading/reader-writer-locks.md)  
- [<span data-ttu-id="995b4-240">Engel</span><span class="sxs-lookup"><span data-stu-id="995b4-240">Barrier</span></span>](../../../docs/standard/threading/barrier.md)  
- [<span data-ttu-id="995b4-241">SpinWait</span><span class="sxs-lookup"><span data-stu-id="995b4-241">SpinWait</span></span>](../../../docs/standard/threading/spinwait.md)  
- [<span data-ttu-id="995b4-242">SpinLock</span><span class="sxs-lookup"><span data-stu-id="995b4-242">SpinLock</span></span>](../../../docs/standard/threading/spinlock.md)

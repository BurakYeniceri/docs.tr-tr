---
title: Uzantı Metotları (C# Programlama Kılavuzu)
ms.date: 07/20/2015
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: e2e63953e130dc83ce83bcdd2f8e9a2ffc7fe5f3
ms.sourcegitcommit: 89c93d05c2281b4c834f48f6c8df1047e1410980
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/15/2018
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="eae8f-102">Uzantı Metotları (C# Programlama Kılavuzu)</span><span class="sxs-lookup"><span data-stu-id="eae8f-102">Extension Methods (C# Programming Guide)</span></span>
<span data-ttu-id="eae8f-103">Uzantı yöntemleri, yeni türetilmiş bir tür oluşturmadan, yeniden derlemeden ya da özgün türü değiştirmeden yöntemler "eklemenizi" sağlar.</span><span class="sxs-lookup"><span data-stu-id="eae8f-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="eae8f-104">Uzantı yöntemleri özel bir statik yöntem türüdür, ancak bunlar genişletilmiş türdeki örnek yöntemler ise çağrılır.</span><span class="sxs-lookup"><span data-stu-id="eae8f-104">Extension methods are a special kind of static method, but they are called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="eae8f-105">C#, F # ve Visual Basic'te yazılmış istemci kodu için bir genişletme yöntemi ve gerçekte bir türde tanımlanan yöntemler çağırma arasında görünen fark yoktur.</span><span class="sxs-lookup"><span data-stu-id="eae8f-105">For client code written in C#, F# and Visual Basic, there is no apparent difference between calling an extension method and the methods that are actually defined in a type.</span></span>  
  
 <span data-ttu-id="eae8f-106">En sık kullanılan uzantı yöntemleri [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] sorgu işlevselliği, mevcut eklemek standart sorgu işleçleri <xref:System.Collections.IEnumerable?displayProperty=nameWithType> ve <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> türleri.</span><span class="sxs-lookup"><span data-stu-id="eae8f-106">The most common extension methods are the [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="eae8f-107">Standart sorgu işleçleri kullanmak için önce bunları kapsamıyla duruma getirmek bir `using System.Linq` yönergesi.</span><span class="sxs-lookup"><span data-stu-id="eae8f-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="eae8f-108">Uygulayan sonra herhangi bir türü <xref:System.Collections.Generic.IEnumerable%601> örnek yöntemleri gibi görünüyor <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>ve benzeri.</span><span class="sxs-lookup"><span data-stu-id="eae8f-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="eae8f-109">"Nokta" yazdığınızda, IntelliSense deyim tamamlama, bu ek yöntemleri örneği sonra görebilirsiniz bir <xref:System.Collections.Generic.IEnumerable%601> gibi yazın <xref:System.Collections.Generic.List%601> veya <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="eae8f-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="eae8f-110">Aşağıdaki örnek, standart sorgu işleci çağırmak gösterilmiştir `OrderBy` dizisi yöntemi.</span><span class="sxs-lookup"><span data-stu-id="eae8f-110">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="eae8f-111">Parantez içindeki ifade bir lambda ifadesidir.</span><span class="sxs-lookup"><span data-stu-id="eae8f-111">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="eae8f-112">Birçok standart sorgu işleçleri, lambda ifadeleri parametre olarak alır, ancak bu uzantı yöntemleri için bir gereklilik değildir.</span><span class="sxs-lookup"><span data-stu-id="eae8f-112">Many standard query operators take lambda expressions as parameters, but this is not a requirement for extension methods.</span></span> <span data-ttu-id="eae8f-113">Daha fazla bilgi için bkz: [Lambda ifadeleri](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="eae8f-113">For more information, see [Lambda Expressions](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span></span>  
  
 [!code-csharp[csProgGuideExtensionMethods#3](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_1.cs)]  
  
 <span data-ttu-id="eae8f-114">Uzantı yöntemleri statik yöntemler olarak adlandırılır ancak örnek yöntemi söz dizimi kullanılarak çağrılır.</span><span class="sxs-lookup"><span data-stu-id="eae8f-114">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="eae8f-115">Kendi ilk parametre yöntemi tür çalıştırır ve parametre öncesinde belirtir [bu](../../../csharp/language-reference/keywords/this.md) değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="eae8f-115">Their first parameter specifies which type the method operates on, and the parameter is preceded by the [this](../../../csharp/language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="eae8f-116">Genişletme yöntemleri ile kaynak kodunuzu içine ad alanını açıkça aktarırken yalnızca kapsamında olan bir `using` yönergesi.</span><span class="sxs-lookup"><span data-stu-id="eae8f-116">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>  
  
 <span data-ttu-id="eae8f-117">İçin tanımlanmış bir genişletme yöntemi aşağıdaki örnekte <xref:System.String?displayProperty=nameWithType> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="eae8f-117">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="eae8f-118">Bunun iç içe ve genel olmayan bir statik sınıf içinde tanımlandığına dikkat edin:</span><span class="sxs-lookup"><span data-stu-id="eae8f-118">Note that it is defined inside a non-nested, non-generic static class:</span></span>  
  
 [!code-csharp[csProgGuideExtensionMethods#4](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_2.cs)]  
  
 <span data-ttu-id="eae8f-119">`WordCount` Genişletme yöntemi tıkladığında bu kapsam içine `using` yönergesi:</span><span class="sxs-lookup"><span data-stu-id="eae8f-119">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>  
  
```csharp  
using ExtensionMethods;  
```  
  
 <span data-ttu-id="eae8f-120">Ve bu sözdizimi kullanılarak bir uygulamadan çağrılabilir:</span><span class="sxs-lookup"><span data-stu-id="eae8f-120">And it can be called from an application by using this syntax:</span></span>  
  
```csharp  
string s = "Hello Extension Methods";  
int i = s.WordCount();  
```  
  
 <span data-ttu-id="eae8f-121">Kodunuzda örnek yöntemi sözdizimini ile genişletme yöntemi çağırırsınız.</span><span class="sxs-lookup"><span data-stu-id="eae8f-121">In your code you invoke the extension method with instance method syntax.</span></span> <span data-ttu-id="eae8f-122">Ancak derleyici tarafından üretilen ara dil (IL), kodunuzu statik yöntemdeki bir çağrıya dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="eae8f-122">However, the intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="eae8f-123">Bu nedenle, kapsülleme ilkesi gerçekten ihlal edilmez.</span><span class="sxs-lookup"><span data-stu-id="eae8f-123">Therefore, the principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="eae8f-124">Aslında genişletme yöntemleri, genişletildikleri türde özel değişkenlere erişemez.</span><span class="sxs-lookup"><span data-stu-id="eae8f-124">In fact, extension methods cannot access private variables in the type they are extending.</span></span>  
  
 <span data-ttu-id="eae8f-125">Daha fazla bilgi için bkz: [nasıl yapılır: uygulama ve özel uzantı metodu çağırma](../../../csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method.md).</span><span class="sxs-lookup"><span data-stu-id="eae8f-125">For more information, see [How to: Implement and Call a Custom  Extension Method](../../../csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method.md).</span></span>  
  
 <span data-ttu-id="eae8f-126">Genel olarak, büyük olasılıkla kendinizinkileri uygulamayla kıyaslandığında genişletme yöntemlerini çok daha arayacaksınız.</span><span class="sxs-lookup"><span data-stu-id="eae8f-126">In general, you will probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="eae8f-127">Genişletme yöntemleri örnek yöntem sözdizimi tarafından çağrıldığından istemci kodundan kullanmak için herhangi bir özel bilgi gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="eae8f-127">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="eae8f-128">Belirli bir tür için genişletme yöntemleri etkinleştirmek için yalnızca Ekle bir `using` yöntemleri tanımlanır ad alanı için yönerge.</span><span class="sxs-lookup"><span data-stu-id="eae8f-128">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="eae8f-129">Örneğin, standart sorgu işleçleri kullanmak için bu ekleyin `using` kodunuza yönerge:</span><span class="sxs-lookup"><span data-stu-id="eae8f-129">For example, to use the standard query operators, add this `using` directive to your code:</span></span>  
  
```csharp  
using System.Linq;  
```  
  
 <span data-ttu-id="eae8f-130">(System.Core.dll öğesine başvuru eklemeniz gerekebilir.) Standart sorgu işleçleri şimdi IntelliSense içinde ek yöntemleri kullanılabilir çoğu için olarak göründüğünü fark edeceksiniz <xref:System.Collections.Generic.IEnumerable%601> türleri.</span><span class="sxs-lookup"><span data-stu-id="eae8f-130">(You may also have to add a reference to System.Core.dll.) You will notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eae8f-131">Standart sorgu işleçleri için IntelliSense görünmez rağmen <xref:System.String>, hala kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="eae8f-131">Although standard query operators do not appear in IntelliSense for <xref:System.String>, they are still available.</span></span>  
  
## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="eae8f-132">Derleme Zamanında Uzantı Yöntemleri Bağlama</span><span class="sxs-lookup"><span data-stu-id="eae8f-132">Binding Extension Methods at Compile Time</span></span>  
 <span data-ttu-id="eae8f-133">Bir sınıfı veya arabirimi genişletmek için genişletme yöntemini kullanabilir, ancak bunları geçersiz kılamazsınız.</span><span class="sxs-lookup"><span data-stu-id="eae8f-133">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="eae8f-134">Arabirim veya sınıf yöntemiyle aynı ada ve imzaya sahip genişletme yöntemi asla çağrılmaz.</span><span class="sxs-lookup"><span data-stu-id="eae8f-134">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="eae8f-135">Derleme sırasında genişletme yöntemleri, her zaman türün kendisinde tanımlı örnek yöntemlerden daha düşük önceliğe sahiptir.</span><span class="sxs-lookup"><span data-stu-id="eae8f-135">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="eae8f-136">Diğer bir deyişle, bir tür değilse sahip bir yöntem adlı `Process(int i)`ve bir genişletme yöntemi ile aynı imzaya sahip, derleyicinin her zaman için örnek yöntemi bağlarsınız.</span><span class="sxs-lookup"><span data-stu-id="eae8f-136">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="eae8f-137">Derleyici bir yöntem çağırmayla karşılaştığında, türün örnek yöntemleri önce bir eşleşme arar.</span><span class="sxs-lookup"><span data-stu-id="eae8f-137">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="eae8f-138">Eşleşme bulunmazsa, tür için tanımlanan uzantı yöntemleri aranır ve ilk bulunan uzantı yöntemine bağlanılır.</span><span class="sxs-lookup"><span data-stu-id="eae8f-138">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="eae8f-139">Aşağıdaki örnek, derleyicinin hangi genişletme yöntemine veya örnek yöntemine bağlanılacağını nasıl belirlediğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="eae8f-139">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>  
  
## <a name="example"></a><span data-ttu-id="eae8f-140">Örnek</span><span class="sxs-lookup"><span data-stu-id="eae8f-140">Example</span></span>  
 <span data-ttu-id="eae8f-141">Aşağıdaki örnek, C# derleyicisinin bir yöntem çağrısını türde bir örnek yöntemine mi yoksa bir genişletme yöntemine mi bağlayacağını belirlemede izlediği kuralları gösterir.</span><span class="sxs-lookup"><span data-stu-id="eae8f-141">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="eae8f-142">Statik sınıf `Extensions` uygulayan herhangi bir türü için tanımlı genişletme yöntemleri içeren `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="eae8f-142">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="eae8f-143">Sınıfları `A`, `B`, ve `C` tüm arabirimini uygular.</span><span class="sxs-lookup"><span data-stu-id="eae8f-143">Classes `A`, `B`, and `C` all implement the interface.</span></span>  
  
 <span data-ttu-id="eae8f-144">`MethodB` Genişletme yöntemi adını ve imza zaten sınıfları tarafından uygulanan yöntemleri tam olarak aynı olduğundan hiçbir zaman çağrılır.</span><span class="sxs-lookup"><span data-stu-id="eae8f-144">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>  
  
 <span data-ttu-id="eae8f-145">Derleyici eşleştirilen imzayla bir oluşum yöntemi bulamadığında, varsa, eşleşen bir uzantı yöntemini bağlayın.</span><span class="sxs-lookup"><span data-stu-id="eae8f-145">When the compiler cannot find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>  
  
 [!code-csharp[csProgGuideExtensionMethods#5](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_3.cs)]  
  
## <a name="general-guidelines"></a><span data-ttu-id="eae8f-146">Genel Yönergeler</span><span class="sxs-lookup"><span data-stu-id="eae8f-146">General Guidelines</span></span>  
 <span data-ttu-id="eae8f-147">Genel olarak, genişletme yöntemlerini tutumlu ve yalnızca gerektiğinde uygulamanızı öneririz.</span><span class="sxs-lookup"><span data-stu-id="eae8f-147">In general, we recommend that you implement extension methods sparingly and only when you have to.</span></span> <span data-ttu-id="eae8f-148">Mümkün olduğunda, varolan türü genişletmesi gereken istemci kodu, bunu varolan türden türetilmiş yeni bir tür oluşturarak yapmalıdır.</span><span class="sxs-lookup"><span data-stu-id="eae8f-148">Whenever possible, client code that must extend an existing type should do so by creating a new type derived from the existing type.</span></span> <span data-ttu-id="eae8f-149">Daha fazla bilgi için bkz: [devralma](../../../csharp/programming-guide/classes-and-structs/inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="eae8f-149">For more information, see [Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md).</span></span>  
  
 <span data-ttu-id="eae8f-150">Kaynak kodunu değiştiremediğiniz bir türü genişletmek üzere genişletme yöntemini kullanırsanız, türün uygulanmasındaki bir değişikliğin genişletme yönteminizin kesilmesine neden olabileceği riskini göze alırsınız.</span><span class="sxs-lookup"><span data-stu-id="eae8f-150">When using an extension method to extend a type whose source code you cannot change, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>  
  
 <span data-ttu-id="eae8f-151">Belirtilen tür için genişletme yöntemleri uygularsanız, aşağıdaki hususları unutmayın:</span><span class="sxs-lookup"><span data-stu-id="eae8f-151">If you do implement extension methods for a given type, remember the following points:</span></span>  
  
-   <span data-ttu-id="eae8f-152">Türden tanımlı yöntemle aynı imzaya sahip değilse genişletme yöntemi asla çağrılmaz.</span><span class="sxs-lookup"><span data-stu-id="eae8f-152">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>  
  
-   <span data-ttu-id="eae8f-153">Uzantı yöntemleri ad alanı seviyesinde kapsama alınır.</span><span class="sxs-lookup"><span data-stu-id="eae8f-153">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="eae8f-154">Örneğin, adlı tek bir ad alanı uzantı yöntemleri içeren birden çok statik sınıflar varsa `Extensions`, bunlar tüm kapsam tarafından içine gidersiniz `using Extensions;` yönergesi.</span><span class="sxs-lookup"><span data-stu-id="eae8f-154">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they will all be brought into scope by the `using Extensions;` directive.</span></span>  
  
 <span data-ttu-id="eae8f-155">Uygulanan bir sınıf kitaplığı için derleme sürüm numarasının artıyor olmasını önlemek için uzantı yöntemleri kullanmamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="eae8f-155">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="eae8f-156">Kaynak koduna sahip olduğunuz kitaplığa önemli işlevsellik eklemek isterseniz, derleme sürüm oluşturma için standart .NET Framework yönergelerini izlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="eae8f-156">If you want to add significant functionality to a library for which you own the source code, you should follow the standard .NET Framework guidelines for assembly versioning.</span></span> <span data-ttu-id="eae8f-157">Daha fazla bilgi için bkz: [derleme sürümü oluşturma](../../../../docs/framework/app-domains/assembly-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="eae8f-157">For more information, see [Assembly Versioning](../../../../docs/framework/app-domains/assembly-versioning.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="eae8f-158">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="eae8f-158">See Also</span></span>  
 [<span data-ttu-id="eae8f-159">C# Programlama Kılavuzu</span><span class="sxs-lookup"><span data-stu-id="eae8f-159">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="eae8f-160">Paralel Programlama örnekleri (bunlar, birçok örnek genişletme yöntemleri içerir)</span><span class="sxs-lookup"><span data-stu-id="eae8f-160">Parallel Programming Samples (these include many example extension methods)</span></span>](http://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364)  
 [<span data-ttu-id="eae8f-161">Lambda İfadeleri</span><span class="sxs-lookup"><span data-stu-id="eae8f-161">Lambda Expressions</span></span>](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)  
 [<span data-ttu-id="eae8f-162">Standart Sorgu İşleçlerine Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="eae8f-162">Standard Query Operators Overview</span></span>](http://msdn.microsoft.com/library/24cda21e-8af8-4632-b519-c404a839b9b2)  
 [<span data-ttu-id="eae8f-163">Dönüştürme örneği için parametreler ve bunların etkisini kuralları</span><span class="sxs-lookup"><span data-stu-id="eae8f-163">Conversion rules for Instance parameters and their impact</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/10/11/conversion-rules-for-instance-parameters-and-their-impact)  
 [<span data-ttu-id="eae8f-164">Diller arasında birlikte çalışabilirlik genişletme yöntemleri</span><span class="sxs-lookup"><span data-stu-id="eae8f-164">Extension methods Interoperability between languages</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/10/11/extension-methods-interoperability-between-languages)  
 [<span data-ttu-id="eae8f-165">Genişletme yöntemleri ve Curried temsilciler</span><span class="sxs-lookup"><span data-stu-id="eae8f-165">Extension methods and Curried Delegates</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/05/01/extension-methods-and-curried-delegates)  
 [<span data-ttu-id="eae8f-166">Genişletme yöntemi bağlama ve hata raporlama</span><span class="sxs-lookup"><span data-stu-id="eae8f-166">Extension method Binding and Error reporting</span></span>](https://blogs.msdn.microsoft.com/sreekarc/2007/04/26/extension-method-binding-and-error-reporting)

---
title: İş parçacığı eşitleme (C#)
ms.date: 07/20/2015
ms.assetid: e42b1be6-c93c-479f-a148-be0759f1a4e1
ms.openlocfilehash: 4ed6cad647c965882a63282ce32c998cec138eec
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/02/2018
ms.locfileid: "43463162"
---
# <a name="thread-synchronization-c"></a><span data-ttu-id="a2624-102">İş parçacığı eşitleme (C#)</span><span class="sxs-lookup"><span data-stu-id="a2624-102">Thread Synchronization (C#)</span></span>
<span data-ttu-id="a2624-103">Aşağıdaki bölümlerde, özellikleri ve kaynakları birden çok iş parçacıklı uygulamalarda erişimi eşitlemek için kullanılan sınıflar açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="a2624-103">The following sections describe features and classes that can be used to synchronize access to resources in multithreaded applications.</span></span>  
  
 <span data-ttu-id="a2624-104">Bir uygulamada birden çok iş parçacığı kullanmanın avantajları her iş parçacığı zaman uyumsuz olarak yürütür biridir.</span><span class="sxs-lookup"><span data-stu-id="a2624-104">One of the benefits of using multiple threads in an application is that each thread executes asynchronously.</span></span> <span data-ttu-id="a2624-105">Windows uygulamaları için bu uygulama penceresinin arka planda gerçekleştirilecek zaman alan görevlerin sağlar ve denetimleri yanıt verebilir durumda kalması.</span><span class="sxs-lookup"><span data-stu-id="a2624-105">For Windows applications, this allows time-consuming tasks to be performed in the background while the application window and controls remain responsive.</span></span> <span data-ttu-id="a2624-106">Uygulamalar, çoklu iş parçacığı kullanımı, sunucu için farklı bir iş parçacığına gelen her bir istekle işleyebilme yeteneği sağlar.</span><span class="sxs-lookup"><span data-stu-id="a2624-106">For server applications, multithreading provides the ability to handle each incoming request with a different thread.</span></span> <span data-ttu-id="a2624-107">Önceki istek tam olarak memnun kadar Aksi takdirde, her yeni isteği verilemeyen.</span><span class="sxs-lookup"><span data-stu-id="a2624-107">Otherwise, each new request would not get serviced until the previous request had been fully satisfied.</span></span>  
  
 <span data-ttu-id="a2624-108">Ancak, zaman uyumsuz dosya tanıtıcıları, ağ bağlantıları ve bellek gibi kaynaklara erişen iş parçacığı anlamına gelir yapısını koordine edilmelidir.</span><span class="sxs-lookup"><span data-stu-id="a2624-108">However, the asynchronous nature of threads means that access to resources such as file handles, network connections, and memory must be coordinated.</span></span> <span data-ttu-id="a2624-109">Aksi takdirde, iki veya daha fazla iş parçacığı aynı zamanda, diğer kişinin eylemlerini her farkında aynı kaynağa erişebilir.</span><span class="sxs-lookup"><span data-stu-id="a2624-109">Otherwise, two or more threads could access the same resource at the same time, each unaware of the other's actions.</span></span> <span data-ttu-id="a2624-110">Beklenmeyen veri bozulması sonucudur.</span><span class="sxs-lookup"><span data-stu-id="a2624-110">The result is unpredictable data corruption.</span></span>  
  
 <span data-ttu-id="a2624-111">Tamsayı sayısal veri türleri üzerinde basit işlemleri için iş parçacığı eşitleme üyeleriyle gerçekleştirilebilir <xref:System.Threading.Interlocked> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="a2624-111">For simple operations on integral numeric data types, synchronizing threads can be accomplished with members of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="a2624-112">İçin tüm diğer veri türleri ve iş parçacığı güvenli olmayan kaynaklar, çoklu iş parçacığı kullanımı yalnızca güvenli bir şekilde bu konudaki yapıları kullanarak gerçekleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="a2624-112">For all other data types and non thread-safe resources, multithreading can only be safely performed using the constructs in this topic.</span></span>  
  
 <span data-ttu-id="a2624-113">Çok iş parçacıklı programlama hakkında bilgi için bkz:</span><span class="sxs-lookup"><span data-stu-id="a2624-113">For background information on multithreaded programming, see:</span></span>  
  
-   [<span data-ttu-id="a2624-114">Yönetilen İş Parçacığı Oluşturma Temelleri</span><span class="sxs-lookup"><span data-stu-id="a2624-114">Managed Threading Basics</span></span>](../../../../standard/threading/managed-threading-basics.md)  
  
-   [<span data-ttu-id="a2624-115">İş Parçacıkları ve İş Parçacığı Oluşturmayı Kullanma</span><span class="sxs-lookup"><span data-stu-id="a2624-115">Using Threads and Threading</span></span>](../../../../standard/threading/using-threads-and-threading.md)  
  
-   [<span data-ttu-id="a2624-116">Yönetilen İş Parçacığı Oluşturma En İyi Yöntemleri</span><span class="sxs-lookup"><span data-stu-id="a2624-116">Managed Threading Best Practices</span></span>](../../../../standard/threading/managed-threading-best-practices.md)  
  
## <a name="the-lock-keyword"></a><span data-ttu-id="a2624-117">Lock anahtar sözcüğü</span><span class="sxs-lookup"><span data-stu-id="a2624-117">The lock Keyword</span></span>  
 <span data-ttu-id="a2624-118">C# `lock` deyimi bir kod bloğu kesintisiz tamamlanması için çalıştığından emin olmak için kullanılabilir başka iş parçacıklarının engellemelerinden.</span><span class="sxs-lookup"><span data-stu-id="a2624-118">The C# `lock` statement can be used to ensure that a block of code runs to completion without interruption by other threads.</span></span> <span data-ttu-id="a2624-119">Bu işlem, kod bloğunun süresi için karşılıklı dışlama kilidini belirli nesne elde ederek gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="a2624-119">This is accomplished by obtaining a mutual-exclusion lock for a given object for the duration of the code block.</span></span>  
  
 <span data-ttu-id="a2624-120">A `lock` deyimi bir nesne bir bağımsız değişken olarak verilir ve bir kerede yalnızca bir iş parçacığı tarafından yürütülecek bir kod bloğu tarafından izlenir.</span><span class="sxs-lookup"><span data-stu-id="a2624-120">A `lock` statement is given an object as an argument, and is followed by a code block that is to be executed by only one thread at a time.</span></span> <span data-ttu-id="a2624-121">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="a2624-121">For example:</span></span>  
  
```csharp  
public class TestThreading  
{  
    private System.Object lockThis = new System.Object();  
  
    public void Process()  
    {  
  
        lock (lockThis)  
        {  
            // Access thread-sensitive resources.  
        }  
    }  
  
}  
```  
  
 <span data-ttu-id="a2624-122">Sağlanan bağımsız değişken `lock` anahtar sözcüğü bir başvuru türüne göre bir nesne olmalıdır ve kilit kapsamını tanımlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a2624-122">The argument provided to the `lock` keyword must be an object based on a reference type, and is used to define the scope of the lock.</span></span> <span data-ttu-id="a2624-123">Yukarıdaki örnekte, kilit kapsamı olduğundan bu işleve sınırlıdır nesnesine başvuru `lockThis` dışında işlev yok.</span><span class="sxs-lookup"><span data-stu-id="a2624-123">In the example above, the lock scope is limited to this function because no references to the object `lockThis` exist outside the function.</span></span> <span data-ttu-id="a2624-124">Böyle bir başvuruyu eksik, kilit kapsamı bu nesneye kapsayacak şekilde genişletilebilir.</span><span class="sxs-lookup"><span data-stu-id="a2624-124">If such a reference did exist, lock scope would extend to that object.</span></span> <span data-ttu-id="a2624-125">NET olarak söylemek gerekirse, sağlanan nesne, yalnızca rastgele sınıfı örneğini olabilmeleri birden çok iş parçacıkları arasında paylaşılan kaynağı benzersiz şekilde tanımlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a2624-125">Strictly speaking, the object provided is used solely to uniquely identify the resource being shared among multiple threads, so it can be an arbitrary class instance.</span></span> <span data-ttu-id="a2624-126">Uygulamada, ancak bu nesne genellikle hangi iş parçacığı için eşitleme gereklidir kaynak temsil eder.</span><span class="sxs-lookup"><span data-stu-id="a2624-126">In practice, however, this object usually represents the resource for which thread synchronization is necessary.</span></span> <span data-ttu-id="a2624-127">Örneğin, bir kapsayıcı nesnesi birden çok iş parçacıkları tarafından kullanılacaksa, kilitlemek için kapsayıcı ardından geçirilebilir ve kilit aşağıdaki eşitlenmiş kod bloğu kapsayıcı erişir.</span><span class="sxs-lookup"><span data-stu-id="a2624-127">For example, if a container object is to be used by multiple threads, then the container can be passed to lock, and the synchronized code block following the lock would access the container.</span></span> <span data-ttu-id="a2624-128">Diğer iş parçacıklarını kilit üzerinde sürece aynı erişmeden önce içeren ve ardından nesnesine erişimi güvenli bir şekilde eşitlenir.</span><span class="sxs-lookup"><span data-stu-id="a2624-128">As long as other threads locks on the same contain before accessing it, then access to the object is safely synchronized.</span></span>  
  
 <span data-ttu-id="a2624-129">Genel olarak, üzerinde kilitlenmesini önlemek en iyi bir `public` türü veya uygulamanızı kontrolü nesne örneği.</span><span class="sxs-lookup"><span data-stu-id="a2624-129">Generally, it is best to avoid locking on a `public` type, or on object instances beyond the control of your application.</span></span> <span data-ttu-id="a2624-130">Örneğin, `lock(this)` denetiminiz dışında kod nesne üzerinde kilit çünkü örnek bir genel olarak, erişilebiliyorsa sorunlara neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="a2624-130">For example, `lock(this)` can be problematic if the instance can be accessed publicly, because code beyond your control may lock on the object as well.</span></span> <span data-ttu-id="a2624-131">Bu, burada iki veya daha fazla iş parçacığı aynı nesne sürümü beklemenize kilitlenme durumlar oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="a2624-131">This could create deadlock situations where two or more threads wait for the release of the same object.</span></span> <span data-ttu-id="a2624-132">Bir nesne yerine bir genel veri türü üzerinde kilitleme aynı nedenden dolayı sorunlara neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="a2624-132">Locking on a public data type, as opposed to an object, can cause problems for the same reason.</span></span> <span data-ttu-id="a2624-133">Değişmez değer dizeleri kilitleme özellikle riskli değişmez değer dizeleri olduğundan *interned* ortak dil çalışma zamanı (CLR) tarafından.</span><span class="sxs-lookup"><span data-stu-id="a2624-133">Locking on literal strings is especially risky because literal strings are *interned* by the common language runtime (CLR).</span></span> <span data-ttu-id="a2624-134">Herhangi bir dize örneği için tüm programı sabit değeri, değişmez değer tüm tam aynı nesneyi temsil yani uygulama etki alanları, tüm iş parçacıkları üzerinde çalışıyor.</span><span class="sxs-lookup"><span data-stu-id="a2624-134">This means that there is one instance of any given string literal for the entire program, the exact same object represents the literal in all running application domains, on all threads.</span></span> <span data-ttu-id="a2624-135">Sonuç olarak, bir kilit aynı içeriğe sahip bir dize herhangi bir uygulama işlemi kilitler o dizeyi uygulamanın tüm örneklerini yerleştirildiği.</span><span class="sxs-lookup"><span data-stu-id="a2624-135">As a result, a lock placed on a string with the same contents anywhere in the application process locks all instances of that string in the application.</span></span> <span data-ttu-id="a2624-136">Sonuç olarak değil interned özel veya korumalı bir üye kilitlemek en iyisidir.</span><span class="sxs-lookup"><span data-stu-id="a2624-136">As a result, it is best to lock a private or protected member that is not interned.</span></span> <span data-ttu-id="a2624-137">Bazı sınıflar, özellikle kilitlemek için üyeleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="a2624-137">Some classes provide members specifically for locking.</span></span> <span data-ttu-id="a2624-138"><xref:System.Array> Türü, örneğin sağlar <xref:System.Array.SyncRoot%2A>.</span><span class="sxs-lookup"><span data-stu-id="a2624-138">The <xref:System.Array> type, for example, provides <xref:System.Array.SyncRoot%2A>.</span></span> <span data-ttu-id="a2624-139">Çok sayıda koleksiyon türleri sağlar bir `SyncRoot` üyesi de.</span><span class="sxs-lookup"><span data-stu-id="a2624-139">Many collection types provide a `SyncRoot` member as well.</span></span>  
  
 <span data-ttu-id="a2624-140">Hakkında daha fazla bilgi için `lock` deyimi, aşağıdaki konulara bakın:</span><span class="sxs-lookup"><span data-stu-id="a2624-140">For more information about the `lock` statement, see the following topics:</span></span>  
  
-   [<span data-ttu-id="a2624-141">lock Deyimi</span><span class="sxs-lookup"><span data-stu-id="a2624-141">lock Statement</span></span>](../../../../csharp/language-reference/keywords/lock-statement.md)  
  
-   <xref:System.Threading.Monitor>  
  
## <a name="monitors"></a><span data-ttu-id="a2624-142">İzlemeler</span><span class="sxs-lookup"><span data-stu-id="a2624-142">Monitors</span></span>  
 <span data-ttu-id="a2624-143">Gibi `lock` anahtar sözcüğü, izleyiciler, birden çok iş parçacığı tarafından kod eş zamanlı yürütme taşları önlemek.</span><span class="sxs-lookup"><span data-stu-id="a2624-143">Like the `lock` keyword, monitors prevent blocks of code from simultaneous execution by multiple threads.</span></span> <span data-ttu-id="a2624-144"><xref:System.Threading.Monitor.Enter%2A> Yöntemi aşağıdaki deyimleri devam etmek bir ve yalnızca bir iş parçacığı sağlar; diğer tüm iş parçacıklarının yürütme iş parçacığı çağrı kadar engellenir <xref:System.Threading.Monitor.Exit%2A>.</span><span class="sxs-lookup"><span data-stu-id="a2624-144">The <xref:System.Threading.Monitor.Enter%2A> method allows one and only one thread to proceed into the following statements; all other threads are blocked until the executing thread calls <xref:System.Threading.Monitor.Exit%2A>.</span></span> <span data-ttu-id="a2624-145">Bu, yalnızca kullanma gibi `lock` anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="a2624-145">This is just like using the `lock` keyword.</span></span> <span data-ttu-id="a2624-146">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="a2624-146">For example:</span></span>  
  
```csharp  
lock (x)  
{  
    DoSomething();  
}  
```  
  
 <span data-ttu-id="a2624-147">Bu eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="a2624-147">This is equivalent to:</span></span>  
  
```csharp  
System.Object obj = (System.Object)x;  
System.Threading.Monitor.Enter(obj);  
try  
{  
    DoSomething();  
}  
finally  
{  
    System.Threading.Monitor.Exit(obj);  
}  
```  
  
 <span data-ttu-id="a2624-148">Kullanarak `lock` anahtar sözcüğü, genellikle tercih edilen yerine <xref:System.Threading.Monitor> hem doğrudan, çünkü sınıf `lock` daha kısa olduğundan ve çünkü `lock` bile korunan kod oluşturur, temel alınan İzleyici yayımlanan oluşturmasını sağlar bir özel durum.</span><span class="sxs-lookup"><span data-stu-id="a2624-148">Using the `lock` keyword is generally preferred over using the <xref:System.Threading.Monitor> class directly, both because `lock` is more concise, and because `lock` insures that the underlying monitor is released, even if the protected code throws an exception.</span></span> <span data-ttu-id="a2624-149">Bu ile gerçekleştirilir `finally` anahtar sözcüğü bir özel durum olup bağımsız olarak, ilişkili kod bloğunu yürütür.</span><span class="sxs-lookup"><span data-stu-id="a2624-149">This is accomplished with the `finally` keyword, which executes its associated code block regardless of whether an exception is thrown.</span></span>  
  
## <a name="synchronization-events-and-wait-handles"></a><span data-ttu-id="a2624-150">Eşitleme olayları ve bekleme tanıtıcıları</span><span class="sxs-lookup"><span data-stu-id="a2624-150">Synchronization Events and Wait Handles</span></span>  
 <span data-ttu-id="a2624-151">Bir kilit ya da izleyiciyi kullanarak eşzamanlı iş parçacığı duyarlı kod bloklarının yürütülmesini önlemek için yararlıdır, ancak bu yapıları başka bir olaya iletişim kurmak bir iş parçacığı izin verme.</span><span class="sxs-lookup"><span data-stu-id="a2624-151">Using a lock or monitor is useful for preventing the simultaneous execution of thread-sensitive blocks of code, but these constructs do not allow one thread to communicate an event to another.</span></span> <span data-ttu-id="a2624-152">Bu gerektirir *eşitleme olayları*, iki durumdan birinde olan nesneleri olan sinyal ve geri dönmesine etkinleştirmek ve iş parçacıklarını askıya almak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a2624-152">This requires *synchronization events*, which are objects that have one of two states, signaled and un-signaled, that can be used to activate and suspend threads.</span></span> <span data-ttu-id="a2624-153">İş parçacıkları unsignaled bir eşitleme olay beklemek için yapılan tarafından askıya alınabilir ve sinyal olay durumu değiştirerek etkinleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="a2624-153">Threads can be suspended by being made to wait on a synchronization event that is unsignaled, and can be activated by changing the event state to signaled.</span></span> <span data-ttu-id="a2624-154">Ardından bir iş parçacığı zaten işareti olaya beklenecek çalışırsa, iş parçacığı gecikme olmadan yürütme devam eder.</span><span class="sxs-lookup"><span data-stu-id="a2624-154">If a thread attempts to wait on an event that is already signaled, then the thread continues to execute without delay.</span></span>  
  
 <span data-ttu-id="a2624-155">Eşitleme olayları iki tür vardır: <xref:System.Threading.AutoResetEvent>, ve <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="a2624-155">There are two kinds of synchronization events: <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="a2624-156">Yalnızca, farklı <xref:System.Threading.AutoResetEvent> değişikliklerden sinyal çok unsignaled otomatik olarak istediğiniz zaman, bir iş parçacığı etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="a2624-156">They differ only in that <xref:System.Threading.AutoResetEvent> changes from signaled to unsignaled automatically any time it activates a thread.</span></span> <span data-ttu-id="a2624-157">Buna karşılık, bir <xref:System.Threading.ManualResetEvent> herhangi bir sayıda sinyal durumuna göre etkinleştirilmesi için iş parçacığı verir ve yalnızca bir unsignaled döner durumuna kendi <xref:System.Threading.EventWaitHandle.Reset%2A> yöntemi çağrılır.</span><span class="sxs-lookup"><span data-stu-id="a2624-157">Conversely, a <xref:System.Threading.ManualResetEvent> allows any number of threads to be activated by its signaled state, and will only revert to an unsignaled state when its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="a2624-158">İş parçacıkları olayları bekleme yöntemleri çağıran bir tarafından gibi bekleyin yapılabilir <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, veya <xref:System.Threading.WaitHandle.WaitAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="a2624-158">Threads can be made to wait on events by calling one of the wait methods, such as <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="a2624-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> tek bir olay sinyal haline gelir kadar beklenecek iş parçacığının neden <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> bir veya daha fazla belirtilen olayları sinyal haline kadar bir iş parçacığını engeller ve <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> belirtilen olayların tümünü sinyal haline kadar iş parçacığını engeller.</span><span class="sxs-lookup"><span data-stu-id="a2624-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> causes the thread to wait until a single event becomes signaled, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> blocks a thread until one or more indicated events become signaled, and <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> blocks the thread until all of the indicated events become signaled.</span></span> <span data-ttu-id="a2624-160">Bir olayın sinyal haline gelir, kendi <xref:System.Threading.EventWaitHandle.Set%2A> yöntemi çağrılır.</span><span class="sxs-lookup"><span data-stu-id="a2624-160">An event becomes signaled when its <xref:System.Threading.EventWaitHandle.Set%2A> method is called.</span></span>  
  
 <span data-ttu-id="a2624-161">Aşağıdaki örnekte, bir iş parçacığı oluşturulur ve başlangıç `Main` işlevi.</span><span class="sxs-lookup"><span data-stu-id="a2624-161">In the following example, a thread is created and started by the `Main` function.</span></span> <span data-ttu-id="a2624-162">Yeni iş parçacığı kullanarak bir olay bekler <xref:System.Threading.WaitHandle.WaitOne%2A> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="a2624-162">The new thread waits on an event using the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="a2624-163">Yürütülmekte olan birincil iş parçacığı tarafından olayın sinyal haline gelir kadar iş parçacığı askıda `Main` işlevi.</span><span class="sxs-lookup"><span data-stu-id="a2624-163">The thread is suspended until the event becomes signaled by the primary thread that is executing the `Main` function.</span></span> <span data-ttu-id="a2624-164">Olayın sinyal haline gelir sonra ikincil iş parçacığı döndürür.</span><span class="sxs-lookup"><span data-stu-id="a2624-164">Once the event becomes signaled, the auxiliary thread returns.</span></span> <span data-ttu-id="a2624-165">Bu durumda, olay yalnızca tek bir iş parçacığı etkinleştirme için ya da kullanıldığından <xref:System.Threading.AutoResetEvent> veya <xref:System.Threading.ManualResetEvent> sınıfları kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a2624-165">In this case, because the event is only used for one thread activation, either the <xref:System.Threading.AutoResetEvent> or <xref:System.Threading.ManualResetEvent> classes could be used.</span></span>  
  
```csharp  
using System;  
using System.Threading;  
  
class ThreadingExample  
{  
    static AutoResetEvent autoEvent;  
  
    static void DoWork()  
    {  
        Console.WriteLine("   worker thread started, now waiting on event...");  
        autoEvent.WaitOne();  
        Console.WriteLine("   worker thread reactivated, now exiting...");  
    }  
  
    static void Main()  
    {  
        autoEvent = new AutoResetEvent(false);  
  
        Console.WriteLine("main thread starting worker thread...");  
        Thread t = new Thread(DoWork);  
        t.Start();  
  
        Console.WriteLine("main thread sleeping for 1 second...");  
        Thread.Sleep(1000);  
  
        Console.WriteLine("main thread signaling worker thread...");  
        autoEvent.Set();  
    }  
}  
```  
  
## <a name="mutex-object"></a><span data-ttu-id="a2624-166">Mutex nesnesi</span><span class="sxs-lookup"><span data-stu-id="a2624-166">Mutex Object</span></span>  
 <span data-ttu-id="a2624-167">A *mutex* bir izleme; benzer, kod bloğunun aynı anda yürütülmesini birden fazla iş parçacığı tarafından aynı anda engeller.</span><span class="sxs-lookup"><span data-stu-id="a2624-167">A *mutex* is similar to a monitor; it prevents the simultaneous execution of a block of code by more than one thread at a time.</span></span> <span data-ttu-id="a2624-168">Aslında, adı "mutex" bir "birbirini." terimi kısaltılmış biçimindedir</span><span class="sxs-lookup"><span data-stu-id="a2624-168">In fact, the name "mutex" is a shortened form of the term "mutually exclusive."</span></span> <span data-ttu-id="a2624-169">İzleyicilerin aksine, ancak iş parçacıkları süreçler arasında eşitlemek için bir mutex kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="a2624-169">Unlike monitors, however, a mutex can be used to synchronize threads across processes.</span></span> <span data-ttu-id="a2624-170">Bir mutex tarafından temsil edilen <xref:System.Threading.Mutex> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="a2624-170">A mutex is represented by the <xref:System.Threading.Mutex> class.</span></span>  
  
 <span data-ttu-id="a2624-171">İşlemler arası eşitleme için kullanıldığında, bir mutex olarak adlandırılan bir *adlandırılmış mutex* , başka bir uygulamada kullanılmak üzere olduğundan ve bu nedenle bir genel veya statik değişken yoluyla paylaşılamaz.</span><span class="sxs-lookup"><span data-stu-id="a2624-171">When used for inter-process synchronization, a mutex is called a *named mutex* because it is to be used in another application, and therefore it cannot be shared by means of a global or static variable.</span></span> <span data-ttu-id="a2624-172">Her iki uygulama aynı mutex nesnesi erişebilmesi için bir ad verilmelidir.</span><span class="sxs-lookup"><span data-stu-id="a2624-172">It must be given a name so that both applications can access the same mutex object.</span></span>  
  
 <span data-ttu-id="a2624-173">İşlem içi iş parçacığı eşitleme için bir mutex kullanılabilse kullanarak <xref:System.Threading.Monitor> izleyiciler .NET Framework için özellikle tasarlanmış için genellikle tercih edilir ve bu nedenle daha iyi kaynak kullanımını olun.</span><span class="sxs-lookup"><span data-stu-id="a2624-173">Although a mutex can be used for intra-process thread synchronization, using <xref:System.Threading.Monitor> is generally preferred, because monitors were designed specifically for the .NET Framework and therefore make better use of resources.</span></span> <span data-ttu-id="a2624-174">Buna karşılık, <xref:System.Threading.Mutex> bir Win32 yapısı için bir sarmalayıcı sınıftır.</span><span class="sxs-lookup"><span data-stu-id="a2624-174">In contrast, the <xref:System.Threading.Mutex> class is a wrapper to a Win32 construct.</span></span> <span data-ttu-id="a2624-175">Bir izleyici daha güçlü olsa da, bir mutex tarafından gerekli olandan daha fazla hesaplama açısından pahalıdır birlikte çalışma geçişleri gerektirir <xref:System.Threading.Monitor> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="a2624-175">While it is more powerful than a monitor, a mutex requires interop transitions that are more computationally expensive than those required by the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="a2624-176">Bir mutex kullanılması, bir örnek için bkz. [mutex'ler](../../../../standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="a2624-176">For an example of using a mutex, see [Mutexes](../../../../standard/threading/mutexes.md).</span></span>  
  
## <a name="interlocked-class"></a><span data-ttu-id="a2624-177">Interlocked sınıfı</span><span class="sxs-lookup"><span data-stu-id="a2624-177">Interlocked Class</span></span>  
 <span data-ttu-id="a2624-178">Yöntemlerini kullanabilirsiniz <xref:System.Threading.Interlocked> birden çok iş parçacığı aynı anda güncelleştirme ya da aynı değeri ile karşılaştırmak istediğinizde oluşabilecek sorunları önlemek için sınıf.</span><span class="sxs-lookup"><span data-stu-id="a2624-178">You can use the methods of the <xref:System.Threading.Interlocked> class to prevent problems that can occur when multiple threads attempt to simultaneously update or compare the same value.</span></span> <span data-ttu-id="a2624-179">Bu sınıftaki yöntemleri güvenli bir şekilde artışı sağlar, azaltma, exchange ve herhangi bir iş parçacığı değerlerini karşılaştırın.</span><span class="sxs-lookup"><span data-stu-id="a2624-179">The methods of this class let you safely increment, decrement, exchange, and compare values from any thread.</span></span>  
  
## <a name="readerwriter-locks"></a><span data-ttu-id="a2624-180">ReaderWriter kilitleri</span><span class="sxs-lookup"><span data-stu-id="a2624-180">ReaderWriter Locks</span></span>  
 <span data-ttu-id="a2624-181">Bazı durumlarda, yalnızca veri yazılmakta olan, bir kaynak kilidi ve birden çok istemciye veri güncelleştirilmiyor aynı anda verilerini okumaya izin vermek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a2624-181">In some cases, you may want to lock a resource only when data is being written and permit multiple clients to simultaneously read data when data is not being updated.</span></span> <span data-ttu-id="a2624-182"><xref:System.Threading.ReaderWriterLock> Sınıfı bir iş parçacığı kaynak değiştiriyor, ancak kaynağı okunurken münhasır olmayan erişim sağlayan bir kaynağa özel erişim zorlar.</span><span class="sxs-lookup"><span data-stu-id="a2624-182">The <xref:System.Threading.ReaderWriterLock> class enforces exclusive access to a resource while a thread is modifying the resource, but it allows non-exclusive access when reading the resource.</span></span> <span data-ttu-id="a2624-183">ReaderWriter kilitleri beklemek bile, bu iş parçacıkları verileri güncelleştirmek gerekmez, diğer iş parçacıklarını neden özel bir kilit kullanışlı bir alternatiftir.</span><span class="sxs-lookup"><span data-stu-id="a2624-183">ReaderWriter locks are a useful alternative to exclusive locks, which cause other threads to wait, even when those threads do not need to update data.</span></span>  
  
## <a name="deadlocks"></a><span data-ttu-id="a2624-184">Kilitlenmeler</span><span class="sxs-lookup"><span data-stu-id="a2624-184">Deadlocks</span></span>  
 <span data-ttu-id="a2624-185">Çok iş parçacıklı uygulamalarda çok iş parçacığı eşitleme, ancak her zaman oluşturma olma tehlikesi yoktur bir `deadlock`burada diğer için bekleyen birden çok iş parçacığı ve uygulama bir durmasına gelir.</span><span class="sxs-lookup"><span data-stu-id="a2624-185">Thread synchronization is invaluable in multithreaded applications, but there is always the danger of creating a `deadlock`, where multiple threads are waiting for each other and the application comes to a halt.</span></span> <span data-ttu-id="a2624-186">Bir dört yönlü durağında otomobiller durdurulur ve her kişinin diğer gitmek bekleyen bir duruma yönelik bir kilitlenme benzerdir.</span><span class="sxs-lookup"><span data-stu-id="a2624-186">A deadlock is analogous to a situation in which cars are stopped at a four-way stop and each person is waiting for the other to go.</span></span> <span data-ttu-id="a2624-187">Kilitlenmeler kaçınmak önemlidir; dikkatli planlama anahtardır.</span><span class="sxs-lookup"><span data-stu-id="a2624-187">Avoiding deadlocks is important; the key is careful planning.</span></span> <span data-ttu-id="a2624-188">Kodlama başlamadan önce çok iş parçacıklı uygulamalar diyagram tarafından kilitlenmesi durumda genellikle tahmin edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a2624-188">You can often predict deadlock situations by diagramming multithreaded applications before you start coding.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a2624-189">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="a2624-189">See Also</span></span>  
 <xref:System.Threading.Thread>  
 <xref:System.Threading.WaitHandle.WaitOne%2A>  
 <xref:System.Threading.WaitHandle.WaitAny%2A>  
 <xref:System.Threading.WaitHandle.WaitAll%2A>  
 <xref:System.Threading.Thread.Join%2A>  
 <xref:System.Threading.Thread.Start%2A>  
 <xref:System.Threading.Thread.Sleep%2A>  
 <xref:System.Threading.Monitor>  
 <xref:System.Threading.Mutex>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 <xref:System.Threading.Interlocked>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading>  
 <xref:System.Threading.EventWaitHandle.Set%2A>  
 <xref:System.Threading.Monitor>  
 [<span data-ttu-id="a2624-190">lock Deyimi</span><span class="sxs-lookup"><span data-stu-id="a2624-190">lock Statement</span></span>](../../../../csharp/language-reference/keywords/lock-statement.md)  
 [<span data-ttu-id="a2624-191">Karşılıklı dışlamalar</span><span class="sxs-lookup"><span data-stu-id="a2624-191">Mutexes</span></span>](../../../../standard/threading/mutexes.md)  
 [<span data-ttu-id="a2624-192">Birbirine Kenetlenmiş İşlemler</span><span class="sxs-lookup"><span data-stu-id="a2624-192">Interlocked Operations</span></span>](../../../../standard/threading/interlocked-operations.md)  
 [<span data-ttu-id="a2624-193">AutoResetEvent</span><span class="sxs-lookup"><span data-stu-id="a2624-193">AutoResetEvent</span></span>](../../../../standard/threading/autoresetevent.md)  
 [<span data-ttu-id="a2624-194">Çoklu İş Parçacığı Kullanımı için Veri Eşitleme</span><span class="sxs-lookup"><span data-stu-id="a2624-194">Synchronizing Data for Multithreading</span></span>](../../../../standard/threading/synchronizing-data-for-multithreading.md)

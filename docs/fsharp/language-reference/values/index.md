---
title: Değerler (F#)
description: 'F # değerleri belirli bir türe sahip miktarları nasıl olduğunu öğrenin.'
ms.date: 05/16/2016
ms.openlocfilehash: 4d2874a694d9c39048a28827be858cba499dca87
ms.sourcegitcommit: e5bb395ec86f536e114314184288f40a8c745e2e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/12/2018
ms.locfileid: "34149120"
---
# <a name="values"></a><span data-ttu-id="2142c-103">Değerler</span><span class="sxs-lookup"><span data-stu-id="2142c-103">Values</span></span>

<span data-ttu-id="2142c-104">F # belirli bir türe sahip miktarları değerler; değerleri tamsayı veya kayan nokta sayıları, karakter veya metin, listeler, dizileri, dizileri, diziler, ayrılmış birleşimler, kayıtları, sınıf türleri veya işlevi değerleri olabilir.</span><span class="sxs-lookup"><span data-stu-id="2142c-104">Values in F# are quantities that have a specific type; values can be integral or floating point numbers, characters or text, lists, sequences, arrays, tuples, discriminated unions, records, class types, or function values.</span></span>


## <a name="binding-a-value"></a><span data-ttu-id="2142c-105">Bir değer bağlama</span><span class="sxs-lookup"><span data-stu-id="2142c-105">Binding a Value</span></span>
<span data-ttu-id="2142c-106">Terim *bağlama* bir adı bir tanımıyla ilişkilendirme anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="2142c-106">The term *binding* means associating a name with a definition.</span></span> <span data-ttu-id="2142c-107">`let` Anahtar sözcüğü bağlar aşağıdaki örneklerde olduğu gibi bir değer:</span><span class="sxs-lookup"><span data-stu-id="2142c-107">The `let` keyword binds a value, as in the following examples:</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet601.fs)]

<span data-ttu-id="2142c-108">Bir değerin türü tanımı algılanır.</span><span class="sxs-lookup"><span data-stu-id="2142c-108">The type of a value is inferred from the definition.</span></span> <span data-ttu-id="2142c-109">Bir tam sayı veya kayan nokta sayısı gibi basit bir tür için türü sabit türünden belirlenir.</span><span class="sxs-lookup"><span data-stu-id="2142c-109">For a primitive type, such as an integral or floating point number, the type is determined from the type of the literal.</span></span> <span data-ttu-id="2142c-110">Bu nedenle, önceki örnekte türü derleyici oluşturur `b` olmasını `unsigned int`, türü derleyici oluşturur ancak `a` olmasını `int`.</span><span class="sxs-lookup"><span data-stu-id="2142c-110">Therefore, in the previous example, the compiler infers the type of `b` to be `unsigned int`, whereas the compiler infers the type of `a` to be `int`.</span></span> <span data-ttu-id="2142c-111">Bir işlev değerin türü, işlev gövdesi dönüş değerden belirlenir.</span><span class="sxs-lookup"><span data-stu-id="2142c-111">The type of a function value is determined from the return value in the function body.</span></span> <span data-ttu-id="2142c-112">İşlev değer türleri hakkında daha fazla bilgi için bkz: [işlevler](../functions/index.md).</span><span class="sxs-lookup"><span data-stu-id="2142c-112">For more information about function value types, see [Functions](../functions/index.md).</span></span> <span data-ttu-id="2142c-113">Değişmez değer türleri hakkında daha fazla bilgi için bkz: [değişmez değerleri](../literals.md).</span><span class="sxs-lookup"><span data-stu-id="2142c-113">For more information about literal types, see [Literals](../literals.md).</span></span>

<span data-ttu-id="2142c-114">Derleyici, varsayılan olarak kullanılmayan bağlamaları hakkında tanılama kesmez.</span><span class="sxs-lookup"><span data-stu-id="2142c-114">The compiler does not issue diagnostics about unused bindings by default.</span></span> <span data-ttu-id="2142c-115">Bu iletiler almayı etkinleştirme 1182 proje dosyası veya derleyici çağrılırken, uyarı (bkz `--warnon` altında [derleyici seçenekleri](../compiler-options.md)).</span><span class="sxs-lookup"><span data-stu-id="2142c-115">To receive these messages, enable warning 1182 in your project file or when invoking the compiler (see `--warnon` under [Compiler Options](../compiler-options.md)).</span></span>

## <a name="why-immutable"></a><span data-ttu-id="2142c-116">Değişmez neden?</span><span class="sxs-lookup"><span data-stu-id="2142c-116">Why Immutable?</span></span>
<span data-ttu-id="2142c-117">Değişmez değerler bir programın yürütme seyri değiştirilemez değerlerdir.</span><span class="sxs-lookup"><span data-stu-id="2142c-117">Immutable values are values that cannot be changed throughout the course of a program's execution.</span></span> <span data-ttu-id="2142c-118">C++, Visual Basic veya C# gibi diller için kullandıysanız, şaşırtıcı F # primacy bir program yürütülmesi sırasında yeni değerler atanabilir değişkenleri yerine değişmez değerler üzerinden geçirir olduğunu görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2142c-118">If you are used to languages such as C++, Visual Basic, or C#, you might find it surprising that F# puts primacy over immutable values rather than variables that can be assigned new values during the execution of a program.</span></span> <span data-ttu-id="2142c-119">Sabit veri işlevsel programlama önemli bir öğedir.</span><span class="sxs-lookup"><span data-stu-id="2142c-119">Immutable data is an important element of functional programming.</span></span> <span data-ttu-id="2142c-120">Birden çok iş parçacıklı bir ortamda, birçok farklı iş parçacıkları tarafından değiştirilebilecek paylaşılan değişebilir yönetmek zor değişkenlerdir.</span><span class="sxs-lookup"><span data-stu-id="2142c-120">In a multithreaded environment, shared mutable variables that can be changed by many different threads are difficult to manage.</span></span> <span data-ttu-id="2142c-121">Ayrıca, değişebilir değişkenlerle, bazen başka bir işleve geçirildiğinde bir değişken değişebilir varsa söyleyin zor olabilir.</span><span class="sxs-lookup"><span data-stu-id="2142c-121">Also, with mutable variables, it can sometimes be hard to tell if a variable might be changed when it is passed to another function.</span></span>

<span data-ttu-id="2142c-122">Saf işlevsel dillerin değişken vardır ve işlevler kesinlikle matematik işlevleri olarak davranır.</span><span class="sxs-lookup"><span data-stu-id="2142c-122">In pure functional languages, there are no variables, and functions behave strictly as mathematical functions.</span></span> <span data-ttu-id="2142c-123">Yordam bir dil kodu değeri değiştirmek için bir değişken ataması kullandığı yerde, işlevsel bir dilde eşdeğer kod giriş, sabit bir işlev ve farklı değişmez değerler çıktısı olarak bir sabit değere sahip.</span><span class="sxs-lookup"><span data-stu-id="2142c-123">Where code in a procedural language uses a variable assignment to alter a value, the equivalent code in a functional language has an immutable value that is the input, an immutable function, and different immutable values as the output.</span></span> <span data-ttu-id="2142c-124">Bu matematik strictness program davranışı hakkında akıl daha sıkı sağlar.</span><span class="sxs-lookup"><span data-stu-id="2142c-124">This mathematical strictness allows for tighter reasoning about the behavior of the program.</span></span> <span data-ttu-id="2142c-125">Ne derleyicileri kodu daha kesin denetlemek ve daha etkili bir şekilde en iyi duruma getirmek için sağlayan daha sıkı bu mantığı olan ve geliştiricilerin anlamak ve doğru kod yazmak kolaylaştırmak yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="2142c-125">This tighter reasoning is what enables compilers to check code more stringently and to optimize more effectively, and helps make it easier for developers to understand and write correct code.</span></span> <span data-ttu-id="2142c-126">İşlevsel kod bu nedenle daha sıradan yordam kod hatalarını ayıklamak daha kolay olması olasıdır.</span><span class="sxs-lookup"><span data-stu-id="2142c-126">Functional code is therefore likely to be easier to debug than ordinary procedural code.</span></span>

<span data-ttu-id="2142c-127">F # saf işlevsel bir dil değil henüz tam olarak işlevsel programlama destekler.</span><span class="sxs-lookup"><span data-stu-id="2142c-127">F# is not a pure functional language, yet it fully supports functional programming.</span></span> <span data-ttu-id="2142c-128">Bunun yapılması önemli bir işlevsel programlama açısından yararlanmak kodunuzu verdiğinden değişmez değerleri kullanarak iyi bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="2142c-128">Using immutable values is a good practice because doing this allows your code to benefit from an important aspect of functional programming.</span></span>


## <a name="mutable-variables"></a><span data-ttu-id="2142c-129">Değişebilir değişkenleri</span><span class="sxs-lookup"><span data-stu-id="2142c-129">Mutable Variables</span></span>
<span data-ttu-id="2142c-130">Anahtar sözcüğünü kullanabilirsiniz `mutable` değiştirilebilir bir değişken olarak belirtmek için.</span><span class="sxs-lookup"><span data-stu-id="2142c-130">You can use the keyword `mutable` to specify a variable that can be changed.</span></span> <span data-ttu-id="2142c-131">F # değişebilir değişkenleri, genel bir türünde bir alan veya bir yerel değer olarak sınırlı bir kapsam olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="2142c-131">Mutable variables in F# should generally have a limited scope, either as a field of a type or as a local value.</span></span> <span data-ttu-id="2142c-132">Sınırlı kapsam değişebilir değişkenlerle denetlemek için daha kolay ve yanlış şekilde değiştirilmiş olasılığı daha düşüktür.</span><span class="sxs-lookup"><span data-stu-id="2142c-132">Mutable variables with a limited scope are easier to control and are less likely to be modified in incorrect ways.</span></span>

<span data-ttu-id="2142c-133">Kullanarak bir başlangıç değeri değişebilir bir değişkene atayabilirsiniz `let` anahtar ile aynı şekilde bir değer tanımlamanız.</span><span class="sxs-lookup"><span data-stu-id="2142c-133">You can assign an initial value to a mutable variable by using the `let` keyword in the same way as you would define a value.</span></span> <span data-ttu-id="2142c-134">Ancak, daha sonra yeni değerleri değişebilir değişkenlere kullanarak atayabilirsiniz olduğunu farktır `<-` aşağıdaki örnekteki gibi işleci.</span><span class="sxs-lookup"><span data-stu-id="2142c-134">However, the difference is that you can subsequently assign new values to mutable variables by using the `<-` operator, as in the following example.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet602.fs)]

<span data-ttu-id="2142c-135">İşaretli değerleri `mutable` için otomatik olarak yükseltilebilir `'a ref` kapatma tarafından yakalanan, kapanışlar, gibi oluşturmasına formlar dahil `seq` oluşturucular.</span><span class="sxs-lookup"><span data-stu-id="2142c-135">Values marked `mutable` may be automatically promoted to `'a ref` if captured by a closure, including forms that create closures, such as `seq` builders.</span></span> <span data-ttu-id="2142c-136">Bu meydana geldiğinde bildirim almak istiyorsanız, uyarı etkinleştirin 3180 proje dosyası veya derleyicisini çağırma.</span><span class="sxs-lookup"><span data-stu-id="2142c-136">If you wish to be notified when this occurs, enable warning 3180 in your project file or when invoking the compiler.</span></span>
    
## <a name="related-topics"></a><span data-ttu-id="2142c-137">İlgili Konular</span><span class="sxs-lookup"><span data-stu-id="2142c-137">Related Topics</span></span>


|<span data-ttu-id="2142c-138">Başlık</span><span class="sxs-lookup"><span data-stu-id="2142c-138">Title</span></span>|<span data-ttu-id="2142c-139">Açıklama</span><span class="sxs-lookup"><span data-stu-id="2142c-139">Description</span></span>|
|-----|-----------|
|[<span data-ttu-id="2142c-140">let Bağlamaları</span><span class="sxs-lookup"><span data-stu-id="2142c-140">let Bindings</span></span>](../functions/let-bindings.md)|<span data-ttu-id="2142c-141">Kullanma hakkında bilgi sağlar `let` değerlerin ve işlevlerin adlarını bağlamak için anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="2142c-141">Provides information about using the `let` keyword to bind names to values and functions.</span></span>|
|[<span data-ttu-id="2142c-142">İşlevler</span><span class="sxs-lookup"><span data-stu-id="2142c-142">Functions</span></span>](../functions/index.md)|<span data-ttu-id="2142c-143">F # işlevleri genel bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="2142c-143">Provides an overview of functions in F#.</span></span>|

## <a name="see-also"></a><span data-ttu-id="2142c-144">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="2142c-144">See Also</span></span>
[<span data-ttu-id="2142c-145">Null Değerler</span><span class="sxs-lookup"><span data-stu-id="2142c-145">Null Values</span></span>](null-Values.md)

[<span data-ttu-id="2142c-146">F# Dili Başvurusu</span><span class="sxs-lookup"><span data-stu-id="2142c-146">F# Language Reference</span></span>](../index.md)

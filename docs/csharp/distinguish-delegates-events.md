---
title: "Temsilciler ve olaylar ayrım"
description: "Temsilciler ve olaylar ve ne zaman .NET Core, bu özelliklerin her biri kullanılacağı arasındaki fark hakkında bilgi edinin."
keywords: .NET, .NET core
author: BillWagner
ms.author: wiwagn
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: 3026a0d853cb17dcf05d3b98d814044d743e48dc
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/18/2017
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="ce6a2-104">Temsilciler ve olaylar ayrım</span><span class="sxs-lookup"><span data-stu-id="ce6a2-104">Distinguishing Delegates and Events</span></span>

[<span data-ttu-id="ce6a2-105">Önceki</span><span class="sxs-lookup"><span data-stu-id="ce6a2-105">Previous</span></span>](modern-events.md)

<span data-ttu-id="ce6a2-106">Genellikle .NET Core platformuna yeni geliştiriciler güçlük arasında bir tasarıma karar temel `delegates` ve temel tasarım `events`.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-106">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="ce6a2-107">İki dil özellikleri çok benzer zor bir kavram olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-107">This is a difficult concept, because the two language features are very similar.</span></span> <span data-ttu-id="ce6a2-108">Olayları bile temsilciler için dil desteği kullanılarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-108">Events are even built using the language support for delegates.</span></span> 

<span data-ttu-id="ce6a2-109">Her ikisi de geç bağlama senaryosu sunar: bir bileşeni iletişim kurar burada yalnızca çalışma zamanında bilinen bir yöntemini çağırarak senaryoları etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-109">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="ce6a2-110">Her ikisi de tek ve birden çok abone yöntemleri destekler.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-110">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="ce6a2-111">Bu singlecast olarak da adlandırılır ve çok noktaya yayın desteği bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-111">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="ce6a2-112">Her ikisi de benzer sözdizimi ekleme ve kaldırma işleyicileri için destek.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-112">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="ce6a2-113">Son olarak, bir olay oluşturma ve bir temsilci çağırma tam olarak aynı yöntemi çağrı sözdizimini kullanın.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-113">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="ce6a2-114">Her ikisi de bile aynı destek `Invoke()` yöntem sözdizimi ile kullanılmak üzere `?.` işleci.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-114">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="ce6a2-115">Bu benzerlikler ile ne zaman hangi kullanılacağını belirleme güçlük kolaydır.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-115">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="ce6a2-116">İsteğe bağlı olduğunda olayları dinleme</span><span class="sxs-lookup"><span data-stu-id="ce6a2-116">Listening to Events is Optional</span></span>

<span data-ttu-id="ce6a2-117">Ekli abone olmalıdır desteklemediğini kullanmak için hangi dil özelliği belirlemede en önemli noktadır.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-117">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="ce6a2-118">Kodunuzu abone tarafından sağlanan kod çağırmalısınız yetkililer dayalı bir tasarım kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-118">If your code must call the code supplied by the subscriber, you should use a design based on delegates.</span></span> <span data-ttu-id="ce6a2-119">Kodunuzu, tüm aboneler çağırmadan tüm çalışmasını tamamlayabilir olaylara dayanarak bir tasarım kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-119">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span> 

<span data-ttu-id="ce6a2-120">Bu bölümde sırasında oluşturulan örneklere bakın.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-120">Consider the examples built during this section.</span></span> <span data-ttu-id="ce6a2-121">Yerleşik kullanarak kod `List.Sort()` düzgün öğeleri sıralamak için bir karşılaştırıcı işlevi verilmelidir.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-121">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="ce6a2-122">LINQ sorgularını döndürmek için hangi öğelerin belirlemek için temsilciler ile sağlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-122">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="ce6a2-123">Her ikisi de temsilciler ile yerleşik bir tasarım kullanılır.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-123">Both used a design built with delegates.</span></span>

<span data-ttu-id="ce6a2-124">Göz önünde bulundurun `Progress` olay.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-124">Consider the `Progress` event.</span></span> <span data-ttu-id="ce6a2-125">İlerleme görevde rapor.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-125">It reports progress on a task.</span></span>
<span data-ttu-id="ce6a2-126">Görev vardır olup olmadığına bakılmaksızın tüm dinleyiciler devam etmek devam eder.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-126">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="ce6a2-127">`FileSearcher` Başka bir örnektir.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-127">The `FileSearcher` is another example.</span></span> <span data-ttu-id="ce6a2-128">Hala arama ve bile bağlı hiçbir olay aboneleri ile Aranan tüm dosyaları bulur.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-128">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="ce6a2-129">Olayları dinleme abone olduğunda bile UX denetimleri hala düzgün çalışır.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-129">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="ce6a2-130">Her ikisi de olaylara dayanarak tasarımları kullanın.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-130">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="ce6a2-131">Dönüş değerleri temsilciler gerektirir</span><span class="sxs-lookup"><span data-stu-id="ce6a2-131">Return Values Require Delegates</span></span>

<span data-ttu-id="ce6a2-132">Temsilci yönteminizi istersiniz yöntemi prototip başka bir konudur.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-132">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="ce6a2-133">Gördüğünüz gibi tüm olaylar için kullanılan temsilciler geçersiz bir dönüş türüne sahip.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-133">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="ce6a2-134">Ayrıca, bilgileri olay bağımsız değişkeni nesnenin özelliklerini değiştirme aracılığıyla geri olay kaynakları için kullandıkları olay işleyicileri oluşturmak için deyimleri olduğunu gördünüz.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-134">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="ce6a2-135">Bu deyimleri çalışırken, bu değer bir yöntemden döndürme olarak olarak doğal değiller.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-135">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="ce6a2-136">Bu iki buluşsal yöntemler çoğunlukla her ikisi de olabilir, dikkat edin: temsilci yöntemi bir değer döndürürse, büyük olasılıkla algoritması şekilde etkiler.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-136">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="ce6a2-137">Olay dinleyicileri genellikle uzun ömürleri vardır</span><span class="sxs-lookup"><span data-stu-id="ce6a2-137">Event Listeners Often Have Longer Lifetimes</span></span> 

<span data-ttu-id="ce6a2-138">Biraz daha zayıf bir gerekçe budur.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-138">This is a slightly weaker justification.</span></span> <span data-ttu-id="ce6a2-139">Ancak, uzun bir süre boyunca olaylar olay kaynağı oluşturma, olay tabanlı tasarımları daha doğal olduğunu fark edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-139">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="ce6a2-140">Bu örnek birçok sistemi UX denetimler için görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-140">You can see examples of this for UX controls on many systems.</span></span> <span data-ttu-id="ce6a2-141">Olay kaynağı, bir olaya abone olduktan sonra program ömrü boyunca olayları neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-141">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="ce6a2-142">(Artık gereksinim duyduğunuzda olaylarından abonelikten çıkabilirsiniz.)</span><span class="sxs-lookup"><span data-stu-id="ce6a2-142">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="ce6a2-143">Burada bir yöntem bağımsız değişkeni olarak bir temsilci kullanıldığında, birçok temsilci tabanlı tasarımı ile karşıtlık ve bu yöntem döndükten sonra temsilci kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-143">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="ce6a2-144">Dikkatlice değerlendirin</span><span class="sxs-lookup"><span data-stu-id="ce6a2-144">Evaluate Carefully</span></span>

<span data-ttu-id="ce6a2-145">Yukarıdaki konuları sabit ve hızlı kuralları değildir.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-145">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="ce6a2-146">Bunun yerine, hangi belirli kullanımınız için en iyi seçimdir karar vermenize yardımcı olabilir Kılavuzu gösterir.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-146">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="ce6a2-147">Benzer oldukları için prototip hem bile ve bu çalışmak daha doğal olur göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-147">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="ce6a2-148">Her ikisi de geç bağlama senaryoları iyi işler.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-148">They both handle late binding scenarios well.</span></span> <span data-ttu-id="ce6a2-149">Tasarımınızın iletişim kuran bir en iyi kullanın.</span><span class="sxs-lookup"><span data-stu-id="ce6a2-149">Use the one that communicates your design the best.</span></span>

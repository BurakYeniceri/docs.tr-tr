---
title: "Kod Sözleşmeleri"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Code contracts
ms.assetid: 84526045-496f-489d-8517-a258cf76f040
caps.latest.revision: 
author: mairaw
ms.author: mairaw
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: 4a7f6dd2f97f7d57cdaa59d1420a34409804f9dd
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 12/22/2017
---
# <a name="code-contracts"></a><span data-ttu-id="e4511-102">Kod Sözleşmeleri</span><span class="sxs-lookup"><span data-stu-id="e4511-102">Code Contracts</span></span>
<span data-ttu-id="e4511-103">Kod sözleşmeleri önkoşulları, Sonkoşullar ve nesne invariants kodunuzda belirtmek için bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="e4511-103">Code contracts provide a way to specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="e4511-104">Önkoşulları yöntemi veya özelliği girerken karşılanması gereken gereksinimleri verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="e4511-104">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="e4511-105">Sonkoşullar beklentilerini yöntemi veya özelliği kod çıkar aynı anda açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="e4511-105">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="e4511-106">Nesne invariants iyi bir durumda bir sınıfı için beklenen durumu açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="e4511-106">Object invariants describe the expected state for a class that is in a good state.</span></span>  
  
 <span data-ttu-id="e4511-107">Kod sözleşmeleri kodunuzu, derleme zamanı çözümleme için statik bir Çözümleyicisi ve bir çalışma zamanı Çözümleyicisi işaretlemek için sınıflar içerir.</span><span class="sxs-lookup"><span data-stu-id="e4511-107">Code contracts include classes for marking your code, a static analyzer for compile-time analysis, and a runtime analyzer.</span></span> <span data-ttu-id="e4511-108">Kod sözleşmeleri sınıflarını bulunabilir <xref:System.Diagnostics.Contracts> ad alanı.</span><span class="sxs-lookup"><span data-stu-id="e4511-108">The classes for code contracts can be found in the <xref:System.Diagnostics.Contracts> namespace.</span></span>  
  
 <span data-ttu-id="e4511-109">Kod sözleşmeleri avantajları şunlardır:</span><span class="sxs-lookup"><span data-stu-id="e4511-109">The benefits of code contracts include the following:</span></span>  
  
-   <span data-ttu-id="e4511-110">Sınama geliştirilmiş: kod sözleşmeleri statik sözleşme doğrulama, çalışma zamanı denetleniyor ve belgeleri oluşturma sağlar.</span><span class="sxs-lookup"><span data-stu-id="e4511-110">Improved testing: Code contracts provide static contract verification, runtime checking, and documentation generation.</span></span>  
  
-   <span data-ttu-id="e4511-111">Otomatik test araçları: kod sözleşmeleri önkoşulları karşılamadığı anlamsız test bağımsız değişkenleri filtreleyerek daha anlamlı birim testleri oluşturmak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e4511-111">Automatic testing tools: You can use code contracts to generate more meaningful unit tests by filtering out meaningless test arguments that do not satisfy preconditions.</span></span>  
  
-   <span data-ttu-id="e4511-112">Statik doğrulama: statik denetleyicisi programı çalıştırmadan herhangi bir sözleşme ihlal olup olmadığına karar verebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e4511-112">Static verification: The static checker can decide whether there are any contract violations without running the program.</span></span> <span data-ttu-id="e4511-113">Null gibi örtük sözleşmeleri denetler dereferences ve dizi sınırları ve açık sözleşmeleri.</span><span class="sxs-lookup"><span data-stu-id="e4511-113">It checks for implicit contracts, such as null dereferences and array bounds, and explicit contracts.</span></span>  
  
-   <span data-ttu-id="e4511-114">Başvuru belgelerini: Sözleşme bilgilerle varolan XML belge dosyalarını belgelerine Oluşturucu artırmaktadır.</span><span class="sxs-lookup"><span data-stu-id="e4511-114">Reference documentation: The documentation generator augments existing XML documentation files with contract information.</span></span> <span data-ttu-id="e4511-115">Ayrıca ile kullanılan stil sayfaları vardır [Sandcastle](https://github.com/EWSoftware/SHFB) böylece oluşturulan belge sayfalarının sözleşme bölümler.</span><span class="sxs-lookup"><span data-stu-id="e4511-115">There are also style sheets that can be used with [Sandcastle](https://github.com/EWSoftware/SHFB) so that the generated documentation pages have contract sections.</span></span>  
  
 <span data-ttu-id="e4511-116">Tüm .NET Framework diller hemen sözleşmeleri yararlanabilir; bir özel ayrıştırıcı veya derleyici yazmak zorunda değildir.</span><span class="sxs-lookup"><span data-stu-id="e4511-116">All .NET Framework languages can immediately take advantage of contracts; you do not have to write a special parser or compiler.</span></span> <span data-ttu-id="e4511-117">Visual Studio eklentisi gerçekleştirilecek kod sözleşme çözümleme düzeyini belirtmenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="e4511-117">A Visual Studio add-in lets you specify the level of code contract analysis to be performed.</span></span> <span data-ttu-id="e4511-118">Çözümleyiciler sözleşmeleri doğru biçimlendirilmiş olduğunu doğrulayın (tür denetimini gerçekleştireceğini ve ad çözümlemesi) ve Microsoft Ara dili (MSIL) biçiminde sözleşmelerin derlenmiş bir formu üretebilir.</span><span class="sxs-lookup"><span data-stu-id="e4511-118">The analyzers can confirm that the contracts are well-formed (type checking and name resolution) and can produce a compiled form of the contracts in Microsoft intermediate language (MSIL) format.</span></span> <span data-ttu-id="e4511-119">Sözleşmeleri Visual Studio geliştirme, IntelliSense aracı tarafından sağlanan standart yararlanmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="e4511-119">Authoring contracts in Visual Studio lets you take advantage of the standard IntelliSense provided by the tool.</span></span>  
  
 <span data-ttu-id="e4511-120">Sözleşme sınıfı çoğu yöntemleri koşullu derlenen; diğer bir deyişle, yalnızca CONTRACTS_FULL, özel bir simge kullanarak tanımlarken bu yöntemlere çağrılar derleyici yayar `#define` yönergesi.</span><span class="sxs-lookup"><span data-stu-id="e4511-120">Most methods in the contract class are conditionally compiled; that is, the compiler emits calls to these methods only when  you define a special symbol, CONTRACTS_FULL, by using the `#define` directive.</span></span> <span data-ttu-id="e4511-121">CONTRACTS_FULL kullanmadan kodunuzda sözleşmeleri yazmanıza olanak tanır `#ifdef` yönergeleri; farklı derlemeleri, bazı Sözleşmelerle ve bazı olmadan üretebilir.</span><span class="sxs-lookup"><span data-stu-id="e4511-121">CONTRACTS_FULL lets you write contracts in your code without using `#ifdef` directives; you can produce different builds, some with contracts, and some without.</span></span>  
  
 <span data-ttu-id="e4511-122">Araçlar ve kod sözleşmeleri kullanmaya yönelik ayrıntılı yönergeler için bkz: [kod sözleşmeleri](http://go.microsoft.com/fwlink/?LinkId=152461) MSDN DevLabs Web sitesinde.</span><span class="sxs-lookup"><span data-stu-id="e4511-122">For tools and detailed instructions for using code contracts, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
## <a name="preconditions"></a><span data-ttu-id="e4511-123">Önkoşulları</span><span class="sxs-lookup"><span data-stu-id="e4511-123">Preconditions</span></span>  
 <span data-ttu-id="e4511-124">Kullanarak önkoşulları açıklayabilir <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="e4511-124">You can express preconditions by using the <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="e4511-125">Bir yöntem çağrıldığında önkoşulları durumunu belirtin.</span><span class="sxs-lookup"><span data-stu-id="e4511-125">Preconditions specify state when a method is invoked.</span></span> <span data-ttu-id="e4511-126">Bunlar genellikle geçerli parametre değerleri belirtmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e4511-126">They are generally used to specify valid parameter values.</span></span> <span data-ttu-id="e4511-127">Önkoşulları içinde açıklanan tüm üyeleri en az yöntemi olarak olarak erişilebilir olmalıdır; Aksi takdirde önkoşulu tüm bir yöntemini arayanlar tarafından anlaşılmayan.</span><span class="sxs-lookup"><span data-stu-id="e4511-127">All members that are mentioned in preconditions must be at least as accessible as the method itself; otherwise, the precondition might not be understood by all callers of a method.</span></span> <span data-ttu-id="e4511-128">Koşul hiçbir yan etkisi olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e4511-128">The condition must have no side-effects.</span></span> <span data-ttu-id="e4511-129">Başarısız önkoşulları çalışma zamanı davranışını çalışma zamanı Çözümleyicisi tarafından belirlenir.</span><span class="sxs-lookup"><span data-stu-id="e4511-129">The run-time behavior of failed preconditions is determined by the runtime analyzer.</span></span>  
  
 <span data-ttu-id="e4511-130">Örneğin, bu parametre aşağıdaki önkoşulu ifade `x` null olmayan olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e4511-130">For example, the following precondition expresses that parameter `x` must be non-null.</span></span>  
  
 `Contract.Requires( x != null );`  
  
 <span data-ttu-id="e4511-131">Kodunuzu belirli bir özel durum, bir önkoşul hatası durumunda throw gerekir, genel aşırı yüklemesini kullanabilirsiniz <xref:System.Diagnostics.Contracts.Contract.Requires%2A> gibi.</span><span class="sxs-lookup"><span data-stu-id="e4511-131">If your code must throw a particular exception on failure of a precondition, you can use the generic overload of <xref:System.Diagnostics.Contracts.Contract.Requires%2A> as follows.</span></span>  
  
 `Contract.Requires<ArgumentNullException>( x != null, "x" );`  
  
### <a name="legacy-requires-statements"></a><span data-ttu-id="e4511-132">Eski deyimleri gerektirir</span><span class="sxs-lookup"><span data-stu-id="e4511-132">Legacy Requires Statements</span></span>  
 <span data-ttu-id="e4511-133">Bazı parametre doğrulaması biçiminde çoğu kod içeren `if` - `then` - `throw` kodu.</span><span class="sxs-lookup"><span data-stu-id="e4511-133">Most code contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="e4511-134">Sözleşme araçları bu deyimleri önkoşulları aşağıdaki durumlarda olarak algılar:</span><span class="sxs-lookup"><span data-stu-id="e4511-134">The contract tools recognize these statements as preconditions in the following cases:</span></span>  
  
-   <span data-ttu-id="e4511-135">Diğer herhangi bir yöntem deyimlerinde önce deyimleri görünür.</span><span class="sxs-lookup"><span data-stu-id="e4511-135">The statements appear before any other statements in a method.</span></span>  
  
-   <span data-ttu-id="e4511-136">Bu tür ifadeleri kümesinin tamamını açık bir tarafından izlenir <xref:System.Diagnostics.Contracts.Contract> yapılan bir çağrı gibi yöntem çağrısı <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, veya <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="e4511-136">The entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a call to the <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> method.</span></span>  
  
 <span data-ttu-id="e4511-137">Zaman `if` - `then` - `throw` deyimleri araçları tanıması bunları eski bu formda görünen `requires` deyimleri.</span><span class="sxs-lookup"><span data-stu-id="e4511-137">When `if`-`then`-`throw` statements appear in this form, the tools recognize them as legacy `requires` statements.</span></span> <span data-ttu-id="e4511-138">Diğer bir sözleşmeleri izlerseniz `if` - `then` - `throw` serisi, kodla end <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="e4511-138">If no other contracts follow the `if`-`then`-`throw` sequence, end the code with the <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> method.</span></span>  
  
```  
if ( x == null ) throw new ...  
Contract.EndContractBlock(); // All previous "if" checks are preconditions  
```  
  
 <span data-ttu-id="e4511-139">Önceki test koşulunda çevrilerek önkoşulu olduğuna dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="e4511-139">Note that the condition in the preceding test is a negated precondition.</span></span> <span data-ttu-id="e4511-140">(Gerçek önkoşulu olacaktır `x != null`.) Çevrilerek önkoşulu ileri derecede kısıtlı: önceki örnekte; gösterildiği gibi yazılmalıdır diğer bir deyişle, Hayır içermelidir `else` yan tümceleri ve gövdesini `then` yan tümcesi, tek bir olmalıdır `throw` deyimi.</span><span class="sxs-lookup"><span data-stu-id="e4511-140">(The actual precondition would be `x != null`.) A negated precondition is highly restricted: It must be written as shown in the previous example; that is, it should contain no `else` clauses, and the body of the `then` clause must be a single `throw` statement.</span></span> <span data-ttu-id="e4511-141">`if` Test olmak üzere ve görünürlük kuralları tabi olur (bkz [kullanım yönergeleri](#usage_guidelines)), ancak `throw` ifadesidir yalnızca olmak üzere kuralları konu.</span><span class="sxs-lookup"><span data-stu-id="e4511-141">The `if` test is subject to both purity and visibility rules (see [Usage Guidelines](#usage_guidelines)), but the `throw` expression is subject only to purity rules.</span></span> <span data-ttu-id="e4511-142">Ancak, özel durum türünü sözleşme oluştuğu yöntemi olarak olarak görünür olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e4511-142">However, the type of the exception thrown must be as visible as the method in which the contract occurs.</span></span>  
  
## <a name="postconditions"></a><span data-ttu-id="e4511-143">Sonkoşullar</span><span class="sxs-lookup"><span data-stu-id="e4511-143">Postconditions</span></span>  
 <span data-ttu-id="e4511-144">Sonkoşullar durumuna yönelik bir yöntem sözleşmeleri alındığında sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="e4511-144">Postconditions are contracts for the state of a method when it terminates.</span></span> <span data-ttu-id="e4511-145">Sonkoşul bir yöntem çıkmadan önce denetlenir.</span><span class="sxs-lookup"><span data-stu-id="e4511-145">The postcondition is checked just before exiting a method.</span></span> <span data-ttu-id="e4511-146">Başarısız Sonkoşullar çalışma zamanı davranışını çalışma zamanı Çözümleyicisi tarafından belirlenir.</span><span class="sxs-lookup"><span data-stu-id="e4511-146">The run-time behavior of failed postconditions is determined by the runtime analyzer.</span></span>  
  
 <span data-ttu-id="e4511-147">Önkoşulları, daha az görünürlük üyeleriyle Sonkoşullar başvurabilir.</span><span class="sxs-lookup"><span data-stu-id="e4511-147">Unlike preconditions, postconditions may reference members with less visibility.</span></span> <span data-ttu-id="e4511-148">Bir istemci anlamak veya yapmak mümkün olmayabilir bazı özel durumu kullanarak Sonkoşul ifade edilen bilgileri kullanır, ancak bu istemcinin yöntemi doğru bir şekilde kullanma yeteneğini etkilemez.</span><span class="sxs-lookup"><span data-stu-id="e4511-148">A client may not be able to understand or make use of some of the information expressed by a postcondition using private state, but this does not affect the client's ability to use the method correctly.</span></span>  
  
### <a name="standard-postconditions"></a><span data-ttu-id="e4511-149">Standart Sonkoşullar</span><span class="sxs-lookup"><span data-stu-id="e4511-149">Standard Postconditions</span></span>  
 <span data-ttu-id="e4511-150">Kullanarak standart Sonkoşullar açıklayabilir <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="e4511-150">You can express standard postconditions by using the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method.</span></span> <span data-ttu-id="e4511-151">Sonkoşullar express olmalıdır bir koşul `true` yönteminin normal sonlandırmada.</span><span class="sxs-lookup"><span data-stu-id="e4511-151">Postconditions express a condition that must be `true` upon normal termination of the method.</span></span>  
  
 `Contract.Ensures( this.F > 0 );`  
  
### <a name="exceptional-postconditions"></a><span data-ttu-id="e4511-152">Olağanüstü Sonkoşullar</span><span class="sxs-lookup"><span data-stu-id="e4511-152">Exceptional Postconditions</span></span>  
 <span data-ttu-id="e4511-153">Olağanüstü Sonkoşullar olan olmalıdır Sonkoşullar `true` belirli bir özel durum bir yöntemle oluşur zaman.</span><span class="sxs-lookup"><span data-stu-id="e4511-153">Exceptional postconditions are postconditions that should be `true` when a particular exception is thrown by a method.</span></span> <span data-ttu-id="e4511-154">Kullanarak bu Sonkoşullar belirtebilirsiniz <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType> aşağıdaki örnekte gösterildiği gibi yöntemi.</span><span class="sxs-lookup"><span data-stu-id="e4511-154">You can specify these postconditions by using the <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType> method, as the following example shows.</span></span>  
  
 `Contract.EnsuresOnThrow<T>( this.F > 0 );`  
  
 <span data-ttu-id="e4511-155">Bağımsız değişken olmalıdır durumdur `true` alt türü olan bir özel durum her `T` atılır.</span><span class="sxs-lookup"><span data-stu-id="e4511-155">The argument is the condition that must be `true` whenever an exception that is a subtype of `T` is thrown.</span></span>  
  
 <span data-ttu-id="e4511-156">Bir olağanüstü Sonkoşul içinde kullanmak zordur bazı özel durum türü vardır.</span><span class="sxs-lookup"><span data-stu-id="e4511-156">There are some exception types that are difficult to use in an exceptional postcondition.</span></span> <span data-ttu-id="e4511-157">Örneğin, türü kullanılarak <xref:System.Exception> için `T` bir yığın taşması veya diğer denetim imkansız özel durum olsa bile, koşul oluşturulur, özel durum türü ne olursa olsun güvence altına almak için bir yöntem gerektirir.</span><span class="sxs-lookup"><span data-stu-id="e4511-157">For example, using the type <xref:System.Exception> for `T` requires the method to guarantee the condition regardless of the type of exception that is thrown, even if it is a stack overflow or other impossible-to-control exception.</span></span> <span data-ttu-id="e4511-158">Olağanüstü Sonkoşullar üyesi, örneğin, ne zaman çağrıldığında oluşturulan yalnızca belirli durumlar için kullanması gereken bir <xref:System.InvalidTimeZoneException> için oluşturulan bir <xref:System.TimeZoneInfo> yöntem çağrısı.</span><span class="sxs-lookup"><span data-stu-id="e4511-158">You should use exceptional postconditions only for specific exceptions that might be thrown when a member is called, for example, when an <xref:System.InvalidTimeZoneException> is thrown for a <xref:System.TimeZoneInfo> method call.</span></span>  
  
### <a name="special-postconditions"></a><span data-ttu-id="e4511-159">Özel Sonkoşullar</span><span class="sxs-lookup"><span data-stu-id="e4511-159">Special Postconditions</span></span>  
 <span data-ttu-id="e4511-160">Aşağıdaki yöntemlerden yalnızca Sonkoşullar içinde kullanılabilir:</span><span class="sxs-lookup"><span data-stu-id="e4511-160">The following methods may be used only within postconditions:</span></span>  
  
-   <span data-ttu-id="e4511-161">Dönüş değerleri Sonkoşullar yöntemi ifade kullanarak başvurabilirsiniz `Contract.Result<T>()`, burada `T` yönteminin dönüş türü tarafından değiştirilir.</span><span class="sxs-lookup"><span data-stu-id="e4511-161">You can refer to method return values in postconditions by using the expression `Contract.Result<T>()`, where `T` is replaced by the return type of the method.</span></span> <span data-ttu-id="e4511-162">Derleyici türü Infer başlatılamadığında açıkça sağlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="e4511-162">When the compiler is unable to infer the type, you must explicitly provide it.</span></span> <span data-ttu-id="e4511-163">Örneğin, C# Derleyici türleri aşağıdaki Sonkoşul gerekir, böylece tüm bağımsız değişkenler almayan yöntemleri için Infer alamıyor: `Contract.Ensures(0 <Contract.Result<int>())` dönüş türüne sahip yöntemleri `void` başvuramıyor `Contract.Result<T>()` kendi Sonkoşullar içinde.</span><span class="sxs-lookup"><span data-stu-id="e4511-163">For example, the C# compiler is unable to infer types for methods that do not take any arguments, so it requires the following postcondition: `Contract.Ensures(0 <Contract.Result<int>())` Methods with a return type of `void` cannot refer to `Contract.Result<T>()` in their postconditions.</span></span>  
  
-   <span data-ttu-id="e4511-164">Sonkoşul prestate değerinde bir ifadenin başlangıcında bir yöntemi veya özelliği değerini gösterir.</span><span class="sxs-lookup"><span data-stu-id="e4511-164">A prestate value in a postcondition refers to the value of an expression at the start of a method or property.</span></span> <span data-ttu-id="e4511-165">Deyim kullanan `Contract.OldValue<T>(e)`, burada `T` türü `e`.</span><span class="sxs-lookup"><span data-stu-id="e4511-165">It uses the expression `Contract.OldValue<T>(e)`, where `T` is the type of `e`.</span></span> <span data-ttu-id="e4511-166">Derleyici türünü Infer mümkün olduğunda genel tür bağımsız değişkeni atlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e4511-166">You can omit the generic type argument whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="e4511-167">(Bir bağımsız değişken aldığından Örneğin, C# Derleyici her zaman türü oluşturur.) Ne de oluşabilir bazı kısıtlamalar vardır `e` ve eski deyim görünebilir bağlamı.</span><span class="sxs-lookup"><span data-stu-id="e4511-167">(For example, the C# compiler always infers the type because it takes an argument.) There are several restrictions on what can occur in `e` and the contexts in which an old expression may appear.</span></span> <span data-ttu-id="e4511-168">Eski deyim başka bir eski ifade içeremez.</span><span class="sxs-lookup"><span data-stu-id="e4511-168">An old expression cannot contain another old expression.</span></span> <span data-ttu-id="e4511-169">En önemlisi, eski deyim yöntemin önkoşulu durumunda var olan bir değer başvurmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e4511-169">Most importantly, an old expression must refer to a value that existed in the method's precondition state.</span></span> <span data-ttu-id="e4511-170">Diğer bir deyişle, bu yöntemin önkoşulu olduğu sürece sonucu verebilen bir ifade olmalıdır `true`.</span><span class="sxs-lookup"><span data-stu-id="e4511-170">In other words, it must be an expression that can be evaluated as long as the method's precondition is `true`.</span></span> <span data-ttu-id="e4511-171">Bu kural için birkaç örneği aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="e4511-171">Here are several instances of that rule.</span></span>  
  
    -   <span data-ttu-id="e4511-172">Değer yöntemin önkoşulu durumda olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e4511-172">The value must exist in the method's precondition state.</span></span> <span data-ttu-id="e4511-173">Bir nesne üzerinde bir alana başvuru için önkoşulları söz konusu nesne her zaman null olmayan olduğunu güvence altına almalıdır.</span><span class="sxs-lookup"><span data-stu-id="e4511-173">In order to reference a field on an object, the preconditions must guarantee that that object is always non-null.</span></span>  
  
    -   <span data-ttu-id="e4511-174">Eski bir ifadede yöntemin dönüş değerine başvuruda bulunamaz:</span><span class="sxs-lookup"><span data-stu-id="e4511-174">You cannot refer to the method's return value in an old expression:</span></span>  
  
        ```  
        Contract.OldValue(Contract.Result<int>() + x) // ERROR  
        ```  
  
    -   <span data-ttu-id="e4511-175">İçin başvuramaz `out` eski deyimde parametreleri.</span><span class="sxs-lookup"><span data-stu-id="e4511-175">You cannot refer to `out` parameters in an old expression.</span></span>  
  
    -   <span data-ttu-id="e4511-176">Niceleyici aralığını yöntemin dönüş değeri temel alıyorsa eski deyim bir niceleyici ilişkili değişkenine bağlı olamaz:</span><span class="sxs-lookup"><span data-stu-id="e4511-176">An old expression cannot depend on the bound variable of a quantifier if the range of the quantifier depends on the return value of the method:</span></span>  
  
        ```  
        Contract. ForAll (0,Contract. Result<int>(),  
        i => Contract.OldValue(xs[i]) > 3); // ERROR  
        ```  
  
    -   <span data-ttu-id="e4511-177">Eski deyim anonim temsilci parametresinin başvuramıyor bir <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> veya <xref:System.Diagnostics.Contracts.Contract.Exists%2A> bir dizin oluşturucu veya yöntem çağrısı için bağımsız değişken olarak kullanılmadıkça çağırın:</span><span class="sxs-lookup"><span data-stu-id="e4511-177">An old expression cannot refer to the parameter of the anonymous delegate in a <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> call unless it is used as an indexer or argument to a method call:</span></span>  
  
        ```  
        Contract. ForAll (0, xs .Length, i => Contract.OldValue(xs[i]) > 3); // OK  
        Contract. ForAll (0, xs .Length, i => Contract.OldValue(i) > 3); // ERROR  
        ```  
  
    -   <span data-ttu-id="e4511-178">Eski ifadesinin değerini anonim temsilci parametrelerinin hiçbirinde bağımlıysa anonim temsilci bağımsız değişken olmadıkça eski deyim anonim bir temsilci gövdesinde gerçekleşemez <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> veya <xref:System.Diagnostics.Contracts.Contract.Exists%2A> yöntemi:</span><span class="sxs-lookup"><span data-stu-id="e4511-178">An old expression cannot occur in the body of an anonymous delegate if the value of the old expression depends on any of the parameters of the anonymous delegate, unless the anonymous delegate is an argument to the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> method:</span></span>  
  
        ```  
        Method( ... (T t) => Contract.OldValue(... t ...) ... ); // ERROR  
        ```  
  
    -   <span data-ttu-id="e4511-179">`Out`parametreleri mevcut bir sorun sözleşmeleri yönteminin gövdesi önce görünür ve çoğu derleyicileri başvurular izin verme çünkü `out` Sonkoşullar parametreleri.</span><span class="sxs-lookup"><span data-stu-id="e4511-179">`Out` parameters present a problem because contracts appear before the body of the method, and most compilers do not allow references to `out` parameters in postconditions.</span></span> <span data-ttu-id="e4511-180">Bu sorunu çözmek için <xref:System.Diagnostics.Contracts.Contract> SAX <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> göre Sonkoşul sağlayan yöntemi bir `out` parametresi.</span><span class="sxs-lookup"><span data-stu-id="e4511-180">To solve this problem, the <xref:System.Diagnostics.Contracts.Contract> class provides the <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method, which allows a postcondition based on an `out` parameter.</span></span>  
  
        ```  
        public void OutParam(out int x) f  
        Contract.Ensures(Contract.ValueAtReturn(out x) == 3);  
        x = 3;  
        ```  
  
         <span data-ttu-id="e4511-181">İle <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> yöntemi kullanmayabilir genel tür parametresi derleyici türünü Infer mümkün olduğunda.</span><span class="sxs-lookup"><span data-stu-id="e4511-181">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="e4511-182">Sözleşme yeniden yazan yöntem çağrısının değeri ile değiştirir. `out` parametresi.</span><span class="sxs-lookup"><span data-stu-id="e4511-182">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="e4511-183"><xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> Yöntemi yalnızca Sonkoşullar içinde görünebilir.</span><span class="sxs-lookup"><span data-stu-id="e4511-183">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="e4511-184">Yöntemin bağımsız değişkeni olmalıdır bir `out` parametresi ya da alan bir yapısının `out` parametresi.</span><span class="sxs-lookup"><span data-stu-id="e4511-184">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="e4511-185">İkincisi de yapısı Oluşturucusu Sonkoşul alanlara söz konusu olduğunda yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="e4511-185">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>  
  
        > [!NOTE]
        >  <span data-ttu-id="e4511-186">Şu anda, kod sözleşme çözümleme araçları denetleme olup olmadığını `out` parametreleri düzgün şekilde başlatılmadı ve bunların Bahsetme Sonkoşul içinde göz ardı.</span><span class="sxs-lookup"><span data-stu-id="e4511-186">Currently, the code contract analysis tools do not check whether `out` parameters are initialized properly and disregard their mention in the postcondition.</span></span> <span data-ttu-id="e4511-187">Sözleşme satırdan değeri kullanılırsa bu nedenle, önceki örnekte, `x` tamsayı kendisine atamak yerine, bir derleyici doğru hatası sorunu değil.</span><span class="sxs-lookup"><span data-stu-id="e4511-187">Therefore, in the previous example, if the line after the contract had used the value of `x` instead of assigning an integer to it, a compiler would not issue the correct error.</span></span> <span data-ttu-id="e4511-188">Ancak, üzerinde CONTRACTS_FULL önişlemci sembolü olduğu bir yapı (böyle asa yayın derlemesi) tanımlı değil, derleyici hata verecek.</span><span class="sxs-lookup"><span data-stu-id="e4511-188">However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.</span></span>  
  
## <a name="invariants"></a><span data-ttu-id="e4511-189">İnvariants</span><span class="sxs-lookup"><span data-stu-id="e4511-189">Invariants</span></span>  
 <span data-ttu-id="e4511-190">Nesne invariants bu nesne için bir istemci görünür olduğunda, bir sınıfın her örneği için doğru olması gereken koşullardır.</span><span class="sxs-lookup"><span data-stu-id="e4511-190">Object invariants are conditions that should be true for each instance of a class whenever that object is visible to a client.</span></span> <span data-ttu-id="e4511-191">Bunlar, altında nesne doğru olarak değerlendirilir koşullar express.</span><span class="sxs-lookup"><span data-stu-id="e4511-191">They express the conditions under which the object is considered to be correct.</span></span>  
  
 <span data-ttu-id="e4511-192">Değişmez yöntemleri ile işaretlenen tarafından tanımlanan <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> özniteliği.</span><span class="sxs-lookup"><span data-stu-id="e4511-192">The invariant methods are identified by being marked with the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute.</span></span> <span data-ttu-id="e4511-193">Değişmez yöntemleri yapılan çağrıların bir sıra dışında hiçbir kod içermelidir <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> yöntemi, her biri belirtir tek tek bir değişmez değer aşağıdaki örnekte gösterildiği gibi.</span><span class="sxs-lookup"><span data-stu-id="e4511-193">The invariant methods must contain no code except for a sequence of calls to the <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> method, each of which specifies an individual invariant, as shown in the following example.</span></span>  
  
```  
[ContractInvariantMethod]  
protected void ObjectInvariant ()   
{  
Contract.Invariant(this.y >= 0);  
Contract.Invariant(this.x > this.y);  
...  
}  
```  
  
 <span data-ttu-id="e4511-194">İnvariants koşullu CONTRACTS_FULL önişlemci sembolü tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="e4511-194">Invariants are conditionally defined by the CONTRACTS_FULL preprocessor symbol.</span></span> <span data-ttu-id="e4511-195">Çalışma zamanı denetimi sırasında invariants her genel yöntem sonunda denetlenir.</span><span class="sxs-lookup"><span data-stu-id="e4511-195">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="e4511-196">Genel yöntem aynı sınıfta bir değişmez değer değinmektedir, normal olarak bu genel yöntem sonunda olacağını değişmez denetimi devre dışı bırakılır.</span><span class="sxs-lookup"><span data-stu-id="e4511-196">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled.</span></span> <span data-ttu-id="e4511-197">Bunun yerine, yalnızca o sınıfın en dıştaki yöntemi çağrısı sonunda onay oluşur.</span><span class="sxs-lookup"><span data-stu-id="e4511-197">Instead, the check occurs only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="e4511-198">Bu durum, aynı zamanda sınıfın başka bir sınıf bir yöntem çağrısı nedeniyle yeniden girilirse gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="e4511-198">This also happens if the class is re-entered because of a call to a method on another class.</span></span> <span data-ttu-id="e4511-199">Nesne sonlandırıcılar veya uygulayan herhangi bir yöntem, invariants işaretli değil <xref:System.IDisposable.Dispose%2A> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="e4511-199">Invariants are not checked for object finalizers or for any methods that implement the <xref:System.IDisposable.Dispose%2A> method.</span></span>  
  
<a name="usage_guidelines"></a>   
## <a name="usage-guidelines"></a><span data-ttu-id="e4511-200">Kullanım yönergeleri</span><span class="sxs-lookup"><span data-stu-id="e4511-200">Usage Guidelines</span></span>  
  
### <a name="contract-ordering"></a><span data-ttu-id="e4511-201">Sözleşme sıralama</span><span class="sxs-lookup"><span data-stu-id="e4511-201">Contract Ordering</span></span>  
 <span data-ttu-id="e4511-202">Aşağıdaki tabloda yöntemi sözleşmeleri yazdığınızda kullanması gereken öğelerin sırasını gösterir.</span><span class="sxs-lookup"><span data-stu-id="e4511-202">The following table shows the order of elements you should use when you write method contracts.</span></span>  
  
|`If-then-throw statements`|<span data-ttu-id="e4511-203">Geriye dönük olarak uyumlu ortak önkoşulları</span><span class="sxs-lookup"><span data-stu-id="e4511-203">Backward-compatible public preconditions</span></span>|  
|-|-|  
|<xref:System.Diagnostics.Contracts.Contract.Requires%2A>|<span data-ttu-id="e4511-204">Tüm ortak önkoşulları.</span><span class="sxs-lookup"><span data-stu-id="e4511-204">All public preconditions.</span></span>|  
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="e4511-205">Tüm ortak (normal) Sonkoşullar.</span><span class="sxs-lookup"><span data-stu-id="e4511-205">All public (normal) postconditions.</span></span>|  
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="e4511-206">Tüm genel olağanüstü Sonkoşullar.</span><span class="sxs-lookup"><span data-stu-id="e4511-206">All public exceptional postconditions.</span></span>|  
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="e4511-207">Tüm özel/iç (normal) Sonkoşullar.</span><span class="sxs-lookup"><span data-stu-id="e4511-207">All private/internal (normal) postconditions.</span></span>|  
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="e4511-208">Tüm özel/iç olağanüstü Sonkoşullar.</span><span class="sxs-lookup"><span data-stu-id="e4511-208">All private/internal exceptional postconditions.</span></span>|  
|<xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>|<span data-ttu-id="e4511-209">Kullanıyorsanız `if` - `then` - `throw` stil önkoşulları diğer sözleşmeleri olmadan, bir çağrı için <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> göstermek için denetimleri önkoşulları varsa tüm önceki.</span><span class="sxs-lookup"><span data-stu-id="e4511-209">If using `if`-`then`-`throw` style preconditions without any other contracts, place a call to <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> to indicate that all previous if checks are preconditions.</span></span>|  
  
<a name="purity"></a>   
### <a name="purity"></a><span data-ttu-id="e4511-210">Olmak üzere</span><span class="sxs-lookup"><span data-stu-id="e4511-210">Purity</span></span>  
 <span data-ttu-id="e4511-211">İçinde bir sözleşme adında tüm yöntemleri saf olmalıdır; diğer bir deyişle, bunlar önceden var olan herhangi bir durum güncelleştirmelisiniz değil.</span><span class="sxs-lookup"><span data-stu-id="e4511-211">All methods that are called within a contract must be pure; that is, they must not update any preexisting state.</span></span> <span data-ttu-id="e4511-212">Saf yönteminde, saf yöntemi giriş sonra oluşturulan nesneleri değiştirmek için izin verilir.</span><span class="sxs-lookup"><span data-stu-id="e4511-212">A pure method is allowed to modify objects that have been created after entry into the pure method.</span></span>  
  
 <span data-ttu-id="e4511-213">Aşağıdaki kod öğeleri saf kod sözleşme araçları şu anda varsayın:</span><span class="sxs-lookup"><span data-stu-id="e4511-213">Code contract tools currently assume that the following code elements are pure:</span></span>  
  
-   <span data-ttu-id="e4511-214">İle işaretlenen yöntemleri <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="e4511-214">Methods that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span>  
  
-   <span data-ttu-id="e4511-215">İle işaretlenen türleri <xref:System.Diagnostics.Contracts.PureAttribute> (öznitelik tipinin tüm yöntemleri için geçerlidir).</span><span class="sxs-lookup"><span data-stu-id="e4511-215">Types that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute> (the attribute applies to all the type's methods).</span></span>  
  
-   <span data-ttu-id="e4511-216">Özellik get erişimcisi.</span><span class="sxs-lookup"><span data-stu-id="e4511-216">Property get accessors.</span></span>  
  
-   <span data-ttu-id="e4511-217">İşleçler (bir veya iki parametreleri ve void olmayan dönüş türüne sahip statik yöntemler adları "Aç" ve, ile başlayan).</span><span class="sxs-lookup"><span data-stu-id="e4511-217">Operators (static methods whose names start with "op", and that have one or two parameters and a non-void return type).</span></span>  
  
-   <span data-ttu-id="e4511-218">Tam adı "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path" veya "System.Type" ile başlayan herhangi bir yöntem.</span><span class="sxs-lookup"><span data-stu-id="e4511-218">Any method whose fully qualified name begins with "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path", or "System.Type".</span></span>  
  
-   <span data-ttu-id="e4511-219">Temsilci türü ile öznitelikli koşuluyla herhangi bir temsilci çağrılır <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="e4511-219">Any invoked delegate, provided that the delegate type itself is attributed with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span> <span data-ttu-id="e4511-220">Temsilci türleri <xref:System.Predicate%601?displayProperty=nameWithType> ve <xref:System.Comparison%601?displayProperty=nameWithType> saf olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="e4511-220">The delegate types <xref:System.Predicate%601?displayProperty=nameWithType> and <xref:System.Comparison%601?displayProperty=nameWithType> are considered pure.</span></span>  
  
<a name="visibility"></a>   
### <a name="visibility"></a><span data-ttu-id="e4511-221">Görünürlük</span><span class="sxs-lookup"><span data-stu-id="e4511-221">Visibility</span></span>  
 <span data-ttu-id="e4511-222">Bir sözleşmede belirtilen tüm üyeleri en az göründükleri yöntemi olarak olarak görünür olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e4511-222">All members mentioned in a contract must be at least as visible as the method in which they appear.</span></span> <span data-ttu-id="e4511-223">Örneğin, özel bir alan bir public yöntemi için bir önkoşulu bölümünde belirtildiği olamaz; Bunlar yöntemi çağırmadan önce istemcileri böyle bir sözleşme doğrulanamıyor.</span><span class="sxs-lookup"><span data-stu-id="e4511-223">For example, a private field cannot be mentioned in a precondition for a public method; clients cannot validate such a contract before they call the method.</span></span> <span data-ttu-id="e4511-224">Ancak, alanın işaretlenmişse <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, bu kurallardan tutulur.</span><span class="sxs-lookup"><span data-stu-id="e4511-224">However, if the field is marked with the <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, it is exempt from these rules.</span></span>  
  
## <a name="example"></a><span data-ttu-id="e4511-225">Örnek</span><span class="sxs-lookup"><span data-stu-id="e4511-225">Example</span></span>  
 <span data-ttu-id="e4511-226">Aşağıdaki örnek kod sözleşmeleri kullanımını göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="e4511-226">The following example shows the use of code contracts.</span></span>  
  
 [!code-csharp[ContractExample#1](../../../samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#1)]
 [!code-vb[ContractExample#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#1)]

---
title: ".NET derleme Platform SDK sözdizimi modelini kullanın"
description: "Bu genel bakışta anlamak ve sözdizimi düğümleri yönetmek için kullandığınız türleri bir anlayış sağlar."
author: billwagner
ms.author: wiwagn
ms.date: 10/15/2017
ms.topic: conceptual
ms.prod: .net
ms.devlang: devlang-csharp
ms.custom: mvc
ms.openlocfilehash: fa3b7af871380d4f18ebe7ef4f5bc5963cc247c4
ms.sourcegitcommit: 2142a4732bb4ff519b9817db4c24a237b9810d4b
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/05/2018
---
# <a name="work-with-syntax"></a><span data-ttu-id="874e8-103">Sözdizimi ile çalışma</span><span class="sxs-lookup"><span data-stu-id="874e8-103">Work with syntax</span></span>

<span data-ttu-id="874e8-104">**Sözdizimi ağacı** olan API'leri derleyici tarafından kullanıma sunulan bir temel veri yapısı.</span><span class="sxs-lookup"><span data-stu-id="874e8-104">The **syntax tree** is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="874e8-105">Bu ağaçları kaynak kod sözcük ve söz dizimi yapısını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="874e8-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="874e8-106">Bunlar, iki önemli amaca hizmet eder:</span><span class="sxs-lookup"><span data-stu-id="874e8-106">They serve two important purposes:</span></span>

1. <span data-ttu-id="874e8-107">-Bir IDE gibi araçlar izin vermek için eklentiler, kod çözümleme araçları ve yapan yeniden düzenlemeler - görmek ve bir kullanıcının proje kaynak kodunda söz dizimi yapısını işlemek için.</span><span class="sxs-lookup"><span data-stu-id="874e8-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user’s project.</span></span>
2. <span data-ttu-id="874e8-108">Araçları - yapan yeniden düzenlemeler ve oluşturmak için bir IDE - gibi etkinleştirmek için değiştirmek ve kaynak kodu kullanım doğrudan metin düzenlemeleri gerek kalmadan doğal bir şekilde yeniden düzenleyin.</span><span class="sxs-lookup"><span data-stu-id="874e8-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having use direct text edits.</span></span> <span data-ttu-id="874e8-109">Oluşturma ve ağaçları düzenleme araçları kolayca oluşturabilir ve kaynak kodu yeniden düzenleyin.</span><span class="sxs-lookup"><span data-stu-id="874e8-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="874e8-110">Sözdizimi ağacı</span><span class="sxs-lookup"><span data-stu-id="874e8-110">Syntax trees</span></span>

<span data-ttu-id="874e8-111">Sözdizimi ağacı yeniden düzenleme, IDE özellikleri ve kod oluşturma kod analizi, bağlama, derleme için kullanılan birincil yapısı var.</span><span class="sxs-lookup"><span data-stu-id="874e8-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="874e8-112">Kaynak kodun hiçbir bölümü ilk tanımlanan ve pek çok iyi bilinen yapısal dil öğeleri birine kategorilere olmadan anladım.</span><span class="sxs-lookup"><span data-stu-id="874e8-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span> 

<span data-ttu-id="874e8-113">Sözdizimi ağacı üç anahtar özniteliklere sahiptir.</span><span class="sxs-lookup"><span data-stu-id="874e8-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="874e8-114">Sözdizimi ağacı tam bir güvenilirlik tüm kaynak bilgileri tutun ilk özniteliğidir.</span><span class="sxs-lookup"><span data-stu-id="874e8-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="874e8-115">Başka bir deyişle, sözdizimi ağacı her bilgiye boşluk, açıklamalar ve önişlemci yönergeleri de dahil olmak üzere kaynak metni, her dilbilgisi yapısı, her sözcük belirteci ve şey arasındaki, bulunan içerir.</span><span class="sxs-lookup"><span data-stu-id="874e8-115">This means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including whitespace, comments, and preprocessor directives.</span></span> <span data-ttu-id="874e8-116">Örneğin, tam olarak yazılmış şekilde kaynağında belirtilen her değişmez değeri gösterilir.</span><span class="sxs-lookup"><span data-stu-id="874e8-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="874e8-117">Program Atlanan ya da eksik belirteçleri sözdizimi ağacında temsil eden eksik veya hatalı oluşturulmuş olduğunda sözdizimi ağaçları Ayrıca kaynak kod hatalarını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="874e8-117">The syntax trees also represent errors in source code when the program is incomplete or malformed by representing skipped or missing tokens in the syntax tree.</span></span>  

<span data-ttu-id="874e8-118">Bu, söz dizimi ağaçları ikinci öznitelik sağlar.</span><span class="sxs-lookup"><span data-stu-id="874e8-118">This enables the second attribute of syntax trees.</span></span> <span data-ttu-id="874e8-119">Ayrıştırıcının elde edilen bir sözdizimi ağacı gelen ayrıştırıldığında tam metin üretebilir.</span><span class="sxs-lookup"><span data-stu-id="874e8-119">A syntax tree obtained from the parser can produce the exact text it was parsed from.</span></span> <span data-ttu-id="874e8-120">Tüm sözdizimi düğümden bu düğümden başlayan alt ağaç metin gösterimini alır mümkündür.</span><span class="sxs-lookup"><span data-stu-id="874e8-120">From any syntax node, it is possible to get the text representation of the sub-tree rooted at that node.</span></span> <span data-ttu-id="874e8-121">Bu, söz dizimi ağaçları oluşturmak ve kaynak metnini düzenlemek için bir yol olarak kullanılabileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="874e8-121">This means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="874e8-122">Yeni bir ağaç değişiklikleri dışında varolan ağacına yapmadan eşdeğer metni oluşturulan uygulanır ve bir sözdizimi ağacı düzenleyerek sahip bir ağaç oluşturarak, metin etkili bir şekilde düzenlediniz.</span><span class="sxs-lookup"><span data-stu-id="874e8-122">By creating a tree you have by implication created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span> 

<span data-ttu-id="874e8-123">Üçüncü sözdizimi ağaçları değişmez ve iş parçacığı açısından güvenli olduğunu özniteliğidir.</span><span class="sxs-lookup"><span data-stu-id="874e8-123">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span>  <span data-ttu-id="874e8-124">Bu bir ağaç alındıktan sonra bu kodu geçerli durumunu anlık görüntüsüdür, hiçbir zaman anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="874e8-124">This means that after a tree is obtained, it is a snapshot of the current state of the code, and never changes.</span></span> <span data-ttu-id="874e8-125">Bu, aynı sözdizimi ağacı ile aynı anda farklı iş parçacıklarındaki kilitleme veya çoğaltma etkileşim kurmak birden çok kullanıcı sağlar.</span><span class="sxs-lookup"><span data-stu-id="874e8-125">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="874e8-126">Çünkü ağaçları sabittir ve değişikliğe doğrudan ağacına yapılabilmesi için Fabrika yöntemleri oluşturmak ve ağaç ek anlık görüntüleri oluşturarak sözdizimi ağaçlarını değiştirme yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="874e8-126">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="874e8-127">Yeni bir sürüm hızlı ve çok az ek bellek ile yeniden oluşturulması için temel alınan düğümleri yeniden şekilde ağaçları verimlidir.</span><span class="sxs-lookup"><span data-stu-id="874e8-127">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="874e8-128">Sözdizimi ağacı gerçek anlamda bir ağaç veri, burada terminal olmayan yapısal öğeler diğer öğeleri üst yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="874e8-128">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="874e8-129">Her söz dizimi ağaç düğümleri, belirteçleri ve trivia oluşur.</span><span class="sxs-lookup"><span data-stu-id="874e8-129">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>  

## <a name="syntax-nodes"></a><span data-ttu-id="874e8-130">Sözdizimi düğümler</span><span class="sxs-lookup"><span data-stu-id="874e8-130">Syntax nodes</span></span>

<span data-ttu-id="874e8-131">Sözdizimi düğümleri sözdizimi ağaçları birincil öğelerini biridir.</span><span class="sxs-lookup"><span data-stu-id="874e8-131">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="874e8-132">Bu düğümler bildirimleri, deyimleri, yan tümceleri ve ifadeler gibi söz dizimi yapıları temsil eder.</span><span class="sxs-lookup"><span data-stu-id="874e8-132">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="874e8-133">Sözdizimi düğümlerinin her kategori türetilmiş ayrı bir sınıf tarafından temsil edilen <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="874e8-133">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="874e8-134">Düğüm sınıfları kümesi Genişletilebilir değil.</span><span class="sxs-lookup"><span data-stu-id="874e8-134">The set of node classes is not extensible.</span></span> 

<span data-ttu-id="874e8-135">Tüm sözdizimi düğümleri her zaman diğer düğümler ve alt öğeleri olarak belirteçleri sahip oldukları anlamına gelir sözdizimi ağacındaki terminal olmayan düğümler var.</span><span class="sxs-lookup"><span data-stu-id="874e8-135">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="874e8-136">Başka bir düğüm alt olarak, her düğümün üzerinden erişilen bir üst düğümün sahip <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> özelliği.</span><span class="sxs-lookup"><span data-stu-id="874e8-136">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="874e8-137">Bir düğümün üst düğümleri ve ağaçları değişmez olduğundan, hiçbir zaman değiştirir.</span><span class="sxs-lookup"><span data-stu-id="874e8-137">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="874e8-138">Ağaç kökü null üst öğe içermiyor.</span><span class="sxs-lookup"><span data-stu-id="874e8-138">The root of the tree has a null parent.</span></span>  

<span data-ttu-id="874e8-139">Her düğümün sahip bir <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> kaynak metni konumlarını temel sıralı bir düzende alt düğümleri listesini döndürür yöntemi.</span><span class="sxs-lookup"><span data-stu-id="874e8-139">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="874e8-140">Bu liste belirteçleri içermiyor.</span><span class="sxs-lookup"><span data-stu-id="874e8-140">This list does not contain tokens.</span></span> <span data-ttu-id="874e8-141">Her düğümün alt gibi incelemek için yöntemler de sahip <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, veya <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> -tüm düğümler, belirteçleri veya bu düğüm tarafından kökü alt ağaç var trivia listesini temsil eder.</span><span class="sxs-lookup"><span data-stu-id="874e8-141">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia, that exist in the sub-tree rooted by that node.</span></span>  

<span data-ttu-id="874e8-142">Ayrıca, her bir sözdizimi düğüm alt hepsi aynı alt kesin türü belirtilmiş özellikleri aracılığıyla kullanıma sunar.</span><span class="sxs-lookup"><span data-stu-id="874e8-142">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="874e8-143">Örneğin, bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> düğümü sınıfına sahip üç ek özellikler için ikili işleçler belirli: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, ve <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span><span class="sxs-lookup"><span data-stu-id="874e8-143">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="874e8-144">Türü <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> ve <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> olan <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>ve türünü <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> olan <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span><span class="sxs-lookup"><span data-stu-id="874e8-144">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="874e8-145">İsteğe bağlı alt bazı sözdizimi düğümünüz.</span><span class="sxs-lookup"><span data-stu-id="874e8-145">Some syntax nodes have optional children.</span></span> <span data-ttu-id="874e8-146">Örneğin, bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> isteğe sahip <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span><span class="sxs-lookup"><span data-stu-id="874e8-146">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="874e8-147">Alt mevcut değilse, özelliği null döndürür.</span><span class="sxs-lookup"><span data-stu-id="874e8-147">If the child is not present, the property returns null.</span></span> 

## <a name="syntax-tokens"></a><span data-ttu-id="874e8-148">Sözdizimi belirteçleri</span><span class="sxs-lookup"><span data-stu-id="874e8-148">Syntax tokens</span></span>

<span data-ttu-id="874e8-149">Sözdizimi, kodunun en küçük söz dizimi parçaları temsil eden dil dilbilgisi Terminal belirteçleridir.</span><span class="sxs-lookup"><span data-stu-id="874e8-149">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="874e8-150">Hiçbir zaman diğer düğümleri veya belirteçleri üst oldukları.</span><span class="sxs-lookup"><span data-stu-id="874e8-150">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="874e8-151">Anahtar sözcükler, tanımlayıcılar, değişmez değerleri ve noktalama sözdizimi belirteçleri oluşur.</span><span class="sxs-lookup"><span data-stu-id="874e8-151">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span> 

<span data-ttu-id="874e8-152">Verimlilik amacıyla <xref:Microsoft.CodeAnalysis.SyntaxToken> türü olan bir CLR değer türü.</span><span class="sxs-lookup"><span data-stu-id="874e8-152">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="874e8-153">Bu nedenle, sözdizimi düğümleri farklı olarak, her türlü belirteçleri bağlı olarak temsil edilen belirteç türü anlamları özellikleri karışımını içeren için yalnızca bir yapısı yoktur.</span><span class="sxs-lookup"><span data-stu-id="874e8-153">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="874e8-154">Örneğin, bir tamsayı değişmez değer belirteci sayısal bir değeri temsil eder.</span><span class="sxs-lookup"><span data-stu-id="874e8-154">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="874e8-155">Ek olarak ham kaynak metni belirteci yayılma değişmez değer belirteci sahip bir <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> tam söyler özelliği Integer değeri kodunu çözdü.</span><span class="sxs-lookup"><span data-stu-id="874e8-155">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="874e8-156">Bu özellik olarak yazılan <xref:System.Object> çünkü pek çok basit türlerden biri olabilir.</span><span class="sxs-lookup"><span data-stu-id="874e8-156">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="874e8-157"><xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> Özelliği bildirir, aynı bilgileri <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> özellik; ancak bu özellik her zaman olarak yazılan <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="874e8-157">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="874e8-158">C# kaynak metni tanımlayıcıda Unicode kaçış karakterleri içerebilir, ancak kaçış sırası sözdizimi tanımlayıcı adı bir parçası olarak kabul edilmez.</span><span class="sxs-lookup"><span data-stu-id="874e8-158">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="874e8-159">Belirtecin tarafından kapsanan ham metni kaçış sırası içeren ancak bunu <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> özelliğini desteklemez.</span><span class="sxs-lookup"><span data-stu-id="874e8-159">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="874e8-160">Bunun yerine, kaçış tarafından tanımlanan Unicode karakterler içerir.</span><span class="sxs-lookup"><span data-stu-id="874e8-160">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="874e8-161">Örneğin, kaynak metin olarak yazılmış bir tanımlayıcı içeriyorsa `\u03C0`, sonra <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> özelliği bu belirtece döndürecektir `π`.</span><span class="sxs-lookup"><span data-stu-id="874e8-161">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="874e8-162">Sözdizimi trivia</span><span class="sxs-lookup"><span data-stu-id="874e8-162">Syntax trivia</span></span>

<span data-ttu-id="874e8-163">Sözdizimi trivia kodu, boşluk, açıklamalar ve önişlemci yönergeleri gibi normal anlamak için büyük ölçüde anlamsız kaynak metni bölümlerini temsil eder.</span><span class="sxs-lookup"><span data-stu-id="874e8-163">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as whitespace, comments, and preprocessor directives.</span></span> <span data-ttu-id="874e8-164">Sözdizimi belirteçleri gibi trivia değer türleridir.</span><span class="sxs-lookup"><span data-stu-id="874e8-164">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="874e8-165">Tek <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> türü trivia her türlü açıklamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="874e8-165">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="874e8-166">Trivia normal dili sözdizimi parçası olmayan ve her iki belirteç arasında herhangi bir yerde görünebilir çünkü bunlar sözdizimi ağacında bir düğümün bir alt öğesi olarak dahil edilmez.</span><span class="sxs-lookup"><span data-stu-id="874e8-166">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="874e8-167">Yeniden düzenleme gibi ve kaynak metinle tam uygunluğunu korumak için bir özellik uygularken önemli olduklarından, henüz sözdizimi ağacının bir parçası kalırlar.</span><span class="sxs-lookup"><span data-stu-id="874e8-167">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="874e8-168">Bir belirtecin inceleyerek trivia erişebilirsiniz <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> veya <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> koleksiyonları.</span><span class="sxs-lookup"><span data-stu-id="874e8-168">You can access trivia by inspecting a token’s <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="874e8-169">Kaynak metni ayrıştırıldığında trivia dizilerini belirteçleri ile ilişkilendirilir.</span><span class="sxs-lookup"><span data-stu-id="874e8-169">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="874e8-170">Genel olarak, bir belirteç herhangi trivia sonra aynı satıra kadar sonraki belirtece sahip olur.</span><span class="sxs-lookup"><span data-stu-id="874e8-170">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="874e8-171">Tüm trivia o satırdan aşağıdaki belirteç ile ilişkilidir.</span><span class="sxs-lookup"><span data-stu-id="874e8-171">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="874e8-172">Tüm ilk trivia kaynak dosyasında ilk belirteci alır ve son trivia dosyasında yapılan dizisini Sıfır Genişlik sahip değilse, dosya sonu belirteç sabitlenmiş.</span><span class="sxs-lookup"><span data-stu-id="874e8-172">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="874e8-173">Sözdizimi düğümleri ve belirteçleri aksine, sözdizimi trivia üst öğeleri yok.</span><span class="sxs-lookup"><span data-stu-id="874e8-173">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="874e8-174">Henüz ağacının bir parçası olan ve her bir tek belirteçle ilişkili olduğu için kullanarak ilişkili olduğu belirteci erişebilir <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> özelliği.</span><span class="sxs-lookup"><span data-stu-id="874e8-174">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="874e8-175">Yayılma</span><span class="sxs-lookup"><span data-stu-id="874e8-175">Spans</span></span>

<span data-ttu-id="874e8-176">Her düğüm, belirteç veya trivia kaynak metni ve oluşur karakter sayısı içindeki konumuna bilir.</span><span class="sxs-lookup"><span data-stu-id="874e8-176">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="874e8-177">Bir metin konumu bir sıfır tabanlı olduğundan ve 32 bit tamsayı olarak temsil edilir `char` dizini.</span><span class="sxs-lookup"><span data-stu-id="874e8-177">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="874e8-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> nesnesidir başlangıç konumu ve karakter sayısını, her ikisi de tamsayı olarak temsil.</span><span class="sxs-lookup"><span data-stu-id="874e8-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="874e8-179">Varsa <xref:Microsoft.CodeAnalysis.Text.TextSpan> bir sıfır uzunlukta olan iki karakter arasında bir konuma başvuruyor.</span><span class="sxs-lookup"><span data-stu-id="874e8-179">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="874e8-180">Her düğümü iki sahip <xref:Microsoft.CodeAnalysis.Text.TextSpan> özellikleri: < xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> ve < xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*>.</span><span class="sxs-lookup"><span data-stu-id="874e8-180">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*>.</span></span> 

<span data-ttu-id="874e8-181"><xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> Düğümün alt ağaç ilk belirteç başından metin aralık son belirteç sonuna bir özelliktir.</span><span class="sxs-lookup"><span data-stu-id="874e8-181">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> property is the text span from the start of the first token in the node’s sub-tree to the end of the last token.</span></span> <span data-ttu-id="874e8-182">Bu aralık, başında veya sonunda trivia içermez.</span><span class="sxs-lookup"><span data-stu-id="874e8-182">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="874e8-183"><xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*> Düğümün normal aralık yanı sıra, başında veya sonunda trivia aralık içeren metin aralık bir özelliktir.</span><span class="sxs-lookup"><span data-stu-id="874e8-183">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*> property is the text span that includes the node’s normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="874e8-184">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="874e8-184">For example:</span></span> 

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="874e8-185">Bloktaki deyimi düğüm tek dikey çubuk (|) tarafından gösterilen bir aralık sahiptir.</span><span class="sxs-lookup"><span data-stu-id="874e8-185">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="874e8-186">Karakterler içeren `throw new Exception("Not right.");`.</span><span class="sxs-lookup"><span data-stu-id="874e8-186">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="874e8-187">Tam aralık çift dikey çubuk (|) tarafından belirtilir.</span><span class="sxs-lookup"><span data-stu-id="874e8-187">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="874e8-188">Aynı aralık olarak ve baştaki ve sondaki trivia ile ilişkili karakterler içerir.</span><span class="sxs-lookup"><span data-stu-id="874e8-188">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="874e8-189">Tür</span><span class="sxs-lookup"><span data-stu-id="874e8-189">Kinds</span></span>

<span data-ttu-id="874e8-190">Her düğüm, belirteç veya trivia sahip bir <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> türünde özellik <xref:System.Int32?displayProperty=fullName>, gösterilen söz dizimi öğesi tanımlar.</span><span class="sxs-lookup"><span data-stu-id="874e8-190">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=fullName>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="874e8-191">Bu değer için dile özgü numaralandırması çevirebilirsiniz; tek bir C# veya VB, her dil sahip `SyntaxKind` numaralandırması (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=fullName> ve <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=fullName>sırasıyla) tüm olası düğümleri, belirteçleri ve trivia öğeleri dilbilgisi listeler.</span><span class="sxs-lookup"><span data-stu-id="874e8-191">This value can be cast to a language-specific enumeration; each language, C# or VB, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=fullName> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=fullName>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="874e8-192">Bu dönüştürme erişerek otomatik olarak yapılabilir < xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*? displayProperty nameWithType = > veya < xref: Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind*? displayProperty nameWithType = > genişletme yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="874e8-192">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind*?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="874e8-193"><xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> Özelliği için aynı düğüm sınıfı paylaşmak sözdizimi düğüm türü kolay Kesinleştirme izin verir.</span><span class="sxs-lookup"><span data-stu-id="874e8-193">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="874e8-194">Belirteçleri ve trivia için bu özellik bir öğe türü diğerinden ayırt etmek için tek yoludur.</span><span class="sxs-lookup"><span data-stu-id="874e8-194">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span> 

<span data-ttu-id="874e8-195">Örneğin, bir tek <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> sınıfına sahip <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, ve <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> alt öğeleri olarak.</span><span class="sxs-lookup"><span data-stu-id="874e8-195">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="874e8-196"><xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*> Özelliği ayırt olduğunu bir <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, veya <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> sözdizimi düğümün tür.</span><span class="sxs-lookup"><span data-stu-id="874e8-196">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="874e8-197">Hatalar</span><span class="sxs-lookup"><span data-stu-id="874e8-197">Errors</span></span>

<span data-ttu-id="874e8-198">Kaynak metni bile sözdizimi hataları içeriyorsa, kaynak ayrıştırılabilmelerini tam sözdizimi ağacı açıktır.</span><span class="sxs-lookup"><span data-stu-id="874e8-198">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="874e8-199">Ayrıştırıcının dili tanımlanmış sözdizimine uymuyor kod karşılaştığında, iki teknikleri birini sözdizimi ağacı oluşturmak için kullanır.</span><span class="sxs-lookup"><span data-stu-id="874e8-199">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree.</span></span>

<span data-ttu-id="874e8-200">Ayrıştırıcı belirteci belirli bir tür bekliyor, ancak onu bulamazsa, ilk olarak, bu eksik belirteci belirteç bekleniyordu konumu sözdizimi ağacında yerleştirme.</span><span class="sxs-lookup"><span data-stu-id="874e8-200">First, if the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="874e8-201">Eksik bir belirteç bekleniyordu gerçek belirteci temsil eder, ancak boş bir aralığın var ve kendi <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> özelliği döndürür `true`.</span><span class="sxs-lookup"><span data-stu-id="874e8-201">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

<span data-ttu-id="874e8-202">İkinci olarak, bir tane ayrıştırma burada devam edebilirsiniz bulana kadar ayrıştırıcı belirteçleri atlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="874e8-202">Second, the parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="874e8-203">Bu durumda, atlanan belirteçleri türü trivia düğümle olarak bağlı olan <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span><span class="sxs-lookup"><span data-stu-id="874e8-203">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>

---
title: "Eşitleme Temellerine Genel Bakış"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- synchronization, threads
- threading [.NET Framework],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
caps.latest.revision: "17"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 58fb520365d0a80a8f8bc46e3fdbd23483fdf07f
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/21/2017
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="14b9d-102">Eşitleme Temellerine Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="14b9d-102">Overview of Synchronization Primitives</span></span>
<a name="top"></a><span data-ttu-id="14b9d-103">.NET Framework eşitleme temelleri çeşitli iş parçacığı etkileşimlerinin denetleme ve yarış durumları önleme sağlar.</span><span class="sxs-lookup"><span data-stu-id="14b9d-103">The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions.</span></span> <span data-ttu-id="14b9d-104">Bunlar kabaca üç kategoriye ayrılabilir: kilitleme, sinyal ve ınterlocked işlemleri.</span><span class="sxs-lookup"><span data-stu-id="14b9d-104">These can be roughly divided into three categories: locking, signaling, and interlocked operations.</span></span>  
  
 <span data-ttu-id="14b9d-105">Kategoriler derleyin veya açıkça tanımlanmış değildir: birden çok kategori; özelliklerini bazı eşitleme mekanizmaları sahip bir kerede tek bir iş parçacığı yayın işlevsel olarak kilitler gibi olaylardır; Tüm kilidi sürümü, bir sinyal düşünülebilir; ve birbirine kenetlenmiş işlemler kilitleri oluşturmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-105">The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks.</span></span> <span data-ttu-id="14b9d-106">Ancak, kategoriler hala faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="14b9d-106">However, the categories are still useful.</span></span>  
  
 <span data-ttu-id="14b9d-107">İş parçacığı eşitleme işbirlikçi olduğunu unutmamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-107">It is important to remember that thread synchronization is cooperative.</span></span> <span data-ttu-id="14b9d-108">Tek iş parçacığı eşitleme mekanizması atlar ve doğrudan korunan bir kaynağa erişir, bu eşitleme mekanizması etkin olamaz.</span><span class="sxs-lookup"><span data-stu-id="14b9d-108">If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.</span></span>  
  
 <span data-ttu-id="14b9d-109">Bu genel bakışta aşağıdaki bölümleri içerir:</span><span class="sxs-lookup"><span data-stu-id="14b9d-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="14b9d-110">Kilitleme</span><span class="sxs-lookup"><span data-stu-id="14b9d-110">Locking</span></span>](#locking)  
  
-   [<span data-ttu-id="14b9d-111">Sinyal</span><span class="sxs-lookup"><span data-stu-id="14b9d-111">Signaling</span></span>](#signaling)  
  
-   [<span data-ttu-id="14b9d-112">Basit eşitleme türleri</span><span class="sxs-lookup"><span data-stu-id="14b9d-112">Lightweight Synchronization Types</span></span>](#lightweight_synchronization_types)  
  
-   [<span data-ttu-id="14b9d-113">SpinWait</span><span class="sxs-lookup"><span data-stu-id="14b9d-113">SpinWait</span></span>](#spinwait)  
  
-   [<span data-ttu-id="14b9d-114">Birbirine kenetlenmiş işlemler</span><span class="sxs-lookup"><span data-stu-id="14b9d-114">Interlocked Operations</span></span>](#interlocked_operations)  
  
<a name="locking"></a>   
## <a name="locking"></a><span data-ttu-id="14b9d-115">Kilitleme</span><span class="sxs-lookup"><span data-stu-id="14b9d-115">Locking</span></span>  
 <span data-ttu-id="14b9d-116">Kilitleri kaynak denetimi aynı anda tek bir iş parçacığı ya da belirtilen bir iş parçacığı sayısını verin.</span><span class="sxs-lookup"><span data-stu-id="14b9d-116">Locks give control of a resource to one thread at a time, or to a specified number of threads.</span></span> <span data-ttu-id="14b9d-117">Kilit olduğunda, özel bir kilit isteyen bir iş parçacığı kilit kullanılabilir oluncaya kadar blokları kullanın.</span><span class="sxs-lookup"><span data-stu-id="14b9d-117">A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.</span></span>  
  
### <a name="exclusive-locks"></a><span data-ttu-id="14b9d-118">Özel kilit</span><span class="sxs-lookup"><span data-stu-id="14b9d-118">Exclusive Locks</span></span>  
 <span data-ttu-id="14b9d-119">Kilitleme en basit biçimidir `lock` deyimi C# ve `SyncLock` kod bloğu için erişim denetimleri Visual Basic deyimi.</span><span class="sxs-lookup"><span data-stu-id="14b9d-119">The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code.</span></span> <span data-ttu-id="14b9d-120">Bu tür bir blok, sık önemli bir bölümü da adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="14b9d-120">Such a block is frequently referred to as a critical section.</span></span> <span data-ttu-id="14b9d-121">`lock` Deyimi kullanarak gerçekleştirilir <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> ve <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> yöntemleri ve onu kullanan `try…catch…finally` blok kilidi serbest emin olun.</span><span class="sxs-lookup"><span data-stu-id="14b9d-121">The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods, and it uses `try…catch…finally` block to ensure that the lock is released.</span></span>  
  
 <span data-ttu-id="14b9d-122">Genel olarak, kullanarak `lock` veya `SyncLock` kodu, hiçbir zaman yayılan birden fazla tek bir yöntem küçük bloklarını korumak için açıklamadır kullanmak için en iyi yolu <xref:System.Threading.Monitor> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="14b9d-122">In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="14b9d-123">Güçlü rağmen <xref:System.Threading.Monitor> sınıftır artık kilitler ve kilitlenmeleri yatkın.</span><span class="sxs-lookup"><span data-stu-id="14b9d-123">Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks.</span></span>  
  
#### <a name="monitor-class"></a><span data-ttu-id="14b9d-124">İzleme sınıfı</span><span class="sxs-lookup"><span data-stu-id="14b9d-124">Monitor Class</span></span>  
 <span data-ttu-id="14b9d-125"><xref:System.Threading.Monitor> Sınıfı ile birlikte kullanılan ek işlevsellik sağlar `lock` deyimi:</span><span class="sxs-lookup"><span data-stu-id="14b9d-125">The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:</span></span>  
  
-   <span data-ttu-id="14b9d-126"><xref:System.Threading.Monitor.TryEnter%2A> Yöntemi belirtilen bir zaman aralığından sonra vermek kaynağı için bekleyen engellenmiş iş parçacığı sağlar.</span><span class="sxs-lookup"><span data-stu-id="14b9d-126">The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval.</span></span> <span data-ttu-id="14b9d-127">Başarısını veya başarısızlığını algılamak ve olası kilitlenmeleri önlemek için kullanılan gösteren bir Boole değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="14b9d-127">It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.</span></span>  
  
-   <span data-ttu-id="14b9d-128"><xref:System.Threading.Monitor.Wait%2A> Yöntemi, bir iş parçacığı önemli bir bölümü tarafından çağrılır.</span><span class="sxs-lookup"><span data-stu-id="14b9d-128">The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section.</span></span> <span data-ttu-id="14b9d-129">Kaynak yeniden kullanılabilir hale gelene kadar blokları ve kaynak denetim olanağı verir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-129">It gives up control of the resource and blocks until the resource is available again.</span></span>  
  
-   <span data-ttu-id="14b9d-130"><xref:System.Threading.Monitor.Pulse%2A> Ve <xref:System.Threading.Monitor.PulseAll%2A> yöntemlere izin hakkında kilidi veya çağırmak için bir iş parçacığı <xref:System.Threading.Monitor.Wait%2A> kilidi elde edebilirsiniz hazır sıraya bir veya daha fazla iş parçacığı yerleştirmek için.</span><span class="sxs-lookup"><span data-stu-id="14b9d-130">The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock.</span></span>  
  
 <span data-ttu-id="14b9d-131">Zaman aşımlarını <xref:System.Threading.Monitor.Wait%2A> yöntemi aşırı hazır kuyruğuna kaçınmak, bekleyen iş parçacıkları izin verin.</span><span class="sxs-lookup"><span data-stu-id="14b9d-131">Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue.</span></span>  
  
 <span data-ttu-id="14b9d-132"><xref:System.Threading.Monitor> Sınıfı, kilitleme için kullanılan nesne türetilen durumunda birden çok uygulama etki alanlarında kilitleme sağlayabilir <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="14b9d-132">The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
 <span data-ttu-id="14b9d-133"><xref:System.Threading.Monitor>iş parçacığı benzeşimini sahiptir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-133"><xref:System.Threading.Monitor> has thread affinity.</span></span> <span data-ttu-id="14b9d-134">Diğer bir deyişle, İzleyici girilen bir iş parçacığı çağırarak çıkmalı <xref:System.Threading.Monitor.Exit%2A> veya <xref:System.Threading.Monitor.Wait%2A>.</span><span class="sxs-lookup"><span data-stu-id="14b9d-134">That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>.</span></span>  
  
 <span data-ttu-id="14b9d-135"><xref:System.Threading.Monitor> Sınıf instantiable değil.</span><span class="sxs-lookup"><span data-stu-id="14b9d-135">The <xref:System.Threading.Monitor> class is not instantiable.</span></span> <span data-ttu-id="14b9d-136">Yöntemlerinin statik (`Shared` Visual Basic'te) ve hareket instantiable kilit nesne.</span><span class="sxs-lookup"><span data-stu-id="14b9d-136">Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object.</span></span>  
  
 <span data-ttu-id="14b9d-137">Kavramsal genel bakış için bkz: [izleyicileri](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span><span class="sxs-lookup"><span data-stu-id="14b9d-137">For a conceptual overview, see [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span></span>  
  
#### <a name="mutex-class"></a><span data-ttu-id="14b9d-138">Mutex Sınıfı</span><span class="sxs-lookup"><span data-stu-id="14b9d-138">Mutex Class</span></span>  
 <span data-ttu-id="14b9d-139">İş parçacığı isteği bir <xref:System.Threading.Mutex> bir aşırı yüklemesini çağırarak kendi <xref:System.Threading.WaitHandle.WaitOne%2A> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="14b9d-139">Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="14b9d-140">Aşırı zaman aşımları ile bekleme vermek iş parçacığı olanak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="14b9d-140">Overloads with timeouts are provided, to allow threads to give up the wait.</span></span> <span data-ttu-id="14b9d-141">Farklı <xref:System.Threading.Monitor> sınıfı, bir mutex yerel veya genel olabilir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-141">Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global.</span></span> <span data-ttu-id="14b9d-142">Genel zaman uyumu sağlayıcılar adlandırılmış zaman uyumu sağlayıcılar, olarak da adlandırılan, işletim sistemi görünür durumda ve birden çok uygulama etki alanları veya işlemler iş parçacıklarında eşitlemek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="14b9d-142">Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes.</span></span> <span data-ttu-id="14b9d-143">Yerel zaman uyumu sağlayıcılar türetilen <xref:System.MarshalByRefObject>ve uygulama etki alanı sınırlarında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-143">Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="14b9d-144">Ayrıca, <xref:System.Threading.Mutex> türetilen <xref:System.Threading.WaitHandle>, yani bu tarafından sağlanan sinyal mekanizmaları ile kullanılabilir <xref:System.Threading.WaitHandle>, gibi <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, ve <xref:System.Threading.WaitHandle.SignalAndWait%2A> yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="14b9d-144">In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods.</span></span>  
  
 <span data-ttu-id="14b9d-145">Gibi <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> iş parçacığı benzeşimini sahiptir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-145">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity.</span></span> <span data-ttu-id="14b9d-146">Farklı <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> instantiable bir nesnedir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-146">Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object.</span></span>  
  
 <span data-ttu-id="14b9d-147">Kavramsal genel bakış için bkz: [zaman uyumu sağlayıcılar](../../../docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="14b9d-147">For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md).</span></span>  
  
#### <a name="spinlock-class"></a><span data-ttu-id="14b9d-148">SpinLock sınıfı</span><span class="sxs-lookup"><span data-stu-id="14b9d-148">SpinLock Class</span></span>  
 <span data-ttu-id="14b9d-149">İle başlayarak [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], kullanabileceğiniz <xref:System.Threading.SpinLock> sınıfı tarafından yükü gerekli olduğunda <xref:System.Threading.Monitor> performansı düşürür.</span><span class="sxs-lookup"><span data-stu-id="14b9d-149">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance.</span></span> <span data-ttu-id="14b9d-150">Zaman <xref:System.Threading.SpinLock> kilitli kritik bir bölüme karşılaştığında kilit kullanılabilir oluncaya kadar bu yalnızca bir döngüde döner.</span><span class="sxs-lookup"><span data-stu-id="14b9d-150">When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available.</span></span> <span data-ttu-id="14b9d-151">Kilit çok kısa bir süre tutulursa dönen engelleme daha iyi performans sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="14b9d-151">If the lock is held for a very short time, spinning can provide better performance than blocking.</span></span> <span data-ttu-id="14b9d-152">Ancak, kilit döngüleri, birden fazla birkaç onlarca tutulursa <xref:System.Threading.SpinLock> da gerçekleştirir olarak <xref:System.Threading.Monitor>, ancak daha fazla CPU döngüsü kullanır ve bu nedenle diğer iş parçacıkları veya işlemler performansını düşürebilir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-152">However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.</span></span>  
  
### <a name="other-locks"></a><span data-ttu-id="14b9d-153">Diğer kilitleri</span><span class="sxs-lookup"><span data-stu-id="14b9d-153">Other Locks</span></span>  
 <span data-ttu-id="14b9d-154">Kilitleri özel olması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="14b9d-154">Locks need not be exclusive.</span></span> <span data-ttu-id="14b9d-155">Genellikle, iş parçacıkları, sınırlı sayıda eşzamanlı bir kaynağa erişmesine izin vermek kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="14b9d-155">It is often useful to allow a limited number of threads concurrent access to a resource.</span></span> <span data-ttu-id="14b9d-156">Semafor ve Okuyucu-Yazıcı kilitleri, bu tür bir havuza alınmış kaynak erişimi denetlemek için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="14b9d-156">Semaphores and reader-writer locks are designed to control this kind of pooled resource access.</span></span>  
  
#### <a name="readerwriterlock-class"></a><span data-ttu-id="14b9d-157">ReaderWriterLock Sınıfı</span><span class="sxs-lookup"><span data-stu-id="14b9d-157">ReaderWriterLock Class</span></span>  
 <span data-ttu-id="14b9d-158"><xref:System.Threading.ReaderWriterLockSlim> Sınıfı adresleri verileri, yazıcı değiştiren bir iş parçacığı gerekir sahip olduğu bir kaynağa özel erişim durumu.</span><span class="sxs-lookup"><span data-stu-id="14b9d-158">The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource.</span></span> <span data-ttu-id="14b9d-159">Yazıcı etkin değilken, herhangi bir sayıda okuyucular kaynağa erişebilir (örneğin, çağıran tarafından <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> yöntemi).</span><span class="sxs-lookup"><span data-stu-id="14b9d-159">When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method).</span></span> <span data-ttu-id="14b9d-160">Bir iş parçacığı özel erişim istediğinde (örneğin, çağıran tarafından <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> yöntemi), tüm mevcut okuyucular kilit çıkış ve yazıcı girilen ve kilidi çıkıldı kadar sonraki okuyucu istekleri bloğu.</span><span class="sxs-lookup"><span data-stu-id="14b9d-160">When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>  
  
 <span data-ttu-id="14b9d-161"><xref:System.Threading.ReaderWriterLockSlim>iş parçacığı benzeşimini sahiptir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-161"><xref:System.Threading.ReaderWriterLockSlim> has thread affinity.</span></span>  
  
 <span data-ttu-id="14b9d-162">Kavramsal genel bakış için bkz: [Okuyucu-Yazıcı kilitleri](../../../docs/standard/threading/reader-writer-locks.md).</span><span class="sxs-lookup"><span data-stu-id="14b9d-162">For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md).</span></span>  
  
#### <a name="semaphore-class"></a><span data-ttu-id="14b9d-163">Semafor Sınıfı</span><span class="sxs-lookup"><span data-stu-id="14b9d-163">Semaphore Class</span></span>  
 <span data-ttu-id="14b9d-164"><xref:System.Threading.Semaphore> Sınıfı, bir kaynağa erişmek için iş parçacığı belirtilen sayıda olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="14b9d-164">The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource.</span></span> <span data-ttu-id="14b9d-165">Bir iş parçacığı semafor yayımları kadar kaynak blok isteyen ek iş parçacığı.</span><span class="sxs-lookup"><span data-stu-id="14b9d-165">Additional threads requesting the resource block until a thread releases the semaphore.</span></span>  
  
 <span data-ttu-id="14b9d-166">Gibi <xref:System.Threading.Mutex> sınıfı, <xref:System.Threading.Semaphore> türetilen <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="14b9d-166">Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="14b9d-167">Ayrıca ister <xref:System.Threading.Mutex>, <xref:System.Threading.Semaphore> yerel veya genel olabilir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-167">Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global.</span></span> <span data-ttu-id="14b9d-168">Uygulama etki alanı sınırlarında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-168">It can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="14b9d-169">Farklı <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, ve <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> iş parçacığı benzeşimini yok.</span><span class="sxs-lookup"><span data-stu-id="14b9d-169">Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity.</span></span> <span data-ttu-id="14b9d-170">Bu, burada bir iş parçacığı semafor edinir ve başka yayımları senaryolarda kullanılabileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-170">This means it can be used in scenarios where one thread acquires the semaphore and another releases it.</span></span>  
  
 <span data-ttu-id="14b9d-171">Kavramsal genel bakış için bkz: [semafor ve SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="14b9d-171">For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="14b9d-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>tek bir işlem sınırında eşitleme için basit bir semafor olur.</span><span class="sxs-lookup"><span data-stu-id="14b9d-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight semaphore for synchronization within a single process boundary.</span></span>  
  
 [<span data-ttu-id="14b9d-173">Başa dön</span><span class="sxs-lookup"><span data-stu-id="14b9d-173">Back to top</span></span>](#top)  
  
<a name="signaling"></a>   
## <a name="signaling"></a><span data-ttu-id="14b9d-174">Sinyal</span><span class="sxs-lookup"><span data-stu-id="14b9d-174">Signaling</span></span>  
 <span data-ttu-id="14b9d-175">Başka bir iş parçacığından sinyal çağırmak için beklenecek en basit yolu <xref:System.Threading.Thread.Join%2A> başka bir iş parçacığı tamamlanana kadar engeller yöntemi.</span><span class="sxs-lookup"><span data-stu-id="14b9d-175">The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes.</span></span> <span data-ttu-id="14b9d-176"><xref:System.Threading.Thread.Join%2A>Belirtilen bir zaman aralığı geçtikten sonra dışında bekleme bölüneceği engellenmiş iş parçacığı izin iki aşırı yüklemeye sahip.</span><span class="sxs-lookup"><span data-stu-id="14b9d-176"><xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.</span></span>  
  
 <span data-ttu-id="14b9d-177">Bekleme tanıtıcıları bekleyen ve yetenekleri sinyal çok daha zengin kümesi sağlar.</span><span class="sxs-lookup"><span data-stu-id="14b9d-177">Wait handles provide a much richer set of waiting and signaling capabilities.</span></span>  
  
### <a name="wait-handles"></a><span data-ttu-id="14b9d-178">Bekleme Tanıtıcıları</span><span class="sxs-lookup"><span data-stu-id="14b9d-178">Wait Handles</span></span>  
 <span data-ttu-id="14b9d-179">Bekleme tanıtıcıları türetilen <xref:System.Threading.WaitHandle> sırayla türeyen sınıf <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="14b9d-179">Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="14b9d-180">Bu nedenle, bekleme tanıtıcıları iş parçacığı etkinliklerini uygulama etki alanı sınırlarında eşitlemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-180">Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="14b9d-181">İş parçacığı bloğu bekleme üzerinde işler örneği yöntemini çağırarak <xref:System.Threading.WaitHandle.WaitOne%2A> veya statik yöntemler <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, veya <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="14b9d-181">Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span></span> <span data-ttu-id="14b9d-182">Nasıl yayımlanan hangi yöntemi çağrıldı ve bekleme tanıtıcıları türüne bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="14b9d-182">How they are released depends on which method was called, and on the kind of wait handles.</span></span>  
  
 <span data-ttu-id="14b9d-183">Kavramsal genel bakış için bkz: [bekleyin işleme](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span><span class="sxs-lookup"><span data-stu-id="14b9d-183">For a conceptual overview, see [Wait Handles](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span></span>  
  
#### <a name="event-wait-handles"></a><span data-ttu-id="14b9d-184">Olay bekleme tanıtıcıları</span><span class="sxs-lookup"><span data-stu-id="14b9d-184">Event Wait Handles</span></span>  
 <span data-ttu-id="14b9d-185">Olay bekleme tanıtıcıları içeren <xref:System.Threading.EventWaitHandle> sınıf ve türetilmiş sınıflarının, <xref:System.Threading.AutoResetEvent> ve <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="14b9d-185">Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="14b9d-186">İş parçacığı, bir olay bekleme tanıtıcısı yayımlandığında, olay bekleme tanıtıcısı çağırarak işaret zaman kendi <xref:System.Threading.EventWaitHandle.Set%2A> yöntemi kullanarak veya <xref:System.Threading.WaitHandle.SignalAndWait%2A> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="14b9d-186">Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span>  
  
 <span data-ttu-id="14b9d-187">Olay tanıtıcıları ya da kendilerini otomatik olarak yalnızca bir iş parçacığı aracılığıyla işareti veya el ile sıfırlama işaret ve birisi kapatana kadar açın kadar kapalı bir ağ geçidi gibi her zaman izin veren bir Turnike gibi Sıfırla bekleyin.</span><span class="sxs-lookup"><span data-stu-id="14b9d-187">Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it.</span></span> <span data-ttu-id="14b9d-188">Adları kapsıyor gibi <xref:System.Threading.AutoResetEvent> ve <xref:System.Threading.ManualResetEvent> önceki ve sonraki, sırasıyla temsil eder.</span><span class="sxs-lookup"><span data-stu-id="14b9d-188">As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively.</span></span> <span data-ttu-id="14b9d-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>tek bir işlem sınırında eşitleme için basit bir olaydır.</span><span class="sxs-lookup"><span data-stu-id="14b9d-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight event for synchronization within a single process boundary.</span></span>  
  
 <span data-ttu-id="14b9d-190">Bir <xref:System.Threading.EventWaitHandle> iki tür olay gösterebilir ve yerel veya genel olabilir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-190">An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global.</span></span> <span data-ttu-id="14b9d-191">Türetilen sınıflar <xref:System.Threading.AutoResetEvent> ve <xref:System.Threading.ManualResetEvent> her zaman yerel olarak.</span><span class="sxs-lookup"><span data-stu-id="14b9d-191">The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local.</span></span>  
  
 <span data-ttu-id="14b9d-192">Olay bekleme tanıtıcıları iş parçacığı benzeşimini gerekmez.</span><span class="sxs-lookup"><span data-stu-id="14b9d-192">Event wait handles do not have thread affinity.</span></span> <span data-ttu-id="14b9d-193">Tüm iş parçacığı bir olay bekleme tanıtıcısı işaret.</span><span class="sxs-lookup"><span data-stu-id="14b9d-193">Any thread can signal an event wait handle.</span></span>  
  
 <span data-ttu-id="14b9d-194">Kavramsal genel bakış için bkz: [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="14b9d-194">For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
#### <a name="mutex-and-semaphore-classes"></a><span data-ttu-id="14b9d-195">Mutex ve semafor sınıfları</span><span class="sxs-lookup"><span data-stu-id="14b9d-195">Mutex and Semaphore Classes</span></span>  
 <span data-ttu-id="14b9d-196">Çünkü <xref:System.Threading.Mutex> ve <xref:System.Threading.Semaphore> sınıfları türetilen <xref:System.Threading.WaitHandle>, statik yöntemleriyle kullanılan <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="14b9d-196">Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="14b9d-197">Örneğin, bir iş parçacığı kullanabilir <xref:System.Threading.WaitHandle.WaitAll%2A> Aşağıdakilerden üçü true olana kadar beklenecek yöntemi: bir <xref:System.Threading.EventWaitHandle> işareti verilen bir <xref:System.Threading.Mutex> yayımlandığı ve <xref:System.Threading.Semaphore> yayımlanır.</span><span class="sxs-lookup"><span data-stu-id="14b9d-197">For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released.</span></span> <span data-ttu-id="14b9d-198">Benzer şekilde, bir iş parçacığı kullanabilir <xref:System.Threading.WaitHandle.WaitAny%2A> yöntemi Bu koşullardan herhangi biri true olana kadar bekleyin.</span><span class="sxs-lookup"><span data-stu-id="14b9d-198">Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true.</span></span>  
  
 <span data-ttu-id="14b9d-199">İçin bir <xref:System.Threading.Mutex> veya <xref:System.Threading.Semaphore>, işaret yayımlanan anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-199">For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released.</span></span> <span data-ttu-id="14b9d-200">Her iki türü ilk bağımsız değişken olarak kullanılıyorsa, <xref:System.Threading.WaitHandle.SignalAndWait%2A> yöntemi, serbest bırakılır.</span><span class="sxs-lookup"><span data-stu-id="14b9d-200">If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released.</span></span> <span data-ttu-id="14b9d-201">Durumunda bir <xref:System.Threading.Mutex>, iş parçacığı benzeşimini olan, çağıran iş parçacığı mutex kendisine değil, özel durum oluşur.</span><span class="sxs-lookup"><span data-stu-id="14b9d-201">In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex.</span></span> <span data-ttu-id="14b9d-202">Daha önce belirtildiği gibi semafor iş parçacığı benzeşimini sahip değilsiniz.</span><span class="sxs-lookup"><span data-stu-id="14b9d-202">As noted previously, semaphores do not have thread affinity.</span></span>  
  
#### <a name="barrier"></a><span data-ttu-id="14b9d-203">Engel</span><span class="sxs-lookup"><span data-stu-id="14b9d-203">Barrier</span></span>  
 <span data-ttu-id="14b9d-204"><xref:System.Threading.Barrier> Sınıfı, böylece bunlar aynı tüm bloğundaki noktası ve tamamlamak tüm diğer iş parçacığı için bekleyin birden çok iş parçacığı cyclically eşitlemenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="14b9d-204">The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete.</span></span> <span data-ttu-id="14b9d-205">Bir veya daha fazla iş parçacığı bir algoritma sonraki aşamasına devam etmeden önce başka bir iş parçacığı sonuçlarını gerektirdiğinde bir engel yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="14b9d-205">A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm.</span></span> <span data-ttu-id="14b9d-206">Daha fazla bilgi için bkz: [engel](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="14b9d-206">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>  
  
 [<span data-ttu-id="14b9d-207">Başa dön</span><span class="sxs-lookup"><span data-stu-id="14b9d-207">Back to top</span></span>](#top)  
  
<a name="lightweight_synchronization_types"></a>   
## <a name="lightweight-synchronization-types"></a><span data-ttu-id="14b9d-208">Basit eşitleme türleri</span><span class="sxs-lookup"><span data-stu-id="14b9d-208">Lightweight Synchronization Types</span></span>  
 <span data-ttu-id="14b9d-209">İle başlayarak [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], Win32 çekirdek pahalı bağımlılık önleme tarafından hızlı performans bekleme tanıtıcıları mümkün olduğunca gibi nesneleri sağlamak eşitleme temelleri kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="14b9d-209">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.</span></span> <span data-ttu-id="14b9d-210">Genel olarak, bu tür bekleme süresini kısa olduğunda ve yalnızca özgün eşitleme türleri denedi ve yetersiz olduğu tespit ne zaman kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-210">In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory.</span></span> <span data-ttu-id="14b9d-211">Basit türler, işlem içi iletişimi gerektiren senaryolar içinde kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="14b9d-211">The lightweight types cannot be used in scenarios that require cross-process communication.</span></span>  
  
-   <span data-ttu-id="14b9d-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>hafif bir sürümüdür <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="14b9d-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="14b9d-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>hafif bir sürümüdür <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="14b9d-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="14b9d-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType>sayımına sıfır olduğunda işaret hale bir olayı temsil eder.</span><span class="sxs-lookup"><span data-stu-id="14b9d-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> represents an event that becomes signaled when its count is zero.</span></span>  
  
-   <span data-ttu-id="14b9d-215"><xref:System.Threading.Barrier?displayProperty=nameWithType>bir ana iş parçacığı tarafından denetim gerektirmeden birbirleriyle eşitlemek birden çok iş parçacığı sağlar.</span><span class="sxs-lookup"><span data-stu-id="14b9d-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> enables multiple threads to synchronize with one another without requiring control by a master thread.</span></span> <span data-ttu-id="14b9d-216">Tüm iş parçacıklarının belirli bir noktaya ulaştınız kadar bir engel her iş parçacığı devam etmesini engelliyor.</span><span class="sxs-lookup"><span data-stu-id="14b9d-216">A barrier prevents each thread from continuing until all threads have reached a specified point.</span></span>  
  
 [<span data-ttu-id="14b9d-217">Başa dön</span><span class="sxs-lookup"><span data-stu-id="14b9d-217">Back to top</span></span>](#top)  
  
<a name="spinwait"></a>   
## <a name="spinwait"></a><span data-ttu-id="14b9d-218">SpinWait</span><span class="sxs-lookup"><span data-stu-id="14b9d-218">SpinWait</span></span>  
 <span data-ttu-id="14b9d-219">İle başlayarak [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], kullanabileceğiniz <xref:System.Threading.SpinWait?displayProperty=nameWithType> bildirilmesini bir olay ya da karşılanması gereken bir koşul için beklenecek bir iş parçacığı vardır, ancak gerçek bekleme süresi değerinden küçük bir bekleme tanıtıcısı kullanarak veya otherwi gerekli bekleme süresi olması beklenir yapısı Geçerli iş parçacığının engelleme kullan.</span><span class="sxs-lookup"><span data-stu-id="14b9d-219">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread.</span></span> <span data-ttu-id="14b9d-220">Kullanarak <xref:System.Threading.SpinWait>, bekleme sırasında Döndür ve ardından yalnızca belirtilen sürede koşul değil, (örneğin, bekleyen veya uyku) elde etmek için kısa bir süre belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="14b9d-220">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>  
  
 [<span data-ttu-id="14b9d-221">Başa dön</span><span class="sxs-lookup"><span data-stu-id="14b9d-221">Back to top</span></span>](#top)  
  
<a name="interlocked_operations"></a>   
## <a name="interlocked-operations"></a><span data-ttu-id="14b9d-222">Birbirine Kenetlenmiş İşlemler</span><span class="sxs-lookup"><span data-stu-id="14b9d-222">Interlocked Operations</span></span>  
 <span data-ttu-id="14b9d-223">Birbirine kenetlenmiş işlemler olan bir bellek konumuna statik yöntemleri tarafından gerçekleştirilen basit atomik işlemleri <xref:System.Threading.Interlocked> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="14b9d-223">Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="14b9d-224">Bu atomik işlemleri toplama dahil, Artır azaltma, exchange, bir karşılaştırma bağlı olarak koşullu exchange ve okuma işlemlerini 64-bit değerleri için 32-bit platformlarda.</span><span class="sxs-lookup"><span data-stu-id="14b9d-224">Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="14b9d-225">Kararlılık garanti tek tek işlemleri sınırlıdır; bir birim olarak birden çok işlemi gerçekleştirilmesi gerekir, daha parçalı bir eşitleme mekanizması kullanılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-225">The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.</span></span>  
  
 <span data-ttu-id="14b9d-226">Bu işlemlerin hiçbiri kilitleri ya da sinyalleri olsa da, kilitler ve sinyalleri oluşturmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-226">Although none of these operations are locks or signals, they can be used to construct locks and signals.</span></span> <span data-ttu-id="14b9d-227">Windows işletim sisteminin yerel olduklarından, birbirine kenetlenmiş işlemler son derece hızlı.</span><span class="sxs-lookup"><span data-stu-id="14b9d-227">Because they are native to the Windows operating system, interlocked operations are extremely fast.</span></span>  
  
 <span data-ttu-id="14b9d-228">Birbirine kenetlenmiş işlemler geçici bellek garanti ile güçlü engellemeyen eşzamanlılık sergilemesine uygulamaları yazmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="14b9d-228">Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency.</span></span> <span data-ttu-id="14b9d-229">Bununla birlikte, çoğu amaç için basit kilitleri daha uygun bir seçenektir; bu nedenle Gelişmiş, alt düzey programlama, duyarlar.</span><span class="sxs-lookup"><span data-stu-id="14b9d-229">However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.</span></span>  
  
 <span data-ttu-id="14b9d-230">Kavramsal genel bakış için bkz: [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).</span><span class="sxs-lookup"><span data-stu-id="14b9d-230">For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="14b9d-231">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="14b9d-231">See Also</span></span>  
 [<span data-ttu-id="14b9d-232">İçin Veri Eşitleme çoklu iş parçacığı kullanımı</span><span class="sxs-lookup"><span data-stu-id="14b9d-232">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
 [<span data-ttu-id="14b9d-233">İzleyicileri</span><span class="sxs-lookup"><span data-stu-id="14b9d-233">Monitors</span></span>](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)  
 [<span data-ttu-id="14b9d-234">Zaman uyumu sağlayıcılar</span><span class="sxs-lookup"><span data-stu-id="14b9d-234">Mutexes</span></span>](../../../docs/standard/threading/mutexes.md)  
 [<span data-ttu-id="14b9d-235">Semafor ve SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="14b9d-235">Semaphore and SemaphoreSlim</span></span>](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)  
 [<span data-ttu-id="14b9d-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="14b9d-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)  
 [<span data-ttu-id="14b9d-237">Bekleme tanıtıcıları</span><span class="sxs-lookup"><span data-stu-id="14b9d-237">Wait Handles</span></span>](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)  
 [<span data-ttu-id="14b9d-238">Birbirine kenetlenmiş işlemler</span><span class="sxs-lookup"><span data-stu-id="14b9d-238">Interlocked Operations</span></span>](../../../docs/standard/threading/interlocked-operations.md)  
 [<span data-ttu-id="14b9d-239">Okuyucu-Yazıcı kilitleri</span><span class="sxs-lookup"><span data-stu-id="14b9d-239">Reader-Writer Locks</span></span>](../../../docs/standard/threading/reader-writer-locks.md)  
 [<span data-ttu-id="14b9d-240">Engelle</span><span class="sxs-lookup"><span data-stu-id="14b9d-240">Barrier</span></span>](../../../docs/standard/threading/barrier.md)  
 [<span data-ttu-id="14b9d-241">SpinWait</span><span class="sxs-lookup"><span data-stu-id="14b9d-241">SpinWait</span></span>](../../../docs/standard/threading/spinwait.md)  
 [<span data-ttu-id="14b9d-242">SpinLock</span><span class="sxs-lookup"><span data-stu-id="14b9d-242">SpinLock</span></span>](../../../docs/standard/threading/spinlock.md)

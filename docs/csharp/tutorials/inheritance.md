---
title: C# devralma
description: "C# kitaplıkları ve uygulamalarda devralma kullanmayı öğrenin."
keywords: "devralma (C#) temel sınıfları, türetilmiş sınıfları, soyut taban sınıfları"
author: rpetrusha
manager: wpickett
ms.author: ronpet
ms.date: 08/16/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: ec5ca3132ac68b85ebb517e569241f20080b4f63
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/18/2017
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="68302-104">C# ve .NET devralma</span><span class="sxs-lookup"><span data-stu-id="68302-104">Inheritance in C# and .NET</span></span>

<span data-ttu-id="68302-105">Bu öğretici, C# ' nde Devralmanın tanıtır.</span><span class="sxs-lookup"><span data-stu-id="68302-105">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="68302-106">Devralma (verileri ve davranış) belirli işlevleri sağlayan bir temel sınıf tanımlar ve devralmalı ya da bu işlevleri geçersiz kılma türetilmiş sınıfları tanımlamak için sağlayan bir nesne odaklı programlama dilleri özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="68302-106">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="68302-107">Önkoşullar</span><span class="sxs-lookup"><span data-stu-id="68302-107">Prerequisites</span></span>

<span data-ttu-id="68302-108">Bu öğreticide, .NET Core yüklediğiniz varsayılır.</span><span class="sxs-lookup"><span data-stu-id="68302-108">This tutorial assumes that you've installed .NET Core.</span></span> <span data-ttu-id="68302-109">Yükleme yönergeleri için bkz: [.NET Core Yükleme Kılavuzu'na](https://www.microsoft.com/net/core).</span><span class="sxs-lookup"><span data-stu-id="68302-109">For installation instructions, see [.NET Core installation guide](https://www.microsoft.com/net/core).</span></span> <span data-ttu-id="68302-110">Kod Düzenleyicisi de gerekir.</span><span class="sxs-lookup"><span data-stu-id="68302-110">You also need a code editor.</span></span> <span data-ttu-id="68302-111">Bu öğretici kullanır [Visual Studio Code](https://code.visualstudio.com), herhangi bir kod düzenleyiciyi kullanabilirsiniz ancak.</span><span class="sxs-lookup"><span data-stu-id="68302-111">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="68302-112">Örnekleri çalıştırma</span><span class="sxs-lookup"><span data-stu-id="68302-112">Running the examples</span></span>

<span data-ttu-id="68302-113">Oluşturmak ve Bu öğreticide örnekleri çalıştırmak için kullandığınız [dotnet](../../core/tools/dotnet.md) komut satırından yardımcı programı.</span><span class="sxs-lookup"><span data-stu-id="68302-113">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="68302-114">Her örneği için şu adımları izleyin:</span><span class="sxs-lookup"><span data-stu-id="68302-114">Follow these steps for each example:</span></span>

1. <span data-ttu-id="68302-115">Örnek depolamak için bir dizin oluşturun.</span><span class="sxs-lookup"><span data-stu-id="68302-115">Create a directory to store the example.</span></span>
1. <span data-ttu-id="68302-116">Girin [dotnet yeni konsol](../../core/tools/dotnet-new.md) yeni bir .NET Core projesi oluşturmak için bir komut isteminde komutu.</span><span class="sxs-lookup"><span data-stu-id="68302-116">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="68302-117">Kopyalama ve örnek kod, kod düzenleyicisine yapıştırın.</span><span class="sxs-lookup"><span data-stu-id="68302-117">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="68302-118">Girin [dotnet geri yükleme](../../core/tools/dotnet-restore.md) yüklemek veya proje bağımlılıkları geri yüklemek için komut satırından komutu.</span><span class="sxs-lookup"><span data-stu-id="68302-118">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

  [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="68302-119">Girin [çalıştırmak dotnet](../../core/tools/dotnet-run.md) derlemek ve örnek çalıştırmak için komutu.</span><span class="sxs-lookup"><span data-stu-id="68302-119">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>


## <a name="background-what-is-inheritance"></a><span data-ttu-id="68302-120">Arka plan: Devralma nedir?</span><span class="sxs-lookup"><span data-stu-id="68302-120">Background: What is inheritance?</span></span>

<span data-ttu-id="68302-121">*Devralma* nesne odaklı programlama temel özniteliklerini biridir.</span><span class="sxs-lookup"><span data-stu-id="68302-121">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="68302-122">Yeniden kullanır bir alt sınıfı tanımlamanıza olanak verir (devralır) genişletir ya da bir üst sınıf davranışını değiştirir.</span><span class="sxs-lookup"><span data-stu-id="68302-122">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="68302-123">Üyeleri devralındığı sınıfı adlı *temel sınıfı*.</span><span class="sxs-lookup"><span data-stu-id="68302-123">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="68302-124">Taban sınıfı üyeleri devralınan sınıflarda adlı *türetilmiş sınıf*.</span><span class="sxs-lookup"><span data-stu-id="68302-124">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="68302-125">C# ve .NET Destek *tek devralma* yalnızca.</span><span class="sxs-lookup"><span data-stu-id="68302-125">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="68302-126">Diğer bir deyişle, bir sınıfın yalnızca tek bir sınıfı devralabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="68302-126">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="68302-127">Ancak, devralma türleri kümesi için bir devralma hiyerarşisi tanımlamanıza olanak sağlayan geçişli olur.</span><span class="sxs-lookup"><span data-stu-id="68302-127">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="68302-128">Diğer bir deyişle, yazın `D` türünden devralabilirsiniz `C`, türünden devralan `B`, taban sınıf türünden devralan `A`.</span><span class="sxs-lookup"><span data-stu-id="68302-128">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="68302-129">Devralma geçişli olduğundan türün üyeleri `A` yazmak kullanılabilen `D`.</span><span class="sxs-lookup"><span data-stu-id="68302-129">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="68302-130">Bir taban sınıfın tüm üyeleri türetilmiş sınıflar tarafından devralınır.</span><span class="sxs-lookup"><span data-stu-id="68302-130">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="68302-131">Aşağıdaki üyeleri devralınmaz:</span><span class="sxs-lookup"><span data-stu-id="68302-131">The following members are not inherited:</span></span>

- <span data-ttu-id="68302-132">[Statik oluşturucular](../programming-guide/classes-and-structs/static-constructors.md), bir sınıfın statik verileri başlatılamıyor.</span><span class="sxs-lookup"><span data-stu-id="68302-132">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="68302-133">[Örnek oluşturucuları](../programming-guide/classes-and-structs/constructors.md), hangi sınıfının yeni bir örneğini oluşturmak için çağırın.</span><span class="sxs-lookup"><span data-stu-id="68302-133">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="68302-134">Her sınıf kendi oluşturucular tanımlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="68302-134">Each class must define its own constructors.</span></span>

- <span data-ttu-id="68302-135">[Sonlandırıcılar](../programming-guide/classes-and-structs/destructors.md), bir sınıfın örneklerini yok etmek için çalışma zamanındaki atık toplayıcısı tarafından çağrılır.</span><span class="sxs-lookup"><span data-stu-id="68302-135">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="68302-136">Tüm bir taban sınıfı üyeleri türetilmiş sınıflar tarafından devralınır olsa da, veya görünür olup olmadıklarına kendi erişilebilirliği bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="68302-136">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="68302-137">Bir üyenin erişilebilirlik görünürlüğü türetilen sınıflar için şu şekilde etkiler:</span><span class="sxs-lookup"><span data-stu-id="68302-137">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="68302-138">[Özel](../language-reference/keywords/private.md) üyeleri yalnızca kendi taban sınıf içinde iç içe geçmiş türetilmiş sınıfları görünür.</span><span class="sxs-lookup"><span data-stu-id="68302-138">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="68302-139">Aksi takdirde, bunlar türetilmiş sınıflarda görünür değildir.</span><span class="sxs-lookup"><span data-stu-id="68302-139">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="68302-140">Aşağıdaki örnekte, `A.B` türetilen iç içe bir sınıf `A`, ve `C` türetilen `A`.</span><span class="sxs-lookup"><span data-stu-id="68302-140">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="68302-141">Özel `A.value` alandır A.B. içinde görünür</span><span class="sxs-lookup"><span data-stu-id="68302-141">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="68302-142">Ancak, açıklamalardan kaldırırsanız `C.GetValue` yöntemi ve örnek derleme girişimi derleyici hatası CS0122 oluşturur: "'A.value' kendi koruma düzeyi nedeniyle erişilemiyor."</span><span class="sxs-lookup"><span data-stu-id="68302-142">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="68302-143">[Korumalı](../language-reference/keywords/protected.md) üyeleri yalnızca türetilmiş sınıflarda görünür.</span><span class="sxs-lookup"><span data-stu-id="68302-143">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="68302-144">[İç](../language-reference/keywords/internal.md) üyeleridir temel sınıf olarak aynı bütünleştirilmiş kodda yer alan yalnızca türetilmiş sınıflarda görünür.</span><span class="sxs-lookup"><span data-stu-id="68302-144">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="68302-145">Bunlar türetilmiş sınıflarda temel sınıfından farklı bir derlemede bulunan görünür değildir.</span><span class="sxs-lookup"><span data-stu-id="68302-145">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="68302-146">[Ortak](../language-reference/keywords/public.md) üyeleri türetilmiş sınıflarda görünür ve türetilmiş sınıf ortak arabirimi bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="68302-146">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="68302-147">Yalnızca türetilmiş sınıfta tanımlanmadı sanki genel devralınan üyeler çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="68302-147">Public inherited members can be called just as if they were defined in the derived class.</span></span> <span data-ttu-id="68302-148">Aşağıdaki örnekte, sınıf `A` adlı bir yöntem tanımlar `Method1`ve sınıf `B` sınıfından devralan `A`.</span><span class="sxs-lookup"><span data-stu-id="68302-148">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="68302-149">Bu örnek daha sonra çağırır `Method1` üzerinde örnek yöntemi gibi `B`.</span><span class="sxs-lookup"><span data-stu-id="68302-149">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="68302-150">Türetilen sınıflar için de *geçersiz kılma* alternatif uygulaması sağlayarak devralınan üyeleri.</span><span class="sxs-lookup"><span data-stu-id="68302-150">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="68302-151">Üye geçersiz kılma oluşturabilmek, temel sınıf üye ile işaretlenmelidir [sanal](../language-reference/keywords/virtual.md) anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="68302-151">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="68302-152">Varsayılan olarak, taban sınıfı üyeleri olarak işaretlenmemiş `virtual` ve değiştirilemiyor.</span><span class="sxs-lookup"><span data-stu-id="68302-152">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="68302-153">Aşağıdaki örnekte olduğu gibi sanal olmayan üyesi geçersiz kılma girişiminde derleyici hatası CS0506 oluşturur: "<member> devralınan üye geçersiz kılamaz <member> sanal işaretlenmemiş çünkü soyut veya geçersiz kılamazsınız.</span><span class="sxs-lookup"><span data-stu-id="68302-153">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "<member> cannot override inherited member <member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="68302-154">Bazı durumlarda, türetilmiş bir sınıf *gerekir* taban sınıfı uygulama geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="68302-154">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="68302-155">Taban sınıfı üyeleri ile işaretli [soyut](../language-reference/keywords/abstract.md) anahtar sözcüğü gerektiren türetilen sınıflar onları geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="68302-155">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="68302-156">Aşağıdaki örnek derleme çalışılıyor oluşturur derleyici hatası CS0534, "<class> devralınan özet üyesini uygulamıyor <member>', çünkü sınıfı `B` hiçbir uygulamasını sağlar `A.Method1`.</span><span class="sxs-lookup"><span data-stu-id="68302-156">Attempting to compile the following example generates compiler error CS0534, "<class> does not implement inherited abstract member <member>', because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="68302-157">Devralma yalnızca sınıfları ve arabirimleri için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="68302-157">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="68302-158">Diğer tür kategorileri (yapılar, temsilciler ve numaralandırmaları) devralma desteklemez.</span><span class="sxs-lookup"><span data-stu-id="68302-158">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="68302-159">Bu nedenle, aşağıdaki gibi kod derleme çalışılıyor derleyici hatası CS0527 oluşturur: "Arabirim listesindeki ' ValueType' türünde değil bir arabirim."</span><span class="sxs-lookup"><span data-stu-id="68302-159">Because of this, attempting to compile code like the following produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="68302-160">Yapı uygulayan arabirimler tanımlayabilirsiniz rağmen devralma desteklenmiyor, hata iletisi gösterir.</span><span class="sxs-lookup"><span data-stu-id="68302-160">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="68302-161">Örtük devralma</span><span class="sxs-lookup"><span data-stu-id="68302-161">Implicit inheritance</span></span>

<span data-ttu-id="68302-162">Bunlar tek devralma yoluyla devralınmalıdır herhangi bir türünün yanı sıra, devralınmalıdır örtük olarak .NET tür sistemi içindeki tüm türler <xref:System.Object> veya ondan türetilmiş bir tür.</span><span class="sxs-lookup"><span data-stu-id="68302-162">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="68302-163">Bu ortak işlevsellik için herhangi bir türü kullanılabilir olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="68302-163">This ensures that common functionality is available to any type.</span></span>

<span data-ttu-id="68302-164">Şimdi yeni bir sınıf tanımlama hangi örtük devralma gelir görmek için `SimpleClass`, yalnızca boş sınıf tanımı değil:</span><span class="sxs-lookup"><span data-stu-id="68302-164">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="68302-165">Biz sonra (sağlayan bize türü hakkında bilgi almak için bir tür meta verileri incelemek) yansıma kullanabilirsiniz ait üyelerin listesini almak için `SimpleClass` türü.</span><span class="sxs-lookup"><span data-stu-id="68302-165">We can then use reflection (which lets us inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="68302-166">Herhangi bir üye tanımlanan henüz rağmen bizim `SimpleClass` örnekten çıktı sınıfı gösterir gerçekte dokuz üye olduğunu.</span><span class="sxs-lookup"><span data-stu-id="68302-166">Although we haven't defined any members in our `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="68302-167">Bunlardan biridir için otomatik olarak sağlanan bir parametresiz (veya varsayılan) Oluşturucu `SimpleClass` C# Derleyici tarafından türü.</span><span class="sxs-lookup"><span data-stu-id="68302-167">One of these is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="68302-168">Sekiz kalan üyeleri olan <xref:System.Object>, kendisinden tüm sınıflar ve arabirimler .NET içinde sistem sonuçta örtük olarak yazın devralır.</span><span class="sxs-lookup"><span data-stu-id="68302-168">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="68302-169">Örtük devralmadan <xref:System.Object> sınıfı bu yöntemleri kullanılabilir kılar `SimpleClass` sınıfı:</span><span class="sxs-lookup"><span data-stu-id="68302-169">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="68302-170">Ortak `ToString` dönüştürür yöntemi bir `SimpleClass` nesnesi tam olarak nitelenmiş tür adını kendi dize gösterimini döndürür.</span><span class="sxs-lookup"><span data-stu-id="68302-170">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="68302-171">Bu durumda, `ToString` yöntemi "SimpleClass" dizesini döndürür.</span><span class="sxs-lookup"><span data-stu-id="68302-171">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="68302-172">İki nesnenin eşitlik için test üç yöntem: ortak örnek `Equals(Object)` yöntemi, bir genel statik `Equals(Object, Object)` yöntemi ve ortak statik `ReferenceEquals(Object, Object)` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="68302-172">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="68302-173">Varsayılan olarak, bu yöntemleri referans eşitlik için test; diğer bir deyişle, eşit olacak şekilde iki nesne değişkenleri de aynı nesneye başvurması gerekir.</span><span class="sxs-lookup"><span data-stu-id="68302-173">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="68302-174">Ortak `GetHashCode` karma koleksiyonlarda kullanılacak türünün bir örneği sağlayan bir değeri hesaplar yöntemi.</span><span class="sxs-lookup"><span data-stu-id="68302-174">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="68302-175">Ortak `GetType` döndürür yöntemi bir <xref:System.Type> temsil eden nesnesi `SimpleClass` türü.</span><span class="sxs-lookup"><span data-stu-id="68302-175">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="68302-176">Korumalı <xref:System.Object.Finalize%2A> nesnenin bellek çöp toplayıcı tarafından alınmadan önce yönetilmeyen kaynakları serbest bırakmak için tasarlanmış yöntemi.</span><span class="sxs-lookup"><span data-stu-id="68302-176">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="68302-177">Korumalı <xref:System.Object.MemberwiseClone%2A> yöntemi geçerli nesne basit bir kopyasını oluşturur.</span><span class="sxs-lookup"><span data-stu-id="68302-177">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="68302-178">Örtük devralma nedeniyle biz devralınan bir üyeden çağırabilirsiniz bir `SimpleClass` gerçekten üyesi boşmuş gibi yalnızca nesne tanımlanan `SimpleClass` sınıfı.</span><span class="sxs-lookup"><span data-stu-id="68302-178">Because of implicit inheritance, we can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="68302-179">Örneğin, aşağıdaki örnek çağırır `SimpleClass.ToString` yöntemi, hangi `SimpleClass` devraldığı <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="68302-179">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="68302-180">Aşağıdaki tabloda, C# ' ta oluşturabilirsiniz türleri ve kendisinden bunlar örtük olarak devral türleri kategorilerini listeler.</span><span class="sxs-lookup"><span data-stu-id="68302-180">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="68302-181">Her temel türü farklı bir üye kümesi için örtük olarak türetilmiş türler devralma yoluyla kullanılabilir hale getirir.</span><span class="sxs-lookup"><span data-stu-id="68302-181">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="68302-182">Türü kategori</span><span class="sxs-lookup"><span data-stu-id="68302-182">Type category</span></span> | <span data-ttu-id="68302-183">Örtük olarak devralır</span><span class="sxs-lookup"><span data-stu-id="68302-183">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="68302-184">sınıf</span><span class="sxs-lookup"><span data-stu-id="68302-184">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="68302-185">struct </span><span class="sxs-lookup"><span data-stu-id="68302-185">struct</span></span>        | <span data-ttu-id="68302-186"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="68302-186"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="68302-187">enum</span><span class="sxs-lookup"><span data-stu-id="68302-187">enum</span></span>          | <span data-ttu-id="68302-188"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="68302-188"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="68302-189">temsilci</span><span class="sxs-lookup"><span data-stu-id="68302-189">delegate</span></span>      | <span data-ttu-id="68302-190"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="68302-190"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="68302-191">Devralma ve bir "olan bir" ilişki</span><span class="sxs-lookup"><span data-stu-id="68302-191">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="68302-192">Normalde, devralma ifade etmek için kullanılan bir "olan bir" temel sınıf ve türetilen sınıflar temel sınıfın özel sürümleri olduğu bir veya daha fazla türetilmiş sınıflar arasındaki ilişki türetilen sınıfın temel sınıf türüdür.</span><span class="sxs-lookup"><span data-stu-id="68302-192">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="68302-193">Örneğin, `Publication` sınıfı, herhangi bir türde bir yayın'ı temsil eder ve `Book` ve `Magazine` sınıfları belirli tür yayınlar temsil eder.</span><span class="sxs-lookup"><span data-stu-id="68302-193">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="68302-194">Sınıfta veya yapı bir daha fazla arabirim uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="68302-194">A class or struct can implement one more interfaces.</span></span> <span data-ttu-id="68302-195">Arabirim uygulaması genellikle geçici bir çözüm için tek devralma veya devralma ile yapılar kullanmanın bir yolu olarak sunulan olsa da, bir arabirim ve uygulama türü daha arasında farklı bir ilişkiye ("yapabilirsiniz" ilişki) express için tasarlanmıştır Devralma.</span><span class="sxs-lookup"><span data-stu-id="68302-195">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="68302-196">Bir arabirim arabirimi uygulayan türlerinden kullanılabilmesini (örneğin, özelliği nesnelere karşılaştırma veya sıralama eşitlik için test etmek için ya da kültüre duyarlı ayrıştırma ve biçimlendirme desteklemek için) işlevlerinin bir alt kümesini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="68302-196">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="68302-197">Unutmayın "olan bir" de türünü ve belirli bir örnek oluşturma türü arasındaki ilişkiyi ifade eder.</span><span class="sxs-lookup"><span data-stu-id="68302-197">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="68302-198">Aşağıdaki örnekte, `Automobile` üç benzersiz salt okunur özelliklere sahip bir sınıftır: `Make`, otomobil; üreticisi `Model`, otomobil; tür ve `Year`, kendi yılın üretim.</span><span class="sxs-lookup"><span data-stu-id="68302-198">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="68302-199">Bizim `Automobile` sınıfı ayrıca olan bağımsız değişkenler için özellik değerlerine atanmış bir oluşturucuya sahip ve onu geçersiz kılmaları <xref:System.Object.ToString%2A?displayProperty=nameWithType> benzersiz olarak tanımlayan bir dize üretmek için yöntemi `Automobile` örneği yerine `Automobile` sınıfı.</span><span class="sxs-lookup"><span data-stu-id="68302-199">Our `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="68302-200">Bu durumda, biz belirli araba marka ve model temsil devralma güvenmemelisiniz.</span><span class="sxs-lookup"><span data-stu-id="68302-200">In this case, we should not rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="68302-201">Örneğin, tanımlamak ihtiyacımız olmayan bir `Packard` Packard Motor Car şirket tarafından üretilen otomobiller temsil eden tür.</span><span class="sxs-lookup"><span data-stu-id="68302-201">For example, we do not need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="68302-202">Bunun yerine, biz bunları oluşturarak temsil edebilen bir `Automobile` aşağıdaki örnekte olduğu gibi sınıfı oluşturucuya geçirilen uygun değerleri içeren nesne.</span><span class="sxs-lookup"><span data-stu-id="68302-202">Instead, we can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="68302-203">Devralmayı tabanlı bir olan bir ilişki en iyi bir taban sınıf ve türetilen için temel sınıf ek üye eklemek veya ek işlevsellik taban sınıf içinde mevcut değil gerektiren sınıfları uygulanır.</span><span class="sxs-lookup"><span data-stu-id="68302-203">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="68302-204">Taban sınıf tasarlama ve türetilmiş sınıflar</span><span class="sxs-lookup"><span data-stu-id="68302-204">Designing the base class and derived classes</span></span>

<span data-ttu-id="68302-205">Bir taban sınıf ve türetilmiş sınıflarının tasarlama işlemi bakalım.</span><span class="sxs-lookup"><span data-stu-id="68302-205">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="68302-206">Bu bölümde, bir taban sınıf tanımlarız `Publication`, kitap, vb. bir dergi, bir gazete, bir günlük, bir makale herhangi bir türde bir yayın temsil eder. Biz de tanımlarsınız bir `Book` öğesinden türetilen sınıf `Publication`.</span><span class="sxs-lookup"><span data-stu-id="68302-206">In this section, we'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. We'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="68302-207">Biz kolayca diğer türetilen sınıflar gibi tanımlamak için örnek genişletebilirsiniz `Magazine`, `Journal`, `Newspaper`, ve `Article`.</span><span class="sxs-lookup"><span data-stu-id="68302-207">We could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="68302-208">Temel yayım sınıfı</span><span class="sxs-lookup"><span data-stu-id="68302-208">The base Publication class</span></span>

<span data-ttu-id="68302-209">Tasarlama, bizim `Publication` sınıfı, ihtiyacımız birkaç tasarım kararları almak:</span><span class="sxs-lookup"><span data-stu-id="68302-209">In designing our `Publication` class, we need to make several design decisions:</span></span>

- <span data-ttu-id="68302-210">Bizim Bankası'ndaki eklenecek üyeleri `Publication` sınıfı olup `Publication` üyeleri yöntem uygulamalarını sağlayın veya `Publication` türetilmiş sınıflarının için bir şablon olarak hizmet veren bir Özet temel sınıf.</span><span class="sxs-lookup"><span data-stu-id="68302-210">What members to include in our base `Publication` class, and whether the `Publication` members provide method implementations, or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="68302-211">Bu durumda, `Publication` sınıfı, yöntem uygulamalarını sağlayacaktır.</span><span class="sxs-lookup"><span data-stu-id="68302-211">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="68302-212">[Tasarlama soyut taban sınıfları amd kendi türetilen sınıflar](#abstract) bölüm içeren bir Özet kullanan bir örnek türetilmiş sınıfları yöntemlerini tanımlamak için temel sınıf geçersiz kılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="68302-212">The [Designing abstract base classes amd their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="68302-213">Türetilen sınıflar türetilen tür uygun herhangi bir uygulama sağlamak boş.</span><span class="sxs-lookup"><span data-stu-id="68302-213">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="68302-214">Kodunu (bildirim ve uygulamasını taban yöntemleri sınıfı ve bunları geçersiz kılma gerekmez diğer bir deyişle, birden çok türetilen sınıflar paylaşım) yeniden Özet olmayan taban sınıflar avantajı yeteneğidir.</span><span class="sxs-lookup"><span data-stu-id="68302-214">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="68302-215">Bu nedenle, biz üyelerine eklemelisiniz `Publication` kendi kodu bazı tarafından paylaşılabilir veya özelleştirilmiş en büyük olasılıkla ise `Publication` türleri.</span><span class="sxs-lookup"><span data-stu-id="68302-215">Therefore, we should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="68302-216">Biz bunu verimli bir şekilde yapmak başarısız olursa, biz büyük ölçüde aynı üye türetilmiş sınıflarda temel sınıf yerine tek bir uygulama uygulamalarını gerek kalmadan elde edersiniz.</span><span class="sxs-lookup"><span data-stu-id="68302-216">If we fail to do this efficiently, we'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="68302-217">Birden fazla konumda yinelenen kodunu korumak için gereken, hataların olası bir kaynaktır.</span><span class="sxs-lookup"><span data-stu-id="68302-217">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="68302-218">En üst düzeye çıkarmak için her ikisini de yeniden kod ve mantıksal ve sezgisel devralma hiyerarşisi oluşturmak için eklediğimiz emin olmak istiyoruz `Publication` sınıf yalnızca veri ve tüm veya çoğu yayınlar için ortak işlevselliği.</span><span class="sxs-lookup"><span data-stu-id="68302-218">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, we want to be sure that we include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="68302-219">Türetilen sınıflar, ardından belirli temsil ettikleri yayın türleri için benzersiz üyelerini uygulayın.</span><span class="sxs-lookup"><span data-stu-id="68302-219">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="68302-220">Şu ana kadar bizim sınıf hiyerarşisi genişletmek nasıl.</span><span class="sxs-lookup"><span data-stu-id="68302-220">How far to extend our class hierarchy.</span></span> <span data-ttu-id="68302-221">Üç veya daha fazla sınıf yerine yalnızca bir temel sınıf ve bir veya daha fazla türetilmiş sınıflar hiyerarşisi geliştirmek istiyor musunuz?</span><span class="sxs-lookup"><span data-stu-id="68302-221">Do we want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="68302-222">Örneğin, `Publication` temel bir sınıfında olabilir `Periodical`, sırayla olduğu temel bir sınıfında `Magazine`, `Journal` ve `Newspaper`.</span><span class="sxs-lookup"><span data-stu-id="68302-222">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="68302-223">Bizim örneğimizde, basit hiyerarşisini kullanacağız bir `Publication` sınıfı ve tek bir türetilen sınıflar `Book`.</span><span class="sxs-lookup"><span data-stu-id="68302-223">For our example, we'll use the simple hierarchy of a `Publication` class and a single derived classes, `Book`.</span></span> <span data-ttu-id="68302-224">Biz kolayca birkaç öğesinden türetilen ek sınıfları oluşturmak için örnek genişletebilirsiniz `Publication`, gibi `Magazine` ve `Article`.</span><span class="sxs-lookup"><span data-stu-id="68302-224">We could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="68302-225">Olup temel sınıf örneği oluşturmak için mantıklıdır.</span><span class="sxs-lookup"><span data-stu-id="68302-225">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="68302-226">Yoksa, biz uygulamalıdır [soyut](../language-reference/keywords/abstract.md) anahtar sözcüğü ile sınıfı.</span><span class="sxs-lookup"><span data-stu-id="68302-226">If it does not, we should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="68302-227">Girişiminde ile işaretli bir sınıf örneği oluşturmak için yapılması durumunda `abstract` anahtar sözcüğü sınıf oluşturucusu, C# Derleyici doğrudan çağrısıyla hatasına neden CS0144, "soyut sınıf veya arabirim bir örneğini oluşturamıyor."</span><span class="sxs-lookup"><span data-stu-id="68302-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="68302-228">Yansıma, yansıma yöntemi atar kullanarak sınıfının örneği için bir girişimde varsa bir <xref:System.MemberAccessException>.</span><span class="sxs-lookup"><span data-stu-id="68302-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span> <span data-ttu-id="68302-229">Aksi takdirde, bizim `Publication` sınıfı, kendi sınıf oluşturucu çağırarak oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="68302-229">Otherwise, our `Publication` class can be instantiated by calling its class constructor.</span></span>

  <span data-ttu-id="68302-230">Varsayılan olarak, bir taban sınıf, sınıf oluşturucu çağırarak oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="68302-230">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="68302-231">Biz açıkça bir sınıf oluşturucu tanımlamak sahip olmadığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="68302-231">Note that we do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="68302-232">Bir temel sınıf kaynak kodunda mevcut değilse, C# Derleyici (parametresiz) bir varsayılan oluşturucusu otomatik olarak sağlar.</span><span class="sxs-lookup"><span data-stu-id="68302-232">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="68302-233">Bizim örneğimizde, biz işaretlemek `Publication` olarak sınıf [soyut](../language-reference/keywords/abstract.md) böylece örneği oluşturulamıyor.</span><span class="sxs-lookup"><span data-stu-id="68302-233">For our example, we'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>

- <span data-ttu-id="68302-234">Türetilmiş sınıflar temel sınıf uygulamasını belirli üyeleri olup devralmalıdır veya temel sınıf uygulamasını geçersiz kılma seçeneği olup olmadığını.</span><span class="sxs-lookup"><span data-stu-id="68302-234">Whether derived classes must inherit the base class implementation of a particular members, or whether they have the option to override the base class implementation.</span></span> <span data-ttu-id="68302-235">Biz kullanmak zorunda [sanal](../language-reference/keywords/virtual.md) anahtar sözcüğü bir temel sınıf yöntemi geçersiz kılmak türetilen sınıflar izin vermek için.</span><span class="sxs-lookup"><span data-stu-id="68302-235">We have to use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="68302-236">Varsayılan olarak, taban sınıf içinde tanımlanan yöntemlerdir *değil* geçersiz kılınabilir.</span><span class="sxs-lookup"><span data-stu-id="68302-236">By default, methods defined in the base class are *not* overridable.</span></span>

- <span data-ttu-id="68302-237">Türetilmiş sınıf devralma hiyerarşisinde son sınıfı temsil eder ve kendisi için ek türetilmiş sınıflar temel sınıf olarak kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="68302-237">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="68302-238">Varsayılan olarak, herhangi bir sınıfın temel sınıf olarak hizmet verebilir.</span><span class="sxs-lookup"><span data-stu-id="68302-238">By default, any class can serve as a base class.</span></span> <span data-ttu-id="68302-239">Biz uygulayabilirsiniz [korumalı](../language-reference/keywords/sealed.md) bir sınıf ek sınıfları için temel sınıf olarak sunulamıyor göstermek için anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="68302-239">We can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="68302-240">Bir korumalı sınıf oluşturulan derleyici hatası CS0509, çıkarmaya çalışırken "korumalı türünden türetilemez <typeName>".</span><span class="sxs-lookup"><span data-stu-id="68302-240">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type <typeName>".</span></span>

  <span data-ttu-id="68302-241">Bizim örneğimizde, biz bizim türetilmiş sınıf olarak işaretlemek `sealed`.</span><span class="sxs-lookup"><span data-stu-id="68302-241">For our example, we'll mark our derived class as `sealed`.</span></span>

<span data-ttu-id="68302-242">Aşağıdaki örnek için kaynak kodunu gösterir `Publication` sınıfı, yanı sıra bir `PublicationType` tarafından döndürülen numaralandırma `Publication.PublicationType` özelliği.</span><span class="sxs-lookup"><span data-stu-id="68302-242">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="68302-243">Öğesinden devralınan üyeler yanı sıra <xref:System.Object>, `Publication` sınıfı aşağıdaki benzersiz üyeleri tanımlar ve üye geçersiz kılar:</span><span class="sxs-lookup"><span data-stu-id="68302-243">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="68302-244">Bir Oluşturucu</span><span class="sxs-lookup"><span data-stu-id="68302-244">A constructor</span></span>

  <span data-ttu-id="68302-245">Çünkü `Publication` sınıf `abstract`, doğrudan aşağıdaki gibi kodundan örneği oluşturulamıyor:</span><span class="sxs-lookup"><span data-stu-id="68302-245">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="68302-246">Ancak, örnek kurucusu türetilmiş sınıf oluşturucu doğrudan için kaynak kodunu olarak çağrılabilir `Book` sınıfı gösterir.</span><span class="sxs-lookup"><span data-stu-id="68302-246">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="68302-247">İki yayın ilgili Özellikler</span><span class="sxs-lookup"><span data-stu-id="68302-247">Two publication-related properties</span></span>

  <span data-ttu-id="68302-248">`Title`salt okunur <xref:System.String> özelliği değeri, çağıran sağlanmaktadır `Publication` Oluşturucusu.</span><span class="sxs-lookup"><span data-stu-id="68302-248">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="68302-249">`Pages`bir okuma-yazma <xref:System.Int32> kaç toplam yayın sayfaları gösterir özelliğine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="68302-249">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="68302-250">Değer adlı özel bir alanda depolanan `totalPages`.</span><span class="sxs-lookup"><span data-stu-id="68302-250">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="68302-251">Pozitif bir sayı olmalıdır veya bir <xref:System.ArgumentOutOfRangeException> oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="68302-251">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="68302-252">Yayımcı ilgili üyeleri</span><span class="sxs-lookup"><span data-stu-id="68302-252">Publisher-related members</span></span>

  <span data-ttu-id="68302-253">İki salt okunur özellikler `Publisher` ve `Type`.</span><span class="sxs-lookup"><span data-stu-id="68302-253">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="68302-254">Değerlerin ilk olarak çağrısıyla sağlanan `Publication` sınıfı oluşturucusu.</span><span class="sxs-lookup"><span data-stu-id="68302-254">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="68302-255">Yayımlama ile ilgili üyeleri</span><span class="sxs-lookup"><span data-stu-id="68302-255">Publishing-related members</span></span>

  <span data-ttu-id="68302-256">İki yöntem `Publish` ve `GetPublicationDate`, ayarlayın ve yayın tarihi döndürür.</span><span class="sxs-lookup"><span data-stu-id="68302-256">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="68302-257">`Publish` Yöntemi bir özel ayarlar `published` bayrağını `true` zaman olarak adlandırılır ve tarihi atadığında geçirilen kendisine özel bir bağımsız değişken olarak `datePublished` alan.</span><span class="sxs-lookup"><span data-stu-id="68302-257">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="68302-258">`GetPublicationDate` Yöntemi durumunda "NYP" dizesini döndürür `published` bayrağı `false`, değerini `datePublished` , alan `true`.</span><span class="sxs-lookup"><span data-stu-id="68302-258">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="68302-259">Telif Hakkı ilgili üyeleri</span><span class="sxs-lookup"><span data-stu-id="68302-259">Copyright-related members</span></span>

  <span data-ttu-id="68302-260">`Copyright` Yöntemi telif hakkı sahibinin adını ve telif hakkı yılın bağımsız değişkenleri olarak alır ve bunlara atar `CopyrightName` ve `CopyrightDate` özellikleri.</span><span class="sxs-lookup"><span data-stu-id="68302-260">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="68302-261">Geçersiz kılma `ToString` yöntemi</span><span class="sxs-lookup"><span data-stu-id="68302-261">An override of the `ToString` method</span></span>

  <span data-ttu-id="68302-262">Bir tür değil geçersiz kılarsanız <xref:System.Object.ToString%2A?displayProperty=nameWithType> yöntemi türü olan bir örneği başka bir ayrım içinde çok az kullanım tam adını döndürür.</span><span class="sxs-lookup"><span data-stu-id="68302-262">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="68302-263">`Publication` Geçersiz kılmaları sınıf <xref:System.Object.ToString%2A?displayProperty=nameWithType> değerini döndürmek için `Title` özelliği.</span><span class="sxs-lookup"><span data-stu-id="68302-263">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="68302-264">Aşağıdaki şekilde bizim temel arasındaki ilişki gösterilmektedir `Publication` sınıfı ve onun örtük olarak devralınan <xref:System.Object> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="68302-264">The following figure illustrates the relationship between our base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Nesne ve yayın sınıfları](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="68302-266">`Book` Sınıfı</span><span class="sxs-lookup"><span data-stu-id="68302-266">The `Book` class</span></span>

<span data-ttu-id="68302-267">`Book` Sınıfı kitap yayın özel bir tür olarak temsil eder.</span><span class="sxs-lookup"><span data-stu-id="68302-267">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="68302-268">Aşağıdaki örnek için kaynak kodunu gösterir `Book` sınıfı.</span><span class="sxs-lookup"><span data-stu-id="68302-268">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="68302-269">Öğesinden devralınan üyeler yanı sıra `Publication`, `Book` sınıfı aşağıdaki benzersiz üyeleri tanımlar ve üye geçersiz kılar:</span><span class="sxs-lookup"><span data-stu-id="68302-269">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="68302-270">İki Oluşturucusu</span><span class="sxs-lookup"><span data-stu-id="68302-270">Two constructors</span></span>

  <span data-ttu-id="68302-271">İki `Book` oluşturucular üç ortak parametreler paylaşın.</span><span class="sxs-lookup"><span data-stu-id="68302-271">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="68302-272">İki *başlık* ve *yayımcı*, parametreleri için karşılık gelen `Publication` Oluşturucusu.</span><span class="sxs-lookup"><span data-stu-id="68302-272">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="68302-273">Üçüncü olan *Yazar*, özel depolanmış `authorName` alan.</span><span class="sxs-lookup"><span data-stu-id="68302-273">The third is *author*, which is stored to a private `authorName` field.</span></span> <span data-ttu-id="68302-274">Bir oluşturucu içeren bir *ISBN* depolanan parametresi `ISBN` otomatik özelliği.</span><span class="sxs-lookup"><span data-stu-id="68302-274">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="68302-275">İlk Oluşturucusu kullanan [bu](../language-reference/keywords/this.md) diğer oluşturucuyu çağırmak için anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="68302-275">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="68302-276">Oluşturucular tanımlamakta genel bir desen budur.</span><span class="sxs-lookup"><span data-stu-id="68302-276">This is a common pattern in defining constructors.</span></span> <span data-ttu-id="68302-277">Daha az parametreli oluşturucular en fazla sayıda parametre ile oluşturucu çağrılırken, varsayılan değerleri sağlayın.</span><span class="sxs-lookup"><span data-stu-id="68302-277">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="68302-278">İkinci oluşturucu kullanan [temel](../language-reference/keywords/base.md) temel sınıf oluşturucu başlık ve yayımcı adını geçirmek için anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="68302-278">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="68302-279">Kaynak kodunuz bir temel sınıf oluşturucu için açık bir çağrı yapmazsanız, C# derleyici temel sınıf varsayılan veya parametresiz oluşturucu için bir çağrı otomatik olarak sağlar.</span><span class="sxs-lookup"><span data-stu-id="68302-279">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="68302-280">Salt okunur `ISBN` döndürür özelliği `Book` nesnenin uluslararası standart kitap numarası, benzersiz 10 veya 13 basamaklı bir sayı.</span><span class="sxs-lookup"><span data-stu-id="68302-280">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="68302-281">ISBN birine bağımsız değişken olarak sağlanan `Book` oluşturucular.</span><span class="sxs-lookup"><span data-stu-id="68302-281">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="68302-282">ISBN derleyici tarafından otomatik olarak oluşturulan bir özel yedekleme alanını depolanır.</span><span class="sxs-lookup"><span data-stu-id="68302-282">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="68302-283">Salt okunur `Author` özelliği.</span><span class="sxs-lookup"><span data-stu-id="68302-283">A read-only `Author` property.</span></span> <span data-ttu-id="68302-284">Yazar adı hem de bağımsız değişken olarak sağlanan `Book` oluşturucular ve özel depolanan `authorName` alan.</span><span class="sxs-lookup"><span data-stu-id="68302-284">The author name is supplied as an argument to both `Book` constructors and is stored in the private `authorName` field.</span></span>

- <span data-ttu-id="68302-285">İki salt okunur fiyat ile ilgili özellikler, `Price` ve `Currency`.</span><span class="sxs-lookup"><span data-stu-id="68302-285">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="68302-286">Bağımsız değişken olarak değerlerine sağlanan bir `SetPrice` yöntem çağrısı.</span><span class="sxs-lookup"><span data-stu-id="68302-286">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="68302-287">Fiyat özel bir alanda depolanan `bookPrice`.</span><span class="sxs-lookup"><span data-stu-id="68302-287">The price is stored in a private field, `bookPrice`.</span></span> <span data-ttu-id="68302-288">`Currency` Özelliği üç basamaklı ISO para birimi simgesini (örneğin, ABD Doları ABD Doları) ve özel depolanan `ISOCurrencySymbol` alan.</span><span class="sxs-lookup"><span data-stu-id="68302-288">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar) and is stored in the private `ISOCurrencySymbol` field.</span></span> <span data-ttu-id="68302-289">ISO para birimi simgeleri alınabileceği <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> özelliği.</span><span class="sxs-lookup"><span data-stu-id="68302-289">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span>

- <span data-ttu-id="68302-290">A `SetPrice` değerlerini ayarlar yöntemi `bookPrice` ve `ISOCurrencySymbol` alanları.</span><span class="sxs-lookup"><span data-stu-id="68302-290">A `SetPrice` method, which sets the values of the `bookPrice` and `ISOCurrencySymbol` fields.</span></span> <span data-ttu-id="68302-291">Bunlar tarafından döndürülen değerlerdir `Price` ve `Currency` özellikleri.</span><span class="sxs-lookup"><span data-stu-id="68302-291">These are the values returned by the `Price` and `Currency` properties.</span></span>

- <span data-ttu-id="68302-292">Geçersiz kılmaları `ToString` yöntemi (devralınan `Publication`) ve <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> ve <xref:System.Object.GetHashCode%2A> yöntemleri (devralınan <xref:System.Object>).</span><span class="sxs-lookup"><span data-stu-id="68302-292">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="68302-293">Bu geçersiz kılınmadığı sürece <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> yöntemi testleri başvuru eşitliği.</span><span class="sxs-lookup"><span data-stu-id="68302-293">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="68302-294">Diğer bir deyişle, iki nesne değişkenlerini de aynı nesneye başvurduğundan eşit olduğu kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="68302-294">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="68302-295">Durumunda `Book` sınıfı, diğer yandan, iki `Book` nesneleri aynı ISBN varsa eşit olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="68302-295">In the case of the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="68302-296">Kıldığınızda <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> yöntemi, ayrıca kılmanız gerekir <xref:System.Object.GetHashCode%2A> çalışma zamanı verimli alma için karma koleksiyonlarda öğeleri depolamak için kullandığı bir değer döndürür yöntemi.</span><span class="sxs-lookup"><span data-stu-id="68302-296">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="68302-297">Karma kod eşitlik için test ile tutarlı olan bir değer döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="68302-297">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="68302-298">Biz geçersiz olduğundan <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> döndürülecek `true` , iki ISBN özelliklerini `Book` nesneleri eşit olan, biz çağırarak hesaplanan karma kodu döndürür <xref:System.String.GetHashCode%2A> yöntemi tarafından döndürülen dize `ISBN` özelliği.</span><span class="sxs-lookup"><span data-stu-id="68302-298">Since we've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, we return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="68302-299">Aşağıdaki şekilde arasındaki ilişki gösterilmektedir `Book` sınıfı ve `Publication`, kendi temel sınıfı.</span><span class="sxs-lookup"><span data-stu-id="68302-299">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Yayın ve kitap sınıfları](media/book-class.jpg)

<span data-ttu-id="68302-301">Biz şimdi örneği bir `Book` nesnesi, her iki benzersiz ve devralınan üyeleri çağırma ve bağımsız değişken olarak türünde bir parametre bekler bir yönteme geçirin `Publication` veya türünde `Book`, aşağıdaki örnekte gösterildiği gibi.</span><span class="sxs-lookup"><span data-stu-id="68302-301">We can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="68302-302">Soyut taban sınıfları ve bunların türetilmiş sınıfları tasarlama</span><span class="sxs-lookup"><span data-stu-id="68302-302">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="68302-303">Önceki örnekte, bir uygulama çeşitli yöntemler kod paylaşmak türetilen sınıflar izin vermek için sağlanan bir taban sınıf tanımlı.</span><span class="sxs-lookup"><span data-stu-id="68302-303">In the previous example, we defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="68302-304">Çoğu durumda, ancak temel sınıfı bir uygulama sunmak amacıyla beklenmiyor.</span><span class="sxs-lookup"><span data-stu-id="68302-304">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="68302-305">Bunun yerine, temel sınıfı olan bir *soyut sınıf*; her türetilmiş sınıf üyeleri tanımlayan bir şablon uygulamalıdır olarak görev yapar.</span><span class="sxs-lookup"><span data-stu-id="68302-305">Instead, the base class is an *abstract class*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="68302-306">Genellikle Özet temel sınıf söz konusu olduğunda, her türetilmiş bir tür için bu türü benzersiz uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="68302-306">Typically in the case of an abstract base class, the implementation of each derived type is unique to that type.</span></span>

<span data-ttu-id="68302-307">Örneğin, her kapalı iki boyutlu geometrik şekil iki özellikleri içerir: alanı, iç ölçüde şeklin; ve çevre veya şekli kenarlarında uzaklığı.</span><span class="sxs-lookup"><span data-stu-id="68302-307">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="68302-308">Bu özellikler, hesaplanan, yolu tamamen ancak, belirli şekline bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="68302-308">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="68302-309">Bir daire çevre (veya çevresini) hesaplama formülü Örneğin, çok, bir üçgen farklıdır.</span><span class="sxs-lookup"><span data-stu-id="68302-309">The formula for calculating the perimeter (or circumference) of a circle, for example, is very different from that of a triangle.</span></span>

<span data-ttu-id="68302-310">Aşağıdaki örnek adlı Özet temel sınıf tanımlar `Shape` iki özelliklerini tanımlar: `Area` ve `Perimeter`.</span><span class="sxs-lookup"><span data-stu-id="68302-310">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="68302-311">Sınıfı işaretlemeyi yanı sıra unutmayın [soyut](../language-reference/keywords/abstract.md) anahtar sözcüğü, her örnek üyesinin ayrıca ile işaretlenir [soyut](../language-reference/keywords/abstract.md) anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="68302-311">Note that, in addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="68302-312">Bu durumda, `Shape` ayrıca geçersiz kılar <xref:System.Object.ToString%2A?displayProperty=nameWithType> türünün adı yerine tam olarak nitelenmiş adını döndürmek için yöntem.</span><span class="sxs-lookup"><span data-stu-id="68302-312">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="68302-313">Ve iki statik üyeleri tanımlayan `GetArea` ve `GetPerimeter`, alan ve çevre türetilmiş bir sınıf örneği kolayca almak arayanlara izin verin.</span><span class="sxs-lookup"><span data-stu-id="68302-313">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="68302-314">Biz türetilmiş bir sınıf örneği bu yöntemlerden birini geçirdiğinizde, çalışma zamanı türetilmiş sınıf yöntemi geçersiz kılma çağırır.</span><span class="sxs-lookup"><span data-stu-id="68302-314">When we pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="68302-315">Biz sonra bazı sınıflardan türetilemeyeceğini `Shape` belirli şekiller temsil eder.</span><span class="sxs-lookup"><span data-stu-id="68302-315">We can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="68302-316">Aşağıdaki örnek, üç sınıf tanımlar `Triangle`, `Rectangle`, ve `Circle`.</span><span class="sxs-lookup"><span data-stu-id="68302-316">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="68302-317">Her alan ve çevre hesaplamak için bu belirli şekil için benzersiz bir formül kullanır.</span><span class="sxs-lookup"><span data-stu-id="68302-317">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="68302-318">Türetilen sınıfların bazıları da özelliklerini gibi tanımlamak `Rectangle.Diagonal` ve `Circle.Diameter`, bunlar temsil eden şekli benzersiz olan.</span><span class="sxs-lookup"><span data-stu-id="68302-318">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="68302-319">Aşağıdaki örnek, türetilen nesneler kullanır `Shape`.</span><span class="sxs-lookup"><span data-stu-id="68302-319">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="68302-320">Türetilen nesnelerinin bir dizisi başlatır `Shape` ve statik yöntemlerini çağırır `Shape` return sarmalar sınıfı `Shape` özellik değerleri.</span><span class="sxs-lookup"><span data-stu-id="68302-320">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="68302-321">Çalışma zamanı türetilmiş türlerde geçersiz kılınan özelliklerinden değerleri alan unutmayın.</span><span class="sxs-lookup"><span data-stu-id="68302-321">Note that the runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="68302-322">Bu örnek ayrıca her bıraktığı `Shape` dizi, türetilmiş bir tür olarak nesnesinde ve Dönüştürme başarılı olursa, o belirli bir alt sınıfı özelliklerini alır `Shape`.</span><span class="sxs-lookup"><span data-stu-id="68302-322">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span> 

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="68302-323">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="68302-323">See also</span></span>

<span data-ttu-id="68302-324">[Sınıflar ve nesneler](../tour-of-csharp/classes-and-objects.md) </span><span class="sxs-lookup"><span data-stu-id="68302-324">[Classes and objects](../tour-of-csharp/classes-and-objects.md) </span></span>  
[<span data-ttu-id="68302-325">Devralma (C# programlama Kılavuzu)</span><span class="sxs-lookup"><span data-stu-id="68302-325">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)

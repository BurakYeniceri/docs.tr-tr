---
title: "Etki alanı olaylar. Tasarım ve uygulama"
description: "Kapsayıcılı .NET uygulamaları için .NET mikro mimarisi | Etki alanı olayları, tasarım ve uygulama"
keywords: "Docker, mikro, ASP.NET, kapsayıcı"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 12/11/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 607ca2977f382a3af20dac7470e970f483133756
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 12/23/2017
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="8bad0-105">Etki alanı olayları: tasarım ve uygulama</span><span class="sxs-lookup"><span data-stu-id="8bad0-105">Domain events: design and implementation</span></span>

<span data-ttu-id="8bad0-106">Açıkça yan etkileri etki alanınızda değişiklikleri uygulamak için etki alanı olayları kullanın.</span><span class="sxs-lookup"><span data-stu-id="8bad0-106">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="8bad0-107">Diğer sözcükleri ve DDD terminolojisi kullanarak, açıkça yan etkileri arasında birden çok toplamalar uygulama için etki alanı olaylarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="8bad0-107">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="8bad0-108">İsteğe bağlı olarak, daha iyi ölçeklenebilirlik ve daha az veritabanı kilitleri etkileri aynı etki alanındaki toplamalar arasında nihai tutarlılık kullanın.</span><span class="sxs-lookup"><span data-stu-id="8bad0-108">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="8bad0-109">Bir etki alanı olay nedir?</span><span class="sxs-lookup"><span data-stu-id="8bad0-109">What is a domain event?</span></span>

<span data-ttu-id="8bad0-110">Bir olay geçmişteki şeydir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-110">An event is something that has happened in the past.</span></span> <span data-ttu-id="8bad0-111">Bir etki alanı, mantıksal olarak, belirli bir etki alanında gerçekleşen bir şey olayıdır ve şeyin farkında olmanız ve olası tepki için aynı etki alanında (işlemdeki) diğer bölümleri istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="8bad0-111">A domain event is, logically, something that happened in a particular domain, and something you want other parts of the same domain (in-process) to be aware of and potentially react to.</span></span>

<span data-ttu-id="8bad0-112">Etki alanı olayların önemli bir avantajı, bir şeyler bir etki alanında olduğu sonra etkilerinin açıkça yerine örtük olarak ifade edilebilir ' dir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-112">An important benefit of domain events is that side effects after something happened in a domain can be expressed explicitly instead of implicitly.</span></span> <span data-ttu-id="8bad0-113">Bu yan etkileri iş görevle ilgili ya da tüm işlemleri gerçekleşecek şekilde tutarlı olmalıdır, veya bunların hiçbiri.</span><span class="sxs-lookup"><span data-stu-id="8bad0-113">Those side effects must be consistent so either all the operations related to the business task happen, or none of them.</span></span> <span data-ttu-id="8bad0-114">Ayrıca, etki alanı olayları sorunları aynı etki alanındaki sınıflar arasında daha iyi ayrılması etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-114">In addition, domain events enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="8bad0-115">Yan etkileri kullanım örneği tarafından provoked olmasını var. varsa, yalnızca Entity Framework ve varlıklar veya hatta toplamalar kullanıyorsanız, bir şeyler olduğu sonra Örneğin, bu bağlı kodda örtük bir kavram olarak uygulanacaktır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-115">For example, if you're just using Entity Framework and entities or even aggregates, if there have to be side effects provoked by a use case, those will be implemented as an implicit concept in the coupled code after something happened.</span></span> <span data-ttu-id="8bad0-116">Ancak, bu kod yalnızca görürseniz, bu kodu (yan etkisi) ana işleminin bir parçası ise veya gerçekten bir yan etkisi ise anlamayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8bad0-116">But, if you just see that code, you might not know if that code (the side effect) is part of the main operation or if it really is a side effect.</span></span> <span data-ttu-id="8bad0-117">Diğer taraftan, etki alanı olayları kullanarak kavramı açık ve her yerden dil parçası hale getirir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-117">On the other hand, using domain events makes the concept explicit and part of the ubiquitous language.</span></span> <span data-ttu-id="8bad0-118">Örneğin, eShopOnContainers uygulamada bir sıra oluşturma neredeyse sırası değildir; güncelleştirmeleri veya yerine bir sipariş kadar kullanıcı bir alıcı olmadığından özgün kullanıcıyı temel alarak bir alıcı toplama oluşturur.</span><span class="sxs-lookup"><span data-stu-id="8bad0-118">For example, in the eShopOnContainers application, creating an order is not just about the order; it updates or creates a buyer aggregate based on the original user, because the user is not a buyer until there is an order in place.</span></span> <span data-ttu-id="8bad0-119">Etki alanı olayları kullanırsanız, etki alanı uzmanlar tarafından sağlanan bulunabilen dilde göre bu etki alanı kural açıkça hızlı.</span><span class="sxs-lookup"><span data-stu-id="8bad0-119">If you use domain events, you can explicitly express that domain rule based in the ubiquitous language provided by the domain experts.</span></span>

<span data-ttu-id="8bad0-120">Etki alanı olayları, önemli bir farkla Mesajlaşma stili olayları biraz benzer.</span><span class="sxs-lookup"><span data-stu-id="8bad0-120">Domain events are somewhat similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="8bad0-121">Gerçek Mesajlaşma, message queuing, ileti aracıları veya AMPQ kullanarak bir hizmet veri yolu ile bir ileti her zaman zaman uyumsuz olarak gönderilir ve işlemleri ve makineler arasında iletişim.</span><span class="sxs-lookup"><span data-stu-id="8bad0-121">With real messaging, message queuing, message brokers, or a service bus using AMPQ, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="8bad0-122">Bu, birden çok ilişkisindeki bağlamları, mikro veya hatta farklı uygulamaları tümleştirmek için kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="8bad0-123">Ancak, etki alanı olaylarla çalıştırmakta olduğunuz etki alanı işlemi bir olaydan yükseltmek istediğiniz ancak aynı etki alanı içinde gerçekleşmesi için hiçbir yan etkileri istiyor.</span><span class="sxs-lookup"><span data-stu-id="8bad0-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="8bad0-124">Etki alanı olayları ve bunların yan etkileri (olay işleyicileri tarafından yönetilen sonradan tetiklenen eylemler) hemen hemen gerçekleşeceğini genellikle işlem içinde ve aynı etki alanı içinde.</span><span class="sxs-lookup"><span data-stu-id="8bad0-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="8bad0-125">Bu nedenle, etki alanı olayları zaman uyumlu veya zaman uyumsuz olabilir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="8bad0-126">Tümleştirme olayları, ancak her zaman zaman uyumsuz olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="8bad0-127">Etki alanı olayları tümleştirme olaylarını karşılaştırması</span><span class="sxs-lookup"><span data-stu-id="8bad0-127">Domain events versus integration events</span></span>

<span data-ttu-id="8bad0-128">Anlam olarak, etki alanı ve tümleştirme olaylarını aynı şeydir: yalnızca gerçekleşen bir şey hakkında bildirimler.</span><span class="sxs-lookup"><span data-stu-id="8bad0-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="8bad0-129">Ancak, kendi uygulama farklı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-129">However, their implementation must be different.</span></span> <span data-ttu-id="8bad0-130">Etki alanı, bir bellek içi Dünyası IOC kapsayıcı veya başka bir yöntem dayalı olarak uygulanabilir bir etki alanı olay dağıtıcıya gönderilen yalnızca ileti olaylardır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="8bad0-131">Diğer mikro, sınırlanmış bağlamları ve hatta dış uygulamaları olup diğer yandan, tümleştirme olayların yürütülen işlemler ve ek alt sistemleri, güncelleştirmelerinin yayılması amaçtır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="8bad0-132">Bu nedenle, gerçekleşeceğini yalnızca varlık başarıyla kalıcı değilse bu yana birçok senaryoda bu başarısız olursa, tüm işlem etkili bir şekilde asla oldu.</span><span class="sxs-lookup"><span data-stu-id="8bad0-132">Hence, they should occur only if the entity is successfully persisted, since in many scenarios if this fails, the entire operation effectively never happened.</span></span>

<span data-ttu-id="8bad0-133">Buna ek olarak ve belirtilen, tümleştirme olarak olayları birden çok mikro (diğer ilişkisindeki bağlamlarda) ya da hatta dış sistemler/uygulamalar arasında zaman uyumsuz iletişim temel gerekir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-133">In addition, and as mentioned, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span> <span data-ttu-id="8bad0-134">Bu nedenle, olay veri yolu arabirimi arası işlem sağlar ve büyük olasılıkla uzak Hizmetleri arasındaki iletişimi dağıtılan bazı altyapı gerekir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="8bad0-135">Ticari service bus, kuyruklar, bir posta kutusu olarak kullanılan paylaşılan bir veritabanı veya diğer dağıtılmış göre ve ideal olarak temel ileti sistemini gönderme.</span><span class="sxs-lookup"><span data-stu-id="8bad0-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="8bad0-136">Aynı etki alanı içinde birden çok toplamalar arasında yan etkileri tetiklemek için tercih edilen bir yolu olarak etki alanı olayları</span><span class="sxs-lookup"><span data-stu-id="8bad0-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="8bad0-137">Bir veya daha fazla ek toplamalar çalıştırılacak ek etki alanı kuralları toplama örneği gerektirir için ilgili bir komutu yürütülürken, tasarım ve etki alanı olaylar tarafından tetiklenen bu yan etkileri uygulamak.</span><span class="sxs-lookup"><span data-stu-id="8bad0-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="8bad0-138">Şekil 9-14'de gösterildiği gibi ve en önemli biri olarak kullanım, bir etki alanı olay aynı etki alanı modeli içinde birden çok toplamalar arasında durum değişiklikleri yaymak için kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-138">As shown in Figure 9-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![](./media/image15.png)

<span data-ttu-id="8bad0-139">**Şekil 9-14**.</span><span class="sxs-lookup"><span data-stu-id="8bad0-139">**Figure 9-14**.</span></span> <span data-ttu-id="8bad0-140">Aynı etki alanı içinde birden çok toplamalar arasında tutarlılığı zorlamak için etki alanı olayları</span><span class="sxs-lookup"><span data-stu-id="8bad0-140">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="8bad0-141">Kullanıcı bir sipariş başlattığında şekilde, özgün kimlik mikro hizmet kullanıcı bilgisi (bilgilerle CreateOrder komutta sağlanan) göre sıralama mikro hizmet alıcı nesnesinde oluşturulmasını OrderStarted etki alanı olay tetiklenir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-141">In the figure, when the user initiates an order, the OrderStarted domain event triggers creation of a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span> <span data-ttu-id="8bad0-142">İlk başta oluşturulduğunda, etki alanı olayı sırası toplama tarafından oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="8bad0-142">The domain event is generated by the order aggregate when it is created in the first place.</span></span>

<span data-ttu-id="8bad0-143">Alternatif olarak, kendi toplamalar (alt varlıkları) üyeleri tarafından oluşturulan olaylara abone birleşik kök olabilir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-143">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="8bad0-144">Örneğin, her ÖgeSipariş alt varlık öğesi fiyat belirli miktardan daha yüksek olduğunda ya da ürün öğesi tutarı çok yüksek olduğunda bir olay yükseltebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8bad0-144">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="8bad0-145">Birleşik kök sonra bu olayları almak ve bir genel hesaplama veya toplama gerçekleştirin.</span><span class="sxs-lookup"><span data-stu-id="8bad0-145">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="8bad0-146">Bu olay tabanlı iletişim doğrudan içinde toplamalar uygulanmadı anlamak önemlidir; etki alanı olay işleyicileri uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-146">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span> <span data-ttu-id="8bad0-147">Etki alanı olayları işleme bir uygulama konusudur.</span><span class="sxs-lookup"><span data-stu-id="8bad0-147">Handling the domain events is an application concern.</span></span> <span data-ttu-id="8bad0-148">Etki alanı modeli katmanı, yalnızca etki alanı mantığı odaklanmanız gerekir — bir etki alanı Uzman öğrenmesi şey, uygulama altyapısı işleyicileri ve depoları kullanarak yan etkisi Kalıcılık eylemleri gibi değil.</span><span class="sxs-lookup"><span data-stu-id="8bad0-148">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="8bad0-149">Bu nedenle, uygulama katmanı düzeyi bir etki alanı olay oluşturulduğunda eylemleri tetikleyen etki alanı olay işleyicileri, sahip değil.</span><span class="sxs-lookup"><span data-stu-id="8bad0-149">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="8bad0-150">Etki alanı olaylar ayrıca herhangi bir sayıda uygulama eylemleri tetiklemek için kullanılabilir ve daha önemli bir ayrılmış şekilde gelecekte bu sayıyı artırmak için açık olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-150">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="8bad0-151">Örneğin, sipariş başlatıldığında, bir etki alanı olay başka Toplamalar için bu bilgileri yayılmasına veya hatta bildirimleri gibi uygulama eylemleri yükseltmek için yayımlama isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8bad0-151">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="8bad0-152">Bir etki alanı olay gerçekleştiğinde yürütülecek eylem açık sayısı anahtar noktasıdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-152">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="8bad0-153">Sonuç olarak, etki alanı ve uygulama kuralları ve eylemleri büyüyecektir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-153">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="8bad0-154">Kodunuzu "Yapıştır" ile bağlı ancak karmaşıklığa veya bir şey olduğunda yan etkisi eylemlerin sayısını, büyüyecektir (diğer bir deyişle, yalnızca C yeni anahtar sözcüğüyle örnek oluşturma nesneleri\#), yeni bir eylem eklemek için gereken her zaman için gerekir Özgün kod değiştirin.</span><span class="sxs-lookup"><span data-stu-id="8bad0-154">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, just instantiating objects with the new keyword in C\#), then every time you needed to add a new action you would need to change the original code.</span></span> <span data-ttu-id="8bad0-155">Her yeni gereksinimi özgün kod akış değiştirmeniz gerekir çünkü bu yeni hataları neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-155">This could result in new bugs, because with each new requirement you would need to change the original code flow.</span></span> <span data-ttu-id="8bad0-156">Bu karşı gider [açık/kapalı ilkesine](https://en.wikipedia.org/wiki/Open/closed_principle) gelen [DÜZ](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span><span class="sxs-lookup"><span data-stu-id="8bad0-156">This goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span></span> <span data-ttu-id="8bad0-157">Hangi karşı gider yalnızca, işlemleri yönetme özgün sınıf ve büyümesine büyüme, not [tek sorumluluk İlkesi'ni (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span><span class="sxs-lookup"><span data-stu-id="8bad0-157">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="8bad0-158">Diğer taraftan, etki alanı olayları kullanırsanız, bu yaklaşımı kullanarak sorumlulukları ayrıştırarak hassas ve ayrılmış bir uygulama oluşturabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="8bad0-158">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1.  <span data-ttu-id="8bad0-159">Bir komutu (örneğin, CreateOrder) gönderin.</span><span class="sxs-lookup"><span data-stu-id="8bad0-159">Send a command (for example, CreateOrder).</span></span>
2.  <span data-ttu-id="8bad0-160">Komutu bir komut işleyici alır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-160">Receive the command in a command handler.</span></span>
    -   <span data-ttu-id="8bad0-161">Tek bir toplama 's işlem yürütün.</span><span class="sxs-lookup"><span data-stu-id="8bad0-161">Execute a single aggregate’s transaction.</span></span>
    -   <span data-ttu-id="8bad0-162">(İsteğe bağlı) Yan etkiler (örneğin, OrderStartedDomainDvent) için etki alanı olayları yükseltin.</span><span class="sxs-lookup"><span data-stu-id="8bad0-162">(Optional) Raise domain events for side effects (for example, OrderStartedDomainDvent).</span></span>
1.  <span data-ttu-id="8bad0-163">Açık bir yan etkileri sayısı birden çok toplamalar veya uygulama eylemleri yürütecek etki alanı olayları (geçerli işlemdeki) idare eder.</span><span class="sxs-lookup"><span data-stu-id="8bad0-163">Handle domain events (within the current process) that will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="8bad0-164">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="8bad0-164">For example:</span></span>
    -   <span data-ttu-id="8bad0-165">Doğrulamak veya alıcı ve ödeme yöntemini oluşturun.</span><span class="sxs-lookup"><span data-stu-id="8bad0-165">Verify or create buyer and payment method.</span></span>
    -   <span data-ttu-id="8bad0-166">Oluşturun ve olay veri yoluna alıcıya e-posta gönderme gibi mikro veya tetikleyici dış eylemler arasında durumları yaymak için ilgili tümleştirme olay gönderin.</span><span class="sxs-lookup"><span data-stu-id="8bad0-166">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
    -   <span data-ttu-id="8bad0-167">Diğer yan etkileri işleyin.</span><span class="sxs-lookup"><span data-stu-id="8bad0-167">Handle other side effects.</span></span>

<span data-ttu-id="8bad0-168">Şekil 9-15'te gösterildiği gibi aynı etki alanı olayından başlangıç başka toplamalar etki alanındaki veya tümleştirme olayların ve olay veri yolu ile bağlanma mikro arasında gerçekleştirmeniz gereken ek uygulama eylemleri ilgili birden çok eylem işleyebilir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-168">As shown in Figure 9-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![](./media/image16.png)

<span data-ttu-id="8bad0-169">**Şekil 9-15**.</span><span class="sxs-lookup"><span data-stu-id="8bad0-169">**Figure 9-15**.</span></span> <span data-ttu-id="8bad0-170">Etki alanı başına birden çok eylem işleme</span><span class="sxs-lookup"><span data-stu-id="8bad0-170">Handling multiple actions per domain</span></span>

<span data-ttu-id="8bad0-171">Mikro hizmet'in davranışını depoları veya bir uygulama API gibi altyapı nesnelerinden kullanacağından olay işleyicileri genellikle uygulama katmanında yayımlanır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-171">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior.</span></span> <span data-ttu-id="8bad0-172">Bu anlamda olay işleyicileri hem de uygulama katmanı parçası olacak şekilde, komut işleyicilerine benzer.</span><span class="sxs-lookup"><span data-stu-id="8bad0-172">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="8bad0-173">Bir komutu yalnızca bir kez işlenmesi önemli farktır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-173">The important difference is that a command should be processed just once.</span></span> <span data-ttu-id="8bad0-174">Bir etki alanı olay olabileceğinden sıfır işlenen veya  *n*  , çünkü zaman, birden çok alıcıya veya farklı bir amaç için her işleyici ile olay işleyicileri tarafından alınan.</span><span class="sxs-lookup"><span data-stu-id="8bad0-174">A domain event could be processed zero or *n* times, because if can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="8bad0-175">Açık bir etki alanı olay başına işleyici sayısı olasılığını geçerli kodunuzu etkilemeden pek çok daha fazla etki alanı kural eklemenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="8bad0-175">The possibility of an open number of handlers per domain event allows you to add many more domain rules without impacting your current code.</span></span> <span data-ttu-id="8bad0-176">Örneğin, bir olaydan sonra sağ gerçekleştirileceğini aşağıdaki iş kuralı uygulama birkaç olay işleyicileri (veya tek bile) ekleme olarak kadar kolay olabilir:</span><span class="sxs-lookup"><span data-stu-id="8bad0-176">For instance, implementing the following business rule that has to happen right after an event might be as easy as adding a few event handlers (or even just one):</span></span>

<span data-ttu-id="8bad0-177">Deposunda bir müşteri tarafından siparişler, herhangi bir sayıda satın alınan toplam miktarı $6,000 aşarsa, her yeni siparişe % 10 indirim kapalı uygulamak ve müşteri bu indirim gelecekteki siparişleri hakkında bir e-posta ile bildir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-177">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implementing-domain-events"></a><span data-ttu-id="8bad0-178">Etki alanı olayları uygulama</span><span class="sxs-lookup"><span data-stu-id="8bad0-178">Implementing domain events</span></span>

<span data-ttu-id="8bad0-179">C# ' ta bir etki alanı yalnızca bir veri bekletme yapısı veya yalnızca etki alanında ne için aşağıdaki örnekte gösterildiği gibi ilgili tüm bilgileri içeren bir DTO gibi sınıfına olayıdır:</span><span class="sxs-lookup"><span data-stu-id="8bad0-179">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : INotification
{
    public string UserId { get; private set; }
    public int CardTypeId { get; private set; }
    public string CardNumber { get; private set; }
    public string CardSecurityNumber { get; private set; }
    public string CardHolderName { get; private set; }
    public DateTime CardExpiration { get; private set; }
    public Order Order { get; private set; }

    public OrderStartedDomainEvent(Order order,
                                   int cardTypeId, string cardNumber,
                                   string cardSecurityNumber, string cardHolderName,
                                   DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="8bad0-180">Bu OrderStarted olaya ilgili tüm verileri tutan aslında bir sınıftır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-180">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="8bad0-181">Bir olay, geçmişteki bir şey olduğundan bakımından bulunabilen dil etki alanının OrderStartedDomainEvent veya OrderShippedDomainEvent gibi bir geçmiş zamanın fiili olarak olay sınıf adını temsil.</span><span class="sxs-lookup"><span data-stu-id="8bad0-181">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="8bad0-182">Etki alanı olay sıralama mikro hizmet eShopOnContainers içinde nasıl uygulandığını olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-182">That is how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="8bad0-183">Bir olay, değil değiştirmelisiniz geçmişteki bir şey olduğundan daha önce belirtildiği gibi bir önemli olayları, özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-183">As noted earlier, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="8bad0-184">Bu nedenle sabit bir sınıf olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-184">Therefore it must be an immutable class.</span></span> <span data-ttu-id="8bad0-185">Özellikleri dışında nesne salt okunur yerine önceki kod görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8bad0-185">You can see in the previous code that the properties are read-only from outside of the object.</span></span> <span data-ttu-id="8bad0-186">Olay nesnesi oluşturduğunuzda, nesneyi güncelleştirmek için yalnızca oluşturucu kullanılarak yoludur.</span><span class="sxs-lookup"><span data-stu-id="8bad0-186">The only way to update the object is through the constructor when you create the event object.</span></span>

### <a name="raising-domain-events"></a><span data-ttu-id="8bad0-187">Etki alanı olaylar oluşturma</span><span class="sxs-lookup"><span data-stu-id="8bad0-187">Raising domain events</span></span>

<span data-ttu-id="8bad0-188">Sonraki soruya kendi ilgili olay işleyicileri eriştiği için bir etki alanı olayını Başlat şeklidir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-188">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="8bad0-189">Birden çok yaklaşımlar kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8bad0-189">You can use multiple approaches.</span></span>

<span data-ttu-id="8bad0-190">UDI Dahan Başlangıçta önerilen (örneğin, birkaç içinde postaları, gibi ilgili [etki alanı olayları – alın 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) olaylar oluşturma ve yönetme için statik bir sınıf kullanma.</span><span class="sxs-lookup"><span data-stu-id="8bad0-190">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="8bad0-191">Bu DomainEvents.Raise (olay myEvent) gibi sözdizimini kullanarak hemen çağrıldığında, etki alanı olaylar oluşturacak DomainEvents adlı bir statik sınıf içerebilir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-191">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like DomainEvents.Raise(Event myEvent).</span></span> <span data-ttu-id="8bad0-192">Jimmy Bogard yazdı bir blog gönderisini ([etki alanınızın güçlendirme: etki alanı olayları](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) benzer bir yaklaşım önerir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-192">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="8bad0-193">Etki alanı olayları sınıfı statik olduğunda, ancak, bu da işleyicilere hemen gönderir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-193">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="8bad0-194">Olay tetiklenir hemen sonra yan etkileri mantığı ile olay işleyicileri çalıştırıldığı için bu test ve hata ayıklama daha zor hale getirir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-194">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="8bad0-195">Test ve hata ayıklama odaklanır ve geçerli toplama sınıflarda neler olduğunu yalnızca istediğinizden; aniden yan etkileri diğer toplamalar veya uygulama mantığını ilgili diğer olay işleyicileri yeniden yönlendirilmesini istediğiniz değil.</span><span class="sxs-lookup"><span data-stu-id="8bad0-195">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="8bad0-196">Diğer yaklaşımlar gelişim göstermiştir nedeni bir sonraki bölümde açıklandığı gibi budur.</span><span class="sxs-lookup"><span data-stu-id="8bad0-196">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-for-raising-and-dispatching-events"></a><span data-ttu-id="8bad0-197">Oluşturma ve olayları gönderme için ertelenmiş yaklaşımı</span><span class="sxs-lookup"><span data-stu-id="8bad0-197">The deferred approach for raising and dispatching events</span></span>

<span data-ttu-id="8bad0-198">Bir etki alanı olay işleyicisine hemen göndermeyi yerine etki alanı olayları bir koleksiyona eklemek için daha iyi bir yaklaşım olduğu ve bu etki alanı olayları gönderme *önceki* veya *sağ*  *sonra* (ile gibi SaveChanges EF içinde) işlemi sonlandırdı.</span><span class="sxs-lookup"><span data-stu-id="8bad0-198">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="8bad0-199">(Bu yaklaşım Jimmy Bogard tarafından bu gönderisinde açıklanan [daha iyi bir etki alanı olayları düzeni](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span><span class="sxs-lookup"><span data-stu-id="8bad0-199">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="8bad0-200">Aynı işlem veya farklı işlemlerin parçası olarak yan etkileri içerecektir olup olmadığını belirler etki alanı olayları gönderip göndermeyeceğini karar vermeden önce veya sağa hareket uygulamadan sonra sağ, önemlidir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-200">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="8bad0-201">İkinci durumda, nihai tutarlılık arasında birden çok toplamalar ilgilenmeniz gereken.</span><span class="sxs-lookup"><span data-stu-id="8bad0-201">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="8bad0-202">Bu konuda bir sonraki bölümde ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-202">This topic is discussed in the next section.</span></span>

<span data-ttu-id="8bad0-203">Hangi eShopOnContainers kullanan ertelenmiş yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-203">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="8bad0-204">İlk olarak, bir koleksiyonu veya varlık başına olayların listesini içine varlıklarınızı içinde gerçekleşen etkinlikler ekleyin.</span><span class="sxs-lookup"><span data-stu-id="8bad0-204">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="8bad0-205">Bu liste, varlık nesnesinin bir parçası veya bile daha iyi temel varlık sınıfınız parçası varlık temel sınıfı aşağıdaki örnekte gösterildiği gibi olmalıdır:</span><span class="sxs-lookup"><span data-stu-id="8bad0-205">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example of the Entity base class:</span></span>

```csharp
public abstract class Entity
{
     //... 
    private List<INotification> _domainEvents;
    public List<INotification> DomainEvents => _domainEvents;

    public void AddDomainEvent(INotification eventItem)
    {
        _domainEvents = _domainEvents ?? new List<INotification>();
        _domainEvents.Add(eventItem);
    }

    public void RemoveDomainEvent(INotification eventItem)
    {
        if (_domainEvents is null) return;
        _domainEvents.Remove(eventItem);
    }
    // ...
}
```

<span data-ttu-id="8bad0-206">Bir olayı oluşturmak istediğinizde, bu olay toplama toplama kök varlık herhangi bir yöntemi sırasında koddan eklemeniz yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-206">When you want to raise an event, you just add it to the event collection from code at any method of the aggregate-root entity.</span></span>

<span data-ttu-id="8bad0-207">Aşağıdaki kod, parçası [eShopOnContainers agregate kök sipariş](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), bir örnek gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="8bad0-207">The following code, part of the [Order agregate-root at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), shows an example:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
                                                          cardTypeId, cardNumber,
                                                          cardSecurityNumber,
                                                          cardHolderName,
                                                          cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="8bad0-208">AddDomainEvent yöntemi yaparsanız tek şey listeye olay ekleme dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="8bad0-208">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="8bad0-209">Henüz hiç olay gönderilir ve hiçbir olay işleyici henüz çağrılır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-209">No event is dispatched yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="8bad0-210">Gerçekte veritabanına işlem yaparsanız olayları daha sonra gönderme istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="8bad0-210">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="8bad0-211">Entity Framework Çekirdek kullanıyorsanız, aşağıdaki kod olduğu gibi EF DbContext SaveChanges yönteminde anlamına gelir:</span><span class="sxs-lookup"><span data-stu-id="8bad0-211">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.        
        await _mediator.DispatchDomainEventsAsync(this);

        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be commited
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="8bad0-212">Bu kodu ile kendi ilgili olay işleyicileri varlık olaylarına gönderme.</span><span class="sxs-lookup"><span data-stu-id="8bad0-212">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="8bad0-213">(Basit bir ekleme bellekte listeye) bir etki alanı olay oluşturma bir olay işleyicisi göndermeyi gelen ayrılmış olduğunu genel sonucudur.</span><span class="sxs-lookup"><span data-stu-id="8bad0-213">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="8bad0-214">Buna ek olarak, ne tür bir dağıtıcı kullandığınıza bağlı olarak, size olayları eşzamanlı veya zaman uyumsuz olarak gönderme.</span><span class="sxs-lookup"><span data-stu-id="8bad0-214">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="8bad0-215">İşlem sınırları içine önemli gelen Burada Yürüt unutmayın.</span><span class="sxs-lookup"><span data-stu-id="8bad0-215">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="8bad0-216">İş ve işlem, birimi birden fazla toplama yayılabilir varsa (as EF çekirdek ve ilişkisel veritabanı kullanılırken), bu da çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-216">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="8bad0-217">Ancak işlem Azure DocumentDB gibi bir NoSQL veritabanı kullanırken gibi toplamalar yayılıyorsa tutarlılık sağlamak için ek adımlar uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-217">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure DocumentDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="8bad0-218">Neden Kalıcılık kullanmayan Evrensel değil başka bir neden de budur; kullandığınız depolama sistemine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-218">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="8bad0-219">Nihai tutarlılık toplamalar arasında karşı toplamalar arasında tek bir işlem</span><span class="sxs-lookup"><span data-stu-id="8bad0-219">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="8bad0-220">Sorunun olup üzerinde nihai tutarlılık bu toplamalara bağlı olan karşı toplamalar arasında tek bir işlem gerçekleştirmek tartışmalı bir adrestir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-220">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="8bad0-221">Eric Evans ve Vaughn Vernon kuralı, bir işlem advocate gibi birçok DDD yazarları bir toplama = ve bu nedenle nihai tutarlılık için toplamalar arasında karşıdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-221">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="8bad0-222">Örneğin, kendi kitaptaki *Domain-Driven tasarım*, Eric Evans diyor bu:</span><span class="sxs-lookup"><span data-stu-id="8bad0-222">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

<span data-ttu-id="8bad0-223">Toplamalar yayılan herhangi bir kural her zaman güncel olması beklenen değil.</span><span class="sxs-lookup"><span data-stu-id="8bad0-223">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="8bad0-224">Olay işleme, toplu işleme veya diğer güncelleştirme mekanizmaları belirli bir süre içinde başka bir bağımlılık çözülebilir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-224">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="8bad0-225">(sayfa 128)</span><span class="sxs-lookup"><span data-stu-id="8bad0-225">(page 128)</span></span>

<span data-ttu-id="8bad0-226">Vaughn Vernon aşağıdakileri belirten [etkili toplama tasarımı. Bölüm II: Yapma toplayan iş birlikte](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="8bad0-226">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

<span data-ttu-id="8bad0-227">Bu nedenle, bir toplama örneği gerektirir ek iş kuralları bir veya daha fazla toplamalarda yürütmek bir komut yürütülürken, nihai tutarlılık kullanırsanız \[...\] Nihai tutarlılık DDD modelinde desteklemek için kullanışlı bir yol yoktur.</span><span class="sxs-lookup"><span data-stu-id="8bad0-227">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="8bad0-228">Bir veya daha fazla zaman uyumsuz abonelere teslim saati olan bir etki alanı olay toplama yöntemi yayımlar.</span><span class="sxs-lookup"><span data-stu-id="8bad0-228">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="8bad0-229">Bu stratejinin yayılan birçok toplamalar veya varlıklar işlemleri yerine hassas işlemler benimsemenin temel alır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-229">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="8bad0-230">İkinci durumda, veritabanı kilit sayısı yüksek ölçeklenebilirlik gereksinimlerini ile büyük ölçekli uygulamalarında önemli olacağını olur.</span><span class="sxs-lookup"><span data-stu-id="8bad0-230">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="8bad0-231">Yüksek düzeyde ölçeklenebilir uygulamalar birden çok toplamalar arasında anlık işlemsel tutarlılık olmaması gereken olgu benimsemenin kavramı nihai tutarlılık, kabul etme ile yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="8bad0-231">Embracing the fact that high-scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="8bad0-232">Atomik değişikliklerin iş tarafından gerekli genelde ve bunu her durumda belirli işlemleri atomik işlemleri olup olmadığını gereksinim söylemek için etki alanı uzmanlar sorumluluğundadır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-232">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="8bad0-233">Her zaman bir işlem birden çok toplamalar arasında atomik bir işlem gerekiyorsa, toplama daha büyük olmalıdır, veya doğru şekilde tasarlanmamış isteyebilir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-233">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="8bad0-234">Ancak, diğer geliştiriciler ve mimarları Jimmy Bogard gibi tek bir işlem arasında birkaç toplamalar kapsayıcı ile teşkil — ancak yalnızca zaman bu ek toplamalar yan etkileri aynı özgün komutu için ilgili.</span><span class="sxs-lookup"><span data-stu-id="8bad0-234">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="8bad0-235">Örneğin, [daha iyi bir etki alanı olayları düzeni](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard bu diyor:</span><span class="sxs-lookup"><span data-stu-id="8bad0-235">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

<span data-ttu-id="8bad0-236">Genellikle, aynı mantıksal işlem içinde olmasa da, etki alanı olayı tetiklenmeden aynı kapsamda gerçekleşmesi için bir etki alanı olayının yan etkileri istiyorum \[...\] Yalnızca şu bizim hareketi önce biz bizim olayları kendi ilgili işleyicilere gönderme.</span><span class="sxs-lookup"><span data-stu-id="8bad0-236">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="8bad0-237">Etki alanı olayları sağ gönderme varsa *önce* yan etkileri bu olayların aynı işlemde dahil edilmesini istediğiniz özgün işlemi sonlandırdı, demektir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-237">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="8bad0-238">EF DbContext SaveChanges yöntem başarısız olursa, örneğin, işlem ilgili etki alanı olay işleyicileri tarafından uygulanan herhangi bir yan etkisi işlem sonucu dahil olmak üzere tüm değişiklikleri geri döner.</span><span class="sxs-lookup"><span data-stu-id="8bad0-238">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="8bad0-239">DbContext yaşam kapsamı varsayılan olarak tanımlı olduğundan bu "kapsamlıdır."</span><span class="sxs-lookup"><span data-stu-id="8bad0-239">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="8bad0-240">Bu nedenle, DbContext nesnesi aynı kapsamı veya Nesne grafiği içinde oluşturulmasını birden çok havuz nesneleri arasında paylaşılır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-240">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="8bad0-241">Web API veya MVC uygulamaları geliştirirken HttpRequest kapsamıyla örtüşür.</span><span class="sxs-lookup"><span data-stu-id="8bad0-241">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="8bad0-242">Gerçekte, her iki yaklaşımın (tek bir atomik işlem ve nihai tutarlılık) doğru olabilir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-242">In reality, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="8bad0-243">Gerçekten, etki alanı veya iş gereksinimlerinize ve hangi etki alanı uzmanların size bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-243">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="8bad0-244">Bu ayrıca nasıl ölçeklenebilir, hizmeti gereksinimlerine göre değişir (daha ayrıntılı işlemler sahip veritabanı kilitleri göre daha az etkiyle).</span><span class="sxs-lookup"><span data-stu-id="8bad0-244">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="8bad0-245">Ve ne kadar yatırım, nihai tutarlılık, olası tutarsızlıklar toplar ve telafi izin eylemlerini uygulamak için gereken arasında saptamak amacıyla daha karmaşık kod gerektirdiğinden, kodunuzda yapmaya hazır olduğunuz üzerinde bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-245">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="8bad0-246">Özgün toplama ve olayların ne zaman gönderilen için daha sonra değişiklikleri, olduğunu sorunu dikkate alın ve olay işleyicileri kendi yan etkileri tamamlanamaz, toplamalar arasında tutarsızlıklar olacaktır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-246">Take into account that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="8bad0-247">Telafi izin eylemlere izin vermek için bir yol özgün işlemin bir parçası olabilir ek veritabanı tablolarında etki alanı olayları depolamak için olacaktır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-247">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="8bad0-248">Daha sonra tutarsızlıklarını algılayan ve toplamalar geçerli durumuyla olayların listesini karşılaştırarak telafi izin eylemleri çalıştırır toplu işlem olabilir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-248">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="8bad0-249">Telafi izin Eylemler iş kullanıcısı ve etki alanı uzmanlarıyla birlikte ele içerir, taraftaki derin çözümleme gerektiren karmaşık bir konu bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-249">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="8bad0-250">Herhangi bir durumda, gereksinim duyduğunuz yaklaşım seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8bad0-250">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="8bad0-251">Ancak ilk yaklaşım ertelenmiş — tek bir işlem kullanmanız kaydetmeden önce olaylar oluşturma — basit EF çekirdek ve ilişkisel veritabanı kullanılırken bir yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-251">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="8bad0-252">Bu uygulama daha kolay ve birçok iş durumda geçerli olur.</span><span class="sxs-lookup"><span data-stu-id="8bad0-252">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="8bad0-253">Bu da sipariş mikro hizmet eShopOnContainers içinde kullanılan yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-253">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="8bad0-254">Ancak nasıl aslında kendi ilgili olay işleyicileri için olaylar gönderme?</span><span class="sxs-lookup"><span data-stu-id="8bad0-254">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="8bad0-255">Nedir \_önceki örnekte bkz Dünyası nesne?</span><span class="sxs-lookup"><span data-stu-id="8bad0-255">What is the \_mediator object that you see in the previous example?</span></span> <span data-ttu-id="8bad0-256">Teknikleri ve olayları ve bunların olay işleyicileri arasında eşleme için kullanabileceğiniz yapıları ile yapmak sahip.</span><span class="sxs-lookup"><span data-stu-id="8bad0-256">That has to do with the techniques and artifacts you can use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="8bad0-257">Etki alanı olay dağıtıcısının: olay işleyicilerini olaylarından eşleme</span><span class="sxs-lookup"><span data-stu-id="8bad0-257">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="8bad0-258">Gönderme veya olayları yayımlama sonra ilgili her işleyici alın ve bu olaya göre yan etkileri işlemek ve böylece olay yayımlayacak yapı çeşit gerekir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-258">Once you're able to dispatch or publish the events, you need some kind of artifact that will publish the event, so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="8bad0-259">Gerçek ileti sistemi veya hizmet veri yolu bellek içi olayları aksine büyük olasılıkla dayalı bile bir olay veri yolu, bunun bir yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="8bad0-259">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="8bad0-260">Ancak, ilk bu durum, gerçek Mesajlaşma yalnızca aynı işlem içinde olayları işlemek gerekli olduğundan, etki alanı olayları işlemek için gereğinden fazla olacaktır (diğer bir deyişle, aynı etki alanı ve uygulama katman içinde).</span><span class="sxs-lookup"><span data-stu-id="8bad0-260">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="8bad0-261">Birden çok olay işleyicilerine olayları eşlemek için başka bir dinamik olarak olayları gönderileceği yeri çıkarımını türleri kayıt IOC kapsayıcısında kullanarak yoludur.</span><span class="sxs-lookup"><span data-stu-id="8bad0-261">Another way to map events to multiple event handlers is by using types registration in an IoC container so that you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="8bad0-262">Diğer bir deyişle, belirli bir olay almak olay işleyicileri gerekenler bilmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-262">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="8bad0-263">Şekil 9-16 basitleştirilmiş bir yaklaşım için gösterir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-263">Figure 9-16 shows a simplified approach for that.</span></span>

![](./media/image17.png)

<span data-ttu-id="8bad0-264">**Şekil 9-16**.</span><span class="sxs-lookup"><span data-stu-id="8bad0-264">**Figure 9-16**.</span></span> <span data-ttu-id="8bad0-265">Etki alanı olay dağıtıcısının IOC kullanma</span><span class="sxs-lookup"><span data-stu-id="8bad0-265">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="8bad0-266">Tüm tesisat ve bu yaklaşımı kendiniz uygulamak için yapıları oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8bad0-266">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="8bad0-267">Ancak, aynı zamanda gibi kullanılabilir kitaplıkları kullanabilirsiniz [MediatR](https://github.com/jbogard/MediatR), perde altında kullanan IOT kapsayıcı.</span><span class="sxs-lookup"><span data-stu-id="8bad0-267">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR), which underneath the covers uses your IoT container.</span></span> <span data-ttu-id="8bad0-268">Bu nedenle doğrudan önceden tanımlanmış arabirimleri ve Dünyası nesnenin yayımlama/dağıtma yöntemleri kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8bad0-268">You can therefore directly use the predefined interfaces and the mediator object’s publish/dispatch methods.</span></span>

<span data-ttu-id="8bad0-269">Kod içinde ilk olay işleyici türlerini, IOC kapsayıcısında kaydetmek aşağıdaki örnekte gösterildiği gibi ihtiyacınız [eShopOnContainers sıralama mikro hizmet](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span><span class="sxs-lookup"><span data-stu-id="8bad0-269">In code, you first need to register the event handler types in your IoC container, as shown in the following example at [eShopOnContainers Ordering microservice](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement IAsyncNotificationHandler<>)
        // in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
                                       .GetTypeInfo().Assembly)
                                         .AsClosedTypesOf(typeof(IAsyncNotificationHandler<>));
        // Other registrations ...
    }
}
```

<span data-ttu-id="8bad0-270">Kod ilk etki alanı olay işleyicileri herhangi bir işleyici tutan derleme bularak içeren derlemenin tanımlar (typeof(ValidateOrAddBuyerAggregateWhenXxxx), ancak kullanarak seçtiniz derleme bulmak için herhangi başka bir olay işleyicisini).</span><span class="sxs-lookup"><span data-stu-id="8bad0-270">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="8bad0-271">Tüm olay işleyicileri IAsyncNotificationHandler arabirimini uygulayan olduğundan, kod sonra olanlar için yalnızca aramaları türleri ve tüm olay işleyicileri kaydeder.</span><span class="sxs-lookup"><span data-stu-id="8bad0-271">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="8bad0-272">Etki alanı olaylarına abone olma</span><span class="sxs-lookup"><span data-stu-id="8bad0-272">How to subscribe to domain events</span></span>

<span data-ttu-id="8bad0-273">MediatR kullandığınızda, aşağıdaki kodda görebileceğiniz gibi her olay işleyicisi INotificationHandler arabiriminin genel parametresinde sağlanan bir olay türü kullanmanız gerekir:</span><span class="sxs-lookup"><span data-stu-id="8bad0-273">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the INotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="8bad0-274">Olay ve abonelik kabul edilebilir, olay işleyici arasındaki ilişkiyi göre MediatR yapı her olay için tüm olay işleyicileri bulun ve her biri bu olay işleyicileri tetikler.</span><span class="sxs-lookup"><span data-stu-id="8bad0-274">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="8bad0-275">Etki alanı olayları işlemek nasıl</span><span class="sxs-lookup"><span data-stu-id="8bad0-275">How to handle domain events</span></span>

<span data-ttu-id="8bad0-276">Son olarak, olay işleyicisi genellikle gerekli ek toplamalar edinme ve yan etkisi etki alanı mantığı yürütmek için altyapı depoları kullanan uygulama katmanı kodu uygular.</span><span class="sxs-lookup"><span data-stu-id="8bad0-276">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="8bad0-277">Aşağıdaki [eShopOnContainers etki alanı olay işleyici kodu](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), bir uygulama örneği gösterir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-277">The following [domain event handler code at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), shows an implementation example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
                   : INotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;

    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // ...Parameter validations...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ? orderStartedEvent.CardTypeId : 1;        
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;

        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }

        buyer.VerifyOrAddPaymentMethod(cardTypeId,
                                       $"Payment Method on {DateTime.UtcNow}",
                                       orderStartedEvent.CardNumber,
                                       orderStartedEvent.CardSecurityNumber,
                                       orderStartedEvent.CardHolderName,
                                       orderStartedEvent.CardExpiration,
                                       orderStartedEvent.Order.Id);

        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer) 
                                                                      : _buyerRepository.Add(buyer);

        await _buyerRepository.UnitOfWork
                .SaveEntitiesAsync();

        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="8bad0-278">Altyapı depoları kullandığından önceki etki alanı olay işleyicisini altyapı Kalıcılık katmanda sonraki bölümde açıklandığı gibi uygulama katmanı kodu kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-278">The previous domain event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="8bad0-279">Olay işleyicileri diğer altyapı bileşenlerini de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8bad0-279">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="8bad0-280">Etki alanı olayları mikro hizmet sınırları dışında yayımlanmasını tümleştirme olaylarını oluşturulmasına neden olabilir</span><span class="sxs-lookup"><span data-stu-id="8bad0-280">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="8bad0-281">Son olarak, bazı durumlarda olayları arasında birden çok mikro yaymak istediğiniz belirtmeyi önemlidir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-281">Finally, is important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="8bad0-282">Bir tümleştirme olay kabul edilir ve herhangi bir özel etki alanı olay işleyicisini olay yolundan aracılığıyla yayınlanabilir.</span><span class="sxs-lookup"><span data-stu-id="8bad0-282">That is considered an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="8bad0-283">Etki alanı olaylarına sonuçları</span><span class="sxs-lookup"><span data-stu-id="8bad0-283">Conclusions on domain events</span></span>

<span data-ttu-id="8bad0-284">Belirtildiği gibi açıkça yan etkileri etki alanınızda değişiklikleri uygulamak için etki alanı olayları kullanın.</span><span class="sxs-lookup"><span data-stu-id="8bad0-284">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="8bad0-285">DDD terminolojisi kullanmak için açıkça bir veya birden çok toplamalar arasında yan etkileri uygulamak için etki alanı olayları kullanın.</span><span class="sxs-lookup"><span data-stu-id="8bad0-285">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="8bad0-286">Ayrıca, daha iyi ölçeklenebilirlik için ve veritabanı kilitleri etkisini daha az aynı etki alanındaki toplamalar arasında nihai tutarlılık kullanın.</span><span class="sxs-lookup"><span data-stu-id="8bad0-286">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="8bad0-287">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="8bad0-287">Additional resources</span></span>

-   <span data-ttu-id="8bad0-288">**Greg Young. Bir etki alanı olay nedir? ** 
     [ *http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span><span class="sxs-lookup"><span data-stu-id="8bad0-288">**Greg Young. What is a Domain Event?**
[*http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span></span>

-   <span data-ttu-id="8bad0-289">**Oca Stenberg. Etki alanı olayları ve nihai tutarlılık**
    [*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span><span class="sxs-lookup"><span data-stu-id="8bad0-289">**Jan Stenberg. Domain Events and Eventual Consistency**
[*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span></span>

-   <span data-ttu-id="8bad0-290">**Jimmy Bogard. Daha iyi bir etki alanı olayları düzeni**
    [*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span><span class="sxs-lookup"><span data-stu-id="8bad0-290">**Jimmy Bogard. A better domain events pattern**
[*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span></span>

-   <span data-ttu-id="8bad0-291">**Vaughn Vernon. Etkin Toplama tasarımı Bölüm II: Toplamalar iş birlikte yapma**
    [*http://dddcommunity.org/wp-content/uploads/files/pdf\_makaleleri/Vernon\_2011\_ 2. pdf*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span><span class="sxs-lookup"><span data-stu-id="8bad0-291">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together**
[*http://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span></span>

-   <span data-ttu-id="8bad0-292">**Jimmy Bogard. Etki alanınızı güçlendirme: etki alanı olayları**
    *<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/>*</span><span class="sxs-lookup"><span data-stu-id="8bad0-292">**Jimmy Bogard. Strengthening your domain: Domain Events**
*<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/> *</span></span>

-   <span data-ttu-id="8bad0-293">**Tony Truong. Etki alanı olayları desen örnek**
    [*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span><span class="sxs-lookup"><span data-stu-id="8bad0-293">**Tony Truong. Domain Events Pattern Example**
[*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span></span>

-   <span data-ttu-id="8bad0-294">**UDI Dahan. Etki alanı modelleri tam oluşturma kapsüllenmiş**
    [*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span><span class="sxs-lookup"><span data-stu-id="8bad0-294">**Udi Dahan. How to create fully encapsulated Domain Models**
[*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span></span>

-   <span data-ttu-id="8bad0-295">**UDI Dahan. Etki alanı olayları – alın 2**
    [*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span><span class="sxs-lookup"><span data-stu-id="8bad0-295">**Udi Dahan. Domain Events – Take 2**
[*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span></span>

-   <span data-ttu-id="8bad0-296">**UDI Dahan. Etki alanı olayları – Salvation**
    [*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span><span class="sxs-lookup"><span data-stu-id="8bad0-296">**Udi Dahan. Domain Events – Salvation**
[*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span></span>

-   <span data-ttu-id="8bad0-297">**Oca Kronquist. Olmayan etki alanı olayları yayınlamak için bunları döndüren! ** 
     [ *https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span><span class="sxs-lookup"><span data-stu-id="8bad0-297">**Jan Kronquist. Don't publish Domain Events, return them!**
[*https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span></span>

-   <span data-ttu-id="8bad0-298">**Cesar de la Torre. Etki alanı olayları vs. Tümleştirme olaylarını DDD ve mikro hizmetler mimarilerindeki**
    [*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span><span class="sxs-lookup"><span data-stu-id="8bad0-298">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures**
[*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="8bad0-299">[Önceki] (istemci-tarafı-validation.md) [sonraki] (altyapı-Kalıcılık-katman-design.md)</span><span class="sxs-lookup"><span data-stu-id="8bad0-299">[Previous] (client-side-validation.md) [Next] (infrastructure-persistence-layer-design.md)</span></span>

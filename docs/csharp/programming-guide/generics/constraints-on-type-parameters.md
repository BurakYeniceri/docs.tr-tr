---
title: "Tür Parametrelerindeki Kısıtlamalar (C# Programlama Kılavuzu)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- generics [C#], type constraints
- type constraints [C#]
- type parameters [C#], constraints
- unbound type parameter [C#]
ms.assetid: 141b003e-1ddb-4e1c-bcb2-e1c3870e6a51
caps.latest.revision: "41"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: 6f7c80acdb3815af4b5d545297894778029a9104
ms.sourcegitcommit: 8bde7a3432f30fc771079744955c75c58c4eb393
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/20/2018
---
# <a name="constraints-on-type-parameters-c-programming-guide"></a><span data-ttu-id="ad92c-102">Tür Parametrelerindeki Kısıtlamalar (C# Programlama Kılavuzu)</span><span class="sxs-lookup"><span data-stu-id="ad92c-102">Constraints on Type Parameters (C# Programming Guide)</span></span>
<span data-ttu-id="ad92c-103">Genel bir sınıf tanımladığınızda, sınıfını başlattığında, istemci kodu tür bağımsız değişkenleri için kullanabileceğiniz türü tür kısıtlamaları uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ad92c-103">When you define a generic class, you can apply restrictions to the kinds of types that client code can use for type arguments when it instantiates your class.</span></span> <span data-ttu-id="ad92c-104">İstemci kodu kısıtlaması tarafından izin verilmeyen bir türünü kullanarak, sınıfının örneği çalışırsa, bir derleme zamanı hatası sonucudur.</span><span class="sxs-lookup"><span data-stu-id="ad92c-104">If client code tries to instantiate your class by using a type that is not allowed by a constraint, the result is a compile-time error.</span></span> <span data-ttu-id="ad92c-105">Bu kısıtlamalar kısıtlamaları denir.</span><span class="sxs-lookup"><span data-stu-id="ad92c-105">These restrictions are called constraints.</span></span> <span data-ttu-id="ad92c-106">Kısıtlamaları belirtilen kullanarak `where` bağlamsal anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="ad92c-106">Constraints are specified by using the `where` contextual keyword.</span></span> <span data-ttu-id="ad92c-107">Aşağıdaki tabloda kısıtlamaları altı türlerini listeler:</span><span class="sxs-lookup"><span data-stu-id="ad92c-107">The following table lists the six types of constraints:</span></span>  
  
|<span data-ttu-id="ad92c-108">Kısıtlama</span><span class="sxs-lookup"><span data-stu-id="ad92c-108">Constraint</span></span>|<span data-ttu-id="ad92c-109">Açıklama</span><span class="sxs-lookup"><span data-stu-id="ad92c-109">Description</span></span>|  
|----------------|-----------------|  
|`where T: struct`|<span data-ttu-id="ad92c-110">Tür bağımsız değişkeni bir değer türü olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ad92c-110">The type argument must be a value type.</span></span> <span data-ttu-id="ad92c-111">Herhangi bir değer türü dışında <xref:System.Nullable> belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="ad92c-111">Any value type except <xref:System.Nullable> can be specified.</span></span> <span data-ttu-id="ad92c-112">Bkz: [kullanarak boş değer atanabilir türler](../../../csharp/programming-guide/nullable-types/using-nullable-types.md) daha fazla bilgi için.</span><span class="sxs-lookup"><span data-stu-id="ad92c-112">See [Using Nullable Types](../../../csharp/programming-guide/nullable-types/using-nullable-types.md) for more information.</span></span>|  
|`where T : class`|<span data-ttu-id="ad92c-113">Tür bağımsız değişkeni bir başvuru türü olmalıdır; Bu aynı zamanda herhangi sınıfı, arabirim, temsilci veya dizi türü için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="ad92c-113">The type argument must be a reference type; this applies also to any class, interface, delegate, or array type.</span></span>|  
|`where T : new()`|<span data-ttu-id="ad92c-114">Tür bağımsız değişkeni genel bir parametresiz oluşturucuya sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ad92c-114">The type argument must have a public parameterless constructor.</span></span> <span data-ttu-id="ad92c-115">Diğer kısıtlamalar ile birlikte kullanıldığında `new()` kısıtlaması son belirtilmelidir.</span><span class="sxs-lookup"><span data-stu-id="ad92c-115">When used together with other constraints, the `new()` constraint must be specified last.</span></span>|  
|<span data-ttu-id="ad92c-116">`where T : `*\<taban sınıf adı >*</span><span class="sxs-lookup"><span data-stu-id="ad92c-116">`where T : `*\<base class name>*</span></span>|<span data-ttu-id="ad92c-117">Tür bağımsız değişkeni, olabilir veya belirtilen temel sınıfından türetilir.</span><span class="sxs-lookup"><span data-stu-id="ad92c-117">The type argument must be or derive from the specified base class.</span></span>|  
|<span data-ttu-id="ad92c-118">`where T : `*\<Arabirim adı >*</span><span class="sxs-lookup"><span data-stu-id="ad92c-118">`where T : `*\<interface name>*</span></span>|<span data-ttu-id="ad92c-119">Tür bağımsız değişkeni olabilir veya belirtilen arabirimini uygulaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="ad92c-119">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="ad92c-120">Birden çok arabirim kısıtlamaları belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="ad92c-120">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="ad92c-121">Kısıtlayan arabirimi genel olabilir.</span><span class="sxs-lookup"><span data-stu-id="ad92c-121">The constraining interface can also be generic.</span></span>|  
|`where T : U`|<span data-ttu-id="ad92c-122">T olması veya u için sağlanan bağımsız değişken öğesinden türetilen için sağlanan tür bağımsız değişkeni</span><span class="sxs-lookup"><span data-stu-id="ad92c-122">The type argument supplied for T must be or derive from the argument supplied for U.</span></span>|  
  
## <a name="why-use-constraints"></a><span data-ttu-id="ad92c-123">Kısıtlamaları neden kullanılır?</span><span class="sxs-lookup"><span data-stu-id="ad92c-123">Why Use Constraints</span></span>  
 <span data-ttu-id="ad92c-124">Geçerli olup olmadığını belirlemek için veya başka bir öğe karşılaştırmak için genel bir listedeki bir öğe incelemek isterseniz, derleyicinin bazı istemci ortak tarafından belirtilen tür bağımsız değişkeni tarafından işleci veya yöntem çağrılacak olan desteklenecek garanti olmalıdır de.</span><span class="sxs-lookup"><span data-stu-id="ad92c-124">If you want to examine an item in a generic list to determine whether it is valid or to compare it to some other item, the compiler must have some guarantee that the operator or method it has to call will be supported by any type argument that might be specified by client code.</span></span> <span data-ttu-id="ad92c-125">Bu garantisi, genel bir sınıf tanımı için bir veya daha fazla kısıtlamaları uygulayarak elde edilir.</span><span class="sxs-lookup"><span data-stu-id="ad92c-125">This guarantee is obtained by applying one or more constraints to your generic class definition.</span></span> <span data-ttu-id="ad92c-126">Örneğin, taban sınıf kısıtlaması bu tür nesneler yalnızca derleyici söyler veya öğesinden türetilmiş türü tür bağımsız değişkenleri kullanılır.</span><span class="sxs-lookup"><span data-stu-id="ad92c-126">For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.</span></span> <span data-ttu-id="ad92c-127">Derleyici bu garantisi sonra genel sınıfında çağrılacak türü yöntemleri izin verebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ad92c-127">Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.</span></span> <span data-ttu-id="ad92c-128">Bağlamsal anahtar sözcüğünü kullanarak kısıtlamalar uygulanır `where`.</span><span class="sxs-lookup"><span data-stu-id="ad92c-128">Constraints are applied by using the contextual keyword `where`.</span></span> <span data-ttu-id="ad92c-129">Aşağıdaki kod örneği için ekleyebilirsiniz biz işlevini gösterir `GenericList<T>` sınıfı (içinde [genel türlere giriş](../../../csharp/programming-guide/generics/introduction-to-generics.md)) bir taban sınıf kısıtlaması uygulayarak.</span><span class="sxs-lookup"><span data-stu-id="ad92c-129">The following code example demonstrates the functionality we can add to the `GenericList<T>` class (in [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)) by applying a base class constraint.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#11](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_1.cs)]  
  
 <span data-ttu-id="ad92c-130">Kullanmak genel bir sınıf kısıtlaması etkinleştirir `Employee.Name` özelliği tüm öğeleri T türü ya da olması garanti çünkü bir `Employee` veya öğesinden devralınan bir nesneyi `Employee`.</span><span class="sxs-lookup"><span data-stu-id="ad92c-130">The constraint enables the generic class to use the `Employee.Name` property because all items of type T are guaranteed to be either an `Employee` object or an object that inherits from `Employee`.</span></span>  
  
 <span data-ttu-id="ad92c-131">Aynı tür parametresi birden çok kısıtlama uygulanabilir ve kısıtlamaları kendilerini genel türleri, aşağıdaki gibi olabilir:</span><span class="sxs-lookup"><span data-stu-id="ad92c-131">Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#12](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_2.cs)]  
  
 <span data-ttu-id="ad92c-132">Tür parametresi kısıtlayarak, izin verilen işlemler ve kısıtlama türü ve devralma hiyerarşisi içindeki tüm türler tarafından desteklenen yöntem çağrılarını sayısını artırın.</span><span class="sxs-lookup"><span data-stu-id="ad92c-132">By constraining the type parameter, you increase the number of allowable operations and method calls to those supported by the constraining type and all types in its inheritance hierarchy.</span></span> <span data-ttu-id="ad92c-133">Bu nedenle, tasarlarken genel sınıfları veya yöntemleri, basit atama ötesinde Genel üyeler üzerinde herhangi bir işlemi gerçekleştirme veya kaldırılacak tarafından desteklenmeyen herhangi bir yöntem çağırma varsa `System.Object`, tür parametresi kısıtlamaları uygulamak gerekir.</span><span class="sxs-lookup"><span data-stu-id="ad92c-133">Therefore, when you design generic classes or methods, if you will be performing any operation on the generic members beyond simple assignment or calling any methods not supported by `System.Object`, you will have to apply constraints to the type parameter.</span></span>  
  
 <span data-ttu-id="ad92c-134">Uygularken `where T : class` kısıtlaması, kaçının `==` ve `!=` tür parametresi işleçlerini çünkü bu işleçlere yalnızca başvuru kimliği olmayan değer eşitlik için test.</span><span class="sxs-lookup"><span data-stu-id="ad92c-134">When applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality.</span></span> <span data-ttu-id="ad92c-135">Bağımsız değişken olarak kullanılan bir türdeki Bu işleçleri aşırı yüklenmiş olsa bile bu geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="ad92c-135">This is the case even if these operators are overloaded in a type that is used as an argument.</span></span> <span data-ttu-id="ad92c-136">Aşağıdaki kod bu noktayı gösterir; Çıktı halde false şeklindedir <xref:System.String> sınıf aşırı `==` işleci.</span><span class="sxs-lookup"><span data-stu-id="ad92c-136">The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#13](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_3.cs)]  
  
 <span data-ttu-id="ad92c-137">Bu davranış derleme zamanında Derleyici yalnızca T bir başvuru türü ve dolayısıyla tüm başvuru türleri için geçerli varsayılan işleçleri kullanması gerekir bilir, nedeni.</span><span class="sxs-lookup"><span data-stu-id="ad92c-137">The reason for this behavior is that, at compile time, the compiler only knows that T is a reference type, and therefore must use the default operators that are valid for all reference types.</span></span> <span data-ttu-id="ad92c-138">Değer eşitlik için test etmeniz gerekir, önerilen yöntem de uygulamak için ise `where T : IComparable<T>` kısıtlaması ve genel bir sınıf oluşturmak için kullanılan herhangi bir sınıf arabirimi uygulayın.</span><span class="sxs-lookup"><span data-stu-id="ad92c-138">If you must test for value equality, the recommended way is to also apply the `where T : IComparable<T>` constraint and implement that interface in any class that will be used to construct the generic class.</span></span>  
  
## <a name="constraining-multiple-parameters"></a><span data-ttu-id="ad92c-139">Birden çok parametre sınırlama</span><span class="sxs-lookup"><span data-stu-id="ad92c-139">Constraining Multiple Parameters</span></span>  
 <span data-ttu-id="ad92c-140">Aşağıdaki örnekte gösterildiği gibi birden çok parametre ve tek bir parametre için birden çok kısıtlama kısıtlamaları uygulayabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="ad92c-140">You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#64](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_4.cs)]  
  
## <a name="unbounded-type-parameters"></a><span data-ttu-id="ad92c-141">Sınırsız tür parametreleri</span><span class="sxs-lookup"><span data-stu-id="ad92c-141">Unbounded Type Parameters</span></span>  
 <span data-ttu-id="ad92c-142">Tür ortak sınıfı T gibi herhangi bir kısıtlama söz konusu parametrelerindeki `SampleClass<T>{}`, sınırsız tür parametreleri olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="ad92c-142">Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters.</span></span> <span data-ttu-id="ad92c-143">Sınırsız tür parametreleri aşağıdaki kurallar vardır:</span><span class="sxs-lookup"><span data-stu-id="ad92c-143">Unbounded type parameters have the following rules:</span></span>  
  
-   <span data-ttu-id="ad92c-144">`!=` Ve `==` somut tür bağımsız değişkeni bu işleçlere destekleyecek garanti olduğundan işleçleri kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="ad92c-144">The `!=` and `==` operators cannot be used because there is no guarantee that the concrete type argument will support these operators.</span></span>  
  
-   <span data-ttu-id="ad92c-145">Ve ondan dönüştürülebilir `System.Object` veya herhangi bir arabirim türü açıkça dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="ad92c-145">They can be converted to and from `System.Object` or explicitly converted to any interface type.</span></span>  
  
-   <span data-ttu-id="ad92c-146">' Karşılaştırabilirsiniz [null](../../../csharp/language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="ad92c-146">You can compare to [null](../../../csharp/language-reference/keywords/null.md).</span></span> <span data-ttu-id="ad92c-147">Sınırsız bir parametre karşılaştırılır varsa `null`, karşılaştırma her zaman tür bağımsız değişkeni bir değer türü ise false döndürür.</span><span class="sxs-lookup"><span data-stu-id="ad92c-147">If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type.</span></span>  
  
## <a name="type-parameters-as-constraints"></a><span data-ttu-id="ad92c-148">Tür parametreleri kısıtlamaları olarak</span><span class="sxs-lookup"><span data-stu-id="ad92c-148">Type Parameters as Constraints</span></span>  
 <span data-ttu-id="ad92c-149">Bir kısıtlama yararlı üye işlevi kendi tür parametresi ile olduğu gibi aşağıdaki örnekte gösterildiği gibi kapsayan tür tür parametresi bu parametreye sınırlamak bir genel tür parametresi kullanımını sahiptir:</span><span class="sxs-lookup"><span data-stu-id="ad92c-149">The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#14](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_5.cs)]  
  
 <span data-ttu-id="ad92c-150">Önceki örnekte, `T` türü kısıtlaması bağlamında `Add` yöntemi ve sınırsız tür parametresi bağlamında `List` sınıfı.</span><span class="sxs-lookup"><span data-stu-id="ad92c-150">In the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class.</span></span>  
  
 <span data-ttu-id="ad92c-151">Tür parametreleri, genel bir sınıf tanımları kısıtlamalar olarak da kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="ad92c-151">Type parameters can also be used as constraints in generic class definitions.</span></span> <span data-ttu-id="ad92c-152">Tür parametresi herhangi bir tür parametre birlikte köşeli ayraç içinde bildirilmelidir dikkat edin:</span><span class="sxs-lookup"><span data-stu-id="ad92c-152">Note that the type parameter must be declared within the angle brackets together with any other type parameters:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#15](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_6.cs)]  
  
 <span data-ttu-id="ad92c-153">Tür parametreleri yararlılığını Genel sınıflar kısıtlamalarıyla olarak den türemesi dışında derleyici tür parametresi hakkında hiçbir şey kabul edilebilir olduğundan çok sınırlı `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="ad92c-153">The usefulness of type parameters as constraints with generic classes is very limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`.</span></span> <span data-ttu-id="ad92c-154">Genel sınıflar, iki tür parametreleri arasında bir devralma ilişkisi uygulamak istediğiniz senaryolarda kısıtlamalar olarak tür parametreleri kullanın.</span><span class="sxs-lookup"><span data-stu-id="ad92c-154">Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ad92c-155">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="ad92c-155">See Also</span></span>  
 <xref:System.Collections.Generic>  
 [<span data-ttu-id="ad92c-156">C# Programlama Kılavuzu</span><span class="sxs-lookup"><span data-stu-id="ad92c-156">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="ad92c-157">Genel Türlere Giriş</span><span class="sxs-lookup"><span data-stu-id="ad92c-157">Introduction to Generics</span></span>](../../../csharp/programming-guide/generics/introduction-to-generics.md)  
 [<span data-ttu-id="ad92c-158">Genel Sınıflar</span><span class="sxs-lookup"><span data-stu-id="ad92c-158">Generic Classes</span></span>](../../../csharp/programming-guide/generics/generic-classes.md)  
 [<span data-ttu-id="ad92c-159">new Kısıtlaması</span><span class="sxs-lookup"><span data-stu-id="ad92c-159">new Constraint</span></span>](../../../csharp/language-reference/keywords/new-constraint.md)

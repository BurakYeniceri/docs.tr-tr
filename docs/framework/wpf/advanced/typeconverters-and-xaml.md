---
title: TypeConverters ve XAML
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology:
- dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
caps.latest.revision: 
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: 1b7ee4b3b00a675cfafc884d41079b76656bdf49
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 12/22/2017
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="eeef1-102">TypeConverters ve XAML</span><span class="sxs-lookup"><span data-stu-id="eeef1-102">TypeConverters and XAML</span></span>
<span data-ttu-id="eeef1-103">Bu konu, bir genel XAML dil özellik olarak dizesinden tür dönüştürme amacı tanıtır.</span><span class="sxs-lookup"><span data-stu-id="eeef1-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="eeef1-104">.NET Framework'teki <xref:System.ComponentModel.TypeConverter> sınıfı XAML öznitelik kullanımı özellik değeri olarak kullanılabilecek özel bir yönetilen sınıf uygulamasını bir parçası olarak belirli bir amaca hizmet.</span><span class="sxs-lookup"><span data-stu-id="eeef1-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="eeef1-105">Özel bir sınıf yazma ve XAML ayarlanabilir öznitelik değerleri kullanılabilmesi için sınıf örneklerinin istiyorsanız uygulamak gerekebilecek bir <xref:System.ComponentModel.TypeConverterAttribute> sınıfınıza, özel bir yazma <xref:System.ComponentModel.TypeConverter> sınıfı ya da her ikisini de.</span><span class="sxs-lookup"><span data-stu-id="eeef1-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  
  

  
## <a name="type-conversion-concepts"></a><span data-ttu-id="eeef1-106">Tür dönüştürme kavramları</span><span class="sxs-lookup"><span data-stu-id="eeef1-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="eeef1-107">XAML ve dize değerleri</span><span class="sxs-lookup"><span data-stu-id="eeef1-107">XAML and String Values</span></span>  
 <span data-ttu-id="eeef1-108">XAML dosyası içinde bir öznitelik değeri ayarladığınızda, ilk değer bir dize saf metinde türüdür.</span><span class="sxs-lookup"><span data-stu-id="eeef1-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="eeef1-109">Hatta başka ilkel gibi <xref:System.Double> başlangıçta metin dizesinin bir XAML işlemciye olup.</span><span class="sxs-lookup"><span data-stu-id="eeef1-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="eeef1-110">XAML işlemci bir öznitelik değeri işlemek için iki parça bilgi gerekir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="eeef1-111">İlk ayarlı özellik değeri türü bilgidir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="eeef1-112">Bir öznitelik değeri tanımlar ve XAML'de işlenen herhangi bir dize sonuçta dönüştürülen veya gerekir bu türde bir değer çözümlendi.</span><span class="sxs-lookup"><span data-stu-id="eeef1-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="eeef1-113">Değer (örneğin, bir sayısal değer) XAML ayrıştırıcısı tarafından anlaşılan basit bir tür ise, dizenin doğrudan dönüştürme denenir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="eeef1-114">Numaralandırma değeri geçerliyse dize adı eşleşir, numaralandırma adlandırılmış bir sabite denetlemek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="eeef1-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="eeef1-115">Değer ne ayrıştırıcı anladım ilkel veya numaralandırma, söz konusu türü ise örneği türü veya dönüştürülmüş dizesini temel alan bir değer sağlayabilir olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="eeef1-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="eeef1-116">Bu tür dönüştürücü sınıfı belirtilerek gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="eeef1-117">Tür dönüştürücüsünü etkili bir şekilde kod .NET kodda çağırır için XAML senaryo hem de büyük olasılıkla başka bir sınıf değerlerini sağlamak için bir yardımcı sınıfıdır.</span><span class="sxs-lookup"><span data-stu-id="eeef1-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="eeef1-118">Var olan tür dönüştürme davranışı XAML içinde kullanma</span><span class="sxs-lookup"><span data-stu-id="eeef1-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="eeef1-119">Temel alınan XAML kavramları, benzerlik bağlı olarak, tür dönüştürme davranışını temel uygulamada XAML kullanıldıklarını olmadan kullanıyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="eeef1-120">Örneğin, WPF türünde bir değer olması özellikleri yüzlerce tanımlar <xref:System.Windows.Point>.</span><span class="sxs-lookup"><span data-stu-id="eeef1-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="eeef1-121">A <xref:System.Windows.Point> koordinat iki boyutlu koordinat alanında açıklayan bir değerdir ve gerçekten yalnızca iki önemli özelliklere sahiptir: <xref:System.Windows.Point.X%2A> ve <xref:System.Windows.Point.Y%2A>.</span><span class="sxs-lookup"><span data-stu-id="eeef1-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="eeef1-122">XAML'de bir noktası belirttiğinizde, bir sınırlayıcı (genellikle bir virgül) ile bir dize olarak arasında belirtmeden <xref:System.Windows.Point.X%2A> ve <xref:System.Windows.Point.Y%2A> sağladığınız değerleri.</span><span class="sxs-lookup"><span data-stu-id="eeef1-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="eeef1-123">Örneğin: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1">`.</span><span class="sxs-lookup"><span data-stu-id="eeef1-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1">`.</span></span>  
  
 <span data-ttu-id="eeef1-124">Bu basit tür bile <xref:System.Windows.Point> ve basit kullanım XAML'de tür dönüştürücüsünü içerir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="eeef1-125">Bu durumda, sınıftır <xref:System.Windows.PointConverter>.</span><span class="sxs-lookup"><span data-stu-id="eeef1-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="eeef1-126">İçin tür dönüştürücüsünü <xref:System.Windows.Point> sınıf düzeyinde ölçeklendirerek ele tüm özelliklerin biçimlendirme kullanımları tanımlanan <xref:System.Windows.Point>.</span><span class="sxs-lookup"><span data-stu-id="eeef1-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="eeef1-127">Tür dönüştürücüsünü Burada, aşağıdaki gerekir daha önce gösterilen aynı örneği için çok daha ayrıntılı biçimlendirme:</span><span class="sxs-lookup"><span data-stu-id="eeef1-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  
  
 `<LinearGradientBrush>`  
  
 `<LinearGradientBrush.StartPoint>`  
  
 `<Point X="0" Y="0"/>`  
  
 `</LinearGradientBrush.StartPoint>`  
  
 `<LinearGradientBrush.EndPoint>`  
  
 `<Point X="1" Y="1"/>`  
  
 `</LinearGradientBrush.EndPoint>`  
  
 `<LinearGradientBrush>`  
  
 <span data-ttu-id="eeef1-128">Tür dönüştürme dize ya da daha ayrıntılı bir eşdeğer sözdizimi kullanıp kullanmayacağınızı genellikle bir kodlama stili seçimdir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="eeef1-129">XAML araç akışınızı ayrıca değerleri nasıl ayarlanacağını etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="eeef1-130">Bazı XAML Araçlar gidiş Tasarımcı görünümleri ya da kendi seri hale getirme mekanizmasını daha kolay olduğundan en ayrıntılı formun biçimlendirme yayma eğilimindedir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="eeef1-131">Var olan tür dönüştürücüleri genellikle keşfedilecek WPF ve .NET Framework türlerinde sınıfı (veya özelliği) bir uygulanmış olup olmadığını kontrol ederek <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="eeef1-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="eeef1-132">Bu öznitelik XAML amacıyla yanı sıra potansiyel olarak diğer amaçlar için bu türü değerleri için destekleyici türü dönüştürücü sınıfı adı.</span><span class="sxs-lookup"><span data-stu-id="eeef1-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="eeef1-133">Tür dönüştürücüleri ve İşaretleme uzantıları</span><span class="sxs-lookup"><span data-stu-id="eeef1-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="eeef1-134">Biçimlendirme uzantıları ve tür dönüştürücüleri XAML işlemci davranışı ve bunlar uygulanır senaryolar açısından resme rolleri doldurun.</span><span class="sxs-lookup"><span data-stu-id="eeef1-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="eeef1-135">Bağlam için işaretleme uzantısı kullanımları kullanılabilir olsa da, burada biçimlendirme uzantısı genellikle değerdir sağlar özellikleri türü dönüştürme davranışını biçimlendirme uzantısı uygulamalarında işaretlenmemiştir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="eeef1-136">Diğer bir deyişle, biçimlendirme uzantısı bir metin dizesi olarak döndürür olsa bile, `ProvideValue` çıkışı, belirli özellik ya da özellik değeri türü uygulanan olarak bu dize türü dönüştürme davranışını değil çağrıldığında, genellikle, bir işaretleme uzantısı amacı işlemdir bir dize ve dönüş türü dönüştürücünün söz konusu olmadan bir nesne.</span><span class="sxs-lookup"><span data-stu-id="eeef1-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="eeef1-137">Biçimlendirme uzantısı yerine tür dönüştürücüsünü gerekli olduğu bir ortak zaten bir nesneye başvuru yapmak için bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="eeef1-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="eeef1-138">En iyi durum bilgisiz tür dönüştürücüsünü yalnızca arzu olmayabilir yeni bir örneği üretebilir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="eeef1-139">Biçimlendirme uzantıları hakkında daha fazla bilgi için bkz: [biçimlendirme uzantıları ve WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="eeef1-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="eeef1-140">Yerel tür dönüştürücüleri</span><span class="sxs-lookup"><span data-stu-id="eeef1-140">Native Type Converters</span></span>  
 <span data-ttu-id="eeef1-141">XAML ayrıştırıcısı WPF ve .NET Framework uygulamasında henüz işleme, genel temelleri düşünülen türleri değil, yerel tür dönüştürme işleme sahip belirli türü vardır.</span><span class="sxs-lookup"><span data-stu-id="eeef1-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="eeef1-142">Bu tür bir türü örneği <xref:System.DateTime>.</span><span class="sxs-lookup"><span data-stu-id="eeef1-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="eeef1-143">Bunun nedeni, .NET Framework mimari nasıl çalıştığı hakkında temel alır: türü <xref:System.DateTime> mscorlib, .NET en temel kitaplıkta tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="eeef1-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="eeef1-144"><xref:System.DateTime>bir bağımlılık tanıtır başka bir derlemeden gelen özniteliğine sahip öznitelikli izin verilmiyor (<xref:System.ComponentModel.TypeConverterAttribute> sistemden olduğu) öznitelik atanıyor tarafından her zamanki türü dönüştürücü bulma mekanizmasından desteklenemez şekilde.</span><span class="sxs-lookup"><span data-stu-id="eeef1-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="eeef1-145">Bunun yerine, XAML ayrıştırıcısı gibi yerel işleme gerek türlerinin bir listesi vardır ve bunlar true temelleri nasıl işlendiği benzer şekilde işler.</span><span class="sxs-lookup"><span data-stu-id="eeef1-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="eeef1-146">(Durumunda <xref:System.DateTime> bu yapılan bir çağrı içerir <xref:System.DateTime.Parse%2A>.)</span><span class="sxs-lookup"><span data-stu-id="eeef1-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>   
## <a name="implementing-a-type-converter"></a><span data-ttu-id="eeef1-147">Tür dönüştürücüsünü uygulama</span><span class="sxs-lookup"><span data-stu-id="eeef1-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="eeef1-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="eeef1-148">TypeConverter</span></span>  
 <span data-ttu-id="eeef1-149">İçinde <xref:System.Windows.Point> sınıfı daha önce verilen örnek <xref:System.Windows.PointConverter> değinilen.</span><span class="sxs-lookup"><span data-stu-id="eeef1-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="eeef1-150">XAML .NET uygulamaları için XAML amacıyla kullanılan tüm tür dönüştürücüleri temel sınıfından türetilen sınıflardır <xref:System.ComponentModel.TypeConverter>.</span><span class="sxs-lookup"><span data-stu-id="eeef1-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="eeef1-151"><xref:System.ComponentModel.TypeConverter> Sınıfı XAML varlığını koyun .NET Framework sürümleri içinde vardı; kendi özgün kullanımlarından özelliği iletişim kutularında görsel tasarımcılar dize dönüştürme sağlamak için.</span><span class="sxs-lookup"><span data-stu-id="eeef1-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="eeef1-152">XAML, rolü <xref:System.ComponentModel.TypeConverter> bir dize öznitelik değeri ayrıştırma ve büyük olasılıkla bir dize uygulamasına geri belirli nesne özelliğinin bir çalışma zamanı değeri işleme etkinleştirmek için dize ve dize öğesinden dönüştürmeleri için temel sınıfı olan içerecek şekilde genişletilmiş Serileştirme özniteliği olarak.</span><span class="sxs-lookup"><span data-stu-id="eeef1-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="eeef1-153"><xref:System.ComponentModel.TypeConverter>XAML işleme amacıyla dizeleri gelen ve giden dönüştürmek için uygun olan dört üyeleri tanımlar:</span><span class="sxs-lookup"><span data-stu-id="eeef1-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
-   <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
-   <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="eeef1-154">Bu, en önemli bir yöntemdir <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="eeef1-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="eeef1-155">Bu yöntem giriş dizesini gerekli nesne türüne dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="eeef1-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="eeef1-156">NET olarak söylemek <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> yöntemin çok geniş bir türü dönüştürücü 's hedeflenen hedef türüne dönüştürün ve böylece çalışma zamanı dönüşümleri destekleme gibi ancak XAML amacıyla XAML genişletmek amaca hizmet eder yalnızca işleyebilir kod yolu olan bir <xref:System.String> önemli giriş.</span><span class="sxs-lookup"><span data-stu-id="eeef1-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="eeef1-157">Sonraki en önemli yöntemi <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="eeef1-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="eeef1-158">(Örneğin, XAML dosyası olarak kaydedilir) bir uygulama bir biçimlendirme gösterimine dönüştürülür varsa, <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> biçimlendirme gösterimi oluşturmaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="eeef1-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="eeef1-159">Geçirdiğiniz bu durumda, XAML için önemli kod yolu olduğunda bir `destinationType` , <xref:System.String> .</span><span class="sxs-lookup"><span data-stu-id="eeef1-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="eeef1-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>ve <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> hizmet özelliklerini sorguladığında kullanılan destek yöntemleri <xref:System.ComponentModel.TypeConverter> uygulaması.</span><span class="sxs-lookup"><span data-stu-id="eeef1-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="eeef1-161">Döndürmek için bu yöntemleri uygulamalıdır `true` türüne özgü durumlarda, dönüştürücü eşdeğer dönüştürme yöntemleri desteği.</span><span class="sxs-lookup"><span data-stu-id="eeef1-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="eeef1-162">XAML amacıyla, bu genellikle anlamına gelir <xref:System.String> türü.</span><span class="sxs-lookup"><span data-stu-id="eeef1-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="eeef1-163">Kültür bilgilerini ve XAML için tür dönüştürücüleri</span><span class="sxs-lookup"><span data-stu-id="eeef1-163">Culture Information and Type Converters for XAML</span></span>  
 <span data-ttu-id="eeef1-164">Her <xref:System.ComponentModel.TypeConverter> uygulaması bir dönüştürme için geçerli bir dize nelerin oluşturduğunu kendi yorumlama sahip ve ayrıca kullanın veya parametre olarak geçirilen türü açıklaması yoksay.</span><span class="sxs-lookup"><span data-stu-id="eeef1-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="eeef1-165">Kültür ve XAML tür dönüştürme açısından önemli bir konu yoktur.</span><span class="sxs-lookup"><span data-stu-id="eeef1-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="eeef1-166">Öznitelik değerleri yerelleştirilebilir dizeleriyle XAML tarafından tamamen desteklenir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="eeef1-167">Ancak türü dönüştürücü giriş kültürü gereksinimleriyle desteklenmediği XAML öznitelik değerleri için tür dönüştürücüleri mutlaka sabit dil ayrıştırma davranışı içerdiğinden bu yerelleştirilebilir dize kullanmak, kullanarak `en-US` kültür.</span><span class="sxs-lookup"><span data-stu-id="eeef1-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="eeef1-168">Bu kısıtlama tasarım nedenleri hakkında daha fazla bilgi için XAML dil belirtimi danışmalısınız ([\[MS XAML\]](http://go.microsoft.com/fwlink/?LinkId=114525)).</span><span class="sxs-lookup"><span data-stu-id="eeef1-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](http://go.microsoft.com/fwlink/?LinkId=114525)).</span></span>  
  
 <span data-ttu-id="eeef1-169">Burada, kültür bir sorun olabilir örnek olarak, bazı kültürler sayılar için kendi ondalık ayırıcı olarak virgül kullanın.</span><span class="sxs-lookup"><span data-stu-id="eeef1-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="eeef1-170">Bu, ayırıcı olarak virgül kullanılacak olan birçok WPF XAML tür dönüştürücüleri olan davranışı birbiriyle çakışır (ortak X gibi geçmiş Etkileyenler bağlı olarak, Y form veya virgülle ayrılmış listesi).</span><span class="sxs-lookup"><span data-stu-id="eeef1-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="eeef1-171">Bile bir kültür çevresindeki XAML'de geçirme (ayar `Language` veya `xml:lang` için `sl-SI` kültür, bu şekilde ondalık virgül kullanımları bir kültür örneği) sorunu çözmez.</span><span class="sxs-lookup"><span data-stu-id="eeef1-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="eeef1-172">ConvertFrom uygulama</span><span class="sxs-lookup"><span data-stu-id="eeef1-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="eeef1-173">Olarak kullanılabilmesi için bir <xref:System.ComponentModel.TypeConverter> XAML destekleyen uygulama <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> yöntemi Bu dönüştürücü için bir dize olarak kabul etmelisiniz `value` parametresi.</span><span class="sxs-lookup"><span data-stu-id="eeef1-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="eeef1-174">Dize geçerli biçimlendirmek ve tarafından dönüştürülebilir olup olmadığını <xref:System.ComponentModel.TypeConverter> uygulama daha sonra döndürülen nesne bir özellik tarafından beklenen türe dönüştürme desteklemesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="eeef1-175">Aksi takdirde, <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> uygulama döndürmelidir `null`.</span><span class="sxs-lookup"><span data-stu-id="eeef1-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="eeef1-176">Her <xref:System.ComponentModel.TypeConverter> uygulama bir dönüştürme için geçerli bir dize nelerin oluşturduğunu kendi yorumlama sahip ve ayrıca kullanın veya parametre olarak geçirilen türü açıklama veya kültüre içerikler yoksay.</span><span class="sxs-lookup"><span data-stu-id="eeef1-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="eeef1-177">Ancak, işleme WPF XAML değerleri türü açıklaması bağlamını tüm durumlarda geçebilir değil ve ayrıca göre kültür geçebilir değil `xml:lang`.</span><span class="sxs-lookup"><span data-stu-id="eeef1-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eeef1-178">Süslü ayraç karakterleri özellikle kullanmayın {, dize biçim olası bir öğe olarak.</span><span class="sxs-lookup"><span data-stu-id="eeef1-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="eeef1-179">Bu karakterleri olarak giriş ve çıkış biçimlendirme uzantısı sırası için ayrılmıştır.</span><span class="sxs-lookup"><span data-stu-id="eeef1-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="eeef1-180">ConvertTo uygulama</span><span class="sxs-lookup"><span data-stu-id="eeef1-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="eeef1-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A>büyük olasılıkla seri hale getirme desteği için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="eeef1-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="eeef1-182">Seri hale getirme desteğini <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> özel türünüz ve onun türü için dönüştürücü kesin bir gereklilik değildir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="eeef1-183">Bir denetimi uygulamak veya özelliklerin bir kısmı veya sınıfınızın tasarım serileştirmek kullanarak, ancak uygulamalıdır <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="eeef1-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="eeef1-184">Olarak kullanılabilmesi için bir <xref:System.ComponentModel.TypeConverter> XAML destekleyen uygulama <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> yöntemi Bu dönüştürücü için kabul etmelisiniz desteklenmekte olan türü (veya bir değer) örneği olarak `value` parametresi.</span><span class="sxs-lookup"><span data-stu-id="eeef1-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="eeef1-185">Zaman `destinationType` parametredir türü <xref:System.String>, döndürülen nesne olarak cast mümkün sonra <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="eeef1-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="eeef1-186">Döndürülen dize serileştirilmiş değerini temsil etmelidir `value`.</span><span class="sxs-lookup"><span data-stu-id="eeef1-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="eeef1-187">İdeal olarak, seçtiğiniz seri hale getirme biçimi için bu dizeyi geçirilmiş varsa aynı değeri oluşturma yeteneği olmalıdır <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> önemli bilgi kaybı olmadan aynı dönüştürücü uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="eeef1-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="eeef1-188">Değer seri hale getirilemez veya dönüştürücü serileştirme, desteklemiyor <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> uygulama döndürmelidir `null`, bu durumda bir özel durum erişmesine izin.</span><span class="sxs-lookup"><span data-stu-id="eeef1-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="eeef1-189">Ancak özel durumlar oluşturma, bir parçası olarak bu dönüştürme kullanamama bildirmelisiniz, <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> uygulama böylece ile denetimi en iyi uygulama olarak <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> ilk özel durumları önlemek için desteklenir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="eeef1-190">Varsa `destinationType` parametresi türü değil <xref:System.String>, kendi dönüştürücü işleme seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="eeef1-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="eeef1-191">Genellikle, işleme, hangi basemost temel uygulamasına geri <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> belirli bir özel durum oluşturur.</span><span class="sxs-lookup"><span data-stu-id="eeef1-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="eeef1-192">CanConvertTo uygulama</span><span class="sxs-lookup"><span data-stu-id="eeef1-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="eeef1-193"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> Uygulama döndürmelidir `true` için `destinationType` türü <xref:System.String>ve aksi durumda temel uygulamayı erteleneceği.</span><span class="sxs-lookup"><span data-stu-id="eeef1-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="eeef1-194">CanConvertFrom uygulama</span><span class="sxs-lookup"><span data-stu-id="eeef1-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="eeef1-195"><xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> Uygulama döndürmelidir `true` için `sourceType` türü <xref:System.String>ve aksi durumda temel uygulamayı erteleneceği.</span><span class="sxs-lookup"><span data-stu-id="eeef1-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>   
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="eeef1-196">TypeConverterAttribute uygulama</span><span class="sxs-lookup"><span data-stu-id="eeef1-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="eeef1-197">Sırayla gibi davranan kullanılması için özel tür dönüştürücü için XAML işlemcisi tarafından özel bir sınıf için tür dönüştürücüsünü, uygulamalısınız [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> sınıf tanımı.</span><span class="sxs-lookup"><span data-stu-id="eeef1-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="eeef1-198"><xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> Özniteliğiyle belirttiğiniz özel tür dönüştürücü türü adı olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="eeef1-199">Uygulanan, bu öznitelik ile XAML işlemci değerleri nerede özellik türü, özel bir sınıf türü kullanan işlediğinde, bu giriş dizeleri ve nesne örneklerini döndürür.</span><span class="sxs-lookup"><span data-stu-id="eeef1-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="eeef1-200">Ayrıca bir özelliği başına temelinde tür dönüştürücüsünü sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="eeef1-201">Uygulama yerine bir [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> bir özellik tanımını uygulayan sınıf tanımına (ana tanımı değil `get` / `set` içindeki uygulamaları).</span><span class="sxs-lookup"><span data-stu-id="eeef1-201">Instead of applying a [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="eeef1-202">Özelliğinin türü, özel tür dönüştürücü tarafından işlenen türü eşleşmelidir.</span><span class="sxs-lookup"><span data-stu-id="eeef1-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="eeef1-203">Uygulanan, bu öznitelik ile bu özelliğin değerleri, bir XAMLprocessor işlediğinde, bu işlem giriş dizelerini ve dönüş nesne örnekleri.</span><span class="sxs-lookup"><span data-stu-id="eeef1-203">With this attribute applied, when a XAMLprocessor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="eeef1-204">Özellik başına türü dönüştürücü teknik bir özellik türünden kullanmayı tercih ederseniz özellikle yararlıdır [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] veya kitaplığından burada sınıf tanımını denetleyemezsiniz ve uygulanamıyor bazı başka bir <xref:System.ComponentModel.TypeConverterAttribute> vardır.</span><span class="sxs-lookup"><span data-stu-id="eeef1-204">The per-property type converter technique is particularly useful if you choose to use a property type from [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="eeef1-205">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="eeef1-205">See Also</span></span>  
 <xref:System.ComponentModel.TypeConverter>  
 [<span data-ttu-id="eeef1-206">XAML'ye Genel Bakış (WPF)</span><span class="sxs-lookup"><span data-stu-id="eeef1-206">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)  
 [<span data-ttu-id="eeef1-207">İşaretleme Uzantıları ve WPF XAML</span><span class="sxs-lookup"><span data-stu-id="eeef1-207">Markup Extensions and WPF XAML</span></span>](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)  
 [<span data-ttu-id="eeef1-208">Ayrıntılı XAML Sözdizimi</span><span class="sxs-lookup"><span data-stu-id="eeef1-208">XAML Syntax In Detail</span></span>](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)

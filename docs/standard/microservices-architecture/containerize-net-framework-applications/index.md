---
title: Eski tek yapılı .NET Framework uygulamaları geçirme Windows kapsayıcıları
description: Kapsayıcılı .NET uygulamaları için .NET mikro mimarisi | Eski tek yapılı .NET Framework uygulamaları geçirme Windows kapsayıcıları
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.openlocfilehash: 01b84d29a559bde02ebd30535488c272d5208167
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/29/2018
ms.locfileid: "37106521"
---
# <a name="migrating-legacy-monolithic-net-framework-applications-to-windows-containers"></a><span data-ttu-id="b94f6-103">Eski tek yapılı .NET Framework uygulamaları geçirme Windows kapsayıcıları</span><span class="sxs-lookup"><span data-stu-id="b94f6-103">Migrating Legacy Monolithic .NET Framework Applications to Windows Containers</span></span>

<span data-ttu-id="b94f6-104">*Geliştirme geliştirmek ve test ortamları ve eski .NET Framework teknolojileri gibi Web tabanlı uygulamaları dağıtmak için bir yol olarak Windows kapsayıcıları kullanılabilir* *Forms. Bu şekilde eski uygulamalar için kapsayıcıları kullanma "yükseltme ve shift" senaryo olarak adlandırılır.*</span><span class="sxs-lookup"><span data-stu-id="b94f6-104">*Windows Containers can be used as a way to improve development and test environments, and to deploy applications that are based on legacy .NET Framework technologies like Web* *Forms. Using containers for legacy applications in this way is referred to as a “lift and shift” scenario.*</span></span>

<span data-ttu-id="b94f6-105">Bu kılavuzun önceki bölümlerde iş uygulamaları farklı kapsayıcılar her küçük, odaklanmış bir hizmeti çalıştıran dağıtıldığı bir mikro mimarisi championed.</span><span class="sxs-lookup"><span data-stu-id="b94f6-105">Earlier sections of this guide have championed a microservices architecture where business applications are distributed among different containers, each running a small, focused service.</span></span> <span data-ttu-id="b94f6-106">Bu hedefe birçok avantaj vardır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-106">That goal has many benefits.</span></span> <span data-ttu-id="b94f6-107">Yeni geliştirme bu yaklaşımı önemle tavsiye edilir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-107">In new development, that approach is strongly recommended.</span></span> <span data-ttu-id="b94f6-108">İşletme açısından kritik uygulamalar yeterli rearchitecture ve yeniden uygulama maliyetini yaslamak için de yararlı olacaktır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-108">Enterprise-critical applications will also benefit enough to justify the cost of a rearchitecture and reimplementation.</span></span>

<span data-ttu-id="b94f6-109">Ancak her uygulama yeterli maliyeti yaslamak için yararlı olacaktır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-109">But not every application will benefit enough to justify the cost.</span></span> <span data-ttu-id="b94f6-110">Bu uygulamaların kapsayıcı senaryosunda kullanılan anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="b94f6-110">That does not mean that those applications cannot be used in container scenarios.</span></span>

<span data-ttu-id="b94f6-111">Bu bölümde, biz eShopOnContainers, Şekil 7-1'de gösterilen için uygulama inceleyeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="b94f6-111">In this section, we will explore an application for eShopOnContainers, shown in Figure 7-1.</span></span> <span data-ttu-id="b94f6-112">Bu uygulamayı görüntülemek ve ürün kataloğu düzenlemek için eShopOnContainers Kurumsal takım üyeleri tarafından kullanılacak.</span><span class="sxs-lookup"><span data-stu-id="b94f6-112">This application would be used by members of the eShopOnContainers enterprise team to view and edit the product catalog.</span></span>

![](./media/image1.png)

<span data-ttu-id="b94f6-113">**Şekil 7-1**.</span><span class="sxs-lookup"><span data-stu-id="b94f6-113">**Figure 7-1**.</span></span> <span data-ttu-id="b94f6-114">Bir Windows kapsayıcısı üzerinde ASP.NET Web Forms uygulaması (eski teknolojisi)</span><span class="sxs-lookup"><span data-stu-id="b94f6-114">ASP.NET Web Forms application (legacy technology) on a Windows Container</span></span>

<span data-ttu-id="b94f6-115">Bu, göz atın ve Katalog girişleri değiştirmek için kullanılan bir Web Forms uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-115">This is a Web Forms application that is used to browse and modify the catalog entries.</span></span> <span data-ttu-id="b94f6-116">Web Forms bağımlılık Web Forms yeniden yazılmıştır ve ASP.NET Core MVC yerine kullanır sürece bu uygulama .NET Core üzerinde çalışmaz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-116">The Web Forms dependency means this application will not run on .NET Core unless it is rewritten without Web Forms and instead uses ASP.NET Core MVC.</span></span> <span data-ttu-id="b94f6-117">Bu değişiklik yapmadan kapsayıcılardaki gibi uygulamaları nasıl çalıştırabileceğiniz görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="b94f6-117">You will see how you can run applications like these in containers without changes.</span></span> <span data-ttu-id="b94f6-118">Ayrıca, burada bazı işlevler ayrı mikro taşındı, ancak çoğu işlevselliği tek yapılı uygulamada kalır bir karma modda çalışmak için küçük değişiklikler nasıl yapabileceğiniz görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="b94f6-118">You will also see how you can make minimal changes to work in a hybrid mode where some functionality has been moved into a separate microservice, but most functionality remains in the monolithic application.</span></span>

## <a name="benefits-of-containerizing-a-monolithic-application"></a><span data-ttu-id="b94f6-119">Tek yapılı bir uygulama containerizing avantajları</span><span class="sxs-lookup"><span data-stu-id="b94f6-119">Benefits of containerizing a monolithic application</span></span>

<span data-ttu-id="b94f6-120">Catalog.WebForms uygulama eShopOnContainers GitHub deposunda kullanılabilir (<https://github.com/dotnet/eShopOnContainers>).</span><span class="sxs-lookup"><span data-stu-id="b94f6-120">The Catalog.WebForms application is available in the eShopOnContainers GitHub repository (<https://github.com/dotnet/eShopOnContainers>).</span></span> <span data-ttu-id="b94f6-121">Bu uygulama, yüksek kullanılabilirlik veri deposuna erişilirken tek başına bir web uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-121">This application is a standalone web application accessing a high-availability data store.</span></span> <span data-ttu-id="b94f6-122">Buna rağmen bir kapsayıcıda uygulama çalıştırmanın avantajı vardır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-122">Even so, there are advantages to running the application in a container.</span></span> <span data-ttu-id="b94f6-123">Uygulama için bir görüntü oluşturun.</span><span class="sxs-lookup"><span data-stu-id="b94f6-123">You create an image for the application.</span></span> <span data-ttu-id="b94f6-124">O noktadan itibaren her dağıtım aynı ortamda çalışır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-124">From that point forward, every deployment runs in the same environment.</span></span> <span data-ttu-id="b94f6-125">Her kapsayıcı aynı işletim sistemi sürümünü kullanır, yüklü bağımlılıkları aynı sürümü, aynı çerçevesi kullanır ve aynı işlemi kullanılarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="b94f6-125">Every container uses the same OS version, has the same version of dependencies installed, uses the same framework, and is built using the same process.</span></span> <span data-ttu-id="b94f6-126">Visual Studio 2017 Şekil 7-2 yüklenen uygulama görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b94f6-126">You can see the application loaded in Visual Studio 2017 in Figure 7-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="b94f6-127">**Şekil 7-2**.</span><span class="sxs-lookup"><span data-stu-id="b94f6-127">**Figure 7-2**.</span></span> <span data-ttu-id="b94f6-128">Katalog Yönetimi Visual Studio 2017 Web Forms uygulamasında</span><span class="sxs-lookup"><span data-stu-id="b94f6-128">Catalog management Web Forms application in Visual Studio 2017</span></span>

<span data-ttu-id="b94f6-129">Ayrıca, geliştiricilerin tüm uygulama tutarlı bu ortamda çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b94f6-129">In addition, developers can all run the application in this consistent environment.</span></span> <span data-ttu-id="b94f6-130">Yalnızca belirli sürümleriyle görünür sorunları hemen bir hazırlık veya üretim ortamında görünmesini yerine geliştiriciler için görünür.</span><span class="sxs-lookup"><span data-stu-id="b94f6-130">Issues that only appear with certain versions will appear immediately for developers rather than surfacing in a staging or production environment.</span></span> <span data-ttu-id="b94f6-131">Uygulamaları kapsayıcılarında çalıştırdığınızda geliştirme ortamları ve geliştirme ekibi arasında arasındaki farklar daha az önemli.</span><span class="sxs-lookup"><span data-stu-id="b94f6-131">Differences between the development environments among the development team matter less once applications run in containers.</span></span>

<span data-ttu-id="b94f6-132">Son olarak, kapsayıcılı uygulamaların daha düz genişleme eğri vardır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-132">Finally, containerized applications have a flatter scale-out curve.</span></span> <span data-ttu-id="b94f6-133">Sahip olduğunuz öğrenilen nasıl kapsayıcılı uygulamaların daha fazla kapsayıcı bir VM'de veya fiziksel bir makine daha fazla kapsayıcılarını sağlamak.</span><span class="sxs-lookup"><span data-stu-id="b94f6-133">You have learned how containerized apps enable more containers in a VM or more containers in a physical machine.</span></span> <span data-ttu-id="b94f6-134">Bu daha yüksek yoğunluk ve daha az gerekli dönüşür kaynakları.</span><span class="sxs-lookup"><span data-stu-id="b94f6-134">This translates to higher density and fewer required resources.</span></span>

<span data-ttu-id="b94f6-135">Bu nedenlerle, bir "yükseltme ve shift" işlemini kullanarak bir Docker kapsayıcısı içinde çalışan eski tek yapılı uygulamalar göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="b94f6-135">For all these reasons, consider running legacy monolithic apps in a Docker container using a “lift-and-shift” operation.</span></span> <span data-ttu-id="b94f6-136">"Kaldırın ve shift" açıklar görevin kapsamı tümcecik:, *Yükselt* bir fiziksel veya sanal makine, tüm uygulama ve *shift* içine bir kapsayıcı.</span><span class="sxs-lookup"><span data-stu-id="b94f6-136">The phrase “lift and shift” describes the scope of the task: you *lift* the entire application from a physical or virtual machine, and *shift* it into a container.</span></span> <span data-ttu-id="b94f6-137">İdeal durumlarda bir kapsayıcıda çalıştırmak için uygulama kodu herhangi bir değişiklik yapmak gerekmez.</span><span class="sxs-lookup"><span data-stu-id="b94f6-137">In ideal situations, you do not need to make any changes to the application code to run it in a container.</span></span>

## <a name="possible-migration-paths"></a><span data-ttu-id="b94f6-138">Olası geçiş yolları</span><span class="sxs-lookup"><span data-stu-id="b94f6-138">Possible migration paths</span></span>

<span data-ttu-id="b94f6-139">Tek yapılı bir uygulama, veri erişim kitaplıkları da dahil olmak üzere tüm kodu içeren bir web uygulaması Catalog.Webforms uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-139">As a monolithic application, the Catalog.Webforms application is one web application containing all the code, including the data access libraries.</span></span> <span data-ttu-id="b94f6-140">Veritabanını farklı bir yüksek kullanılabilirlik makinede çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-140">The database runs on a separate high-availability machine.</span></span> <span data-ttu-id="b94f6-141">Bu yapılandırma sahte katalog hizmetini kullanarak örnek kodda benzetimli: Saf yükseltme shift senaryo benzetimini yapmak için bu sahte verileri karşı Catalog.WebForms uygulamayı çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b94f6-141">That configuration is simulated in the sample code by using a mock catalog service: you can run the Catalog.WebForms application against that fake data to simulate a pure lift-and-shift scenario.</span></span> <span data-ttu-id="b94f6-142">Bu kod değişiklikleri olmadan bir kapsayıcıdaki tüm çalıştırmak için varolan varlıkları taşımak en basit geçiş yol gösterir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-142">This demonstrates the simplest migration path, where you move existing assets to run in a container without any code changes at all.</span></span> <span data-ttu-id="b94f6-143">Bu yol tamamlandıktan ve mikro hizmetler için taşıma işlevselliği en az etkileşimiyle sahip uygulamalar için uygundur.</span><span class="sxs-lookup"><span data-stu-id="b94f6-143">This path is appropriate for applications that are complete and that have minimal interaction with functionality that you are moving to microservices.</span></span>

<span data-ttu-id="b94f6-144">Ancak, eShopOnContainers Web sitesi zaten farklı senaryolar için mikro kullanarak veri depolama erişiyor.</span><span class="sxs-lookup"><span data-stu-id="b94f6-144">However, the eShopOnContainers website is already accessing the data storage using microservices for different scenarios.</span></span> <span data-ttu-id="b94f6-145">Bazı küçük ek değişiklikler katalog düzenleyiciye Kataloğu veri depolama doğrudan erişimini yerine katalog mikro hizmet yararlanmak için yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-145">Some small additional changes can be made to the catalog editor to leverage the catalog microservice instead of accessing the catalog data storage directly.</span></span>

<span data-ttu-id="b94f6-146">Bu değişiklikler, kendi uygulamalarınız için continuum gösterir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-146">These changes demonstrate the continuum for your own applications.</span></span> <span data-ttu-id="b94f6-147">Mevcut uygulamaların tamamen tamamen yeni bir katılmak için uygulamanın yeniden yazma işlemi için yeni mikro bazıları erişmesine olanak veren küçük değişiklikler yapmak kapsayıcıları, varolan bir uygulamayı değişiklik olmadan taşınmasını gelen herhangi bir şey yapabilirsiniz mikro hizmet tabanlı mimari.</span><span class="sxs-lookup"><span data-stu-id="b94f6-147">You can do anything from moving an existing application without change into containers, to making small changes that enable existing applications to access some of the new microservices, to completely rewriting an application to fully participate in a new microservice-based architecture.</span></span> <span data-ttu-id="b94f6-148">Doğru yol maliyeti geçişi ve hiçbir geçirmeden avantajları bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-148">The right path depends on both the cost of the migration and the benefits from any migration.</span></span>

## <a name="application-tour"></a><span data-ttu-id="b94f6-149">Uygulama turu</span><span class="sxs-lookup"><span data-stu-id="b94f6-149">Application tour</span></span>

<span data-ttu-id="b94f6-150">Catalog.WebForms çözüm yükleyin ve uygulamayı bir tek başına uygulama olarak çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="b94f6-150">You can load the Catalog.WebForms solution and run the application as a standalone application.</span></span> <span data-ttu-id="b94f6-151">Bu yapılandırmada, kalıcı depolama veritabanı yerine, verileri döndürmek için sahte bir hizmet uygulaması kullanır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-151">In this configuration, instead of a persistent storage database, the application uses a fake service to return data.</span></span> <span data-ttu-id="b94f6-152">Uygulama Autofac kullanır (<https://autofac.org/>) bir tersine çevirme (IOC) denetim kapsayıcısının olarak.</span><span class="sxs-lookup"><span data-stu-id="b94f6-152">The application uses Autofac (<https://autofac.org/>) as an inversion of control (IOC) container.</span></span> <span data-ttu-id="b94f6-153">Bağımlılık ekleme (dı) kullanarak, sahte verileri veya dinamik Kataloğu veri hizmeti kullanmak için uygulamayı yapılandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b94f6-153">Using Dependency Injection (DI), you can configure the application to use the fake data or the live catalog data service.</span></span> <span data-ttu-id="b94f6-154">(Biz daha dı hakkında kısa bir süre içinde anlatılmıştır.) Başlangıç kodu useFake ayarı web.config dosyalarından okur ve sahte veri hizmeti veya dinamik katalog hizmeti eklemesine Autofac kapsayıcı yapılandırır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-154">(We will explain more about DI shortly.) The startup code reads a useFake setting from the web.config files, and configures the Autofac container to inject either the fake data service or the live catalog service.</span></span> <span data-ttu-id="b94f6-155">Uygulamanın web.config dosyasında false olarak ayarlanmış useFake çalıştırırsanız, katalog verilerini görüntüleme Web Forms uygulaması bakın.</span><span class="sxs-lookup"><span data-stu-id="b94f6-155">If you run the application with useFake set to false in the web.config file, you see the Web Forms application displaying the catalog data.</span></span>

<span data-ttu-id="b94f6-156">Bu uygulamada kullanılan teknikleri çoğunu Web Forms kullanan herkes için çok bilgi sahibi olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-156">Most of the techniques used in this application should be very familiar to anyone who has used Web Forms.</span></span> <span data-ttu-id="b94f6-157">Ancak, katalog mikro hizmet tanınmayan olabilir iki teknikleri tanıtır: bağımlılık ekleme (hangi daha önce değinilen dı) ve zaman uyumsuz veri depolarında Web Forms ile çalışır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-157">However, the catalog microservice introduces two techniques that might be unfamiliar: Dependency Injection (DI), which was mentioned earlier, and working with asynchronous data stores in Web Forms.</span></span>

<span data-ttu-id="b94f6-158">DI tüm gerekli kaynakları tahsis sınıfları yazma tipik olan nesne yönelimli stratejisi tersine çevirir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-158">DI inverts the typical object-oriented strategy of writing classes that allocate all needed resources.</span></span> <span data-ttu-id="b94f6-159">Bunun yerine, sınıflar, hizmet kapsayıcısından bağımlılıklarını isteyin.</span><span class="sxs-lookup"><span data-stu-id="b94f6-159">Instead, classes request their dependencies from a service container.</span></span> <span data-ttu-id="b94f6-160">DI avantajı, test veya diğer ortamlarını desteklemek için fakes ile (mocks) dış hizmetler değiştirebilir ' dir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-160">The advantage of DI is that you can replace external services with fakes (mocks) to support testing or other environments.</span></span>

<span data-ttu-id="b94f6-161">DI kapsayıcı sahte katalog verilerini veya çalışan hizmetin canlı verileri kullanıp kullanmayacağınızı denetlemek için web.config appSettings yapılandırması kullanır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-161">The DI container uses the web.config appSettings configuration to control whether to use the fake catalog data or the live data from the running service.</span></span> <span data-ttu-id="b94f6-162">Uygulama kapsayıcı oluşturur ve bağımlılıkları eklemesine öncesi istek işleyicisi kaydeden bir HTTP nesne kaydeder.</span><span class="sxs-lookup"><span data-stu-id="b94f6-162">The application registers an HttpModule object that builds the container and registers a pre-request handler to inject dependencies.</span></span> <span data-ttu-id="b94f6-163">Bu kodu aşağıdaki gibi görünen Modules/AutoFacHttpModule.cs dosyasında görebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="b94f6-163">You can see that code in the Modules/AutoFacHttpModule.cs file, which looks like the following example:</span></span>

```cs
private static IContainer CreateContainer()
{
  // Configure AutoFac:
  // Register Containers:

  var settings = WebConfigurationManager.AppSettings;
  var useFake = settings["usefake"];
  bool fake = useFake == "true";
  var builder = new ContainerBuilder();

  if (fake)
  {
    builder.RegisterType<CatalogMockService>()
    .As<ICatalogService>();
  }
  else
  {
    builder.RegisterType<CatalogService>()
    .As<ICatalogService>();
    builder.RegisterType<RequestProvider>()
    .As<IRequestProvider>();
  }

  var container = builder.Build();
  return container;
}

private void InjectDependencies()
{
  if (HttpContext.Current.CurrentHandler is Page page)
  {
    // Get the code-behind class that we may have written
    var pageType = page.GetType().BaseType;

    // Determine if there is a constructor to inject, and grab it
    var ctor = (from c in pageType.GetConstructors()
                where c.GetParameters().Length > 0
                select c).FirstOrDefault();

    if (ctor != null)
    {
      // Resolve the parameters for the constructor
      var args = (from parm in ctor.GetParameters()
                  select Container.Resolve(parm.ParameterType))
                  .ToArray();

      // Execute the constructor method with the arguments resolved
      ctor.Invoke(page, args);
    }

    // Use the Autofac method to inject any
    // properties that can be filled by Autofac
    Container.InjectProperties(page);
  }
}
```

<span data-ttu-id="b94f6-164">Uygulama sayfaları (Default.aspx.cs ve EditPage.aspx.cs) Bu bağımlılıklar ele oluşturucular tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="b94f6-164">The application’s pages (Default.aspx.cs and EditPage.aspx.cs) define constructors that take these dependencies.</span></span> <span data-ttu-id="b94f6-165">Varsayılan Oluşturucu hala mevcut ve erişilebilir olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="b94f6-165">Note that the default constructor is still present and accessible.</span></span> <span data-ttu-id="b94f6-166">Aşağıdaki kod altyapısı gerekir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-166">The infrastructure needs the following code.</span></span>

```cs
protected _Default() { }

public _Default(ICatalogService catalog) => this.catalog = catalog;
```

<span data-ttu-id="b94f6-167">Katalog API'leri tüm zaman uyumsuz yöntem bulunmaktadır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-167">The catalog APIs are all asynchronous methods.</span></span> <span data-ttu-id="b94f6-168">Web Forms artık destekliyor bunlar tüm veri denetimleri için.</span><span class="sxs-lookup"><span data-stu-id="b94f6-168">Web Forms now supports these for all data controls.</span></span> <span data-ttu-id="b94f6-169">Catalog.WebForms uygulama model bağlama için listesi kullanır ve sayfaları; sayfalarında Denetimler görev döndüren zaman uyumsuz işlemleri belirtin SelectMethod, UpdateMethod, InsertMethod ve DeleteMethod özellikleri tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="b94f6-169">The Catalog.WebForms application uses model binding for the list and edit pages; controls on the pages define SelectMethod, UpdateMethod, InsertMethod, and DeleteMethod properties that specify Task-returning asynchronous operations.</span></span> <span data-ttu-id="b94f6-170">Bir denetime bağlı yöntemleri zaman uyumsuz olduğunda web Forms denetimleri anlayın.</span><span class="sxs-lookup"><span data-stu-id="b94f6-170">Web Forms controls understand when the methods bound to a control are asynchronous.</span></span> <span data-ttu-id="b94f6-171">Zaman uyumsuz select yöntemleri kullanarak disk belleği destekleyemez olduğunda tek kısıtlama karşılaştığınız.</span><span class="sxs-lookup"><span data-stu-id="b94f6-171">The only restriction you encounter when using asynchronous select methods is that you cannot support paging.</span></span> <span data-ttu-id="b94f6-172">Out parametresi disk belleği imza gerektirir ve zaman uyumsuz yöntemleri out Parametreleri olamaz.</span><span class="sxs-lookup"><span data-stu-id="b94f6-172">The paging signature requires an out parameter, and asynchronous methods cannot have out parameters.</span></span> <span data-ttu-id="b94f6-173">Bu aynı teknik veri Kataloğu hizmetinden gerektiren diğer sayfalarında kullanılır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-173">This same technique is used on other pages that require data from the catalog service.</span></span>

<span data-ttu-id="b94f6-174">Web Forms uygulama kataloğu için varsayılan yapılandırmayı catalog.api hizmetinin sahte bir uygulama kullanır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-174">The default configuration for the catalog Web Forms application uses a mock implementation of the catalog.api service.</span></span> <span data-ttu-id="b94f6-175">Bu mock geliştirme ortamlarında catalog.api hizmet bağımlılık kaldırarak bazı görevler basitleştirir, veriler için sabit kodlanmış bir veri kümesi kullanır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-175">This mock uses a hard-coded dataset for its data, which simplifies some tasks by removing the dependency on the catalog.api service in development environments.</span></span>

## <a name="lifting-and-shifting"></a><span data-ttu-id="b94f6-176">Kaldırma ve kaydırma</span><span class="sxs-lookup"><span data-stu-id="b94f6-176">Lifting and shifting</span></span>

<span data-ttu-id="b94f6-177">Visual Studio, uygulama containerizing için harika desteği sağlar.</span><span class="sxs-lookup"><span data-stu-id="b94f6-177">Visual Studio provides great support for containerizing an application.</span></span> <span data-ttu-id="b94f6-178">Proje düğümüne sağ tıklayın ve ardından **Ekle** ve **Docker Destek**.</span><span class="sxs-lookup"><span data-stu-id="b94f6-178">You right-click the project node and then select **Add** and **Docker Support**.</span></span> <span data-ttu-id="b94f6-179">Docker proje şablonu adlı çözüm için yeni bir proje ekler **docker-oluşturan**.</span><span class="sxs-lookup"><span data-stu-id="b94f6-179">The Docker project template adds a new project to the solution called **docker-compose**.</span></span> <span data-ttu-id="b94f6-180">Proje oluşturma (ya da derleme) gerekir ve gerekli kapsayıcıları çalışmaya başladıktan görüntüleri Docker varlıklar Şekil 7-3'te gösterildiği gibi içeriyor.</span><span class="sxs-lookup"><span data-stu-id="b94f6-180">The project contains the Docker assets that compose (or build) the images you need, and starts running the necessary containers, as shown in Figure 7-3.</span></span>

<span data-ttu-id="b94f6-181">Kolay yükseltme ve shift senaryolarda, Web Forms uygulaması için kullandığınız tek hizmet uygulaması olacaktır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-181">In the simplest lift-and-shift scenarios, the application will be the single service that you use for the Web Forms application.</span></span> <span data-ttu-id="b94f6-182">Şablon de işaret etmek için başlangıç projesi değiştirir **docker compose'u** projesi.</span><span class="sxs-lookup"><span data-stu-id="b94f6-182">The template also changes your startup project to point to the **docker-compose** project.</span></span> <span data-ttu-id="b94f6-183">CTRL + F5'e veya F5 tuşuna basarak şimdi Docker görüntüsünü oluşturur ve Docker kapsayıcısı başlatır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-183">Pressing Ctrl+F5 or F5 now creates the Docker image and launches the Docker container.</span></span>

![](./media/image3.png)

<span data-ttu-id="b94f6-184">**Şekil 7-3**.</span><span class="sxs-lookup"><span data-stu-id="b94f6-184">**Figure 7-3**.</span></span> <span data-ttu-id="b94f6-185">**Docker compose'u** Web Forms çözümde proje</span><span class="sxs-lookup"><span data-stu-id="b94f6-185">The **docker-compose** project in the Web Forms solution</span></span>

<span data-ttu-id="b94f6-186">Çözüm çalıştırmadan önce Windows kapsayıcılar kullanmak için Docker yapılandırma emin olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-186">Before you run the solution, you must make sure that you configure Docker to use Windows Containers.</span></span> <span data-ttu-id="b94f6-187">Bunu yapmak için Docker simgesi Windows seçip sağ tıklatın. **geçiş Windows kapsayıcılara**Şekil 7-4'te gösterildiği gibi.</span><span class="sxs-lookup"><span data-stu-id="b94f6-187">To do that, you right-click the Docker taskbar icon in Windows and select **Switch to Windows Containers**, as shown in Figure 7-4.</span></span>

![](./media/image4.png)

<span data-ttu-id="b94f6-188">**Şekil 7-4**.</span><span class="sxs-lookup"><span data-stu-id="b94f6-188">**Figure 7-4**.</span></span> <span data-ttu-id="b94f6-189">Windows Docker görev simgesinden Windows kapsayıcılara değiştirme</span><span class="sxs-lookup"><span data-stu-id="b94f6-189">Switching to Windows Containers from the Docker taskbar icon in Windows</span></span>

<span data-ttu-id="b94f6-190">Menü öğesi diyorsa **geçiş Linux kapsayıcılara**, Docker ile Windows kapsayıcıları zaten çalışıyor.</span><span class="sxs-lookup"><span data-stu-id="b94f6-190">If the menu item says **Switch to Linux containers**, you are already running Docker with Windows Containers.</span></span>

<span data-ttu-id="b94f6-191">Çözümü çalıştırırken, Docker ana bilgisayarı yeniden başlatır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-191">Running the solution restarts the Docker host.</span></span> <span data-ttu-id="b94f6-192">Oluşturma sırasında uygulama ve Web Forms projesi için Docker görüntü oluşturun.</span><span class="sxs-lookup"><span data-stu-id="b94f6-192">When you build, you build the application and the Docker image for the Web Forms project.</span></span> <span data-ttu-id="b94f6-193">Bunu ilk kez uzun zaman alır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-193">The first time you do this, it takes considerable time.</span></span> <span data-ttu-id="b94f6-194">Derleme işlemi ASP.NET için temel Windows Server görüntüsü ve ek görüntü aşağı çeker olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-194">This is because the build process pulls down the base Windows Server image and the additional image for ASP.NET.</span></span> <span data-ttu-id="b94f6-195">Sonraki derleme ve çalıştırma döngüleri çok daha hızlı olacaktır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-195">Subsequent build and run cycles will be much faster.</span></span>

<span data-ttu-id="b94f6-196">Docker proje şablonu tarafından eklenen dosyalar daha derin bir göz atalım.</span><span class="sxs-lookup"><span data-stu-id="b94f6-196">Let’s take a deeper look at the files added by the Docker project template.</span></span> <span data-ttu-id="b94f6-197">Sizin için birkaç dosyası oluşturuldu.</span><span class="sxs-lookup"><span data-stu-id="b94f6-197">It created several files for you.</span></span> <span data-ttu-id="b94f6-198">Visual Studio Docker görüntüsünü oluşturmak ve bir kapsayıcı başlatmak için bu dosyaları kullanır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-198">Visual Studio uses these files to create the Docker image and launch a container.</span></span> <span data-ttu-id="b94f6-199">Docker komutları el ile çalıştırmak için CLI aynı dosyaları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b94f6-199">You can use the same files from the CLI to run Docker commands manually.</span></span>

<span data-ttu-id="b94f6-200">Aşağıdaki Dockerfile örnek, bir ASP.NET sitesi çalıştıran Windows ASP.NET görüntüyü temel alarak bir Docker görüntüsü oluşturmak için temel ayarlarını gösterir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-200">The following Dockerfile example shows the basic settings for building a Docker image based on the Windows ASP.NET image that runs an ASP.NET site.</span></span>

```
FROM microsoft/aspnet

ARG source

WORKDIR /inetpub/wwwroot

COPY ${source:-obj/Docker/publish} .
```

<span data-ttu-id="b94f6-201">Bu Dockerfile çok benzer bir ASP.NET Core uygulama Linux kapsayıcılarında çalıştırmak için oluşturulan arar.</span><span class="sxs-lookup"><span data-stu-id="b94f6-201">This Dockerfile will look very similar to those created for running an ASP.NET Core application in Linux containers.</span></span> <span data-ttu-id="b94f6-202">Ancak, birkaç önemli farklılıklar vardır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-202">However, there are a few important differences.</span></span> <span data-ttu-id="b94f6-203">En önemli fark temel görüntü .NET Framework içeren geçerli bir Windows Server görüntü olan microsoft/aspnet olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-203">The most important difference is that the base image is microsoft/aspnet, which is the current Windows Server image that includes the .NET Framework.</span></span> <span data-ttu-id="b94f6-204">Diğer farklar kaynak dizininden kopyalanır dizinleri farklı ' dir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-204">Other differences are that the directories copied from your source directory are different.</span></span>

<span data-ttu-id="b94f6-205">Diğer dosyaları **docker-oluşturan** proje olan geliştirmek ve kapsayıcılar yapılandırmak için gereken Docker varlıklar.</span><span class="sxs-lookup"><span data-stu-id="b94f6-205">The other files in the **docker-compose** project are the Docker assets needed to build and configure the containers.</span></span> <span data-ttu-id="b94f6-206">Visual Studio, bunların nasıl kullanıldığı vurgulamak için bir düğümü altındaki çeşitli docker-compose.yml dosyaları yerleştirir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-206">Visual Studio puts the various docker-compose.yml files under one node to highlight how they are used.</span></span> <span data-ttu-id="b94f6-207">Temel docker-compose dosyası tüm yapılandırmalar için ortak olan yönergeleri içerir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-207">The base docker-compose file contains the directives that are common to all configurations.</span></span> <span data-ttu-id="b94f6-208">Ortam değişkenleri ve ilgili geçersiz kılmalar Geliştirici yapılandırması için docker compose.override.yml dosyası içerir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-208">The docker-compose.override.yml file contains environment variables and related overrides for a developer configuration.</span></span> <span data-ttu-id="b94f6-209">Çeşitleri olan. vs.debug ve. vs.release ekleme ve çalışan kapsayıcı yönetmek Visual Studio'nun ortam ayarlarını sağlayın.</span><span class="sxs-lookup"><span data-stu-id="b94f6-209">The variants with .vs.debug and .vs.release provide environment settings that enable Visual Studio to attach to and manage the running container.</span></span>

<span data-ttu-id="b94f6-210">Visual Studio tümleştirmesi çözümünüz için Docker destek ekleyen bir parçası olsa da, ayrıca yapı ve docker kullanarak komut satırından çalıştırma-komutu, önceki bölümlerde anlatıldığı gibi oluşturun.</span><span class="sxs-lookup"><span data-stu-id="b94f6-210">While Visual Studio integration is part of adding Docker support to your solution, you can also build and run from the command line, using the docker-compose up command, as you saw in previous sections.</span></span>

## <a name="getting-data-from-the-existing-catalog-net-core-microservice"></a><span data-ttu-id="b94f6-211">Varolan katalog .NET Core mikro hizmet verileri alma</span><span class="sxs-lookup"><span data-stu-id="b94f6-211">Getting data from the existing catalog .NET Core microservice</span></span>

<span data-ttu-id="b94f6-212">Web Forms uygulamayı sahte veri kullanmak yerine veri almak için eShopOnContainers katalog mikro kullanacak şekilde yapılandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b94f6-212">You can configure the Web Forms application to use the eShopOnContainers catalog microservice to get data instead of using fake data.</span></span> <span data-ttu-id="b94f6-213">Bunu yapmak için web.config dosyasını düzenleyin ve useFake anahtarının değerini false olarak ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="b94f6-213">To do this, you edit the web.config file and set the value of the useFake key to false.</span></span> <span data-ttu-id="b94f6-214">DI kapsayıcı sabit kodlanmış verileri döndürür sınıfı yerine canlı katalog mikro erişen sınıfını kullanır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-214">The DI container will use the class that accesses the live catalog microservice instead of the class that returns the hard-coded data.</span></span> <span data-ttu-id="b94f6-215">Diğer bir kod değişiklikleri gereklidir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-215">No other code changes are needed.</span></span>

<span data-ttu-id="b94f6-216">Canlı Kataloğu hizmetine erişim anlamına güncellemeniz gerekir **docker compose'u** proje Kataloğu hizmet yansıması oluştur ve kataloğu hizmet kapsayıcısı başlatın.</span><span class="sxs-lookup"><span data-stu-id="b94f6-216">Accessing the live catalog service does mean you need to update the **docker-compose** project to build the catalog service image and launch the catalog service container.</span></span> <span data-ttu-id="b94f6-217">Windows CE docker Linux kapsayıcıları ve Windows kapsayıcıları destekler, ancak aynı anda değil.</span><span class="sxs-lookup"><span data-stu-id="b94f6-217">Docker CE for Windows supports both Linux containers and Windows Containers, but not at the same time.</span></span> <span data-ttu-id="b94f6-218">Katalog mikro hizmet çalıştırmak için Windows tabanlı bir kapsayıcı üstünde katalog mikro hizmet çalıştıran bir görüntü oluşturmak gerekir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-218">To run the catalog microservice, you need to build an image that runs the catalog microservice on top of a Windows-based container.</span></span> <span data-ttu-id="b94f6-219">Bu yaklaşım, önceki bölümlerde gördüğünüz daha farklı bir Dockerfile mikro projesi için gerektirir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-219">This approach requires a different Dockerfile for the microservices project than you have seen in earlier sections.</span></span> <span data-ttu-id="b94f6-220">Dockerfile.windows dosyası bir Windows kapsayıcıda çalışır katalog API kapsayıcı görüntü oluşturmak için yapılandırma ayarlarını içerir — örneğin, bir Windows Nano Docker görüntüyü kullanmak için.</span><span class="sxs-lookup"><span data-stu-id="b94f6-220">The Dockerfile.windows file contains the configuration settings to build the catalog API container image so that it runs on a Windows container—for example, to use a Windows Nano Docker image.</span></span>

<span data-ttu-id="b94f6-221">Katalog mikro hizmet üzerinde SQL Server veritabanını kullanır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-221">The catalog microservice relies on the SQL Server database.</span></span> <span data-ttu-id="b94f6-222">Bu nedenle, bir SQL Server Docker Windows tabanlı görüntüsü de kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-222">Therefore, you need to use a Windows-based SQL Server Docker image as well.</span></span>

<span data-ttu-id="b94f6-223">Bu değişikliklerden sonra uygulamayı başlatmak için daha fazla docker-compose proje yapar.</span><span class="sxs-lookup"><span data-stu-id="b94f6-223">After these changes, the docker-compose project does more to start the application.</span></span> <span data-ttu-id="b94f6-224">Projeyi şimdi Windows tabanlı SQL sunucu görüntüsü kullanarak SQL Server başlatır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-224">The project now starts the SQL Server using the Windows based SQL Server image.</span></span> <span data-ttu-id="b94f6-225">Bir Windows kapsayıcısında katalog mikro hizmet başlar.</span><span class="sxs-lookup"><span data-stu-id="b94f6-225">It starts the catalog microservice in a Windows container.</span></span> <span data-ttu-id="b94f6-226">Ve Windows kapsayıcısında Web Forms katalog Düzenleyicisi kapsayıcısı da başlatır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-226">And it starts the Web Forms catalog editor container, also in a Windows container.</span></span> <span data-ttu-id="b94f6-227">Görüntüleri hiçbirini yapı gerekiyorsa, görüntüleri ilk oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="b94f6-227">If any of the images need building, the images are created first.</span></span>

## <a name="development-and-production-environments"></a><span data-ttu-id="b94f6-228">Geliştirme ve üretim ortamları</span><span class="sxs-lookup"><span data-stu-id="b94f6-228">Development and production environments</span></span>

<span data-ttu-id="b94f6-229">Birkaç geliştirme yapılandırması ve üretim yapılandırması arasındaki farklar vardır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-229">There are a couple of differences between the development configuration and a production configuration.</span></span> <span data-ttu-id="b94f6-230">Geliştirme ortamında aynı Docker ana bir parçası olarak Web Forms uygulaması, katalog mikro hizmet ve SQL Server Windows kapsayıcılardaki çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="b94f6-230">In the development environment, you run the Web Forms application, the catalog microservice, and SQL Server in Windows Containers, as part of the same Docker host.</span></span> <span data-ttu-id="b94f6-231">Önceki bölümlerde, Linux tabanlı Docker ana bilgisayardaki diğer .NET Core tabanlı hizmetler aynı Docker ana bilgisayarın SQL Server görüntülerinin dağıtılmış belirtiliyor.</span><span class="sxs-lookup"><span data-stu-id="b94f6-231">In earlier sections, we mentioned SQL Server images deployed in the same Docker host as the other .NET Core-based services on a Linux-based Docker host.</span></span> <span data-ttu-id="b94f6-232">Birden çok mikro aynı Docker ana bilgisayarı (veya küme) çalıştıran avantajı, daha az ağ iletişimi yoktur ve kapsayıcılar arasındaki iletişimi daha düşük gecikme süresine sahip olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-232">The advantage of running the multiple microservices in the same Docker host (or cluster) is that there is less network communication and the communication between containers has lower latency.</span></span>

<span data-ttu-id="b94f6-233">Geliştirme ortamında aynı işletim sisteminde tüm kapsayıcıları çalıştırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b94f6-233">In the development environment, you must run all the containers in the same OS.</span></span> <span data-ttu-id="b94f6-234">Windows CE docker aynı anda çalışan Windows ve Linux tabanlı kapsayıcılar desteklemez.</span><span class="sxs-lookup"><span data-stu-id="b94f6-234">Docker CE for Windows does not support running Windows- and Linux-based containers at the same time.</span></span> <span data-ttu-id="b94f6-235">Üretimde uygulama Linux kapsayıcısında farklı bir üzerinde çalışan katalog mikro hizmet örneği ile iletişim kurabilir Web Forms olması veya tek bir Docker ana bilgisayar (veya küme) Windows kapsayıcısında katalog mikro hizmet çalıştırmak istediğiniz karar verebilirsiniz Docker ana bilgisayar.</span><span class="sxs-lookup"><span data-stu-id="b94f6-235">In production, you can decide if you want to run the catalog microservice in a Windows container in a single Docker host (or cluster), or have the Web Forms application communicate with an instance of the catalog microservice running in a Linux container on a different Docker host.</span></span> <span data-ttu-id="b94f6-236">Bunu nasıl, ağ gecikmesi için en iyi duruma getirmek istediğiniz yere bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-236">It depends on how you want to optimize for network latency.</span></span> <span data-ttu-id="b94f6-237">Çoğu durumda, aynı Docker ana bilgisayar (veya swarm) dağıtım kolaylığı ve düşük iletişim gecikmesi için üzerinde çalışan uygulamalarınızı bağımlı mikro istiyor.</span><span class="sxs-lookup"><span data-stu-id="b94f6-237">In most cases, you want the microservices that your applications depend on running in the same Docker host (or swarm) for ease of deployment and lower communication latency.</span></span> <span data-ttu-id="b94f6-238">Bu yapılandırmalarda mikro hizmet örnekleri ve kalıcı veri depolama için yüksek kullanılabilirlik sunucuları yalnızca pahalı iletişimleri arasındadır.</span><span class="sxs-lookup"><span data-stu-id="b94f6-238">In those configurations, the only costly communications is between the microservice instances and the high-availability servers for the persistent data storage.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="b94f6-239">[Önceki](../net-core-single-containers-linux-windows-server-hosts/index.md)
[sonraki](../multi-container-microservice-net-applications/index.md)</span><span class="sxs-lookup"><span data-stu-id="b94f6-239">[Previous](../net-core-single-containers-linux-windows-server-hosts/index.md)
[Next](../multi-container-microservice-net-applications/index.md)</span></span>

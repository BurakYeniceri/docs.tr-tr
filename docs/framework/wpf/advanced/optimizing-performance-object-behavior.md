---
title: 'Performansı İyileştirme: Nesne Davranışı'
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- user interface virtualization [WPF]
- dependency properties [WPF], performance
- event handlers [WPF]
- object performance considerations [WPF]
- Freezable objects [WPF], performance
ms.assetid: 73aa2f47-1d73-439a-be1f-78dc4ba2b5bd
ms.openlocfilehash: 2e1f56dec87de7a22aa8a0bfefe84222d74ba085
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33549223"
---
# <a name="optimizing-performance-object-behavior"></a><span data-ttu-id="180c4-102">Performansı İyileştirme: Nesne Davranışı</span><span class="sxs-lookup"><span data-stu-id="180c4-102">Optimizing Performance: Object Behavior</span></span>
<span data-ttu-id="180c4-103">İç davranışını anlama [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] nesneleri işlevselliği ve performans arasındaki doğru avantajları yapmanıza yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="180c4-103">Understanding the intrinsic behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] objects will help you make the right tradeoffs between functionality and performance.</span></span>  
  

  
<a name="Not_Removing_Event_Handlers"></a>   
## <a name="not-removing-event-handlers-on-objects-may-keep-objects-alive"></a><span data-ttu-id="180c4-104">Olay işleyicileri nesneler üzerinde nesneleri canlı olabilir</span><span class="sxs-lookup"><span data-stu-id="180c4-104">Not Removing Event Handlers on Objects may Keep Objects Alive</span></span>  
 <span data-ttu-id="180c4-105">Bir nesne, olay geçirdiği temsilci etkili bir şekilde söz konusu nesne başvurusudur.</span><span class="sxs-lookup"><span data-stu-id="180c4-105">The delegate that an object passes to its event is effectively a reference to that object.</span></span> <span data-ttu-id="180c4-106">Bu nedenle, olay işleyicileri nesneleri beklenenden daha uzun canlı tutar.</span><span class="sxs-lookup"><span data-stu-id="180c4-106">Therefore, event handlers can keep objects alive longer than expected.</span></span> <span data-ttu-id="180c4-107">Bir nesnenin olayını dinlemek için kayıtlı olan bir nesnenin temizlenmesini gerçekleştirirken nesneyi serbest bırakmadan önce o temsilciyi kaldırmak için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="180c4-107">When performing clean up of an object that has registered to listen to an object's event, it is essential to remove that delegate before releasing the object.</span></span> <span data-ttu-id="180c4-108">Gereksiz nesneleri canlı tutma uygulamanın bellek kullanımını artırır.</span><span class="sxs-lookup"><span data-stu-id="180c4-108">Keeping unneeded objects alive increases the application's memory usage.</span></span> <span data-ttu-id="180c4-109">Bu, özellikle nesne bir mantıksal ağaç veya görsel ağaç kökü olduğunda geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="180c4-109">This is especially true when the object is the root of a logical tree or a visual tree.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="180c4-110"> Kaynak ve dinleyici arasındaki nesne ömür ilişkilerini izlemenin zor olduğu durumlarda yararlı olabilir olaylar için zayıf olay dinleyici düzenini tanıtır.</span><span class="sxs-lookup"><span data-stu-id="180c4-110"> introduces a weak event listener pattern for events that can be useful in situations where the object lifetime relationships between source and listener are difficult to keep track of.</span></span> <span data-ttu-id="180c4-111">Var olan bazı [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] olayları bu deseni kullanır.</span><span class="sxs-lookup"><span data-stu-id="180c4-111">Some existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] events use this pattern.</span></span> <span data-ttu-id="180c4-112">Özel olaylarla nesneleri uyguluyorsanız, bu deseni size kullanımı olabilir.</span><span class="sxs-lookup"><span data-stu-id="180c4-112">If you are implementing objects with custom events, this pattern may be of use to you.</span></span> <span data-ttu-id="180c4-113">Ayrıntılar için bkz [zayıf olay desenleri](../../../../docs/framework/wpf/advanced/weak-event-patterns.md).</span><span class="sxs-lookup"><span data-stu-id="180c4-113">For details, see [Weak Event Patterns](../../../../docs/framework/wpf/advanced/weak-event-patterns.md).</span></span>  
  
 <span data-ttu-id="180c4-114">CLR Profil Oluşturucu ve çalışma kümesi belirtilen işlemin bellek kullanımı hakkında bilgi sağlayan Görüntüleyicisi, gibi çeşitli araçlar vardır.</span><span class="sxs-lookup"><span data-stu-id="180c4-114">There are several tools, such as the CLR Profiler and the Working Set Viewer, that can provides information on the memory usage of a specified process.</span></span> <span data-ttu-id="180c4-115">CLR Profil oluşturucu ayrılmış türleri, ayırma ve çağrı grafikleri, çöp koleksiyonları çeşitli nesli ve sonra yönetilen yığın sonuç durumunu gösteren bir zaman çizgisi histogram dahil olmak üzere ayırma profil çok kullanışlı görünümlerini içerir Bu koleksiyon ve yöntem başına yüklemeleri ve derleme yüklerini gösteren bir çağrı ağacı.</span><span class="sxs-lookup"><span data-stu-id="180c4-115">The CLR Profiler includes a number of very useful views of the allocation profile, including a histogram of allocated types, allocation and call graphs, a time line showing garbage collections of various generations and the resulting state of the managed heap after those collections, and a call tree showing per-method allocations and assembly loads.</span></span> <span data-ttu-id="180c4-116">Daha fazla bilgi için bkz: [.NET Framework Geliştirici Merkezi](http://go.microsoft.com/fwlink/?LinkId=117435).</span><span class="sxs-lookup"><span data-stu-id="180c4-116">For more information, see [.NET Framework Developer Center](http://go.microsoft.com/fwlink/?LinkId=117435).</span></span>  
  
<a name="DPs_and_Objects"></a>   
## <a name="dependency-properties-and-objects"></a><span data-ttu-id="180c4-117">Bağımlılık özellikleri ve nesneleri</span><span class="sxs-lookup"><span data-stu-id="180c4-117">Dependency Properties and Objects</span></span>  
 <span data-ttu-id="180c4-118">Genel olarak, bir bağımlılık özelliği erişen bir <xref:System.Windows.DependencyObject> erişme daha yavaş değil bir [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] özelliği.</span><span class="sxs-lookup"><span data-stu-id="180c4-118">In general, accessing a dependency property of a <xref:System.Windows.DependencyObject> is not slower than accessing a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] property.</span></span> <span data-ttu-id="180c4-119">Bir özellik değeri ayarlamak için ek yükü küçük bir performans olsa da, bir değer alma değerinden alma olarak hızlı bir [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] özelliği.</span><span class="sxs-lookup"><span data-stu-id="180c4-119">While there is a small performance overhead for setting a property value, getting a value is as fast as getting the value from a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] property.</span></span> <span data-ttu-id="180c4-120">Küçük performansa kaydırma işlemi bağımlılık özellikleri sağlam özellikleri, veri bağlama, animasyon, devralma ve stil gibi destek gerçeğidir.</span><span class="sxs-lookup"><span data-stu-id="180c4-120">Offsetting the small performance overhead is the fact that dependency properties support robust features, such as data binding, animation, inheritance, and styling.</span></span> <span data-ttu-id="180c4-121">Daha fazla bilgi için bkz: [bağımlılık özelliklerine genel bakış](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="180c4-121">For more information, see [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md).</span></span>  
  
### <a name="dependencyproperty-optimizations"></a><span data-ttu-id="180c4-122">DependencyProperty iyileştirmeleri</span><span class="sxs-lookup"><span data-stu-id="180c4-122">DependencyProperty Optimizations</span></span>  
 <span data-ttu-id="180c4-123">Uygulamanızda, bağımlılık özellikleri'ni dikkatle tanımlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="180c4-123">You should define dependency properties in your application very carefully.</span></span> <span data-ttu-id="180c4-124">Varsa, <xref:System.Windows.DependencyProperty> etkiler, yalnızca işleme diğer meta veri seçenekleri yerine türü meta veri seçeneklerini gibi <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, bu nedenle, meta verileri geçersiz kılarak işaretlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="180c4-124">If your <xref:System.Windows.DependencyProperty> affects only render type metadata options, rather than other metadata options such as <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, you should mark it as such by overriding its metadata.</span></span> <span data-ttu-id="180c4-125">Geçersiz kılma veya özellik meta verileri alma hakkında daha fazla bilgi için bkz: [bağımlılık özelliği meta verileri](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="180c4-125">For more information about overriding or obtaining property metadata, see [Dependency Property Metadata](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md).</span></span>  
  
 <span data-ttu-id="180c4-126">Ölçüyü geçersiz kılması, düzenlemek ve geçişleri el ile işleme bir özellik değişikliği işleyiciye sahip daha etkili olabilir değilse tüm özellik değişikliklerini gerçekte ölçü etkiler, düzenlemek ve işlenemiyor.</span><span class="sxs-lookup"><span data-stu-id="180c4-126">It may be more efficient to have a property change handler invalidate the measure, arrange, and render passes manually if not all property changes actually affect measure, arrange, and render.</span></span> <span data-ttu-id="180c4-127">Örneğin, yalnızca bir değer kümesi sınırdan daha büyük olduğunda bir arka plan yeniden işlemek karar verebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="180c4-127">For instance, you might decide to re-render a background only when a value is greater than a set limit.</span></span> <span data-ttu-id="180c4-128">Bu durumda, değeri kümesi sınırını aşarsa, özellik değiştirme işleyicisi yalnızca işlemeyi geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="180c4-128">In this case, your property change handler would only invalidate render when the value exceeds the set limit.</span></span>  
  
### <a name="making-a-dependencyproperty-inheritable-is-not-free"></a><span data-ttu-id="180c4-129">DependencyProperty'yi Devralınabilir yapmak uygun değildir</span><span class="sxs-lookup"><span data-stu-id="180c4-129">Making a DependencyProperty Inheritable is Not Free</span></span>  
 <span data-ttu-id="180c4-130">Varsayılan olarak, kayıtlı bağımlılık devralınabilir olmayan özelliklerdir.</span><span class="sxs-lookup"><span data-stu-id="180c4-130">By default, registered dependency properties are non-inheritable.</span></span> <span data-ttu-id="180c4-131">Ancak, siz açıkça herhangi bir özelliği devralınabilir yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="180c4-131">However, you can explicitly make any property inheritable.</span></span> <span data-ttu-id="180c4-132">Bu yararlı bir özellik olsa da, bir özellik devralınabilir dönüştürme özelliği geçersiz kılma süreyi artırarak performansını etkiler.</span><span class="sxs-lookup"><span data-stu-id="180c4-132">While this is a useful feature, converting a property to be inheritable impacts performance by increasing the length of time for property invalidation.</span></span>  
  
### <a name="use-registerclasshandler-carefully"></a><span data-ttu-id="180c4-133">RegisterClassHandler'ı dikkatli kullanın</span><span class="sxs-lookup"><span data-stu-id="180c4-133">Use RegisterClassHandler Carefully</span></span>  
 <span data-ttu-id="180c4-134">Arama sırasında <xref:System.Windows.EventManager.RegisterClassHandler%2A> , örnek durumu kaydetmenize olanak tanır işleyicisi performans sorunlarına neden olabilir her örneğinde çağrılır bilmeniz önemlidir.</span><span class="sxs-lookup"><span data-stu-id="180c4-134">While calling <xref:System.Windows.EventManager.RegisterClassHandler%2A> allows you to save your instance state, it is important to be aware that the handler is called on every instance, which can cause performance problems.</span></span> <span data-ttu-id="180c4-135">Yalnızca <xref:System.Windows.EventManager.RegisterClassHandler%2A> zaman uygulamanızın gerektirdiği, örnek durumu kaydedin.</span><span class="sxs-lookup"><span data-stu-id="180c4-135">Only use <xref:System.Windows.EventManager.RegisterClassHandler%2A> when your application requires that you save your instance state.</span></span>  
  
### <a name="set-the-default-value-for-a-dependencyproperty-during-registration"></a><span data-ttu-id="180c4-136">Kayıt sırasında DependencyProperty'yi Varsayılan değeri ayarlanamıyor</span><span class="sxs-lookup"><span data-stu-id="180c4-136">Set the Default Value for a DependencyProperty during Registration</span></span>  
 <span data-ttu-id="180c4-137">Oluştururken bir <xref:System.Windows.DependencyProperty> varsayılan bir değer gerektiren, bir parametre olarak geçirilen varsayılan meta verileri kullanarak değerini ayarlama <xref:System.Windows.DependencyProperty.Register%2A> yöntemi <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="180c4-137">When creating a <xref:System.Windows.DependencyProperty> that requires a default value, set the value using the default metadata passed as a parameter to the <xref:System.Windows.DependencyProperty.Register%2A> method of the <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="180c4-138">Özellik değeri bir oluşturucuda veya bir öğenin her bir örneğinde ayarlamak yerine bu yöntemi kullanın.</span><span class="sxs-lookup"><span data-stu-id="180c4-138">Use this technique rather than setting the property value in a constructor or on each instance of an element.</span></span>  
  
### <a name="set-the-propertymetadata-value-using-register"></a><span data-ttu-id="180c4-139">Yazmaç Kullanarak PropertyMetadata değerini ayarla</span><span class="sxs-lookup"><span data-stu-id="180c4-139">Set the PropertyMetadata Value using Register</span></span>  
 <span data-ttu-id="180c4-140">Oluştururken bir <xref:System.Windows.DependencyProperty>, ayarı seçeneğiniz <xref:System.Windows.PropertyMetadata> kullanarak <xref:System.Windows.DependencyProperty.Register%2A> veya <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="180c4-140">When creating a <xref:System.Windows.DependencyProperty>, you have the option of setting the <xref:System.Windows.PropertyMetadata> using either the <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> methods.</span></span> <span data-ttu-id="180c4-141">Nesnenizin çağırmak için statik bir oluşturucuya sahip olabilir ancak <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, bu en iyi çözüm değildir ve performansını etkiler.</span><span class="sxs-lookup"><span data-stu-id="180c4-141">Although your object could have a static constructor to call <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, this is not the optimal solution and will impact performance.</span></span> <span data-ttu-id="180c4-142">En iyi performans için ayarlanmış <xref:System.Windows.PropertyMetadata> çağrı sırasında <xref:System.Windows.DependencyProperty.Register%2A>.</span><span class="sxs-lookup"><span data-stu-id="180c4-142">For best performance, set the <xref:System.Windows.PropertyMetadata> during the call to <xref:System.Windows.DependencyProperty.Register%2A>.</span></span>  
  
<a name="Freezable_Objects"></a>   
## <a name="freezable-objects"></a><span data-ttu-id="180c4-143">Freezable nesneleri</span><span class="sxs-lookup"><span data-stu-id="180c4-143">Freezable Objects</span></span>  
 <span data-ttu-id="180c4-144">A <xref:System.Windows.Freezable> , iki durumlu sahip bir nesne özel bir tür: çözülmüş ve dondurulmuş.</span><span class="sxs-lookup"><span data-stu-id="180c4-144">A <xref:System.Windows.Freezable> is a special type of object that has two states: unfrozen and frozen.</span></span> <span data-ttu-id="180c4-145">Nesneleri olabildiğince dondurmak, uygulamanızın performansını artırır ve kendi çalışma kümesinin azaltır.</span><span class="sxs-lookup"><span data-stu-id="180c4-145">Freezing objects whenever possible improves the performance of your application and reduces its working set.</span></span> <span data-ttu-id="180c4-146">Daha fazla bilgi için bkz: [Freezable nesnelere genel bakış](../../../../docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="180c4-146">For more information, see [Freezable Objects Overview](../../../../docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>  
  
 <span data-ttu-id="180c4-147">Her <xref:System.Windows.Freezable> sahip bir <xref:System.Windows.Freezable.Changed> değiştiğinde olayı.</span><span class="sxs-lookup"><span data-stu-id="180c4-147">Each <xref:System.Windows.Freezable> has a <xref:System.Windows.Freezable.Changed> event that is raised whenever it changes.</span></span> <span data-ttu-id="180c4-148">Ancak, değişiklik bildirimleri uygulama performans açısından maliyetlidir.</span><span class="sxs-lookup"><span data-stu-id="180c4-148">However, change notifications are costly in terms of application performance.</span></span>  
  
 <span data-ttu-id="180c4-149">Aşağıdaki örnek her göz önünde bulundurun <xref:System.Windows.Shapes.Rectangle> aynı kullanan <xref:System.Windows.Media.Brush> nesnesi:</span><span class="sxs-lookup"><span data-stu-id="180c4-149">Consider the following example in which each <xref:System.Windows.Shapes.Rectangle> uses the same <xref:System.Windows.Media.Brush> object:</span></span>  
  
 [!code-csharp[Performance#PerformanceSnippet2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet2)]
 [!code-vb[Performance#PerformanceSnippet2](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet2)]  
  
 <span data-ttu-id="180c4-150">Varsayılan olarak, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] bir olay işleyicisi sağlar <xref:System.Windows.Media.SolidColorBrush> nesnenin <xref:System.Windows.Freezable.Changed> geçersiz kılmak için olay <xref:System.Windows.Shapes.Rectangle> nesnenin <xref:System.Windows.Shapes.Shape.Fill%2A> özelliği.</span><span class="sxs-lookup"><span data-stu-id="180c4-150">By default, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provides an event handler for the <xref:System.Windows.Media.SolidColorBrush> object's <xref:System.Windows.Freezable.Changed> event in order to invalidate the <xref:System.Windows.Shapes.Rectangle> object's <xref:System.Windows.Shapes.Shape.Fill%2A> property.</span></span> <span data-ttu-id="180c4-151">Bu durumda, her zaman <xref:System.Windows.Media.SolidColorBrush> tetiklenecek olan kendi <xref:System.Windows.Freezable.Changed> gerekli her biri için geri çağırma işlevi çağırmak için olay <xref:System.Windows.Shapes.Rectangle>— bu geri çağırma işlevi etkinleştirmeleri toplamı zorunlu tuttukları önemli bir performans sorunu.</span><span class="sxs-lookup"><span data-stu-id="180c4-151">In this case, each time the <xref:System.Windows.Media.SolidColorBrush> has to fire its <xref:System.Windows.Freezable.Changed> event it is required to invoke the callback function for each <xref:System.Windows.Shapes.Rectangle>—the accumulation of these callback function invocations impose a significant performance penalty.</span></span> <span data-ttu-id="180c4-152">Ayrıca, çok performans eklemek ve uygulamanın bunu yapmak için listenin tamamını gezinmesine olacağından işleyicileri bu noktada kaldırmak için yoğun olur.</span><span class="sxs-lookup"><span data-stu-id="180c4-152">In addition, it is very performance intensive to add and remove handlers at this point since the application would have to traverse the entire list to do so.</span></span> <span data-ttu-id="180c4-153">Uygulama senaryonuz hiçbir zaman değişirse <xref:System.Windows.Media.SolidColorBrush>, bakım maliyetini ödeme <xref:System.Windows.Freezable.Changed> olay işleyicileri gereksiz yere.</span><span class="sxs-lookup"><span data-stu-id="180c4-153">If your application scenario never changes the <xref:System.Windows.Media.SolidColorBrush>, you will be paying the cost of maintaining <xref:System.Windows.Freezable.Changed> event handlers unnecessarily.</span></span>  
  
 <span data-ttu-id="180c4-154">Dondurma bir <xref:System.Windows.Freezable> , artık bildirimleri değiştirmeyi korumada kaynakları harcaması gerektiğinden kendi performansını iyileştirebilir.</span><span class="sxs-lookup"><span data-stu-id="180c4-154">Freezing a <xref:System.Windows.Freezable> can improve its performance, because it no longer needs to expend resources on maintaining change notifications.</span></span> <span data-ttu-id="180c4-155">Aşağıdaki tabloda, basit bir boyutunu gösterilmektedir <xref:System.Windows.Media.SolidColorBrush> zaman kendi <xref:System.Windows.Freezable.IsFrozen%2A> özelliği ayarlanmış `true`, olmadığı karşılaştırıldığında.</span><span class="sxs-lookup"><span data-stu-id="180c4-155">The table below shows the size of a simple <xref:System.Windows.Media.SolidColorBrush> when its <xref:System.Windows.Freezable.IsFrozen%2A> property is set to `true`, compared to when it is not.</span></span> <span data-ttu-id="180c4-156">Bu uygulama için bir fırça varsayar <xref:System.Windows.Shapes.Shape.Fill%2A> on özelliğinin <xref:System.Windows.Shapes.Rectangle> nesneleri.</span><span class="sxs-lookup"><span data-stu-id="180c4-156">This assumes applying one brush to the <xref:System.Windows.Shapes.Shape.Fill%2A> property of ten <xref:System.Windows.Shapes.Rectangle> objects.</span></span>  
  
|<span data-ttu-id="180c4-157">**Durum**</span><span class="sxs-lookup"><span data-stu-id="180c4-157">**State**</span></span>|<span data-ttu-id="180c4-158">**Boyutu**</span><span class="sxs-lookup"><span data-stu-id="180c4-158">**Size**</span></span>|  
|---------------|--------------|  
|<span data-ttu-id="180c4-159">Dondurulmuş <xref:System.Windows.Media.SolidColorBrush></span><span class="sxs-lookup"><span data-stu-id="180c4-159">Frozen <xref:System.Windows.Media.SolidColorBrush></span></span>|<span data-ttu-id="180c4-160">212 bayt</span><span class="sxs-lookup"><span data-stu-id="180c4-160">212 Bytes</span></span>|  
|<span data-ttu-id="180c4-161">Olmayan dondurulmuş <xref:System.Windows.Media.SolidColorBrush></span><span class="sxs-lookup"><span data-stu-id="180c4-161">Non-frozen <xref:System.Windows.Media.SolidColorBrush></span></span>|<span data-ttu-id="180c4-162">972 bayt</span><span class="sxs-lookup"><span data-stu-id="180c4-162">972 Bytes</span></span>|  
  
 <span data-ttu-id="180c4-163">Aşağıdaki kod örneği, bu kavramı gösterir:</span><span class="sxs-lookup"><span data-stu-id="180c4-163">The following code sample demonstrates this concept:</span></span>  
  
 [!code-csharp[Performance#PerformanceSnippet3](../../../../samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet3)]
 [!code-vb[Performance#PerformanceSnippet3](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet3)]  
  
### <a name="changed-handlers-on-unfrozen-freezables-may-keep-objects-alive"></a><span data-ttu-id="180c4-164">Çözülmüş Freezables üzerinde değiştirilen işleyiciler nesneleri canlı olabilir</span><span class="sxs-lookup"><span data-stu-id="180c4-164">Changed Handlers on Unfrozen Freezables may Keep Objects Alive</span></span>  
 <span data-ttu-id="180c4-165">Bir nesne geçirir temsilci bir <xref:System.Windows.Freezable> nesnenin <xref:System.Windows.Freezable.Changed> olaydır etkili bir şekilde bu nesneye bir başvurusu.</span><span class="sxs-lookup"><span data-stu-id="180c4-165">The delegate that an object passes to a <xref:System.Windows.Freezable> object's <xref:System.Windows.Freezable.Changed> event is effectively a reference to that object.</span></span> <span data-ttu-id="180c4-166">Bu nedenle, <xref:System.Windows.Freezable.Changed> olay işleyicileri etkin tutma nesneleri beklenenden daha uzun.</span><span class="sxs-lookup"><span data-stu-id="180c4-166">Therefore, <xref:System.Windows.Freezable.Changed> event handlers can keep objects alive longer than expected.</span></span> <span data-ttu-id="180c4-167">Temizleme dinlemek için kayıtlı olan bir nesnenin gerçekleştirirken bir <xref:System.Windows.Freezable> nesnenin <xref:System.Windows.Freezable.Changed> olay, bu nesne serbest bırakmadan önce bu temsilciyi kaldırmak için gerekli.</span><span class="sxs-lookup"><span data-stu-id="180c4-167">When performing clean up of an object that has registered to listen to a <xref:System.Windows.Freezable> object's <xref:System.Windows.Freezable.Changed> event, it is essential to remove that delegate before releasing the object.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="180c4-168"> Ayrıca <xref:System.Windows.Freezable.Changed> olayları dahili olarak.</span><span class="sxs-lookup"><span data-stu-id="180c4-168"> also hooks up <xref:System.Windows.Freezable.Changed> events internally.</span></span> <span data-ttu-id="180c4-169">Örneğin, ele tüm bağımlılık özellikleri <xref:System.Windows.Freezable> için bir değer dinleyecek şekilde <xref:System.Windows.Freezable.Changed> olayları otomatik olarak.</span><span class="sxs-lookup"><span data-stu-id="180c4-169">For example, all dependency properties which take <xref:System.Windows.Freezable> as a value will listen to <xref:System.Windows.Freezable.Changed> events automatically.</span></span> <span data-ttu-id="180c4-170"><xref:System.Windows.Shapes.Shape.Fill%2A> Geçen özelliği bir <xref:System.Windows.Media.Brush>, bu kavramı gösterir.</span><span class="sxs-lookup"><span data-stu-id="180c4-170">The <xref:System.Windows.Shapes.Shape.Fill%2A> property, which takes a <xref:System.Windows.Media.Brush>, illustrates this concept.</span></span>  
  
 [!code-csharp[Performance#PerformanceSnippet4](../../../../samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet4)]
 [!code-vb[Performance#PerformanceSnippet4](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet4)]  
  
 <span data-ttu-id="180c4-171">' In `myBrush` için `myRectangle.Fill`, geri işaret eden bir temsilci <xref:System.Windows.Shapes.Rectangle> nesne eklenir <xref:System.Windows.Media.SolidColorBrush> nesnenin <xref:System.Windows.Freezable.Changed> olay.</span><span class="sxs-lookup"><span data-stu-id="180c4-171">On the assignment of `myBrush` to `myRectangle.Fill`, a delegate pointing back to the <xref:System.Windows.Shapes.Rectangle> object will be added to the <xref:System.Windows.Media.SolidColorBrush> object's <xref:System.Windows.Freezable.Changed> event.</span></span> <span data-ttu-id="180c4-172">Aşağıdaki kod gerçekte yapmaz yani `myRect` çöp toplama için uygun:</span><span class="sxs-lookup"><span data-stu-id="180c4-172">This means the following code does not actually make `myRect` eligible for garbage collection:</span></span>  
  
 [!code-csharp[Performance#PerformanceSnippet5](../../../../samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet5)]
 [!code-vb[Performance#PerformanceSnippet5](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet5)]  
  
 <span data-ttu-id="180c4-173">Bu durumda `myBrush` devam etmenize `myRectangle` canlı ve onu başlatıldığında geri kendisine çağırır kendi <xref:System.Windows.Freezable.Changed> olay.</span><span class="sxs-lookup"><span data-stu-id="180c4-173">In this case `myBrush` is still keeping `myRectangle` alive and will call back to it when it fires its <xref:System.Windows.Freezable.Changed> event.</span></span> <span data-ttu-id="180c4-174">Bu atama Not `myBrush` için <xref:System.Windows.Shapes.Shape.Fill%2A> yeni bir özellik <xref:System.Windows.Shapes.Rectangle> yalnızca başka bir olay işleyicisine ekleyecek `myBrush`.</span><span class="sxs-lookup"><span data-stu-id="180c4-174">Note that assigning `myBrush` to the <xref:System.Windows.Shapes.Shape.Fill%2A> property of a new <xref:System.Windows.Shapes.Rectangle> will simply add another event handler to `myBrush`.</span></span>  
  
 <span data-ttu-id="180c4-175">Bu tür nesneleri temizlemek için önerilen yol kaldırmaktır <xref:System.Windows.Media.Brush> gelen <xref:System.Windows.Shapes.Shape.Fill%2A> sırayla kaldıracak özelliği <xref:System.Windows.Freezable.Changed> olay işleyicisi.</span><span class="sxs-lookup"><span data-stu-id="180c4-175">The recommended way to clean up these types of objects is to remove the <xref:System.Windows.Media.Brush> from the <xref:System.Windows.Shapes.Shape.Fill%2A> property, which will in turn remove the <xref:System.Windows.Freezable.Changed> event handler.</span></span>  
  
 [!code-csharp[Performance#PerformanceSnippet6](../../../../samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet6)]
 [!code-vb[Performance#PerformanceSnippet6](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet6)]  
  
<a name="User_Interface_Virtualization"></a>   
## <a name="user-interface-virtualization"></a><span data-ttu-id="180c4-176">Kullanıcı arabirimi sanallaştırma</span><span class="sxs-lookup"><span data-stu-id="180c4-176">User Interface Virtualization</span></span>  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="180c4-177"> Ayrıca bir çeşitlemesi sağlar <xref:System.Windows.Controls.StackPanel> otomatik olarak "veri bağlama alt içeriğini sanallaştıran" öğesi.</span><span class="sxs-lookup"><span data-stu-id="180c4-177"> also provides a variation of the <xref:System.Windows.Controls.StackPanel> element that automatically "virtualizes" data-bound child content.</span></span> <span data-ttu-id="180c4-178">Bu bağlamda word sanallaştırmak olarak bir alt nesnelerinin oluşturulduğu çok sayıda veri öğeleri hangi öğelerin ekranda görülebilir olduğuna dayalı bir tekniği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="180c4-178">In this context, the word virtualize refers to a technique by which a subset of objects are generated from a larger number of data items based upon which items are visible on-screen.</span></span> <span data-ttu-id="180c4-179">Hem bellek ve sadece birkaç ekranda belirli bir zamanda olabilir, çok sayıda kullanıcı Arabirimi öğeleri oluşturmak için işlemci bakımından yoğun.</span><span class="sxs-lookup"><span data-stu-id="180c4-179">It is intensive, both in terms of memory and processor, to generate a large number of UI elements when only a few may be on the screen at a given time.</span></span> <span data-ttu-id="180c4-180"><xref:System.Windows.Controls.VirtualizingStackPanel> (tarafından sağlanan işlevsellik aracılığıyla <xref:System.Windows.Controls.VirtualizingPanel>) görünen öğeleri hesaplar ve birlikte çalıştığı <xref:System.Windows.Controls.ItemContainerGenerator> gelen bir <xref:System.Windows.Controls.ItemsControl> (gibi <xref:System.Windows.Controls.ListBox> veya <xref:System.Windows.Controls.ListView>) yalnızca görünür öğeler için oluşturmak için.</span><span class="sxs-lookup"><span data-stu-id="180c4-180"><xref:System.Windows.Controls.VirtualizingStackPanel> (through functionality provided by <xref:System.Windows.Controls.VirtualizingPanel>) calculates visible items and works with the <xref:System.Windows.Controls.ItemContainerGenerator> from an <xref:System.Windows.Controls.ItemsControl> (such as <xref:System.Windows.Controls.ListBox> or <xref:System.Windows.Controls.ListView>) to only create elements for visible items.</span></span>  
  
 <span data-ttu-id="180c4-181">Performansı iyileştirme bu öğeler için görsel nesneler yalnızca oluşturulan veya ekranda görünür durumdaysa Canlı tutulur.</span><span class="sxs-lookup"><span data-stu-id="180c4-181">As a performance optimization, visual objects for these items are only generated or kept alive if they are visible on the screen.</span></span> <span data-ttu-id="180c4-182">Artık denetimin görüntülenebilir alanında olduklarında, görsel nesneler kaldırılabilir.</span><span class="sxs-lookup"><span data-stu-id="180c4-182">When they are no longer in the viewable area of the control, the visual objects may be removed.</span></span> <span data-ttu-id="180c4-183">Burada veri nesneleri yerel koleksiyon yerine gerektiği gibi akışla-tüm mevcut olmayan veri sanallaştırma ile karıştırılmamalıdır budur.</span><span class="sxs-lookup"><span data-stu-id="180c4-183">This is not to be confused with data virtualization, where data objects are not all present in the local collection- rather streamed in as needed.</span></span>  
  
 <span data-ttu-id="180c4-184">Aşağıdaki tabloda, ekleme ve 5000 işleme süre gösterilmektedir <xref:System.Windows.Controls.TextBlock> öğelerine bir <xref:System.Windows.Controls.StackPanel> ve <xref:System.Windows.Controls.VirtualizingStackPanel>.</span><span class="sxs-lookup"><span data-stu-id="180c4-184">The table below shows the elapsed time adding and rendering 5000 <xref:System.Windows.Controls.TextBlock> elements to a <xref:System.Windows.Controls.StackPanel> and a <xref:System.Windows.Controls.VirtualizingStackPanel>.</span></span> <span data-ttu-id="180c4-185">Bu senaryoda, bir metin dizesi ekleme arasında geçen zamanı ölçümleri temsil <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> özelliği bir <xref:System.Windows.Controls.ItemsControl> panel öğelerinin metin dizesini görüntülediğinizde zamana nesnesi.</span><span class="sxs-lookup"><span data-stu-id="180c4-185">In this scenario, the measurements represent the time between attaching a text string to the <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> property of an <xref:System.Windows.Controls.ItemsControl> object to the time when the panel elements display the text string.</span></span>  
  
|<span data-ttu-id="180c4-186">**Konak paneli**</span><span class="sxs-lookup"><span data-stu-id="180c4-186">**Host panel**</span></span>|<span data-ttu-id="180c4-187">**İşleme süresi (ms)**</span><span class="sxs-lookup"><span data-stu-id="180c4-187">**Render time (ms)**</span></span>|  
|--------------------|----------------------------|  
|<xref:System.Windows.Controls.StackPanel>|<span data-ttu-id="180c4-188">3210</span><span class="sxs-lookup"><span data-stu-id="180c4-188">3210</span></span>|  
|<xref:System.Windows.Controls.VirtualizingStackPanel>|<span data-ttu-id="180c4-189">46</span><span class="sxs-lookup"><span data-stu-id="180c4-189">46</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="180c4-190">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="180c4-190">See Also</span></span>  
 [<span data-ttu-id="180c4-191">WPF Uygulama Performansını İyileştirme</span><span class="sxs-lookup"><span data-stu-id="180c4-191">Optimizing WPF Application Performance</span></span>](../../../../docs/framework/wpf/advanced/optimizing-wpf-application-performance.md)  
 [<span data-ttu-id="180c4-192">Uygulama Performansını Planlama</span><span class="sxs-lookup"><span data-stu-id="180c4-192">Planning for Application Performance</span></span>](../../../../docs/framework/wpf/advanced/planning-for-application-performance.md)  
 [<span data-ttu-id="180c4-193">Donanımdan Yararlanma</span><span class="sxs-lookup"><span data-stu-id="180c4-193">Taking Advantage of Hardware</span></span>](../../../../docs/framework/wpf/advanced/optimizing-performance-taking-advantage-of-hardware.md)  
 [<span data-ttu-id="180c4-194">Düzen ve Tasarım</span><span class="sxs-lookup"><span data-stu-id="180c4-194">Layout and Design</span></span>](../../../../docs/framework/wpf/advanced/optimizing-performance-layout-and-design.md)  
 [<span data-ttu-id="180c4-195">2B Grafikleri ve Görüntüleme</span><span class="sxs-lookup"><span data-stu-id="180c4-195">2D Graphics and Imaging</span></span>](../../../../docs/framework/wpf/advanced/optimizing-performance-2d-graphics-and-imaging.md)  
 [<span data-ttu-id="180c4-196">Uygulama Kaynakları</span><span class="sxs-lookup"><span data-stu-id="180c4-196">Application Resources</span></span>](../../../../docs/framework/wpf/advanced/optimizing-performance-application-resources.md)  
 [<span data-ttu-id="180c4-197">Metin</span><span class="sxs-lookup"><span data-stu-id="180c4-197">Text</span></span>](../../../../docs/framework/wpf/advanced/optimizing-performance-text.md)  
 [<span data-ttu-id="180c4-198">Veri Bağlama</span><span class="sxs-lookup"><span data-stu-id="180c4-198">Data Binding</span></span>](../../../../docs/framework/wpf/advanced/optimizing-performance-data-binding.md)  
 [<span data-ttu-id="180c4-199">Diğer Performans Önerileri</span><span class="sxs-lookup"><span data-stu-id="180c4-199">Other Performance Recommendations</span></span>](../../../../docs/framework/wpf/advanced/optimizing-performance-other-recommendations.md)

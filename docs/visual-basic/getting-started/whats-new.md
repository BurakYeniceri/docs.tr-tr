---
title: Visual Basic for yenilikler nelerdir?
ms.date: 02/15/2018
ms.prod: .net
ms.technology:
- devlang-visual-basic
ms.topic: article
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
caps.latest.revision: 
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 4df9a34e078de9daeff85c894afbbf4d60501f6b
ms.sourcegitcommit: 96cc82cac4650adfb65ba351506d8a8fbcd17b5c
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/19/2018
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="8dd54-102">Visual Basic for yenilikler nelerdir?</span><span class="sxs-lookup"><span data-stu-id="8dd54-102">What's new for Visual Basic</span></span>

<span data-ttu-id="8dd54-103">Bu konu, her sürümüyle Visual Basic Dil en son sürümündeki yeni ve geliştirilmiş özelliklerine ayrıntılı açıklamaları için anahtar özellik adlarını listeler.</span><span class="sxs-lookup"><span data-stu-id="8dd54-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the lastest version of the language.</span></span>
  
## <a name="current-version"></a><span data-ttu-id="8dd54-104">Geçerli Sürüm</span><span class="sxs-lookup"><span data-stu-id="8dd54-104">Current Version</span></span>

<span data-ttu-id="8dd54-105">Visual Basic 15,5</span><span class="sxs-lookup"><span data-stu-id="8dd54-105">Visual Basic 15.5</span></span>   
<span data-ttu-id="8dd54-106">Yeni özellikler için bkz: [Visual Basic 15,5](#visual-basic-155)</span><span class="sxs-lookup"><span data-stu-id="8dd54-106">For new features, see [Visual Basic 15.5](#visual-basic-155)</span></span>

## <a name="previous-versions"></a><span data-ttu-id="8dd54-107">Önceki sürümler</span><span class="sxs-lookup"><span data-stu-id="8dd54-107">Previous versions</span></span>

<span data-ttu-id="8dd54-108">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="8dd54-108">Visual Basic 15.3</span></span>   
<span data-ttu-id="8dd54-109">Yeni özellikler için bkz: [Visual Basic 15.3](#visual-basic-153)</span><span class="sxs-lookup"><span data-stu-id="8dd54-109">For new features, see [Visual Basic 15.3](#visual-basic-153)</span></span>

<span data-ttu-id="8dd54-110">Visual Basic / Visual Studio .NET 2015</span><span class="sxs-lookup"><span data-stu-id="8dd54-110">Visual Basic / Visual Studio .NET 2015</span></span>   
<span data-ttu-id="8dd54-111">Yeni özellikler için bkz: [Visual Basic 14](#visual-basic-14)</span><span class="sxs-lookup"><span data-stu-id="8dd54-111">For new features, see [Visual Basic 14](#visual-basic-14)</span></span>

<span data-ttu-id="8dd54-112">Visual Basic / Visual Studio .NET 2013</span><span class="sxs-lookup"><span data-stu-id="8dd54-112">Visual Basic / Visual Studio .NET 2013</span></span>  
<span data-ttu-id="8dd54-113">.NET derleme Platformu ("Roslyn") teknolojisi önizlemeleri</span><span class="sxs-lookup"><span data-stu-id="8dd54-113">Technology previews of the .NET Compiler Platform (“Roslyn”)</span></span>

<span data-ttu-id="8dd54-114">Visual Basic / Visual Studio .NET 2012</span><span class="sxs-lookup"><span data-stu-id="8dd54-114">Visual Basic / Visual Studio .NET 2012</span></span>   
<span data-ttu-id="8dd54-115">`Async` ve `await` anahtar sözcükler, yineleyiciler, arayan bilgileri öznitelikleri</span><span class="sxs-lookup"><span data-stu-id="8dd54-115">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="8dd54-116">Visual Basic, Visual Studio .NET 2010</span><span class="sxs-lookup"><span data-stu-id="8dd54-116">Visual Basic, Visual Studio .NET 2010</span></span>   
<span data-ttu-id="8dd54-117">Otomatik uygulanan özellikler, koleksiyon başlatıcıları, örtük satır devamlılığı, dinamik, genel co/karşıt fark, genel ad alanı erişim</span><span class="sxs-lookup"><span data-stu-id="8dd54-117">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="8dd54-118">Visual Basic / Visual Studio .NET 2008</span><span class="sxs-lookup"><span data-stu-id="8dd54-118">Visual Basic / Visual Studio .NET 2008</span></span>   
<span data-ttu-id="8dd54-119">Dil tümleşik sorgu (LINQ), XML değişmez değerleri, yerel türü çıkarımı nesne başlatıcılar, anonim türler, genişletme yöntemleri, yerel `var` yazın çıkarım, lambda ifadeleri `if` işleci, kısmi yöntemler, boş değer atanabilen değer türleri</span><span class="sxs-lookup"><span data-stu-id="8dd54-119">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>  

<span data-ttu-id="8dd54-120">Visual Basic / Visual Studio .NET 2005</span><span class="sxs-lookup"><span data-stu-id="8dd54-120">Visual Basic / Visual Studio .NET 2005</span></span>   
<span data-ttu-id="8dd54-121">`My` Türü ve yardımcı türleri (uygulama, bilgisayar, dosya sistemi, ağ erişimi)</span><span class="sxs-lookup"><span data-stu-id="8dd54-121">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="8dd54-122">Visual Basic / Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="8dd54-122">Visual Basic / Visual Studio .NET 2003</span></span>   
<span data-ttu-id="8dd54-123">Bit kaydırma işleçleri, döngü değişken bildirimi</span><span class="sxs-lookup"><span data-stu-id="8dd54-123">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="8dd54-124">Visual Basic / Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="8dd54-124">Visual Basic / Visual Studio .NET 2002</span></span>   
<span data-ttu-id="8dd54-125">Visual Basic .NET'in ilk sürümü</span><span class="sxs-lookup"><span data-stu-id="8dd54-125">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="8dd54-126">Visual Basic 15,5</span><span class="sxs-lookup"><span data-stu-id="8dd54-126">Visual Basic 15.5</span></span>

[<span data-ttu-id="8dd54-127">Olmayan sondaki-adlandırılmış bağımsız değişkenler</span><span class="sxs-lookup"><span data-stu-id="8dd54-127">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="8dd54-128">Bağımsız değişkenler hem konuma ve ada göre bir yöntem çağrısı dahil olduğunda Visual Basic 15.3 ve önceki sürümlerinde konumsal bağımsız değişkenleri adlandırılmış bağımsız değişkenler koyun gerekiyordu.</span><span class="sxs-lookup"><span data-stu-id="8dd54-128">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="8dd54-129">Visual Basic 15,5 ile başlayarak, doğru konumda son konumsal bağımsız değişken kadar tüm bağımsız değişkenler sürece konumsal ve adlandırılmış bağımsız değişkenler herhangi bir sırada görünebilir.</span><span class="sxs-lookup"><span data-stu-id="8dd54-129">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="8dd54-130">Adlandırılmış bağımsız değişkenler kodunu daha okunabilir hale getirmek için kullanıldığında, bu seçenek özellikle yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="8dd54-130">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="8dd54-131">Örneğin, aşağıdaki yöntem çağrısı adlandırılmış bir bağımsız değişken arasında iki konumsal bağımsız değişkenlere sahiptir.</span><span class="sxs-lookup"><span data-stu-id="8dd54-131">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="8dd54-132">Adlandırılmış bağımsız değişkeni temizleyin 19 değeri temsil eden bir yaş kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="8dd54-132">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

<span data-ttu-id="8dd54-133">**Önde gelen onaltılık/ikili/sekizli ayırıcı**</span><span class="sxs-lookup"><span data-stu-id="8dd54-133">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="8dd54-134">Visual Basic 2017 alt çizgi karakteri desteği eklendi (`_`) basamak ayırıcı olarak.</span><span class="sxs-lookup"><span data-stu-id="8dd54-134">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="8dd54-135">Visual Basic 15,5 ile başlayarak, önek ve onaltılık, ikili veya sekizli basamak arasında başında ayırıcı olarak alt çizgi karakterini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8dd54-135">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="8dd54-136">Aşağıdaki örnek başında basamak ayırıcı 3,271,948,384 onaltılık bir sayı olarak tanımlamak için kullanır:</span><span class="sxs-lookup"><span data-stu-id="8dd54-136">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
``` 
<span data-ttu-id="8dd54-137">Kullanılacak başında ayırıcı olarak puan karakterin altında Visual Basic proje (\*.vbproj) dosyanıza aşağıdaki öğeyi eklemeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="8dd54-137">To use the under score character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="8dd54-138">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="8dd54-138">Visual Basic 15.3</span></span>

[<span data-ttu-id="8dd54-139">Adlandırılmış tanımlama grubu çıkarımı</span><span class="sxs-lookup"><span data-stu-id="8dd54-139">Named tuple inference</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="8dd54-140">Başlığın öğeleri değerini değişkenlerinden atadığınızda, Visual Basic karşılık gelen değişken adları tanımlama grubu öğelerinden adını oluşturur; açıkça bir tanımlama grubu öğe adı gerekmez.</span><span class="sxs-lookup"><span data-stu-id="8dd54-140">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="8dd54-141">Aşağıdaki örnek, üç adlı öğeye sahip bir tanımlama grubu oluşturmak için çıkarım kullanır `state`, `stateName`, ve `capital`.</span><span class="sxs-lookup"><span data-stu-id="8dd54-141">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

## <a name="visual-basic-2017"></a><span data-ttu-id="8dd54-142">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="8dd54-142">Visual Basic 2017</span></span>

[<span data-ttu-id="8dd54-143">Demetler</span><span class="sxs-lookup"><span data-stu-id="8dd54-143">Tuples</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="8dd54-144">Diziler olan basit bir veri yapısı en yaygın olarak tek bir yöntem çağrısından birden çok değer döndürmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8dd54-144">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="8dd54-145">Normalde, bir yöntemin birden çok değer döndürmek için aşağıdakilerden birini yapmanız gerekir:</span><span class="sxs-lookup"><span data-stu-id="8dd54-145">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="8dd54-146">Özel tür tanımlama (bir `Class` veya `Structure`).</span><span class="sxs-lookup"><span data-stu-id="8dd54-146">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="8dd54-147">Bu bir ağır çözümüdür.</span><span class="sxs-lookup"><span data-stu-id="8dd54-147">This is a heavyweight solution.</span></span>

- <span data-ttu-id="8dd54-148">Bir veya daha fazla tanımlama `ByRef` yönteminden değer döndürme ek parametreler.</span><span class="sxs-lookup"><span data-stu-id="8dd54-148">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>
 
<span data-ttu-id="8dd54-149">Visual Basic'ın desteği diziler için bir tanımlama grubu hızla tanımlamanıza, isteğe bağlı olarak değerlerini anlamsal adları atamak ve hızlı bir şekilde değerlerini almak olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="8dd54-149">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="8dd54-150">Aşağıdaki örnekte bir çağrı sarmalar <xref:System.Int32.TryParse%2A> yöntemi ve bir tanımlama grubu döndürür.</span><span class="sxs-lookup"><span data-stu-id="8dd54-150">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="8dd54-151">Ardından, yöntemini çağırın ve aşağıdaki gibi kod ile döndürülen tanımlama grubu tanıtıcı.</span><span class="sxs-lookup"><span data-stu-id="8dd54-151">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)] 

<span data-ttu-id="8dd54-152">**İkili değişmez değerleri ve basamak ayırıcıları**</span><span class="sxs-lookup"><span data-stu-id="8dd54-152">**Binary literals and digit separators**</span></span>

<span data-ttu-id="8dd54-153">Önek kullanarak değişmez değer bir ikili tanımlayabilirsiniz `&B` veya `&b`.</span><span class="sxs-lookup"><span data-stu-id="8dd54-153">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="8dd54-154">Ayrıca, alt çizgi karakterini kullanabilirsiniz `_`, okunabilirliğini artırmak için basamak ayırıcı olarak.</span><span class="sxs-lookup"><span data-stu-id="8dd54-154">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="8dd54-155">Aşağıdaki örnek, atamak için her iki özellik kullanır. bir `Byte` değer bir ondalık, onaltılık ve ikili sayı olarak görüntülenecek ve.</span><span class="sxs-lookup"><span data-stu-id="8dd54-155">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="8dd54-156">Daha fazla bilgi için "Değişmez değer atamaları" bölümüne bakın [bayt](../language-reference/data-types/byte-data-type.md#literal-assignments), [tamsayı](../language-reference/data-types/integer-data-type.md#literal-assignments), [uzun](../language-reference/data-types/long-data-type.md#literal-assignments), [kısa](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte ](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [Uınteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), ve [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) veri türleri.</span><span class="sxs-lookup"><span data-stu-id="8dd54-156">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

<span data-ttu-id="8dd54-157">**C# başvurusu dönüş değerleri için destek**</span><span class="sxs-lookup"><span data-stu-id="8dd54-157">**Support for C# reference return values**</span></span>

<span data-ttu-id="8dd54-158">C# 7 ile başlayan, C# destekler başvurusu dönüş değerleri.</span><span class="sxs-lookup"><span data-stu-id="8dd54-158">Starting with C# 7, C# supports reference return values.</span></span> <span data-ttu-id="8dd54-159">Diğer bir deyişle, çağrıyı yapan yöntemini başvuru tarafından döndürülen bir değeri aldığında, başvuru değeri değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8dd54-159">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="8dd54-160">Visual Basic başvurusu yöntemleriyle yazmak için dönüş değerleri ancak kullanabilir ve başvuru dönüş değerlerini değiştirmek olanak izin vermiyor.</span><span class="sxs-lookup"><span data-stu-id="8dd54-160">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="8dd54-161">Örneğin, aşağıdaki `Sentence` C# ile yazılmış sınıfı içeren bir `FindNext` belirtilen bir alt dizesi ile başlayan bir tümcedeki sonraki sözcüğü bulur yöntemi.</span><span class="sxs-lookup"><span data-stu-id="8dd54-161">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="8dd54-162">Bir başvuru döndürmek gibi değer ve bir dize döndürdü `Boolean` başvuruya yöntemine geçirilen değişken gösterir arama başarılı olup olmadığını.</span><span class="sxs-lookup"><span data-stu-id="8dd54-162">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="8dd54-163">Bu, çağrıyı yapan yalnızca döndürülen değeri okunamıyor anlamına gelir; çözemiyorsa de değiştirebilirsiniz ve bu değişikliği yansıtılmıştır `Sentence` sınıfı.</span><span class="sxs-lookup"><span data-stu-id="8dd54-163">This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="8dd54-164">En basit biçimiyle cümlede aşağıdaki gibi kod kullanarak bulduğu sözcüğün değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8dd54-164">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="8dd54-165">Bir değer yöntemi, ancak bunun yerine ifade için başvuru yöntemi döndürür dönüş değeri atadığınız değil olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="8dd54-165">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="8dd54-166">Bu kodu ile ilgili bir sorun yine de bir eşleşme bulunmazsa yöntemi ilk word döndürmesidir.</span><span class="sxs-lookup"><span data-stu-id="8dd54-166">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="8dd54-167">Örnek değerini inceleyin değil bu yana `Boolean` herhangi bir eşleşme olup olmadığını değiştirdiği ilk word eşleşme yoksa belirlemek için bağımsız değişken.</span><span class="sxs-lookup"><span data-stu-id="8dd54-167">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="8dd54-168">Aşağıdaki örnekte bu eşleşme yoksa ilk word kendisiyle değiştirerek düzeltir.</span><span class="sxs-lookup"><span data-stu-id="8dd54-168">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="8dd54-169">Başvuruya göre geçirilen başvuru dönüş değeri için bir yardımcı yöntemi daha iyi bir çözümdür.</span><span class="sxs-lookup"><span data-stu-id="8dd54-169">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="8dd54-170">Yardımcı yöntemi, başvuruya göre geçirilen bağımsız değişken olarak daha sonra değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8dd54-170">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="8dd54-171">Aşağıdaki örnek, yapar.</span><span class="sxs-lookup"><span data-stu-id="8dd54-171">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="8dd54-172">Daha fazla bilgi için bkz: [başvuru dönüş değerleri](../programming-guide/language-features/procedures/ref-return-values.md).</span><span class="sxs-lookup"><span data-stu-id="8dd54-172">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="8dd54-173">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="8dd54-173">Visual Basic 14</span></span>

[<span data-ttu-id="8dd54-174">Nameof</span><span class="sxs-lookup"><span data-stu-id="8dd54-174">Nameof</span></span>](../../csharp/language-reference/keywords/nameof.md)  
 <span data-ttu-id="8dd54-175">Bir dize sabit kodlama olmadan bir hata iletisi kullanmak için bir tür veya üye nitelenmemiş dize adını elde edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8dd54-175">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="8dd54-176">Bu, kodunuzu yeniden düzenleme, doğru kalmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="8dd54-176">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="8dd54-177">Bu özellik ayrıca model-view-controller MVC bağlantıları takma ve özellik değişti olayları tetikleme için yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="8dd54-177">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>  
  
[<span data-ttu-id="8dd54-178">Dize İlişkilendirme</span><span class="sxs-lookup"><span data-stu-id="8dd54-178">String Interpolation</span></span>](../../csharp/language-reference/keywords/interpolated-strings.md)  
 <span data-ttu-id="8dd54-179">Dize ilişkilendirme ifadeler dizeleri oluşturmak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8dd54-179">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="8dd54-180">Ara değerli dize ifadesi ifadeleri içeren bir şablon dize gibi görünüyor.</span><span class="sxs-lookup"><span data-stu-id="8dd54-180">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="8dd54-181">Ara değerli bir dize bağımsız değişkenleri göre anlamak daha kolay [bileşik biçimlendirme](../../standard/base-types/composite-format.md).</span><span class="sxs-lookup"><span data-stu-id="8dd54-181">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-format.md).</span></span>  
  
[<span data-ttu-id="8dd54-182">Null-conditional üye erişimi ve dizin oluşturma</span><span class="sxs-lookup"><span data-stu-id="8dd54-182">Null-conditional Member Access and Indexing</span></span>](../../csharp/language-reference/operators/null-conditional-operators.md)  
<span data-ttu-id="8dd54-183">Null üye erişimi gerçekleştirmeden önce çok açık bir söz dizim şekilde test edebilirsiniz (`?.`) veya dizin (`?[]`) işlemi.</span><span class="sxs-lookup"><span data-stu-id="8dd54-183">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="8dd54-184">Bu işleçleri özellikle veri yapılara azalan düzen için null işlemek için daha az kod denetler yazmanıza yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="8dd54-184">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="8dd54-185">Sol işleneni veya nesne başvurusu null ise, işlemler null döndürür.</span><span class="sxs-lookup"><span data-stu-id="8dd54-185">If the left operand or object reference is null, the operations returns null.</span></span>  
  
[<span data-ttu-id="8dd54-186">Çok satırlı dize değişmez değerleri</span><span class="sxs-lookup"><span data-stu-id="8dd54-186">Multi-line String Literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)  
 <span data-ttu-id="8dd54-187">Dize değişmez değerleri yeni satır dizileri içerebilir.</span><span class="sxs-lookup"><span data-stu-id="8dd54-187">String literals can contain newline sequences.</span></span>  <span data-ttu-id="8dd54-188">Artık eski kullanarak çözmek `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span><span class="sxs-lookup"><span data-stu-id="8dd54-188">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>  
  
<span data-ttu-id="8dd54-189">Açıklamalar</span><span class="sxs-lookup"><span data-stu-id="8dd54-189">Comments</span></span>  
<span data-ttu-id="8dd54-190">Örtük satır devamlılıklar, başlatıcı ifadeleri içinde ve arasında LINQ ifadesi koşulları sonra açıklama koyabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8dd54-190">You can put comments after implicit line continuations, inside initializer expressions, and amongst LINQ expression terms.</span></span>  
  
 <span data-ttu-id="8dd54-191">Daha Akıllı tam ad çözümlemesi</span><span class="sxs-lookup"><span data-stu-id="8dd54-191">Smarter Fully-qualified Name Resolution</span></span>  
 <span data-ttu-id="8dd54-192">Kod gibi verilen `Threading.Thread.Sleep(1000)`, Visual Basic kullanılan ad alanı aramak için "İş parçacığı oluşturma", onu System.Threading ve System.Windows.Threading arasında belirsiz bulmak ve bir hatayı bildirin.</span><span class="sxs-lookup"><span data-stu-id="8dd54-192">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="8dd54-193">Visual Basic artık olası her iki ad alanı birlikte göz önünde bulundurur.</span><span class="sxs-lookup"><span data-stu-id="8dd54-193">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="8dd54-194">Tamamlanma listesi gösterirse, Visual Studio düzenleyicisinde tamamlama listesindeki her iki tür üyeleri listeler.</span><span class="sxs-lookup"><span data-stu-id="8dd54-194">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>  
  
 <span data-ttu-id="8dd54-195">Yılın ilk tarih değişmez değerleri</span><span class="sxs-lookup"><span data-stu-id="8dd54-195">Year-first Date Literals</span></span>  
 <span data-ttu-id="8dd54-196">Tarih değişmez değerleri yyyy-aa-gg biçiminde olabilir `#2015-03-17 16:10 PM#`.</span><span class="sxs-lookup"><span data-stu-id="8dd54-196">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>  
  
 <span data-ttu-id="8dd54-197">Salt okunur arabirimi özellikleri</span><span class="sxs-lookup"><span data-stu-id="8dd54-197">Readonly Interface Properties</span></span>  
 <span data-ttu-id="8dd54-198">Salt okunur arabirimi özellikleri readwrite özelliğini kullanarak uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8dd54-198">You can implement readonly interface properties using a readwrite property.</span></span>  <span data-ttu-id="8dd54-199">En düşük işlevselliği arabirimi güvence altına alır ve ayarlanacak özelliği sağlayan bir uygulama sınıfı durdurmaz.</span><span class="sxs-lookup"><span data-stu-id="8dd54-199">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>  
  
 [<span data-ttu-id="8dd54-200">TypeOf \<expr > IsNot \<türü ></span><span class="sxs-lookup"><span data-stu-id="8dd54-200">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)  
 <span data-ttu-id="8dd54-201">Artık kullanabilirsiniz için daha fazla okunabilirlik kodunuzun `TypeOf` ile `IsNot`.</span><span class="sxs-lookup"><span data-stu-id="8dd54-201">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>  
  
 [<span data-ttu-id="8dd54-202">#Disable uyarı \<kimliği > ve #Enable uyarı \<kimliği ></span><span class="sxs-lookup"><span data-stu-id="8dd54-202">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/directives.md)  
 <span data-ttu-id="8dd54-203">Devre dışı bırakın ve bir kaynak dosyası içinde bölgeler için belirli uyarıları etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="8dd54-203">You can disable and enable specific warnings for regions within a source file.</span></span>  
  
 <span data-ttu-id="8dd54-204">XML Belge açıklama geliştirmeleri</span><span class="sxs-lookup"><span data-stu-id="8dd54-204">XML Doc-comment Improvements</span></span>  
 <span data-ttu-id="8dd54-205">Doc açıklamaları yazarken, akıllı Düzenleyicisi almanıza ve yapı parametre adları, işleme uygun doğrulama desteği `crefs` (genel türler, işleçler, vb.), renklendirme ve yeniden düzenleme.</span><span class="sxs-lookup"><span data-stu-id="8dd54-205">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>  
  
 [<span data-ttu-id="8dd54-206">Kısmi modülü ve arabirim tanımları</span><span class="sxs-lookup"><span data-stu-id="8dd54-206">Partial Module and Interface Definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)  
 <span data-ttu-id="8dd54-207">Sınıflar ve yapılar ek olarak, kısmi modülleri ve arabirimleri bildirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8dd54-207">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>  
  
 [<span data-ttu-id="8dd54-208">Yöntem gövdeleri içinde #Region yönergesi</span><span class="sxs-lookup"><span data-stu-id="8dd54-208">#Region Directives inside Method Bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)  
 <span data-ttu-id="8dd54-209">#Region... koyabilirsiniz #End Region sınırlayıcıları işlevleri, iç ve hatta üzerinden yayılan bir dosyayı başka bir yerindeki işlev gövdesi.</span><span class="sxs-lookup"><span data-stu-id="8dd54-209">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>  
  
 [<span data-ttu-id="8dd54-210">Örtük olarak Overloads geçersiz kılmaları tanımı verilmiştir</span><span class="sxs-lookup"><span data-stu-id="8dd54-210">Overrides Definitions are Implicitly Overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)  
 <span data-ttu-id="8dd54-211">Eklerseniz `Overrides` değiştiricisi bir tanımı derleyici örtük olarak ekler `Overloads` durumlarda böylece daha az kod ortak yazabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8dd54-211">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>  
  
 <span data-ttu-id="8dd54-212">Öznitelikleri değişkenlerinde izin CObj</span><span class="sxs-lookup"><span data-stu-id="8dd54-212">CObj Allowed in Attributes Arguments</span></span>  
 <span data-ttu-id="8dd54-213">Bir hata CObj(...) özniteliği kurulumlarını kullanıldığında bir sabit olmadığını vermek için kullanılan derleyicisi.</span><span class="sxs-lookup"><span data-stu-id="8dd54-213">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>  
  
 <span data-ttu-id="8dd54-214">Bildirme ve farklı arabirimlerinden belirsiz yöntemlerini kullanma</span><span class="sxs-lookup"><span data-stu-id="8dd54-214">Declaring and Consuming Ambiguous Methods from Different Interfaces</span></span>  
 <span data-ttu-id="8dd54-215">Aşağıdaki kod bildirme gelen engelleyen hatalar önceden belirlenmiştir `IMock` veya arama `GetDetails` (bunlar C# ' ta bildirilmiş değilse):</span><span class="sxs-lookup"><span data-stu-id="8dd54-215">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>  
  
```vb  
Interface ICustomer  
  Sub GetDetails(x As Integer)  
End Interface  
  
Interface ITime  
  Sub GetDetails(x As String)  
End Interface  
  
Interface IMock : Inherits ICustomer, ITime  
  Overloads Sub GetDetails(x As Char)  
End Interface  
  
Interface IMock2 : Inherits ICustomer, ITime  
End Interface  
```  
  
 <span data-ttu-id="8dd54-216">Derleyici normal aşırı çözümleme kurallarını en uygun seçmek için kullanacağı artık `GetDetails` çağırmak için ve Visual Basic arabirimi ilişkiye benzer örnekte gösterilen bildirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8dd54-216">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8dd54-217">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="8dd54-217">See also</span></span>  
 [<span data-ttu-id="8dd54-218">Visual Studio 2017 yenilikler</span><span class="sxs-lookup"><span data-stu-id="8dd54-218">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-in-visual-studio)

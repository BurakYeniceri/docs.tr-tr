---
title: Mikro hizmet etki alanı model tasarlama
description: Kapsayıcılı .NET uygulamaları için .NET mikro mimarisi | Mikro hizmet etki alanı model tasarlama
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 11/09/2017
ms.openlocfilehash: e672685666c846ea63bcd9cdb713af58f5e6fb1b
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/29/2018
ms.locfileid: "37106258"
---
# <a name="designing-a-microservice-domain-model"></a><span data-ttu-id="b7e57-103">Mikro hizmet etki alanı model tasarlama</span><span class="sxs-lookup"><span data-stu-id="b7e57-103">Designing a microservice domain model</span></span>

<span data-ttu-id="b7e57-104">*Her iş mikro hizmet ya da ilişkisindeki bağlamı için bir zengin etki alanı modeli tanımlayın*</span><span class="sxs-lookup"><span data-stu-id="b7e57-104">*Define one rich domain model for each business microservice or Bounded Context*</span></span>

<span data-ttu-id="b7e57-105">Amacınız, her iş mikro hizmet ya da ilişkisindeki bağlam (BC) için tek bağlı etki alanı modeli oluşturmaktır.</span><span class="sxs-lookup"><span data-stu-id="b7e57-105">Your goal is to create a single cohesive domain model for each business microservice or Bounded Context (BC).</span></span> <span data-ttu-id="b7e57-106">Ancak bu unutmayın bir BC veya iş mikro hizmet bazen oluşan bir tek etki alanı modeli paylaşan birden fazla fiziksel Hizmetleri.</span><span class="sxs-lookup"><span data-stu-id="b7e57-106">Keep in mind, however, that a BC or business microservice could sometimes be composed of several physical services that share a single domain model.</span></span> <span data-ttu-id="b7e57-107">Etki alanı modeli kuralları, davranışı, iş dili ve tek ilişkisindeki bağlamı veya temsil ettiği iş mikro hizmet kısıtlamaları yakalama gerekir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-107">The domain model must capture the rules, behavior, business language, and constraints of the single Bounded Context or business microservice that it represents.</span></span>

## <a name="the-domain-entity-pattern"></a><span data-ttu-id="b7e57-108">Etki alanı varlığı düzeni</span><span class="sxs-lookup"><span data-stu-id="b7e57-108">The Domain Entity pattern</span></span>

<span data-ttu-id="b7e57-109">Varlıklar etki alanı nesnelerini temsil eder ve temelde yalnızca bunları oluşturan öznitelikleri ve bunların kimlik, sürekliliği ve zaman içinde Kalıcılık tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="b7e57-109">Entities represent domain objects and are primarily defined by their identity, continuity, and persistence over time, and not only by the attributes that comprise them.</span></span> <span data-ttu-id="b7e57-110">Eric Evans diyor gibi "öncelikle kimliğini tarafından tanımlanan bir nesne bir varlık çağrılır."</span><span class="sxs-lookup"><span data-stu-id="b7e57-110">As Eric Evans says, “an object primarily defined by its identity is called an Entity.”</span></span> <span data-ttu-id="b7e57-111">Bir model için temel olduğundan varlıklar etki alanı modelinde çok önemlidir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-111">Entities are very important in the domain model, since they are the base for a model.</span></span> <span data-ttu-id="b7e57-112">Bu nedenle, belirleyin ve dikkatli bir şekilde tasarlayın.</span><span class="sxs-lookup"><span data-stu-id="b7e57-112">Therefore, you should identify and design them carefully.</span></span>

<span data-ttu-id="b7e57-113">*Bir varlığın kimliğini birden fazla mikro veya sınırlanmış bağlamları çapraz.*</span><span class="sxs-lookup"><span data-stu-id="b7e57-113">*An entity’s identity can cross multiple microservices or Bounded Contexts.*</span></span>

<span data-ttu-id="b7e57-114">Aynı kimliğe (değil aynı varlık rağmen) birden çok ilişkisindeki bağlamları veya mikro modellenebilir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-114">The same identity (though not the same entity) can be modeled across multiple Bounded Contexts or microservices.</span></span> <span data-ttu-id="b7e57-115">Ancak, aynı öznitelikleri ve mantığı ile aynı varlık birden çok ilişkisindeki bağlamlarda uygulanan anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="b7e57-115">However, that does not imply that the same entity, with the same attributes and logic would be implemented in multiple Bounded Contexts.</span></span> <span data-ttu-id="b7e57-116">Bunun yerine, kendi öznitelikleri ve bu gerekli için davranışlar bu ilişkisindeki bağlamın etki alanındaki her ilişkisindeki bağlamındaki varlıkları sınırlayın.</span><span class="sxs-lookup"><span data-stu-id="b7e57-116">Instead, entities in each Bounded Context limit their attributes and behaviors to those required in that Bounded Context’s domain.</span></span>

<span data-ttu-id="b7e57-117">Örneğin, alıcı varlık kimliğini de dahil olmak üzere profil veya kimlik mikro kullanıcı varlıkta tanımlanan bir kişinin öznitelikleri çoğunu olabilir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-117">For instance, the buyer entity might have most of a person’s attributes that are defined in the user entity in the profile or identity microservice, including the identity.</span></span> <span data-ttu-id="b7e57-118">Ancak yalnızca belirli alıcı verileri sipariş işlemle ilişkili olduğundan alıcı varlıkta sıralama mikro hizmet daha az sayıda öznitelik olabilir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-118">But the buyer entity in the ordering microservice might have fewer attributes, because only certain buyer data is related to the order process.</span></span> <span data-ttu-id="b7e57-119">Her mikro Hizmet bağlamı veya sınırlanmış bağlamı kendi etki alanı modeli etkiler.</span><span class="sxs-lookup"><span data-stu-id="b7e57-119">The context of each microservice or Bounded Context impacts its domain model.</span></span>

<span data-ttu-id="b7e57-120">*Etki alanı varlıkları veri öznitelikleri uygulama yanı sıra davranışı uygulamalıdır*</span><span class="sxs-lookup"><span data-stu-id="b7e57-120">*Domain entities must implement behavior in addition to implementing data attributes*</span></span>

<span data-ttu-id="b7e57-121">Bir etki alanı varlığı GGG, etki alanı mantığı ya da varlık verilerini (bellekte erişilen nesne) ilgili davranışı uygulamalıdır.</span><span class="sxs-lookup"><span data-stu-id="b7e57-121">A domain entity in DDD must implement the domain logic or behavior related to the entity data (the object accessed in memory).</span></span> <span data-ttu-id="b7e57-122">Örneğin, bir siparişi varlık sınıfı bir parçası olarak iş mantığı ve bir sipariş öğesi, veri doğrulama ve toplam hesaplaması ekleme gibi görevler için yöntemleri olarak uygulanan işlemler olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b7e57-122">For example, as part of an order entity class you must have business logic and operations implemented as methods for tasks such as adding an order item, data validation, and total calculation.</span></span> <span data-ttu-id="b7e57-123">Varlığın yöntemleri invariants ve uygulama katmanı yayılan bu kurallarına sahip yerine varlık kurallar dikkatli olun.</span><span class="sxs-lookup"><span data-stu-id="b7e57-123">The entity’s methods take care of the invariants and rules of the entity instead of having those rules spread across the application layer.</span></span>

<span data-ttu-id="b7e57-124">Şekil 9-8 yalnızca veri öznitelikleri ancak operations veya yöntemleri ile ilgili etki alanının mantığını uygulayan bir etki alanı varlığı gösterir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-124">Figure 9-8 shows a domain entity that implements not only data attributes but operations or methods with related domain logic.</span></span>

![](./media/image9.png)

<span data-ttu-id="b7e57-125">**Şekil 9-8**.</span><span class="sxs-lookup"><span data-stu-id="b7e57-125">**Figure 9-8**.</span></span> <span data-ttu-id="b7e57-126">Verilerin yanı sıra davranışı uygulama etki alanı varlığı tasarım örneği</span><span class="sxs-lookup"><span data-stu-id="b7e57-126">Example of a domain entity design implementing data plus behavior</span></span>

<span data-ttu-id="b7e57-127">Elbette, bazen varlık sınıfı bir parçası olarak herhangi bir mantık uygulamaz varlıklar sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-127">Of course, sometimes you can have entities that do not implement any logic as part of the entity class.</span></span> <span data-ttu-id="b7e57-128">Alt varlık mantığı çoğunu tanımlanmış çünkü toplama kök dizininde özel bir mantık yoksa bir toplama alt varlıkları oluşabilir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-128">This can happen in child entities within an aggregate if the child entity does not have any special logic because most of the logic is defined in the aggregate root.</span></span> <span data-ttu-id="b7e57-129">Çok sayıda etki alanı varlıkları yerine hizmet sınıflarını uygulanan mantığı içeren karmaşık bir mikro hizmet varsa, aşağıdaki bölümde açıklanan anemic etki alanı modeline dönmeden.</span><span class="sxs-lookup"><span data-stu-id="b7e57-129">If you have a complex microservice that has a lot of logic implemented in the service classes instead of in the domain entities, you could be falling into the anemic domain model, explained in the following section.</span></span>

### <a name="rich-domain-model-versus-anemic-domain-model"></a><span data-ttu-id="b7e57-130">Zengin etki alanı modeli anemic etki alanı modeli karşılaştırması</span><span class="sxs-lookup"><span data-stu-id="b7e57-130">Rich domain model versus anemic domain model</span></span>

<span data-ttu-id="b7e57-131">Kendi postasında [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html), Martin Fowler bu şekilde bir anemic etki alanı modeli açıklanmaktadır:</span><span class="sxs-lookup"><span data-stu-id="b7e57-131">In his post [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html), Martin Fowler describes an anemic domain model this way:</span></span>

<span data-ttu-id="b7e57-132">Temel Anemic bir etki alanı modeli blush en önce gerçek bir şey gibi görünüyor, belirtisidir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-132">The basic symptom of an Anemic Domain Model is that at first blush it looks like the real thing.</span></span> <span data-ttu-id="b7e57-133">Nesne, birçok etki alanı içinde isimleri sonra adlı ve bu nesneler zengin ilişkileri ve doğru etki alanı modelleri sahip yapısı ile bağlı.</span><span class="sxs-lookup"><span data-stu-id="b7e57-133">There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have.</span></span> <span data-ttu-id="b7e57-134">Yakalama davranış arayın ve, bu nesneler üzerinde tümcesi herhangi davranış olduğunu paketler alıcılar ve ayarlayıcılar, biraz daha yapmadan farkında olun gelir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-134">The catch comes when you look at the behavior, and you realize that there is hardly any behavior on these objects, making them little more than bags of getters and setters.</span></span>

<span data-ttu-id="b7e57-135">Bir anemic etki alanı modeli kullandığınızda, doğal olarak, bu veri modelleri hizmet nesneleri kümesinden kullanılacak (Geleneksel olarak adlandırılmış *iş katmanı*) tüm etki alanı veya iş mantığı yakalayın.</span><span class="sxs-lookup"><span data-stu-id="b7e57-135">Of course, when you use an anemic domain model, those data models will be used from a set of service objects (traditionally named the *business layer*) which capture all the domain or business logic.</span></span> <span data-ttu-id="b7e57-136">İş katmanı veri modeli üstünde bulunur ve yalnızca veri veri modelini kullanır.</span><span class="sxs-lookup"><span data-stu-id="b7e57-136">The business layer sits on top of the data model and uses the data model just as data.</span></span>

<span data-ttu-id="b7e57-137">Yalnızca bir yordam stil tasarımı anemic etki alanı modelidir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-137">The anemic domain model is just a procedural style design.</span></span> <span data-ttu-id="b7e57-138">Davranışları (yöntemleri) bulunmadığından anemic varlık nesnesi gerçek nesneler değildir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-138">Anemic entity objects are not real objects because they lack behavior (methods).</span></span> <span data-ttu-id="b7e57-139">Bunlar yalnızca veri özellikleri basılı tutun ve böylece nesne odaklı tasarım değildir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-139">They only hold data properties and thus it is not object-oriented design.</span></span> <span data-ttu-id="b7e57-140">Tüm davranışı out (iş katmanı) hizmeti nesnelerine koyarak, aslında şunun [spaghetti kod](https://en.wikipedia.org/wiki/Spaghetti_code) veya [işlem betikleri](https://martinfowler.com/eaaCatalog/transactionScript.html), ve bu nedenle, avantajları, kaybetmeniz etki alanı modeli sağlar.</span><span class="sxs-lookup"><span data-stu-id="b7e57-140">By putting all the behavior out into service objects (the business layer) you essentially end up with [spaghetti code](https://en.wikipedia.org/wiki/Spaghetti_code) or [transaction scripts](https://martinfowler.com/eaaCatalog/transactionScript.html), and therefore you lose the advantages that a domain model provides.</span></span>

<span data-ttu-id="b7e57-141">Mikro hizmet veya sınırlanmış bağlam çok basit ise bakılmaksızın (bir CRUD hizmeti), yalnızca veri özellikleri varlık nesneleriyle biçiminde anemic etki alanı modeli yeterince iyi olabilir ve daha karmaşık DDD desenleri uygulama değerinde olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-141">Regardless, if your microservice or Bounded Context is very simple (a CRUD service), the anemic domain model in the form of entity objects with just data properties might be good enough, and it might not be worth implementing more complex DDD patterns.</span></span> <span data-ttu-id="b7e57-142">Bu durumda, yalnızca verileri CRUD amacıyla sahip bir varlık bilerek oluşturdunuz çünkü Kalıcılık model yalnızca olacaktır.</span><span class="sxs-lookup"><span data-stu-id="b7e57-142">In that case, it will be simply a persistence model, because you have intentionally created an entity with only data for CRUD purposes.</span></span>

<span data-ttu-id="b7e57-143">Mikro mimarileri ilişkisindeki her bağlam bağlı olarak çok mimari bir yaklaşım için mükemmel bir nedeni budur.</span><span class="sxs-lookup"><span data-stu-id="b7e57-143">That is why microservices architectures are perfect for a multi-architectural approach depending on each Bounded Context.</span></span> <span data-ttu-id="b7e57-144">Örneğin, eShopOnContainers, sıralama mikro hizmet DDD desenleri uygular, ancak bir basit CRUD hizmetidir, katalog mikro hizmet yok.</span><span class="sxs-lookup"><span data-stu-id="b7e57-144">For instance, in eShopOnContainers, the ordering microservice implements DDD patterns, but the catalog microservice, which is a simple CRUD service, does not.</span></span>

<span data-ttu-id="b7e57-145">Bazı kişiler anemic etki alanı modeli karşı bir düzeni olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="b7e57-145">Some people say that the anemic domain model is an anti-pattern.</span></span> <span data-ttu-id="b7e57-146">Gerçekten neler, uyguluyorsanız üzerinde bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="b7e57-146">It really depends on what you are implementing.</span></span> <span data-ttu-id="b7e57-147">Oluşturmakta mikro hizmet ise bir koruma desen değil anemic etki alanı modeli izleyen basit yeterince (örneğin, bir CRUD hizmeti).</span><span class="sxs-lookup"><span data-stu-id="b7e57-147">If the microservice you are creating is simple enough (for example, a CRUD service), following the anemic domain model it is not an anti-pattern.</span></span> <span data-ttu-id="b7e57-148">Ancak, çok sayıda sürekli değişen iş kuralları olan bir mikro 's etki karmaşıklığını üstesinden gelmek gerekiyorsa, anemic etki alanı modeli mikro hizmet veya sınırlanmış bağlamı için bir koruma desen olabilir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-148">However, if you need to tackle the complexity of a microservice’s domain that has a lot of ever-changing business rules, the anemic domain model might be an anti-pattern for that microservice or Bounded Context.</span></span> <span data-ttu-id="b7e57-149">Bu durumda, bir zengin tasarlama veri artı davranışı içeren yanı sıra ek DDD desenleri (toplamalar, değer nesneleri, vb.) uygulama varlıkları modeliyle böyle bir mikro hizmet uzun vadeli başarısı için çok büyük yararları olabilir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-149">In that case, designing it as a rich model with entities containing data plus behavior as well as implementing additional DDD patterns (aggregates, value objects, etc.) might have huge benefits for the long-term success of such a microservice.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="b7e57-150">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="b7e57-150">Additional resources</span></span>

-   <span data-ttu-id="b7e57-151">**DevIQ. Etki alanı varlığı**
    [*http://deviq.com/entity/*](http://deviq.com/entity/)</span><span class="sxs-lookup"><span data-stu-id="b7e57-151">**DevIQ. Domain Entity**
[*http://deviq.com/entity/*](http://deviq.com/entity/)</span></span>

-   <span data-ttu-id="b7e57-152">**Martin Fowler. Etki alanı modeli**
    [*https://martinfowler.com/eaaCatalog/domainModel.html*](https://martinfowler.com/eaaCatalog/domainModel.html)</span><span class="sxs-lookup"><span data-stu-id="b7e57-152">**Martin Fowler. The Domain Model**
[*https://martinfowler.com/eaaCatalog/domainModel.html*](https://martinfowler.com/eaaCatalog/domainModel.html)</span></span>

-   <span data-ttu-id="b7e57-153">**Martin Fowler. Anemic etki alanı modeli**</span><span class="sxs-lookup"><span data-stu-id="b7e57-153">**Martin Fowler. The Anemic Domain Model**</span></span>

    <https://martinfowler.com/bliki/AnemicDomainModel.html>

### <a name="the-value-object-pattern"></a><span data-ttu-id="b7e57-154">Değer nesnesi düzeni</span><span class="sxs-lookup"><span data-stu-id="b7e57-154">The Value Object pattern</span></span>

<span data-ttu-id="b7e57-155">Eric Evans belirtildiği gibi bu "çok sayıda nesne kavramsal kimliğe sahip değil.</span><span class="sxs-lookup"><span data-stu-id="b7e57-155">As Eric Evans has noted, “Many objects do not have conceptual identity.</span></span> <span data-ttu-id="b7e57-156">Bu nesneler belirli bir şey özelliklerini tanımlar."</span><span class="sxs-lookup"><span data-stu-id="b7e57-156">These objects describe certain characteristics of a thing.”</span></span>

<span data-ttu-id="b7e57-157">Bir varlık Kimlikteki gerektiriyor, ancak bulunmayan bir sistemde birçok nesne yok değer nesnesi düzeni ister.</span><span class="sxs-lookup"><span data-stu-id="b7e57-157">An entity requires an identity, but there are many objects in a system that do not, like the Value Object pattern.</span></span> <span data-ttu-id="b7e57-158">Bir değer nesnesi, bir etki alanı en boy açıklar ve kavramsal bir kimliği olan bir nesnedir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-158">A value object is an object with no conceptual identity that describes a domain aspect.</span></span> <span data-ttu-id="b7e57-159">Bu, yalnızca geçici olarak ilgilendiren tasarım öğeleri göstermek için örneği nesneleridir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-159">These are objects that you instantiate to represent design elements that only concern you temporarily.</span></span> <span data-ttu-id="b7e57-160">İlgilendiğiniz *ne* bunlar değil, *kimin* oldukları.</span><span class="sxs-lookup"><span data-stu-id="b7e57-160">You care about *what* they are, not *who* they are.</span></span> <span data-ttu-id="b7e57-161">Örnekler sayılara hem de dizelere içerir, ancak özniteliklerin grupları gibi daha üst düzey kavramlarını da olabilir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-161">Examples include numbers and strings, but can also be higher-level concepts like groups of attributes.</span></span>

<span data-ttu-id="b7e57-162">İkinci durumda, sınırlanmış bağlamı farklı bir anlama sahip çünkü bir mikro hizmet varlık benzer bir varlık başka bir mikro olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-162">Something that is an entity in a microservice might not be an entity in another microservice, because in the second case, the Bounded Context might have a different meaning.</span></span> <span data-ttu-id="b7e57-163">Yalnızca bir grup kişi veya şirket için Müşteri'nin profili özniteliklerini temsil edebilir beri Örneğin, bir e-ticaret uygulamada bir adresi Kimlikteki hiç sahip olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-163">For example, an address in an e-commerce application might not have an identity at all, since it might only represent a group of attributes of the customer’s profile for a person or company.</span></span> <span data-ttu-id="b7e57-164">Bu durumda, adresi bir değer nesnesi sınıflandırılmış.</span><span class="sxs-lookup"><span data-stu-id="b7e57-164">In this case, the address should be classified as a value object.</span></span> <span data-ttu-id="b7e57-165">Ancak, bir elektrik güç yardımcı şirket için bir uygulamada, müşteri adresi iş etki alanı için önemli olabilir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-165">However, in an application for an electric power utility company, the customer address could be important for the business domain.</span></span> <span data-ttu-id="b7e57-166">Bu nedenle, fatura sistemiyle adresine doğrudan bağlanabilir şekilde adresi bir kimlik olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b7e57-166">Therefore, the address must have an identity so the billing system can be directly linked to the address.</span></span> <span data-ttu-id="b7e57-167">Bu durumda, bir adresi bir etki alanı varlığı sınıflandırılmış.</span><span class="sxs-lookup"><span data-stu-id="b7e57-167">In that case, an address should be classified as a domain entity.</span></span>

<span data-ttu-id="b7e57-168">Bir ad ve Soyadı kişiyle genellikle bir varlıktır adı ve Soyadı başka bir değer kümesiyle çakıştığı olsa bile bir kişinin kimliğini olduğundan, eğer gibi bu adlar da başvuruyor farklı bir kişiye.</span><span class="sxs-lookup"><span data-stu-id="b7e57-168">A person with a name and surname is usually an entity because a person has identity, even if the name and surname coincide with another set of values, such as if those names also refers to a different person.</span></span>

<span data-ttu-id="b7e57-169">Değer belgede uygulamak ve kullanmak daha kolay veritabanlarına yönelik ancak ilişkisel veritabanları ve ORMs EF gibi yönetmek sabit nesneleridir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-169">Value objects are hard to manage in relational databases and ORMs like EF, whereas in document oriented databases they are easier to implement and use.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="b7e57-170">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="b7e57-170">Additional resources</span></span>

-   <span data-ttu-id="b7e57-171">**Martin Fowler. Değer nesnesi düzeni**
    [*https://martinfowler.com/bliki/ValueObject.html*](https://martinfowler.com/bliki/ValueObject.html)</span><span class="sxs-lookup"><span data-stu-id="b7e57-171">**Martin Fowler. Value Object pattern**
[*https://martinfowler.com/bliki/ValueObject.html*](https://martinfowler.com/bliki/ValueObject.html)</span></span>

-   <span data-ttu-id="b7e57-172">**Değer nesnesi**
    [*http://deviq.com/value-object/*](http://deviq.com/value-object/)</span><span class="sxs-lookup"><span data-stu-id="b7e57-172">**Value Object**
[*http://deviq.com/value-object/*](http://deviq.com/value-object/)</span></span>

-   <span data-ttu-id="b7e57-173">**Değer nesnelerini teste dayalı geliştirme**
    [*https://leanpub.com/tdd-ebook/read\#leanpub-auto-value-objects*](https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects)</span><span class="sxs-lookup"><span data-stu-id="b7e57-173">**Value Objects in Test-Driven Development**
[*https://leanpub.com/tdd-ebook/read\#leanpub-auto-value-objects*](https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects)</span></span>

-   <span data-ttu-id="b7e57-174">**Eric Evans. Etki alanı Odaklı Tasarım: Yazılım Kalp karmaşıklığı Tackling.**</span><span class="sxs-lookup"><span data-stu-id="b7e57-174">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="b7e57-175">(Kitap; değer nesnelerini tartışması içerir) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="b7e57-175">(Book; includes a discussion of value objects) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

### <a name="the-aggregate-pattern"></a><span data-ttu-id="b7e57-176">Toplama düzeni</span><span class="sxs-lookup"><span data-stu-id="b7e57-176">The Aggregate pattern</span></span>

<span data-ttu-id="b7e57-177">Bir etki alanı modeli farklı veri varlıkları ve sipariş fulfilment veya envanter gibi işlevleri önemli bir bölümünü denetleyebilirsiniz işlemleri kümelerini içerir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-177">A domain model contains clusters of different data entities and processes that can control a significant area of functionality, such as order fulfilment or inventory.</span></span> <span data-ttu-id="b7e57-178">Bir daha hassas DDD bir küme veya grup varlıkları ve bağlı bir birim olarak kabul davranışları açıklanmaktadır toplama birimdir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-178">A more fine-grained DDD unit is the aggregate, which describes a cluster or group of entities and behaviors that can be treated as a cohesive unit.</span></span>

<span data-ttu-id="b7e57-179">Gereksinim duyduğunuz hareketlerini temel alarak bir toplama genellikle tanımlarsınız.</span><span class="sxs-lookup"><span data-stu-id="b7e57-179">You usually define an aggregate based on the transactions that you need.</span></span> <span data-ttu-id="b7e57-180">Klasik bir örnek de sipariş öğelerinin bir listesini içeren bir sırasıdır.</span><span class="sxs-lookup"><span data-stu-id="b7e57-180">A classic example is an order that also contains a list of order items.</span></span> <span data-ttu-id="b7e57-181">Bir sipariş öğesi, genellikle bir varlık olacaktır.</span><span class="sxs-lookup"><span data-stu-id="b7e57-181">An order item will usually be an entity.</span></span> <span data-ttu-id="b7e57-182">Ancak bir alt varlık sipariş varlık genellikle bir toplama kök adı verilen kendi kök varlık olarak da içerecek sipariş toplama içinde görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-182">But it will be a child entity within the order aggregate, which will also contain the order entity as its root entity, typically called an aggregate root.</span></span>

<span data-ttu-id="b7e57-183">Toplamalar tanımlayan zor olabilir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-183">Identifying aggregates can be hard.</span></span> <span data-ttu-id="b7e57-184">Bir toplama bir gruptur nesnelerin araya tutarlı olmalıdır, ancak yalnızca bir grup seçin olamaz ve bir toplama etiket.</span><span class="sxs-lookup"><span data-stu-id="b7e57-184">An aggregate is a group of objects that must be consistent together, but you cannot just pick a group of objects and label them an aggregate.</span></span> <span data-ttu-id="b7e57-185">Bir etki alanı kavramı ile başlamalı ve konusu kavrama ilgili yaygın işlemlerde kullanılan varlıkları düşünün.</span><span class="sxs-lookup"><span data-stu-id="b7e57-185">You must start with a domain concept and think about the entities that are used in the most common transactions related to that concept.</span></span> <span data-ttu-id="b7e57-186">İşlemsel olarak tutarlı olması gereken bu ne toplama forms varlıklardır.</span><span class="sxs-lookup"><span data-stu-id="b7e57-186">Those entities that need to be transactionally consistent are what forms an aggregate.</span></span> <span data-ttu-id="b7e57-187">İşlem işlemleri hakkında düşünmeye büyük olasılıkla toplamalar tanımlamak için en iyi yoludur.</span><span class="sxs-lookup"><span data-stu-id="b7e57-187">Thinking about transaction operations is probably the best way to identify aggregates.</span></span>

### <a name="the-aggregate-root-or-root-entity-pattern"></a><span data-ttu-id="b7e57-188">Birleşik kök veya kök varlık düzeni</span><span class="sxs-lookup"><span data-stu-id="b7e57-188">The Aggregate Root or Root Entity pattern</span></span>

<span data-ttu-id="b7e57-189">Bir toplama en az bir varlık oluşur: Birleşik kök, kök varlık veya birincil varlık olarak da bilinir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-189">An aggregate is composed of at least one entity: the aggregate root, also called root entity or primary entity.</span></span> <span data-ttu-id="b7e57-190">Ayrıca, birden çok alt varlıkları ve tüm varlıkları ve gerekli davranışı ve işlemleri uygulamak üzere birlikte çalışan nesnelerle değeri nesneler olabilir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-190">Additionally, it can have multiple child entities and value objects, with all entities and objects working together to implement required behavior and transactions.</span></span>

<span data-ttu-id="b7e57-191">Toplama tutarlılığını sağlamak için bir toplama kök amacı.; Yalnızca giriş noktası için toplama yöntemleri aracılığıyla güncelleştirmeleri olmalı veya işlemleri toplama sınıfı kök.</span><span class="sxs-lookup"><span data-stu-id="b7e57-191">The purpose of an aggregate root is to ensure the consistency of the aggregate; it should be the only entry point for updates to the aggregate through methods or operations in the aggregate root class.</span></span> <span data-ttu-id="b7e57-192">Yalnızca toplama kök üzerinden toplama varlıkları değişiklik.</span><span class="sxs-lookup"><span data-stu-id="b7e57-192">You should make changes to entities within the aggregate only via the aggregate root.</span></span> <span data-ttu-id="b7e57-193">Tüm invariants ve toplam olarak uymak için gerekebilecek tutarlık kuralları dikkate alarak toplama 's tutarlılık koruyucu olur.</span><span class="sxs-lookup"><span data-stu-id="b7e57-193">It is the aggregate’s consistency guardian, taking into account all the invariants and consistency rules you might need to comply with in your aggregate.</span></span> <span data-ttu-id="b7e57-194">Alt varlık veya değer nesne bağımsız olarak değiştirirseniz, toplama kök toplama işlevinde geçerli bir durumda olduğundan emin olun olamaz.</span><span class="sxs-lookup"><span data-stu-id="b7e57-194">If you change a child entity or value object independently, the aggregate root cannot ensure that the aggregate is in a valid state.</span></span> <span data-ttu-id="b7e57-195">Gevşek bir bacağı içeren bir tablo gibi olacaktır.</span><span class="sxs-lookup"><span data-stu-id="b7e57-195">It would be like a table with a loose leg.</span></span> <span data-ttu-id="b7e57-196">Bakımı tutarlılık toplama kök ana amacı budur.</span><span class="sxs-lookup"><span data-stu-id="b7e57-196">Maintaining consistency is the main purpose of the aggregate root.</span></span>

<span data-ttu-id="b7e57-197">Şekil 9-9'da, toplama, tek bir varlık (Birleşik kök alıcı) içeren alıcı gibi örnek toplamalar görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7e57-197">In Figure 9-9, you can see sample aggregates like the buyer aggregate, which contains a single entity (the aggregate root Buyer).</span></span> <span data-ttu-id="b7e57-198">Sipariş toplama birden çok varlık ve bir değer nesnesini içerir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-198">The order aggregate contains multiple entities and a value object.</span></span>

![](./media/image10.png)

<span data-ttu-id="b7e57-199">**Şekil 9-9**.</span><span class="sxs-lookup"><span data-stu-id="b7e57-199">**Figure 9-9**.</span></span> <span data-ttu-id="b7e57-200">Toplamalar birden çok örneği ya da tek varlıklar</span><span class="sxs-lookup"><span data-stu-id="b7e57-200">Example of aggregates with multiple or single entities</span></span>

<span data-ttu-id="b7e57-201">Sıralama mikro hizmet eShopOnContainers başvuru uygulamada içinde yaptığı gibi alıcı toplama etki alanınız bağlı olarak, ek alt varlıkları olabilir unutmayın.</span><span class="sxs-lookup"><span data-stu-id="b7e57-201">Note that the Buyer aggregate could have additional child entities, depending on your domain, as it does in the ordering microservice in the eShopOnContainers reference application.</span></span> <span data-ttu-id="b7e57-202">Şekil 9-9 yalnızca alıcı tek bir varlık birleşik bir kök içeren bir toplama örneği bulunduğu bir durumu gösterir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-202">Figure 9-9 just illustrates a case in which the buyer has a single entity, as an example of an aggregate that contains only an aggregate root.</span></span>

<span data-ttu-id="b7e57-203">Toplamlar ve yalnızca yabancı anahtar (FK) alanı sahip arasında doğrudan Gezinti içinde uygulandığı şekilde izin vermeyecek şekilde DDD etki alanı modeli iyi bir uygulama olmasından Toplamaların birbirinden ayırmaya ve bunlar arasında NET sınırları tutmak için [ Mikro hizmet etki alanı modeli sıralama](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) eShopOnContainers içinde.</span><span class="sxs-lookup"><span data-stu-id="b7e57-203">In order to maintain separation of aggregates and keep clear boundaries between them, it is a good practice in a DDD domain model to disallow direct navigation between aggregates and only having the foreign key (FK) field, as implemented in the [Ordering microservice domain model](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) in eShopOnContainers.</span></span> <span data-ttu-id="b7e57-204">Sipariş varlığın yalnızca FK alan alıcı ancak olmayan bir EF çekirdek gezinti özelliği, aşağıdaki kodda gösterildiği gibi vardır:</span><span class="sxs-lookup"><span data-stu-id="b7e57-204">The Order entity only has a FK field for the buyer, but not an EF Core navigation property, as shown in the following code:</span></span>

```csharp
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId; //FK pointing to a different aggregate root
    public OrderStatus OrderStatus { get; private set; }
    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;
    // ... Additional code
}
```

<span data-ttu-id="b7e57-205">Tanımlama ve toplamalar ile çalışma araştırma ve deneyimi gerektirir.</span><span class="sxs-lookup"><span data-stu-id="b7e57-205">Identifying and working with aggregates requires research and experience.</span></span> <span data-ttu-id="b7e57-206">Daha fazla bilgi için aşağıdaki ek kaynaklar listesine bakın.</span><span class="sxs-lookup"><span data-stu-id="b7e57-206">For more information, see the following Additional resources list.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="b7e57-207">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="b7e57-207">Additional resources</span></span>

-   <span data-ttu-id="b7e57-208">**Vaughn Vernon. Etkin Toplama tasarımı - bölümü I: tek bir toplama modelleme**
    [*https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD\_COMMUNITY\_ESSAY\_AGGREGATES\_PART\_1.pdf*](https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_1.pdf)</span><span class="sxs-lookup"><span data-stu-id="b7e57-208">**Vaughn Vernon. Effective Aggregate Design - Part I: Modeling a Single Aggregate**
[*https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD\_COMMUNITY\_ESSAY\_AGGREGATES\_PART\_1.pdf*](https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_1.pdf)</span></span>

-   <span data-ttu-id="b7e57-209">**Vaughn Vernon. Etkin Toplama tasarımı - Bölüm II: Yapma toplamalar iş birlikte**
    *<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_2.pdf> *</span><span class="sxs-lookup"><span data-stu-id="b7e57-209">**Vaughn Vernon. Effective Aggregate Design - Part II: Making Aggregates Work Together**
*<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_2.pdf> *</span></span>

-   <span data-ttu-id="b7e57-210">**Vaughn Vernon. Etkili toplama tasarım - bölüm III: Bulma aracılığıyla sağlamasını Insight**
    *<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_3.pdf> *</span><span class="sxs-lookup"><span data-stu-id="b7e57-210">**Vaughn Vernon. Effective Aggregate Design - Part III: Gaining Insight Through Discovery**
*<https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_3.pdf> *</span></span>

-   <span data-ttu-id="b7e57-211">**Sergey Grybniak. DDD Taktik tasarım desenleri**
    [*https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part*](https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part)</span><span class="sxs-lookup"><span data-stu-id="b7e57-211">**Sergey Grybniak. DDD Tactical Design Patterns**
[*https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part*](https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part)</span></span>

-   <span data-ttu-id="b7e57-212">**Chris Uludağ. İşlem mikro toplamalar kullanarak geliştirme**
    [*https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson*](https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson)</span><span class="sxs-lookup"><span data-stu-id="b7e57-212">**Chris Richardson. Developing Transactional Microservices Using Aggregates**
[*https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson*](https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson)</span></span>

-   <span data-ttu-id="b7e57-213">**DevIQ. Toplama düzeni**
    [*http://deviq.com/aggregate-pattern/*](http://deviq.com/aggregate-pattern/)</span><span class="sxs-lookup"><span data-stu-id="b7e57-213">**DevIQ. The Aggregate pattern**
[*http://deviq.com/aggregate-pattern/*](http://deviq.com/aggregate-pattern/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="b7e57-214">[Önceki](ddd-oriented-microservice.md)
[sonraki](net-core-microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="b7e57-214">[Previous](ddd-oriented-microservice.md)
[Next](net-core-microservice-domain-model.md)</span></span>

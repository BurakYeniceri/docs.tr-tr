---
title: Windows'da Yönetilen ve Yönetilmeyen İş Parçacığı Oluşturma
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], unmanaged
- threading [.NET Framework], managed
- managed threading
ms.assetid: 4fb6452f-c071-420d-9e71-da16dee7a1eb
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 1be82fd9f26e382f20913551f67e8303cf20e03b
ms.sourcegitcommit: 2eceb05f1a5bb261291a1f6a91c5153727ac1c19
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/05/2018
ms.locfileid: "43731712"
---
# <a name="managed-and-unmanaged-threading-in-windows"></a><span data-ttu-id="728eb-102">Windows'da Yönetilen ve Yönetilmeyen İş Parçacığı Oluşturma</span><span class="sxs-lookup"><span data-stu-id="728eb-102">Managed and Unmanaged Threading in Windows</span></span>
<span data-ttu-id="728eb-103">Tüm iş parçacıklarının Yönetim aracılığıyla gerçekleştirilir <xref:System.Threading.Thread> sınıfı, ortak dil çalışma zamanı tarafından oluşturulan iş parçacığı ve kodu yürütmek için yönetilen ortamı girin çalışma zamanı dışında oluşturulanlar gibi.</span><span class="sxs-lookup"><span data-stu-id="728eb-103">Management of all threads is done through the <xref:System.Threading.Thread> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code.</span></span> <span data-ttu-id="728eb-104">Çalışma zamanı, yönetilen yürütme ortamında kod yürütülen hiç olmadığı kadar tüm iş parçacıkları, işlemindeki izler.</span><span class="sxs-lookup"><span data-stu-id="728eb-104">The runtime monitors all the threads in its process that have ever executed code within the managed execution environment.</span></span> <span data-ttu-id="728eb-105">Diğer iş parçacıklarını izlemez.</span><span class="sxs-lookup"><span data-stu-id="728eb-105">It does not track any other threads.</span></span> <span data-ttu-id="728eb-106">İş parçacıkları, COM birlikte çalışma aracılığıyla yönetilen yürütme ortamında girebilirsiniz, (çalışma zamanı yönetilen nesneleri yönetilmeyen dünya çapında COM nesneleri olarak kullanıma sunduğundan), COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) işlevi ve platform çağırma.</span><span class="sxs-lookup"><span data-stu-id="728eb-106">Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) function, and platform invoke.</span></span>  
  
 <span data-ttu-id="728eb-107">Yönetilmeyen bir iş parçacığı, çalışma zamanı aracılığıyla girdiğinde, COM çağrılabilir sarmalayıcısı bir iç yönetilen için aramak için bu iş parçacığının iş parçacığı yerel deposu sistem gibi denetler <xref:System.Threading.Thread> nesne.</span><span class="sxs-lookup"><span data-stu-id="728eb-107">When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <xref:System.Threading.Thread> object.</span></span> <span data-ttu-id="728eb-108">Çalışma zamanı, zaten bulunması durumunda bu iş parçacığı farkındadır.</span><span class="sxs-lookup"><span data-stu-id="728eb-108">If one is found, the runtime is already aware of this thread.</span></span> <span data-ttu-id="728eb-109">Ancak, bir bulamıyorsanız, çalışma zamanı yeni derlemeler <xref:System.Threading.Thread> nesne ve bu iş parçacığının iş parçacığı yerel deposuna yükler.</span><span class="sxs-lookup"><span data-stu-id="728eb-109">If it cannot find one, however, the runtime builds a new <xref:System.Threading.Thread> object and installs it in the thread-local store of that thread.</span></span>  
  
 <span data-ttu-id="728eb-110">Yönetilen iş parçacığı oluşturma, buna <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> kararlı yönetilen iş parçacığı kimliğidir.</span><span class="sxs-lookup"><span data-stu-id="728eb-110">In managed threading, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> is the stable managed thread identification.</span></span> <span data-ttu-id="728eb-111">İş parçacığının ömrü boyunca, bu değeri elde etmek uygulama etki alanı bağımsız olarak diğer tüm iş parçacığından değerle birbiriyle çakışır değil.</span><span class="sxs-lookup"><span data-stu-id="728eb-111">For the lifetime of your thread, it will not collide with the value from any other thread, regardless of the application domain from which you obtain this value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="728eb-112">Bir işletim sistemi **ThreadID** yönetilmeyen bir konak yönetilen ve yönetilmeyen iş parçacıkları arasındaki ilişkiyi kontrol edebildiğiniz yönetilen iş parçacığı sabit ilişkisi yoktur.</span><span class="sxs-lookup"><span data-stu-id="728eb-112">An operating-system **ThreadId** has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="728eb-113">Özellikle karmaşık bir ana bilgisayar aynı işletim sistemi iş parçacığı birçok yönetilen iş parçacıklarını zamanlama veya yönetilen bir diziyi farklı işletim sistemleri iş parçacıkları arasında Fiber API'yi kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="728eb-113">Specifically, a sophisticated host can use the Fiber API to schedule many managed threads against the same operating system thread, or to move a managed thread among different operating system threads.</span></span>  
  
## <a name="mapping-from-win32-threading-to-managed-threading"></a><span data-ttu-id="728eb-114">Yönetilen iş parçacığı için Win32 Threading eşleme</span><span class="sxs-lookup"><span data-stu-id="728eb-114">Mapping from Win32 Threading to Managed Threading</span></span>  
 <span data-ttu-id="728eb-115">Aşağıdaki tabloda, yaklaşık çalışma zamanı için eşdeğer Win32 iş parçacığı öğeleri eşleştirir.</span><span class="sxs-lookup"><span data-stu-id="728eb-115">The following table maps Win32 threading elements to their approximate runtime equivalent.</span></span> <span data-ttu-id="728eb-116">Bu eşleme aynı işlevselliği kapsamadığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="728eb-116">Note that this mapping does not represent identical functionality.</span></span> <span data-ttu-id="728eb-117">Örneğin, **TerminateThread** değil çalıştırma **son** yan tümceleri veya kaynakları boşaltmaya ve önlenemeyen.</span><span class="sxs-lookup"><span data-stu-id="728eb-117">For example, **TerminateThread** does not execute **finally** clauses or free up resources, and cannot be prevented.</span></span> <span data-ttu-id="728eb-118">Ancak, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> tüm geri alma kodu yürütür, tüm kaynaklarını geri kazanır ve kullanarak reddedildi <xref:System.Threading.Thread.ResetAbort%2A>.</span><span class="sxs-lookup"><span data-stu-id="728eb-118">However, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executes all your rollback code, reclaims all the resources, and can be denied using <xref:System.Threading.Thread.ResetAbort%2A>.</span></span> <span data-ttu-id="728eb-119">İşlevler hakkında varsayımlar yapmadan önce yakından belgeleri okuduğunuzdan emin olun.</span><span class="sxs-lookup"><span data-stu-id="728eb-119">Be sure to read the documentation closely before making assumptions about functionality.</span></span>  
  
|<span data-ttu-id="728eb-120">Win32'de</span><span class="sxs-lookup"><span data-stu-id="728eb-120">In Win32</span></span>|<span data-ttu-id="728eb-121">Ortak dil çalışma zamanı</span><span class="sxs-lookup"><span data-stu-id="728eb-121">In the common language runtime</span></span>|  
|--------------|------------------------------------|  
|<span data-ttu-id="728eb-122">**CreateThread**</span><span class="sxs-lookup"><span data-stu-id="728eb-122">**CreateThread**</span></span>|<span data-ttu-id="728eb-123">Birleşimi **iş parçacığı** ve <xref:System.Threading.ThreadStart></span><span class="sxs-lookup"><span data-stu-id="728eb-123">Combination of **Thread** and <xref:System.Threading.ThreadStart></span></span>|  
|<span data-ttu-id="728eb-124">**TerminateThread**</span><span class="sxs-lookup"><span data-stu-id="728eb-124">**TerminateThread**</span></span>|<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="728eb-125">**SuspendThread**</span><span class="sxs-lookup"><span data-stu-id="728eb-125">**SuspendThread**</span></span>|<xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="728eb-126">**ResumeThread**</span><span class="sxs-lookup"><span data-stu-id="728eb-126">**ResumeThread**</span></span>|<xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="728eb-127">**Uyku**</span><span class="sxs-lookup"><span data-stu-id="728eb-127">**Sleep**</span></span>|<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="728eb-128">**WaitForSingleObject** iş parçacığı tutamacı</span><span class="sxs-lookup"><span data-stu-id="728eb-128">**WaitForSingleObject** on the thread handle</span></span>|<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="728eb-129">**ExitThread**</span><span class="sxs-lookup"><span data-stu-id="728eb-129">**ExitThread**</span></span>|<span data-ttu-id="728eb-130">Eşdeğeri</span><span class="sxs-lookup"><span data-stu-id="728eb-130">No equivalent</span></span>|  
|<span data-ttu-id="728eb-131">**GetCurrentThread**</span><span class="sxs-lookup"><span data-stu-id="728eb-131">**GetCurrentThread**</span></span>|<xref:System.Threading.Thread.CurrentThread%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="728eb-132">**SetThreadPriority**</span><span class="sxs-lookup"><span data-stu-id="728eb-132">**SetThreadPriority**</span></span>|<xref:System.Threading.Thread.Priority%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="728eb-133">Eşdeğeri</span><span class="sxs-lookup"><span data-stu-id="728eb-133">No equivalent</span></span>|<xref:System.Threading.Thread.Name%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="728eb-134">Eşdeğeri</span><span class="sxs-lookup"><span data-stu-id="728eb-134">No equivalent</span></span>|<xref:System.Threading.Thread.IsBackground%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="728eb-135">Kapatmak için **CoInitializeEx** (OLE32. DLL)</span><span class="sxs-lookup"><span data-stu-id="728eb-135">Close to **CoInitializeEx** (OLE32.DLL)</span></span>|<xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>|  
  
## <a name="managed-threads-and-com-apartments"></a><span data-ttu-id="728eb-136">Yönetilen iş parçacıkları ve COM apartmanlar</span><span class="sxs-lookup"><span data-stu-id="728eb-136">Managed Threads and COM Apartments</span></span>  
 <span data-ttu-id="728eb-137">Onu barındıracağını belirtmek için bir yönetilen iş parçacığı işaretli bir [tek iş parçacıklı](/windows/desktop/com/single-threaded-apartments) veya [birden çok iş parçacıklı](/windows/desktop/com/multithreaded-apartments) grup.</span><span class="sxs-lookup"><span data-stu-id="728eb-137">A managed thread can be marked to indicate that it will host a [single-threaded](/windows/desktop/com/single-threaded-apartments) or [multithreaded](/windows/desktop/com/multithreaded-apartments) apartment.</span></span> <span data-ttu-id="728eb-138">(Mimarisi, iş parçacığı COM hakkında daha fazla bilgi için bkz: [işlemler, iş parçacıkları ve apartmanlar](https://msdn.microsoft.com/library/windows/desktop/ms693344.aspx).) <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, Ve <xref:System.Threading.Thread.TrySetApartmentState%2A> yöntemlerinin <xref:System.Threading.Thread> sınıfı döndürür ve bir iş parçacığı grubu durumunu atayın.</span><span class="sxs-lookup"><span data-stu-id="728eb-138">(For more information on the COM threading architecture, see [Processes, threads, and Apartments](https://msdn.microsoft.com/library/windows/desktop/ms693344.aspx).) The <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods of the <xref:System.Threading.Thread> class return and assign the apartment state of a thread.</span></span> <span data-ttu-id="728eb-139">Durumu ayarlanmamış ise <xref:System.Threading.Thread.GetApartmentState%2A> döndürür <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="728eb-139">If the state has not been set, <xref:System.Threading.Thread.GetApartmentState%2A> returns <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="728eb-140">Yalnızca iş parçacığı içinde olduğunda özellik ayarlanabilir <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> durum; bir iş parçacığı için yalnızca bir kez ayarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="728eb-140">The property can be set only when the thread is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state; it can be set only once for a thread.</span></span>  
  
 <span data-ttu-id="728eb-141">İş parçacığı başlatılmadan önce Grup durumu ayarlanmazsa, iş parçacığı bir çok iş parçacıklı grubun (MTA) başlatılır.</span><span class="sxs-lookup"><span data-stu-id="728eb-141">If the apartment state is not set before the thread is started, the thread is initialized as a multithreaded apartment (MTA).</span></span> <span data-ttu-id="728eb-142">Sonlandırıcı iş parçacığı ve tüm iş parçacıkları tarafından denetlenen <xref:System.Threading.ThreadPool> MTA olan.</span><span class="sxs-lookup"><span data-stu-id="728eb-142">The finalizer thread and all threads controlled by <xref:System.Threading.ThreadPool> are MTA.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="728eb-143">Uygulama başlangıç koduna için Grup durumu denetlemek için tek yolu uygulamaktır <xref:System.MTAThreadAttribute> veya <xref:System.STAThreadAttribute> yordamı için giriş noktası.</span><span class="sxs-lookup"><span data-stu-id="728eb-143">For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure.</span></span> <span data-ttu-id="728eb-144">.NET Framework 1.0 ve 1.1, <xref:System.Threading.Thread.ApartmentState%2A> özelliği ilk kod satırı ayarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="728eb-144">In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code.</span></span> <span data-ttu-id="728eb-145">Bu, .NET Framework 2.0 sürümünde izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="728eb-145">This is not permitted in the .NET Framework 2.0.</span></span>  
  
 <span data-ttu-id="728eb-146">Ücretsiz iş parçacıklı Sıralayıcı toplanmış com'a yönetilen nesneleri bilgisayarmış gibi.</span><span class="sxs-lookup"><span data-stu-id="728eb-146">Managed objects that are exposed to COM behave as if they had aggregated the free-threaded marshaler.</span></span> <span data-ttu-id="728eb-147">Diğer bir deyişle, bunlar herhangi bir COM Grup serbest iş parçacıklı bir şekilde çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="728eb-147">In other words, they can be called from any COM apartment in a free-threaded manner.</span></span> <span data-ttu-id="728eb-148">Bu ücretsiz iş parçacıklı eylemi sergilemez yalnızca yönetilen nesneler türetilen bu nesnelerdir <xref:System.EnterpriseServices.ServicedComponent> veya <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span><span class="sxs-lookup"><span data-stu-id="728eb-148">The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <xref:System.EnterpriseServices.ServicedComponent> or <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span></span>  
  
 <span data-ttu-id="728eb-149">Yönetilen dünyada için desteği yoktur <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> bağlamları ve bağlam bağlı yönetilen örnekleri kullanmadığınız sürece.</span><span class="sxs-lookup"><span data-stu-id="728eb-149">In the managed world, there is no support for the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> unless you use contexts and context-bound managed instances.</span></span> <span data-ttu-id="728eb-150">Kurumsal Hizmetler kullandığınız sonra nesnenizin öğesinden türetilmelidir <xref:System.EnterpriseServices.ServicedComponent> (hangi kendisini türetilir <xref:System.ContextBoundObject>).</span><span class="sxs-lookup"><span data-stu-id="728eb-150">If you are using Enterprise Services, then your object must derive from <xref:System.EnterpriseServices.ServicedComponent> (which is itself derived from <xref:System.ContextBoundObject>).</span></span>  
  
 <span data-ttu-id="728eb-151">Her zaman yönetilen kod için COM nesneleri çağırdığında, COM kurallara uygun olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="728eb-151">When managed code calls out to COM objects, it always follows COM rules.</span></span> <span data-ttu-id="728eb-152">Diğer bir deyişle, COM grubu proxy'leri ve OLE32 tarafından belirlenen COM + 1.0 bağlam sarmalayıcılar aracılığıyla çağırır.</span><span class="sxs-lookup"><span data-stu-id="728eb-152">In other words, it calls through COM apartment proxies and COM+ 1.0 context wrappers as dictated by OLE32.</span></span>  
  
## <a name="blocking-issues"></a><span data-ttu-id="728eb-153">Engelleme sorunları</span><span class="sxs-lookup"><span data-stu-id="728eb-153">Blocking Issues</span></span>  
 <span data-ttu-id="728eb-154">Bir iş parçacığı işletim sisteminin, yönetilmeyen kod parçacığında engelledi yönetilmeyen bir çağrı yaparsa, çalışma zamanı için denetimini olmayacak <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> veya <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="728eb-154">If a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="728eb-155">Durumunda, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, çalışma zamanı iş parçacığı işaretler **iptal** ve yönetilen kod yeniden girdiğinde denetimini alır.</span><span class="sxs-lookup"><span data-stu-id="728eb-155">In the case of <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, the runtime marks the thread for **Abort** and takes control of it when it re-enters managed code.</span></span> <span data-ttu-id="728eb-156">Bu, yönetilmeyen engelleme yerine yönetilen engelleme kullanabilmeniz için tercih edilir.</span><span class="sxs-lookup"><span data-stu-id="728eb-156">It is preferable for you to use managed blocking rather than unmanaged blocking.</span></span> <span data-ttu-id="728eb-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>ve benzeri için tüm hızlı yanıt veriyorlar <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> ve <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="728eb-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, and so on are all responsive to <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and to <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="728eb-158">Bir tek iş parçacıklı apartmanda, iş parçacığı ise, iş parçacığı engellenir sırasında Ayrıca, bu yönetilen tüm engelleme işlemleri doğru iletileri, grupta pompa.</span><span class="sxs-lookup"><span data-stu-id="728eb-158">Also, if your thread is in a single-threaded apartment, all these managed blocking operations will correctly pump messages in your apartment while your thread is blocked.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="728eb-159">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="728eb-159">See Also</span></span>  
 <xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>  
 <xref:System.Threading.ThreadState>  
 <xref:System.EnterpriseServices.ServicedComponent>  
 <xref:System.Threading.Thread>  
 <xref:System.Threading.Monitor>

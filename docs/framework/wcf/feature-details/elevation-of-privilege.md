---
title: Ayrıcalık Yükseltme
ms.date: 03/30/2017
helpviewer_keywords:
- elevation of privilege [WCF]
- security [WCF], elevation of privilege
ms.assetid: 146e1c66-2a76-4ed3-98a5-fd77851a06d9
ms.openlocfilehash: c71936d087ef046848c75d1fa0638aaafbe43c9a
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33496200"
---
# <a name="elevation-of-privilege"></a><span data-ttu-id="e52fb-102">Ayrıcalık Yükseltme</span><span class="sxs-lookup"><span data-stu-id="e52fb-102">Elevation of Privilege</span></span>
<span data-ttu-id="e52fb-103">*Ayrıcalık yükseltme* izinleri bu başlangıçta verilen ötesinde bir saldırganın yetkilendirme vermesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="e52fb-103">*Elevation of privilege* results from giving an attacker authorization permissions beyond those initially granted.</span></span> <span data-ttu-id="e52fb-104">Örneğin, bir saldırganın bir ayrıcalık kümesi "salt okunur" izinleri ile "okuma ve yazma" içerecek şekilde kümesi şekilde yükseltir</span><span class="sxs-lookup"><span data-stu-id="e52fb-104">For example, an attacker with a privilege set of "read only" permissions somehow elevates the set to include "read and write."</span></span>  
  
## <a name="trusted-sts-should-sign-saml-token-claims"></a><span data-ttu-id="e52fb-105">STS SAML belirteç talep imzalamalısınız güvenilir</span><span class="sxs-lookup"><span data-stu-id="e52fb-105">Trusted STS Should Sign SAML Token Claims</span></span>  
 <span data-ttu-id="e52fb-106">Verilen belirteçler için varsayılan türdür genel bir XML belirteci bir güvenlik onaylar biçimlendirme dili (SAML) belirtecidir.</span><span class="sxs-lookup"><span data-stu-id="e52fb-106">A Security Assertions Markup Language (SAML) token is a generic XML token that is the default type for issued tokens.</span></span> <span data-ttu-id="e52fb-107">SAML belirteci tarafından bir güvenlik belirteci hizmeti (Web hizmeti bitiş tipik Exchange'de güvendiği STS) oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="e52fb-107">A SAML token can be constructed by a Security Token Service (STS) that the end Web service trusts in a typical exchange.</span></span> <span data-ttu-id="e52fb-108">SAML belirteçleri deyimlerinde içerir.</span><span class="sxs-lookup"><span data-stu-id="e52fb-108">SAML tokens contain claims in statements.</span></span> <span data-ttu-id="e52fb-109">Bir saldırgan, uygulamasından geçerli bir belirteç talep kopyalama, yeni bir SAML belirteci oluşturun ve farklı bir veren ile oturum açın.</span><span class="sxs-lookup"><span data-stu-id="e52fb-109">An attacker may copy the claims from a valid token, create a new SAML token, and sign it with a different issuer.</span></span> <span data-ttu-id="e52fb-110">Sunucu verenler doğrulama olup olmadığını belirlemek ve değilse, bu amaçlayan bir güvenilen STS tarafından ötesinde ayrıcalıklarına izin SAML belirteçleri oluşturmak için zayıflık kullanmak için hedefi değil.</span><span class="sxs-lookup"><span data-stu-id="e52fb-110">The intent is to determine whether the server is validating issuers and, if not, utilize the weakness to construct SAML tokens that allow privileges beyond those intended by a trusted STS.</span></span>  
  
 <span data-ttu-id="e52fb-111"><xref:System.IdentityModel.Tokens.SamlAssertion> Sınıfı bir SAML belirtecine ve varsayılan içinde bulunan dijital imzayı doğrular <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> SAML belirteçleri geçerli olduğunda bir X.509 sertifikası tarafından imzalanmış olmasını gerektirir <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> , <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> içinsetsınıfı<xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span><span class="sxs-lookup"><span data-stu-id="e52fb-111">The <xref:System.IdentityModel.Tokens.SamlAssertion> class verifies the digital signature contained within a SAML token, and the default <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> requires that SAML tokens be signed by an X.509 certificate that is valid when the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> of the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> class is set to <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span></span> <span data-ttu-id="e52fb-112">`ChainTrust` tek başına modunda SAML belirteci veren güvenilir olup olmadığını belirlemek için yeterli değil.</span><span class="sxs-lookup"><span data-stu-id="e52fb-112">`ChainTrust` mode alone is insufficient to determine whether the issuer of the SAML token is trusted.</span></span> <span data-ttu-id="e52fb-113">Daha ayrıntılı bir güven modeli ya da gerektirebilirsiniz Hizmetleri verilen belirteç kimlik doğrulaması tarafından üretilen talep kümelerinin veren denetleyin veya üzerinde X.509 doğrulama ayarlarını kullanmak için yetkilendirme ve zorlama ilkelerini kullanmak <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> kümesini kısıtlamak için İmzalama sertifikaları izin verilir.</span><span class="sxs-lookup"><span data-stu-id="e52fb-113">Services that require a more granular trust model can either use authorization and enforcement policies to check the issuer of the claim sets produced by issued token authentication or use the X.509 validation settings on <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> to restrict the set of allowed signing certificates.</span></span> <span data-ttu-id="e52fb-114">Daha fazla bilgi için bkz: [yönetme beyanlar ve yetkilendirmeyi kimlik modeliyle](../../../../docs/framework/wcf/feature-details/managing-claims-and-authorization-with-the-identity-model.md) ve [Federasyon ve verilen belirteçleri](../../../../docs/framework/wcf/feature-details/federation-and-issued-tokens.md).</span><span class="sxs-lookup"><span data-stu-id="e52fb-114">For more information, see [Managing Claims and Authorization with the Identity Model](../../../../docs/framework/wcf/feature-details/managing-claims-and-authorization-with-the-identity-model.md) and [Federation and Issued Tokens](../../../../docs/framework/wcf/feature-details/federation-and-issued-tokens.md).</span></span>  
  
## <a name="switching-identity-without-a-security-context"></a><span data-ttu-id="e52fb-115">Bir güvenlik bağlamı olmadan kimliğini değiştirme</span><span class="sxs-lookup"><span data-stu-id="e52fb-115">Switching Identity Without a Security Context</span></span>  
 <span data-ttu-id="e52fb-116">Aşağıdaki yalnızca geçerli [!INCLUDE[vstecwinfx](../../../../includes/vstecwinfx-md.md)].</span><span class="sxs-lookup"><span data-stu-id="e52fb-116">The following applies only to [!INCLUDE[vstecwinfx](../../../../includes/vstecwinfx-md.md)].</span></span>  
  
 <span data-ttu-id="e52fb-117">Bir istemci ve sunucu, istemci kimliğini arasında bir bağlantı kuran zaman değiştirmez, dışındaki bir durumda: aşağıdaki koşulların tümü doğruysa, WCF istemcisini açtıktan sonra:</span><span class="sxs-lookup"><span data-stu-id="e52fb-117">When a connection is established between a client and server, the identity of the client does not change, except in one situation: after the WCF client is opened, if all of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="e52fb-118">(Aktarım güvenlik oturumu veya ileti güvenlik oturumu kullanarak) bir güvenlik bağlamı kurmak için yordamları işlev kapalı (<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> özelliği ayarlanmış `false` ileti güvenliği veya güvenlik değil kurabilen aktarım durumunda oturumları Aktarım güvenlik durumda kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e52fb-118">The procedures to establish a security context (using a transport security session or message security session) is switched off (<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> property is set to `false` in case of message security or transport not capable of establishing security sessions is used in transport security case.</span></span> <span data-ttu-id="e52fb-119">HTTPS bir tür taşıma örnektir).</span><span class="sxs-lookup"><span data-stu-id="e52fb-119">HTTPS is one example of such transport).</span></span>  
  
-   <span data-ttu-id="e52fb-120">Windows kimlik doğrulaması kullanıyor.</span><span class="sxs-lookup"><span data-stu-id="e52fb-120">You are using Windows authentication.</span></span>  
  
-   <span data-ttu-id="e52fb-121">Açıkça kimlik bilgisi ayarlamayın.</span><span class="sxs-lookup"><span data-stu-id="e52fb-121">You do not explicitly set the credential.</span></span>  
  
-   <span data-ttu-id="e52fb-122">Hizmetin Kimliğine bürünülen güvenlik bağlamı altında aradığınız.</span><span class="sxs-lookup"><span data-stu-id="e52fb-122">You are calling the service under the impersonated security context.</span></span>  
  
 <span data-ttu-id="e52fb-123">Bu koşullar doğru olduğunda, istemci hizmeti için kimlik doğrulaması için kullanılan kimlik değiştirebilirsiniz (bunu Kimliğine bürünülen kimlik ancak işlem kimliği yerine olmayabilir) WCF istemcisini açıldıktan sonra.</span><span class="sxs-lookup"><span data-stu-id="e52fb-123">If these conditions are true, the identity used to authenticate the client to the service might change (it might not be the impersonated identity but the process identity instead) after the WCF client is opened.</span></span> <span data-ttu-id="e52fb-124">Bu, istemci hizmeti için kimlik doğrulaması için kullanılan Windows kimlik bilgileri ile her ileti iletilir ve kimlik doğrulaması için kullanılan kimlik bilgileri geçerli iş parçacığının Windows kimlik elde nedeniyle oluşur.</span><span class="sxs-lookup"><span data-stu-id="e52fb-124">This occurs because the Windows credential used to authenticate the client to the service is transmitted with every message, and the credential used for authentication is obtained from the current thread's Windows identity.</span></span> <span data-ttu-id="e52fb-125">Geçerli iş parçacığının Windows kimliğini (örneğin, farklı çağıran kimliğine bürünerek) değişirse iletisine ve hizmet için istemci kimlik doğrulaması için kullanılan kimlik bilgisini de değişebilir.</span><span class="sxs-lookup"><span data-stu-id="e52fb-125">If the Windows identity of the current thread changes (for example, by impersonating a different caller), the credential that is attached to the message and used to authenticate the client to the service might also change.</span></span>  
  
 <span data-ttu-id="e52fb-126">Kimliğe bürünme ile birlikte Windows kimlik doğrulamasını kullanırken belirleyici davranışı sahip olmak istiyorsanız açıkça Windows kimlik bilgilerini ayarlamanız gerekir veya bir güvenlik bağlamı hizmetiyle oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="e52fb-126">If you want to have deterministic behavior when using Windows authentication together with impersonation you need to explicitly set the Windows credential or you need to establish a security context with the service.</span></span> <span data-ttu-id="e52fb-127">Bunu yapmak için bir ileti güvenlik oturumu veya bir aktarım güvenlik oturumu kullanın.</span><span class="sxs-lookup"><span data-stu-id="e52fb-127">To do this, use a message security session or a transport security session.</span></span> <span data-ttu-id="e52fb-128">Örneğin, net.tcp aktarım taşıma güvenlik oturumu sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="e52fb-128">For example, the net.tcp transport can provide a transport security session.</span></span> <span data-ttu-id="e52fb-129">Ayrıca, hizmeti çağrılırken istemci işlemleri zaman uyumlu bir sürümünü kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="e52fb-129">Additionally, you must use only a synchronous version of client operations when calling the service.</span></span> <span data-ttu-id="e52fb-130">Bir ileti güvenlik bağlamı kurmak, kimliğini de oturum yenileme işlemi sırasında değişebildiğinden, hizmeti bağlantısı yapılandırılmış oturum yenileme süresini daha uzun açık tutmalısınız değil.</span><span class="sxs-lookup"><span data-stu-id="e52fb-130">If you establish a message security context, you should not keep the connection to the service open longer than the configured session renewal period, because the identity can also change during the session renewal process.</span></span>  
  
### <a name="credentials-capture"></a><span data-ttu-id="e52fb-131">Kimlik bilgilerini yakalama</span><span class="sxs-lookup"><span data-stu-id="e52fb-131">Credentials Capture</span></span>  
 <span data-ttu-id="e52fb-132">Aşağıdaki uygulandığı [!INCLUDE[netfx35_long](../../../../includes/netfx35-long-md.md)]ve sonraki sürümleri.</span><span class="sxs-lookup"><span data-stu-id="e52fb-132">The following applies to [!INCLUDE[netfx35_long](../../../../includes/netfx35-long-md.md)], and subsequent versions.</span></span>  
  
 <span data-ttu-id="e52fb-133">Kimlik bilgileri istemci tarafından kullanılan veya hizmet, geçerli bağlam iş parçacığı üzerinde dayalı.</span><span class="sxs-lookup"><span data-stu-id="e52fb-133">Credentials used by the client or the service are based on the current context thread.</span></span> <span data-ttu-id="e52fb-134">Kimlik bilgileri ne zaman elde edilen `Open` yöntemi (veya `BeginOpen`, zaman uyumsuz çağrılar için) istemci veya hizmet adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="e52fb-134">The credentials are obtained when the `Open` method (or `BeginOpen`, for asynchronous calls) of the client or service is called.</span></span> <span data-ttu-id="e52fb-135">Her ikisi için de <xref:System.ServiceModel.ServiceHost> ve <xref:System.ServiceModel.ClientBase%601> sınıfları `Open` ve `BeginOpen` yöntemleri devral <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> ve <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> yöntemlerinin <xref:System.ServiceModel.Channels.CommunicationObject> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="e52fb-135">For both the <xref:System.ServiceModel.ServiceHost> and <xref:System.ServiceModel.ClientBase%601> classes, the `Open` and `BeginOpen` methods inherit from the <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> methods of the <xref:System.ServiceModel.Channels.CommunicationObject> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e52fb-136">Kullanırken `BeginOpen` yöntemi, yakalanan kimlik bilgilerini garanti edilemediği yöntemini çağırır işlem kimlik bilgileri olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e52fb-136">When using the `BeginOpen` method, the credentials captured cannot be guaranteed to be the credentials of the process that calls the method.</span></span>  
  
## <a name="token-caches-allow-replay-using-obsolete-data"></a><span data-ttu-id="e52fb-137">Belirteç önbellekleri kullanarak eski verileri yeniden yürütme izin ver</span><span class="sxs-lookup"><span data-stu-id="e52fb-137">Token Caches Allow Replay Using Obsolete Data</span></span>  
 <span data-ttu-id="e52fb-138">WCF yerel güvenlik yetkilisi (LSA) kullanan `LogonUser` kullanıcı adı ve parola ile kullanıcıların kimliklerini doğrulamak için işlev.</span><span class="sxs-lookup"><span data-stu-id="e52fb-138">WCF uses the local security authority (LSA) `LogonUser` function to authenticate users by user name and password.</span></span> <span data-ttu-id="e52fb-139">Oturum açma işlevini pahalı bir işlem olduğundan, WCF temsil eden önbellek belirteçleri için performansı artırmak için kullanıcıların kimlik doğrulaması sağlar.</span><span class="sxs-lookup"><span data-stu-id="e52fb-139">Because the logon function is a costly operation, WCF allows you to cache tokens that represent authenticated users to increase performance.</span></span> <span data-ttu-id="e52fb-140">Önbelleğe alma mekanizması sonuçlarından kaydeder `LogonUser` sonraki kullanımlar için.</span><span class="sxs-lookup"><span data-stu-id="e52fb-140">The caching mechanism saves the results from `LogonUser` for subsequent uses.</span></span> <span data-ttu-id="e52fb-141">Bu düzenek, varsayılan olarak devre dışıdır; etkinleştirmek için ayarlanmış <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> özelliğine `true`, veya `cacheLogonTokens` özniteliği [ \<userNameAuthentication >](../../../../docs/framework/configure-apps/file-schema/wcf/usernameauthentication.md).</span><span class="sxs-lookup"><span data-stu-id="e52fb-141">This mechanism is disabled by default; to enable it, set the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> property to `true`, or use the `cacheLogonTokens` attribute of the [\<userNameAuthentication>](../../../../docs/framework/configure-apps/file-schema/wcf/usernameauthentication.md).</span></span>  
  
 <span data-ttu-id="e52fb-142">Ayarlayarak için önbelleğe alınmış belirteçleri Live (TTL) bir süresini ayarlayabilirsiniz <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> özelliğine bir <xref:System.TimeSpan>, veya `cachedLogonTokenLifetime` özniteliği `userNameAuthentication` öğesi; varsayılan değer 15 dakikadır.</span><span class="sxs-lookup"><span data-stu-id="e52fb-142">You can set a Time to Live (TTL) for the cached tokens by setting the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> property to a <xref:System.TimeSpan>, or use the `cachedLogonTokenLifetime` attribute of the `userNameAuthentication` element; the default is 15 minutes.</span></span> <span data-ttu-id="e52fb-143">Bir belirteç önbelleğe olsa da, aynı kullanıcı adı ve parola sunan herhangi bir istemci bir belirteç kullanıcı hesabı Windows'dan silinse bile veya parolasını değiştirdiyseniz kullanabileceğinizi unutmayın.</span><span class="sxs-lookup"><span data-stu-id="e52fb-143">Note that while a token is cached, any client that presents the same user name and password can use the token, even if the user account is deleted from Windows or if its password has been changed.</span></span> <span data-ttu-id="e52fb-144">TTL süresi ve belirteç önbellekten kaldırıldı kadar WCF (büyük olasılıkla kötü amaçlı) kullanıcının kimlik doğrulamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="e52fb-144">Until the TTL expires and the token is removed from the cache, WCF allows the (possibly malicious) user to authenticate.</span></span>  
  
 <span data-ttu-id="e52fb-145">Bunu azaltmak için: ayarlayarak saldırı penceresini azaltmak `cachedLogonTokenLifetime` en kısa süre değerine span kullanıcılar gereksiniminizi.</span><span class="sxs-lookup"><span data-stu-id="e52fb-145">To mitigate this: Decrease the attack window by setting the `cachedLogonTokenLifetime` value to the shortest time span your users need.</span></span>  
  
## <a name="issued-token-authorization-expiration-reset-to-large-value"></a><span data-ttu-id="e52fb-146">Verilen belirteç yetkilendirme: Büyük değer sona erme Sıfırla</span><span class="sxs-lookup"><span data-stu-id="e52fb-146">Issued Token Authorization: Expiration Reset to Large Value</span></span>  
 <span data-ttu-id="e52fb-147">Belirli koşullar altında <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> özelliği <xref:System.IdentityModel.Policy.AuthorizationContext> beklenmedik bir şekilde daha büyük bir değere ayarlanabilir ( <xref:System.DateTime.MaxValue> alan değer eksi bir günden veya 20 Aralık 9999).</span><span class="sxs-lookup"><span data-stu-id="e52fb-147">Under certain conditions, the <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> property of the <xref:System.IdentityModel.Policy.AuthorizationContext> may be set to an unexpectedly larger value (the <xref:System.DateTime.MaxValue> field value minus one day, or December 20, 9999).</span></span>  
  
 <span data-ttu-id="e52fb-148">Bu kullanırken oluşur <xref:System.ServiceModel.WSFederationHttpBinding> ve kimlik bilgisi herhangi bir istemci olarak verilen bir belirteç olan sistem tarafından sağlanan bağlamalar türü.</span><span class="sxs-lookup"><span data-stu-id="e52fb-148">This occurs when using the <xref:System.ServiceModel.WSFederationHttpBinding> and any of the system-provided bindings that have an issued token as the client credential type.</span></span>  
  
 <span data-ttu-id="e52fb-149">Bu ayrıca, aşağıdaki yöntemlerden birini kullanarak özel bağlama oluşturma oluşur:</span><span class="sxs-lookup"><span data-stu-id="e52fb-149">This also occurs when you create custom bindings by using one of the following methods:</span></span>  
  
-   <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenBindingElement%2A>  
  
-   <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement%2A>  
  
-   <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement%2A>  
  
-   <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement%2A>  
  
 <span data-ttu-id="e52fb-150">Bunu azaltmak için yetkilendirme ilkesi, eylem ve süre sonu zamanı her yetkilendirme ilkesinin denetlemelisiniz.</span><span class="sxs-lookup"><span data-stu-id="e52fb-150">To mitigate this, the authorization policy must check the action and the expiration time of each authorization policy.</span></span>  
  
## <a name="the-service-uses-a-different-certificate-than-the-client-intended"></a><span data-ttu-id="e52fb-151">Hizmet, istemci istenen değerinden farklı bir sertifika kullanır.</span><span class="sxs-lookup"><span data-stu-id="e52fb-151">The Service Uses a Different Certificate Than the Client Intended</span></span>  
 <span data-ttu-id="e52fb-152">Belirli koşullar altında bir istemci dijital olarak bir X.509 sertifikası içeren bir ileti oturum ve hedeflenen olandan farklı bir sertifika almak hizmet olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e52fb-152">Under certain conditions, a client can digitally sign a message with an X.509 certificate and have the service retrieve a different certificate than the intended one.</span></span>  
  
 <span data-ttu-id="e52fb-153">Bu şu durumlarda oluşabilir:</span><span class="sxs-lookup"><span data-stu-id="e52fb-153">This can occur under the following circumstances:</span></span>  
  
-   <span data-ttu-id="e52fb-154">İstemci bir X.509 sertifikası kullanarak ileti dijital imzalar ve X.509 sertifikası iletiye eklemek değil, ancak yerine yalnızca kendi konu anahtarı tanımlayıcısı kullanarak sertifikaya başvurur.</span><span class="sxs-lookup"><span data-stu-id="e52fb-154">The client digitally signs a message using an X.509 certificate and does not attach the X.509 certificate to the message, but rather just references the certificate using its subject key identifier.</span></span>  
  
-   <span data-ttu-id="e52fb-155">Hizmetin bilgisayar aynı ortak anahtara sahip iki veya daha fazla sertifikaları içerir, ancak farklı bilgiler içerir.</span><span class="sxs-lookup"><span data-stu-id="e52fb-155">The service's computer contains two or more certificates with the same public key, but they contain different information.</span></span>  
  
-   <span data-ttu-id="e52fb-156">Konu anahtarı tanımlayıcısı eşleşen bir sertifika hizmet alır, ancak istemci kullanmak için amaçlanan bir değil.</span><span class="sxs-lookup"><span data-stu-id="e52fb-156">The service retrieves a certificate that matches the subject key identifier, but it is not the one the client intended to use.</span></span> <span data-ttu-id="e52fb-157">WCF ileti alır ve imzayı doğrular, WCF istenmeyen X.509 sertifikası bilgileri ne istemcisi beklenenden farklı ve büyük olasılıkla yükseltilmiş talepler kümesi eşler.</span><span class="sxs-lookup"><span data-stu-id="e52fb-157">When WCF receives the message and verifies the signature, WCF maps the information in the unintended X.509 certificate to a set of claims that are different and potentially elevated from what the client expected.</span></span>  
  
 <span data-ttu-id="e52fb-158">Başvuru X.509 Sertifika kullanarak gibi başka bir yolu, bunu azaltmak için <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span><span class="sxs-lookup"><span data-stu-id="e52fb-158">To mitigate this, reference the X.509 certificate another way, such as using <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e52fb-159">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="e52fb-159">See Also</span></span>  
 [<span data-ttu-id="e52fb-160">Güvenlik Konuları</span><span class="sxs-lookup"><span data-stu-id="e52fb-160">Security Considerations</span></span>](../../../../docs/framework/wcf/feature-details/security-considerations-in-wcf.md)  
 [<span data-ttu-id="e52fb-161">Bilgilerin Açığa Çıkması</span><span class="sxs-lookup"><span data-stu-id="e52fb-161">Information Disclosure</span></span>](../../../../docs/framework/wcf/feature-details/information-disclosure.md)  
 [<span data-ttu-id="e52fb-162">Hizmet Reddi</span><span class="sxs-lookup"><span data-stu-id="e52fb-162">Denial of Service</span></span>](../../../../docs/framework/wcf/feature-details/denial-of-service.md)  
 [<span data-ttu-id="e52fb-163">Yeniden Yürütme Saldırıları</span><span class="sxs-lookup"><span data-stu-id="e52fb-163">Replay Attacks</span></span>](../../../../docs/framework/wcf/feature-details/replay-attacks.md)  
 [<span data-ttu-id="e52fb-164">İzinsiz Değişiklik</span><span class="sxs-lookup"><span data-stu-id="e52fb-164">Tampering</span></span>](../../../../docs/framework/wcf/feature-details/tampering.md)  
 [<span data-ttu-id="e52fb-165">Desteklenmeyen Senaryolar</span><span class="sxs-lookup"><span data-stu-id="e52fb-165">Unsupported Scenarios</span></span>](../../../../docs/framework/wcf/feature-details/unsupported-scenarios.md)

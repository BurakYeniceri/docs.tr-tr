---
title: "Sınıflar ve nesneler C# ' ta - C# dili turu"
description: "C# yeni misiniz? Bu sınıf, nesneler ve devralma genel bakış"
keywords: ".NET, csharp, sınıf, örneği, nesne, devralma, çok biçimlilik"
author: BillWagner
ms.author: wiwagn
ms.date: 08/10/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.openlocfilehash: 37e04e918ead283f474899a9421aee2140ab7c11
ms.sourcegitcommit: 5fb6646b5ee3769ffb214e672041833ea4ceeb26
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/08/2017
---
# <a name="classes-and-objects"></a><span data-ttu-id="e2309-105">Sınıflar ve nesneler</span><span class="sxs-lookup"><span data-stu-id="e2309-105">Classes and objects</span></span>

<span data-ttu-id="e2309-106">*Sınıfları* olan en temel C# ' ın türü.</span><span class="sxs-lookup"><span data-stu-id="e2309-106">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="e2309-107">Bir sınıf durumu (alanları) ve eylemleri (yöntemleri ve diğer işlevi üyeleri) birleştiren bir veri yapısı içinde tek bir birimdir.</span><span class="sxs-lookup"><span data-stu-id="e2309-107">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="e2309-108">Dinamik olarak oluşturulan için bir sınıf tanımı sağlar *örnekleri* olarak da bilinen sınıfının *nesneleri*.</span><span class="sxs-lookup"><span data-stu-id="e2309-108">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="e2309-109">Destek sınıfları *devralma* ve *çok biçimlilik*, mekanizmaları yapabildiği *türetilmiş sınıfları* genişletmek ve özelleştirmek *temel sınıflar*.</span><span class="sxs-lookup"><span data-stu-id="e2309-109">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="e2309-110">Yeni sınıflar sınıf bildirimleri kullanılarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="e2309-110">New classes are created using class declarations.</span></span> <span data-ttu-id="e2309-111">Sınıf bildirimi öznitelikleri ve sınıfın değiştiricileri, sınıfı, temel sınıfı (belirtilmişse) ve sınıf tarafından uygulanan arabirimler adını belirten bir başlık başlar.</span><span class="sxs-lookup"><span data-stu-id="e2309-111">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="e2309-112">Üstbilgi arasında sınırlayıcıları yazılmış üye bildirimleri listesini oluşan sınıf gövdesi arkasından `{` ve `}`.</span><span class="sxs-lookup"><span data-stu-id="e2309-112">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="e2309-113">Aşağıdaki adlı basit bir sınıf bildirimidir `Point`:</span><span class="sxs-lookup"><span data-stu-id="e2309-113">The following is a declaration of a simple class named `Point`:</span></span>

[!code-csharp[PointClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]

<span data-ttu-id="e2309-114">Sınıfların örneklerini kullanarak oluşturulur `new` bellek için yeni bir örnek ayırır, işleci örneği başlatmak için bir oluşturucu çağırır ve örneğine başvuru döndürür.</span><span class="sxs-lookup"><span data-stu-id="e2309-114">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="e2309-115">Aşağıdaki deyimleri iki nokta nesneleri oluşturmak ve bu nesnelere başvurular iki değişken depolamak:</span><span class="sxs-lookup"><span data-stu-id="e2309-115">The following statements create two Point objects and store references to those objects in two variables:</span></span>

[!code-csharp[PointExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]

<span data-ttu-id="e2309-116">Nesne artık erişilebilir olduğunda bir nesnenin kapladığı bellek otomatik olarak geri.</span><span class="sxs-lookup"><span data-stu-id="e2309-116">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="e2309-117">Ne gerekli ya da açıkça C# nesneleri serbest bırakma mümkün değil.</span><span class="sxs-lookup"><span data-stu-id="e2309-117">It is neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="e2309-118">Üyeler</span><span class="sxs-lookup"><span data-stu-id="e2309-118">Members</span></span>

<span data-ttu-id="e2309-119">Statik üyeler veya örnek üyelerin bir sınıf üyeleridir.</span><span class="sxs-lookup"><span data-stu-id="e2309-119">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="e2309-120">Statik üyeler sınıflarına ait ve örnek üyelerin (sınıfların örneklerini) nesnelere ait.</span><span class="sxs-lookup"><span data-stu-id="e2309-120">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="e2309-121">Bir sınıf içerebilir üyeleri tür genel bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="e2309-121">The following provides an overview of the kinds of members a class can contain.</span></span>

* <span data-ttu-id="e2309-122">Sabitler</span><span class="sxs-lookup"><span data-stu-id="e2309-122">Constants</span></span>
    - <span data-ttu-id="e2309-123">Sınıfıyla ilişkili sabit değerler</span><span class="sxs-lookup"><span data-stu-id="e2309-123">Constant values associated with the class</span></span>
* <span data-ttu-id="e2309-124">Alanlar</span><span class="sxs-lookup"><span data-stu-id="e2309-124">Fields</span></span>
    - <span data-ttu-id="e2309-125">Sınıfının değişkenleri</span><span class="sxs-lookup"><span data-stu-id="e2309-125">Variables of the class</span></span>
* <span data-ttu-id="e2309-126">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="e2309-126">Methods</span></span>
    - <span data-ttu-id="e2309-127">Hesaplamalar ve sınıf tarafından gerçekleştirilen eylemler</span><span class="sxs-lookup"><span data-stu-id="e2309-127">Computations and actions that can be performed by the class</span></span>
* <span data-ttu-id="e2309-128">Özellikler</span><span class="sxs-lookup"><span data-stu-id="e2309-128">Properties</span></span>
    - <span data-ttu-id="e2309-129">Okuma ve yazma sınıfının adlandırılmış özellikleri ile ilişkili eylemler</span><span class="sxs-lookup"><span data-stu-id="e2309-129">Actions associated with reading and writing named properties of the class</span></span>
* <span data-ttu-id="e2309-130">Dizin Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="e2309-130">Indexers</span></span>
    - <span data-ttu-id="e2309-131">Dizin oluşturma sınıfın örnekleri, bir dizi gibi ilişkili eylemler</span><span class="sxs-lookup"><span data-stu-id="e2309-131">Actions associated with indexing instances of the class like an array</span></span>
* <span data-ttu-id="e2309-132">Olaylar</span><span class="sxs-lookup"><span data-stu-id="e2309-132">Events</span></span>
    - <span data-ttu-id="e2309-133">Sınıfı tarafından oluşturulan bildirimleri</span><span class="sxs-lookup"><span data-stu-id="e2309-133">Notifications that can be generated by the class</span></span>
* <span data-ttu-id="e2309-134">İşleçler</span><span class="sxs-lookup"><span data-stu-id="e2309-134">Operators</span></span>
    - <span data-ttu-id="e2309-135">Dönüşümler ve sınıf tarafından desteklenen ifade işleçleri</span><span class="sxs-lookup"><span data-stu-id="e2309-135">Conversions and expression operators supported by the class</span></span>
* <span data-ttu-id="e2309-136">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="e2309-136">Constructors</span></span>
    - <span data-ttu-id="e2309-137">Sınıf veya sınıf örneği başlatmak için gerekli eylemleri</span><span class="sxs-lookup"><span data-stu-id="e2309-137">Actions required to initialize instances of the class or the class itself</span></span>
* <span data-ttu-id="e2309-138">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="e2309-138">Finalizers</span></span>
    - <span data-ttu-id="e2309-139">Sınıfın örnekleri, kalıcı olarak atılmadan önce gerçekleştirilecek eylemler</span><span class="sxs-lookup"><span data-stu-id="e2309-139">Actions to perform before instances of the class are permanently discarded</span></span>
* <span data-ttu-id="e2309-140">Türler</span><span class="sxs-lookup"><span data-stu-id="e2309-140">Types</span></span>
    - <span data-ttu-id="e2309-141">Sınıfı tarafından bildirilen iç içe geçmiş türler</span><span class="sxs-lookup"><span data-stu-id="e2309-141">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="e2309-142">Erişilebilirlik</span><span class="sxs-lookup"><span data-stu-id="e2309-142">Accessibility</span></span>

<span data-ttu-id="e2309-143">Her bir sınıf üyesi üye erişebilen program metin bölümlerinin denetimleri bir ilişkili erişilebilirlik sahiptir.</span><span class="sxs-lookup"><span data-stu-id="e2309-143">Each member of a class has an associated accessibility, which controls the regions of program text that are able to access the member.</span></span> <span data-ttu-id="e2309-144">Erişilebilirlik beş olası form vardır.</span><span class="sxs-lookup"><span data-stu-id="e2309-144">There are five possible forms of accessibility.</span></span> <span data-ttu-id="e2309-145">Bunlar, aşağıda özetlenmiştir.</span><span class="sxs-lookup"><span data-stu-id="e2309-145">These are summarized below.</span></span>

* `public`
    - <span data-ttu-id="e2309-146">Değil sınırlı erişim</span><span class="sxs-lookup"><span data-stu-id="e2309-146">Access not limited</span></span>
* `protected`
    - <span data-ttu-id="e2309-147">Bu sınıf veya sınıfların sınırlı erişim bu sınıfından türetilen</span><span class="sxs-lookup"><span data-stu-id="e2309-147">Access limited to this class or classes derived from this class</span></span>
* `internal`
    - <span data-ttu-id="e2309-148">Geçerli derlemeye (.exe, .dll, vb.) sınırlı erişim</span><span class="sxs-lookup"><span data-stu-id="e2309-148">Access limited to the current assembly (.exe, .dll, etc.)</span></span>
* `protected internal`
    - <span data-ttu-id="e2309-149">İçeren sınıf veya sınıfların sınırlı erişim içeren sınıfından türetilen</span><span class="sxs-lookup"><span data-stu-id="e2309-149">Access limited to the containing class or classes derived from the containing class</span></span>
* `private`
    - <span data-ttu-id="e2309-150">Bu sınıf için sınırlı erişim</span><span class="sxs-lookup"><span data-stu-id="e2309-150">Access limited to this class</span></span>
* `private protected`
    - <span data-ttu-id="e2309-151">İçeren sınıf veya sınıfların sınırlı erişim aynı bütünleştirilmiş kodda içeren türü withing türetilmiş</span><span class="sxs-lookup"><span data-stu-id="e2309-151">Access limited to the containing class or classes derived from the containing type withing the same assembly</span></span>

## <a name="type-parameters"></a><span data-ttu-id="e2309-152">Tür parametreleri</span><span class="sxs-lookup"><span data-stu-id="e2309-152">Type parameters</span></span>

<span data-ttu-id="e2309-153">Bir sınıf tanımı sınıf adı köşeli ayraç tür parametre adları listesini kapsayan izleyerek türü parametreleri kümesini belirtebilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-153">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="e2309-154">Tür parametreleri ardından sınıf bildirimleri gövdesinde sınıfı üyeleri tanımlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e2309-154">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="e2309-155">Aşağıdaki örnekte, tür parametrelerini `Pair` olan `TFirst` ve `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="e2309-155">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

[!code-csharp[Pair](../../../samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]

<span data-ttu-id="e2309-156">Tür parametreleri almak için bildirilen bir sınıf türü olarak adlandırılan bir *genel bir sınıf türü*.</span><span class="sxs-lookup"><span data-stu-id="e2309-156">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="e2309-157">Yapı, arabirim ve temsilci türleri genel olabilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-157">Struct, interface and delegate types can also be generic.</span></span>
<span data-ttu-id="e2309-158">Genel sınıfı kullanıldığında, tür bağımsız değişkenleri her tür parametreleri için sağlanmalıdır:</span><span class="sxs-lookup"><span data-stu-id="e2309-158">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

[!code-csharp[PairExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]

<span data-ttu-id="e2309-159">Tür bağımsız değişkenleri gibi sağlanan ile genel tür `Pair<int,string>` yukarıdaki adlı bir *oluşturulan türü*.</span><span class="sxs-lookup"><span data-stu-id="e2309-159">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="e2309-160">Temel sınıflar</span><span class="sxs-lookup"><span data-stu-id="e2309-160">Base classes</span></span>

<span data-ttu-id="e2309-161">Sınıf bildirimi bir taban sınıf sınıf adını ve türünü parametrelerle bir iki nokta üst üste ve temel sınıfın adını izleyerek belirtebilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-161">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="e2309-162">Bir temel sınıf belirtimi atlama aynıdır türünden türetme `object`.</span><span class="sxs-lookup"><span data-stu-id="e2309-162">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="e2309-163">Aşağıdaki örnekte, temel sınıfını `Point3D` olan `Point`ve temel sınıfını `Point` olan `object`:</span><span class="sxs-lookup"><span data-stu-id="e2309-163">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

[!code-csharp[Point3DClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]

<span data-ttu-id="e2309-164">Bir sınıf devralınabilir. taban sınıfı üyeleri devralır.</span><span class="sxs-lookup"><span data-stu-id="e2309-164">A class inherits the members of its base class.</span></span> <span data-ttu-id="e2309-165">Devralma bir sınıf dolaylı olarak temel sınıfı olan örneği ve statik oluşturucular ve sonlandırıcılar taban sınıfın dışında tüm üyelerini içerir anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="e2309-165">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="e2309-166">Türetilmiş bir sınıf yeni üyeler devralır olanlar ekleyebilirsiniz, ancak bir devralınan üye tanımının kaldıramazsınız.</span><span class="sxs-lookup"><span data-stu-id="e2309-166">A derived class can add new members to those it inherits, but it cannot remove the definition of an inherited member.</span></span> <span data-ttu-id="e2309-167">Önceki örnekte, `Point3D` devralır `x` ve `y` alanlarını `Point`ve her `Point3D` örneği üç alanları içeren `x`, `y`, ve `z`.</span><span class="sxs-lookup"><span data-stu-id="e2309-167">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="e2309-168">Örtük bir dönüştürme bir sınıf türünden temel sınıf türlerinden birine bulunmaktadır.</span><span class="sxs-lookup"><span data-stu-id="e2309-168">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="e2309-169">Bu nedenle, bir sınıf türünde bir değişken bu sınıfının bir örneği veya türetilmiş bir sınıf örneği başvuruda bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-169">Therefore, a variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="e2309-170">Örneğin, önceki sınıf bildirimleri türünde bir değişken verilen `Point` ya da başvurabilirsiniz bir `Point` veya `Point3D`:</span><span class="sxs-lookup"><span data-stu-id="e2309-170">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

[!code-csharp[Point3DExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]

## <a name="fields"></a><span data-ttu-id="e2309-171">Alanlar</span><span class="sxs-lookup"><span data-stu-id="e2309-171">Fields</span></span>

<span data-ttu-id="e2309-172">A *alan* bir sınıf veya sınıfının bir örneği ile ilişkili bir değişkendir.</span><span class="sxs-lookup"><span data-stu-id="e2309-172">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="e2309-173">Statik değiştirici ile bildirilen alan statik bir alana tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e2309-173">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="e2309-174">Statik bir alana tam olarak bir depolama konumu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e2309-174">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="e2309-175">Kaç tane bir sınıf örneğinin oluşturulduğu olsun, statik bir alana yalnızca hiç bir kopyası yoktur.</span><span class="sxs-lookup"><span data-stu-id="e2309-175">No matter how many instances of a class are created, there is only ever one copy of a static field.</span></span>

<span data-ttu-id="e2309-176">Statik değiştirici bildirilen alan bir örnek alanı tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e2309-176">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="e2309-177">Sınıfın her örneği bu sınıfın tüm örneği alanları ayrı bir kopyasını içerir.</span><span class="sxs-lookup"><span data-stu-id="e2309-177">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="e2309-178">Aşağıdaki örnekte, her örneği `Color` sınıfına sahip ayrı bir kopyasını `r`, `g`, ve `b` örneği alanları, ancak yalnızca bir kopyası yok `Black`, `White`, `Red`, `Green`, ve `Blue` statik alanları:</span><span class="sxs-lookup"><span data-stu-id="e2309-178">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there is only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

[!code-csharp[ColorClass](../../../samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]

<span data-ttu-id="e2309-179">Önceki örnekte gösterildiği gibi *salt okunur alanları* ile bildirilen bir `readonly` değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="e2309-179">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="e2309-180">Atamaya bir `readonly` alan parçası olarak alanın bildirimi veya aynı sınıfta oluşturucuda yalnızca oluşabilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-180">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="e2309-181">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="e2309-181">Methods</span></span>

<span data-ttu-id="e2309-182">A *yöntemi* bir hesaplama ya da nesne veya sınıf tarafından gerçekleştirilen eylem uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="e2309-182">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="e2309-183">*Statik yöntemler* sınıfı aracılığıyla erişilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-183">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="e2309-184">*Örnek yöntemleri* sınıfın bir örneği erişilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-184">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="e2309-185">Yöntemleri listesini olabilir *parametreleri*, değerleri veya yönteme geçirilen değişken başvuruları temsil ve *dönüş türü*, hesaplanan ve yöntem tarafından döndürülen değerin türü belirtir.</span><span class="sxs-lookup"><span data-stu-id="e2309-185">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="e2309-186">Bir yöntemin dönüş türü `void` bir değer döndürmezse.</span><span class="sxs-lookup"><span data-stu-id="e2309-186">A method’s return type is `void` if it does not return a value.</span></span>

<span data-ttu-id="e2309-187">Türleri gibi yöntemleri yöntemi çağrıldığında tür bağımsız değişkeni belirtilen gerekir türü parametreleri kümesini de olabilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-187">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="e2309-188">Türleri, farklı tür bağımsız değişkeni bir yöntem çağrısı bağımsız değişkenlerden genellikle çıkarsanabileceği ve açıkça verilmemiş.</span><span class="sxs-lookup"><span data-stu-id="e2309-188">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="e2309-189">*İmza* yöntemi yöntemi bildirilmiş sınıfında benzersiz olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e2309-189">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="e2309-190">Bir yöntemin imzası tür parametreleri ve sayısı, değiştiricileri ve türleri parametrelerinin sayısı yöntemin adını oluşur.</span><span class="sxs-lookup"><span data-stu-id="e2309-190">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="e2309-191">İmza bir yöntemin dönüş türü içermez.</span><span class="sxs-lookup"><span data-stu-id="e2309-191">The signature of a method does not include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="e2309-192">Parametreler</span><span class="sxs-lookup"><span data-stu-id="e2309-192">Parameters</span></span>

<span data-ttu-id="e2309-193">Parametre değerleri veya değişken başvuruları yöntemlere geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e2309-193">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="e2309-194">Bir yöntemin parametrelerini gerçek değerlerine alma *bağımsız değişkenleri* yöntemi çağrıldığında belirtilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-194">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="e2309-195">Parametreleri dört tür vardır: değer parametreleri, başvuru parametreleri, çıktı parametreleri ve parametre dizileri.</span><span class="sxs-lookup"><span data-stu-id="e2309-195">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="e2309-196">A *değer parametresi* giriş bağımsız değişkenleri geçirme kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e2309-196">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="e2309-197">Bir değer parametresini karşılık gelen bir yerel değişkene parametresi için geçirilen bağımsız değişken başlangıç değerini alır.</span><span class="sxs-lookup"><span data-stu-id="e2309-197">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="e2309-198">Bir değer parametresini değişiklikler parametresi için geçirilen bağımsız değişken etkilemez.</span><span class="sxs-lookup"><span data-stu-id="e2309-198">Modifications to a value parameter do not affect the argument that was passed for the parameter.</span></span> 

<span data-ttu-id="e2309-199">Böylece karşılık gelen bağımsız değişkenleri atlanabilir varsayılan bir değer belirterek değer parametreleri isteğe bağlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-199">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="e2309-200">A *parametresi başvuru* başvuruya göre bağımsız değişkenleri geçirme kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e2309-200">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="e2309-201">Bir başvuru parametresi için geçirilen bağımsız değişken kesin bir değere sahip bir değişken olmalıdır ve yönteminin yürütülmesi sırasında başvuru parametre bağımsız değişken olarak aynı depolama konumunu temsil eder.</span><span class="sxs-lookup"><span data-stu-id="e2309-201">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="e2309-202">Bir başvuru parametresi ile bildirilmiş `ref` değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="e2309-202">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="e2309-203">Aşağıdaki örnek kullanımı gösterilmiştir `ref` parametreleri.</span><span class="sxs-lookup"><span data-stu-id="e2309-203">The following example shows the use of `ref` parameters.</span></span>

[!code-csharp[swapExample](../../../samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]

<span data-ttu-id="e2309-204">Bir *çıkış parametresi* başvuruya göre bağımsız değişkenleri geçirme kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e2309-204">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="e2309-205">Bir değer açıkça çağıran tarafından sağlanan bağımsız değişkenine atayın gerektirmez, bir başvuru parametre benzerdir.</span><span class="sxs-lookup"><span data-stu-id="e2309-205">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="e2309-206">Çıktı parametresi ile bildirilmiş `out` değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="e2309-206">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="e2309-207">Aşağıdaki örnek kullanımı gösterilmiştir `out` C# 7'de sunulan sözdizimini kullanarak parametreleri.</span><span class="sxs-lookup"><span data-stu-id="e2309-207">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

[!code-csharp[OutExample](../../../samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]

<span data-ttu-id="e2309-208">A *parametre dizisi* bir yönteme iletilecek bağımsız değişken sayısı izin verir.</span><span class="sxs-lookup"><span data-stu-id="e2309-208">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="e2309-209">Bir parametre dizisi ile bildirilmiş `params` değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="e2309-209">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="e2309-210">Yalnızca son parametresi bir yöntemi, bir parametre dizisi olabilir ve bir parametre dizisi türü bir tek boyutlu dizi türü olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e2309-210">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="e2309-211">Yazma ve WriteLine yöntemlerinin <xref:System.Console?displayProperty=nameWithType> sınıfı parametre dizisi kullanımının iyi örnekler verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="e2309-211">The Write and WriteLine methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="e2309-212">Bunlar aşağıdaki gibi bildirilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-212">They are declared as follows.</span></span>

[!code-csharp[ConsoleExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]

<span data-ttu-id="e2309-213">Bir parametre dizisi kullanan bir yöntem içinde parametre dizisine bir dizi türünün tam olarak normal bir parametre gibi davranır.</span><span class="sxs-lookup"><span data-stu-id="e2309-213">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="e2309-214">Ancak, bir parametre dizisi olan bir yöntem çağrısını içinde tek bir bağımsız değişken parametre dizisi türü veya herhangi bir sayıda parametre dizi öğesi türü bağımsız değişkenleri geçirmek mümkündür.</span><span class="sxs-lookup"><span data-stu-id="e2309-214">However, in an invocation of a method with a parameter array, it is possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="e2309-215">İkinci durumda, bir dizi örneği otomatik olarak oluşturulur ve belirtilen bağımsız değişkenlerle başlatıldı.</span><span class="sxs-lookup"><span data-stu-id="e2309-215">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="e2309-216">Bu örnek</span><span class="sxs-lookup"><span data-stu-id="e2309-216">This example</span></span>

[!code-csharp[StringFormat](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]

<span data-ttu-id="e2309-217">Aşağıdaki yazmaya eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="e2309-217">is equivalent to writing the following.</span></span>

[!code-csharp[StringFormat2](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]

### <a name="method-body-and-local-variables"></a><span data-ttu-id="e2309-218">Yöntem gövdesi ve yerel değişkenler</span><span class="sxs-lookup"><span data-stu-id="e2309-218">Method body and local variables</span></span>

<span data-ttu-id="e2309-219">Bir yöntemin gövde yöntemi çağrıldığında çalıştırılacak deyimleri belirtir.</span><span class="sxs-lookup"><span data-stu-id="e2309-219">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="e2309-220">Yöntem gövdesi yöntemin çağrılması için belirli değişkenleri bildirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e2309-220">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="e2309-221">Bu tür değişkenler adlandırılır *yerel değişkenler*.</span><span class="sxs-lookup"><span data-stu-id="e2309-221">Such variables are called *local variables*.</span></span> <span data-ttu-id="e2309-222">Yerel bir değişken bildirimi bir tür adı, bir değişken adı ve büyük olasılıkla bir başlangıç değeri belirtir.</span><span class="sxs-lookup"><span data-stu-id="e2309-222">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="e2309-223">Aşağıdaki örnek, yerel bir değişken bildirir `i` sıfır ve yerel bir değişken başlangıç değeri ile `j` hiçbir başlangıç değeri.</span><span class="sxs-lookup"><span data-stu-id="e2309-223">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

[!code-csharp[Squares](../../../samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]

<span data-ttu-id="e2309-224">C# olması için yerel bir değişken gerektirir *kesinlikle atanan* değeri elde edilebilir önce.</span><span class="sxs-lookup"><span data-stu-id="e2309-224">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="e2309-225">Örneğin, varsa önceki bildirimi `i` başlangıç değeri içermeyen, derleyici sonraki kullanımlar için bir hata raporlar `i` çünkü `i` kesinlikle noktalarda program atanmamış.</span><span class="sxs-lookup"><span data-stu-id="e2309-225">For example, if the declaration of the previous `i` did not include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` would not be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="e2309-226">Bir yöntemi kullanabilirsiniz `return` çağırıcısına denetim döndürülecek deyimleri.</span><span class="sxs-lookup"><span data-stu-id="e2309-226">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="e2309-227">Döndüren bir yöntem `void`, `return` deyimleri bir ifade belirtemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="e2309-227">In a method returning `void`, `return` statements cannot specify an expression.</span></span> <span data-ttu-id="e2309-228">Olmayan-void, döndüren bir yöntem `return` deyimleri dönüş değeri hesaplar bir ifade içermelidir.</span><span class="sxs-lookup"><span data-stu-id="e2309-228">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="e2309-229">Statik ve örnek yöntemleri</span><span class="sxs-lookup"><span data-stu-id="e2309-229">Static and instance methods</span></span>

<span data-ttu-id="e2309-230">Statik değiştirici ile bildirilmiş bir yöntemi olan bir *statik yöntemi*.</span><span class="sxs-lookup"><span data-stu-id="e2309-230">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="e2309-231">Bir statik yöntem belirli bir örneğinde çalışmaz ve statik üyeler yalnızca doğrudan erişebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e2309-231">A static method does not operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="e2309-232">Statik değiştirici olmayan bir yöntem olarak bildirilen bir *örnek yöntemi*.</span><span class="sxs-lookup"><span data-stu-id="e2309-232">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="e2309-233">Örnek yöntemi belirli bir örneğinde çalışır ve her iki statik erişmek ve üyeleri örneği.</span><span class="sxs-lookup"><span data-stu-id="e2309-233">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="e2309-234">Bir örnek yönteminin çağrıldığı örnek olarak açıkça erişilebilir `this`.</span><span class="sxs-lookup"><span data-stu-id="e2309-234">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="e2309-235">Başvurmak için bir hata olduğunu `this` bir statik yöntem.</span><span class="sxs-lookup"><span data-stu-id="e2309-235">It is an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="e2309-236">Aşağıdaki `Entity` sınıfı statik sahiptir ve üyeleri örneği.</span><span class="sxs-lookup"><span data-stu-id="e2309-236">The following `Entity` class has both static and instance members.</span></span>

[!code-csharp[Entity](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]

<span data-ttu-id="e2309-237">Her `Entity` örneği bir seri numarası (ve burada gösterilmiyor büyük olasılıkla bazı diğer bilgileri içerir).</span><span class="sxs-lookup"><span data-stu-id="e2309-237">Each `Entity` instance contains a serial number (and presumably some other information that is not shown here).</span></span> <span data-ttu-id="e2309-238">`Entity` (Bu örnek yöntemi gibi) Oluşturucu sonraki kullanılabilir seri numarasına sahip yeni örneğini başlatır.</span><span class="sxs-lookup"><span data-stu-id="e2309-238">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="e2309-239">Örnek üyesine Oluşturucusu olduğu için her ikisi de erişim izni `serialNo` örnek alan ve `nextSerialNo` statik alan.</span><span class="sxs-lookup"><span data-stu-id="e2309-239">Because the constructor is an instance member, it is permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="e2309-240">`GetNextSerialNo` Ve `SetNextSerialNo` statik yöntemler erişebilir `nextSerialNo` statik alan, ancak bunları için bir hata doğrudan erişimi olacaktır `serialNo` örnek alanı.</span><span class="sxs-lookup"><span data-stu-id="e2309-240">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="e2309-241">Aşağıdaki örnekte, varlık sınıfı kullanımını göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="e2309-241">The following example shows the use of the Entity class.</span></span>

[!code-csharp[EntityExample](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]

<span data-ttu-id="e2309-242">Unutmayın `SetNextSerialNo` ve `GetNextSerialNo` statik yöntemler, sınıf üzerinde çağrılır, ancak `GetSerialNo` sınıfın bir örneği üzerinde örnek yöntemi çağrılır.</span><span class="sxs-lookup"><span data-stu-id="e2309-242">Note that the `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="e2309-243">Sanal, geçersiz kılma ve soyut yöntemler</span><span class="sxs-lookup"><span data-stu-id="e2309-243">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="e2309-244">Ne zaman bir örnek yöntemi bildirimi içeren bir `virtual` değiştiricisi, yöntem olarak kabul edilir bir *sanal yöntemi*.</span><span class="sxs-lookup"><span data-stu-id="e2309-244">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="e2309-245">Hiçbir sanal değiştiricisi bulunduğunda yöntemi olarak kabul edilir bir *sanal olmayan yöntemi*.</span><span class="sxs-lookup"><span data-stu-id="e2309-245">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="e2309-246">Sanal bir yöntem çağrıldığında, *çalışma zamanı tür* bu çağrısını aldığı örneği yer çağırmak için gerçek uygulama yönteminin belirler.</span><span class="sxs-lookup"><span data-stu-id="e2309-246">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="e2309-247">Sanal olmayan yöntemi çağrısı *derleme zamanı tür* belirleyici faktör örneğidir.</span><span class="sxs-lookup"><span data-stu-id="e2309-247">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="e2309-248">Sanal bir yöntem olabilir *geçersiz kılınmış* türetilmiş bir sınıf içinde.</span><span class="sxs-lookup"><span data-stu-id="e2309-248">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="e2309-249">Bir örneği yöntemi bildiriminde bir geçersiz kılma değiştiricisi içerdiğinde yöntemi aynı imzayla devralınan bir sanal yöntemi geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="e2309-249">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="e2309-250">Bir sanal yöntem bildirimi iki yöntem sunar ancak bu yöntem, yeni bir uygulama sağlayarak bir geçersiz kılma yöntemi bildirimi varolan bir devralınan sanal yöntemi uzmanlaşmış.</span><span class="sxs-lookup"><span data-stu-id="e2309-250">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="e2309-251">Bir *soyut yöntemi* hiçbir uygulaması sanal bir yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="e2309-251">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="e2309-252">Soyut bir yöntem soyut değiştiricisi ile bildirilir ve soyut bildirilmiş bir sınıfta izin verilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-252">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="e2309-253">Her Özet olmayan türetilen sınıfta soyut bir yöntem geçersiz kılınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e2309-253">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="e2309-254">Aşağıdaki örnek, bir Özet sınıf bildirir `Expression`, bir ifade ağaç düğümünü temsil eder ve üç türetilmiş sınıfları `Constant`, `VariableReference`, ve `Operation`, ifade ağaç düğümleri sabitleri, değişken için uygulama başvuruları ve aritmetik işlemler.</span><span class="sxs-lookup"><span data-stu-id="e2309-254">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="e2309-255">(Bu ifade ağaç türleriyle karıştırılmamalıdır ancak, benzer).</span><span class="sxs-lookup"><span data-stu-id="e2309-255">(This is similar to, but not to be confused with the expression tree types).</span></span>

[!code-csharp[ExpressionClass](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]

<span data-ttu-id="e2309-256">Önceki dört sınıflar, aritmetik ifadeler modellemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-256">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="e2309-257">Örneğin, bu sınıfları, ifade kullanarak `x + 3` gibi temsil edilebilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-257">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

[!code-csharp[ExpressionExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]

<span data-ttu-id="e2309-258">`Evaluate` Yöntemi bir `Expression` örneği verilen ifade değerlendirmek ve üretmek için çağrıldığında bir `double` değeri.</span><span class="sxs-lookup"><span data-stu-id="e2309-258">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="e2309-259">Yöntem alır bir `Dictionary` (olarak girişleri anahtarları) değişken adları ve değerleri (olarak girişlerinin değerleri) içeren değişken.</span><span class="sxs-lookup"><span data-stu-id="e2309-259">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="e2309-260">Çünkü `Evaluate` soyut bir yöntem, türetilen soyut olmayan sınıflar `Expression` geçersiz kılmanız gerekir `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="e2309-260">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="e2309-261">A `Constant`'s uyarlamasını `Evaluate` yalnızca depolanmış sabiti döndürür.</span><span class="sxs-lookup"><span data-stu-id="e2309-261">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="e2309-262">A `VariableReference`adı değişken adı sözlükteki uygulama arar ve sonuç değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="e2309-262">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="e2309-263">Bir `Operation`'s uygulama önce sol ve sağ işlenen değerlendirir (özyinelemeli çağırma tarafından kendi `Evaluate` yöntemleri) ve verilen aritmetik işlemi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="e2309-263">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="e2309-264">Aşağıdaki program kullanan `Expression` ifade değerlendirmek için sınıflar `x * (y + 2)` farklı değerler için `x` ve `y`.</span><span class="sxs-lookup"><span data-stu-id="e2309-264">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

[!code-csharp[ExpressionUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]

### <a name="method-overloading"></a><span data-ttu-id="e2309-265">Yöntemi aşırı yüklemesi</span><span class="sxs-lookup"><span data-stu-id="e2309-265">Method overloading</span></span>

<span data-ttu-id="e2309-266">Yöntem *aşırı* benzersiz imzaları sahip oldukları sürece aynı ada sahip aynı sınıfta birden çok yöntem verir.</span><span class="sxs-lookup"><span data-stu-id="e2309-266">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="e2309-267">Aşırı yüklenmiş yöntemin bir çağrısını derlerken, derleme kullanır *aşırı yükleme çözümü* çağırmak için belirli yöntemi belirlemek için.</span><span class="sxs-lookup"><span data-stu-id="e2309-267">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="e2309-268">Aşırı yükleme çözünürlüğü en iyi bağımsız değişkenlerle veya tek en iyi eşleşme bulunamazsa, bir hata raporları bir yöntem bulur.</span><span class="sxs-lookup"><span data-stu-id="e2309-268">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="e2309-269">Aşağıdaki örnek aşırı yükleme çözünürlüğü yürürlükte gösterir.</span><span class="sxs-lookup"><span data-stu-id="e2309-269">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="e2309-270">Her çağırma için yorum `Main` yöntemi gösterilir hangi yöntemi gerçekte çağrılır.</span><span class="sxs-lookup"><span data-stu-id="e2309-270">The comment for each invocation in the `Main` method shows which method is actually invoked.</span></span>

[!code-csharp[OverloadUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]

<span data-ttu-id="e2309-271">Örnekte gösterildiği gibi belirli bir yöntem her zaman açıkça tam parametre türleri değişkenleri atama ve/veya açıkça tür bağımsız değişkenleri sağladığını seçilebilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-271">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="e2309-272">Diğer işlevi üyeleri</span><span class="sxs-lookup"><span data-stu-id="e2309-272">Other function members</span></span>

<span data-ttu-id="e2309-273">Yürütülebilir kod içeren üyeleri topluca olarak bilinen *işlev üyeleri* bir sınıf.</span><span class="sxs-lookup"><span data-stu-id="e2309-273">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="e2309-274">Önceki bölümde işlevi üyeleri birincil tür yöntemleri açıklar.</span><span class="sxs-lookup"><span data-stu-id="e2309-274">The preceding section describes methods, which are the primary kind of function members.</span></span> <span data-ttu-id="e2309-275">Bu bölümde C# tarafından desteklenen işlevi üyelerinin diğer türleri açıklanmaktadır: Oluşturucular, özellikleri, dizin oluşturucular, olaylar, işleçler ve sonlandırıcılar.</span><span class="sxs-lookup"><span data-stu-id="e2309-275">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="e2309-276">Aşağıdaki liste adlı genel bir sınıf gösterir<T>, growable nesnelerin listesini uygular.</span><span class="sxs-lookup"><span data-stu-id="e2309-276">The following shows a generic class called List<T>, which implements a growable list of objects.</span></span> <span data-ttu-id="e2309-277">Sınıfı en yaygın tür işlevi üye bazı örnekleri içerir.</span><span class="sxs-lookup"><span data-stu-id="e2309-277">The class contains several examples of the most common kinds of function members.</span></span>

[!code-csharp[ListClass](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]

### <a name="constructors"></a><span data-ttu-id="e2309-278">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="e2309-278">Constructors</span></span>

<span data-ttu-id="e2309-279">C# örneği ve statik oluşturucular destekler.</span><span class="sxs-lookup"><span data-stu-id="e2309-279">C# supports both instance and static constructors.</span></span> <span data-ttu-id="e2309-280">Bir *örnek oluşturucusu* sınıfının bir örneği başlatmak için gerekli eylemleri uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="e2309-280">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="e2309-281">A *statik Oluşturucusu* ilk yüklendiğinde bir sınıf başlatmak için gerekli eylemleri uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="e2309-281">A *static constructor* is a member that implements the actions required to initialize a class itself when it is first loaded.</span></span>

<span data-ttu-id="e2309-282">Dönüş türü ve içeren sınıf aynı ada sahip bir yöntemi gibi bir oluşturucu bildirildi.</span><span class="sxs-lookup"><span data-stu-id="e2309-282">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="e2309-283">Statik değiştirici Oluşturucu bildirimi içeriyorsa, statik Oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="e2309-283">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="e2309-284">Aksi takdirde, örnek oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="e2309-284">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="e2309-285">Örnek oluşturucuları aşırı yüklenebilir ve isteğe bağlı parametreler olabilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-285">Instance constructors can be overloaded, and can have optional parameters.</span></span> <span data-ttu-id="e2309-286">Örneğin, `List<T>` sınıfı parametresiz ve tutacak bir biriyle iki örnek oluşturucuları bildiren bir `int` parametresi.</span><span class="sxs-lookup"><span data-stu-id="e2309-286">For example, the `List<T>` class declares two instance constructors, one with no parameters and one that takes an `int` parameter.</span></span> <span data-ttu-id="e2309-287">Örnek oluşturucuları kullanarak çağrılır `new` işleci.</span><span class="sxs-lookup"><span data-stu-id="e2309-287">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="e2309-288">Aşağıdaki deyimleri iki tahsis `List<string>` oluşturucusunun kullanma örnekleri `List` sınıfı ile ve isteğe bağlı bağımsız değişkeni olmadan.</span><span class="sxs-lookup"><span data-stu-id="e2309-288">The following statements allocate two `List<string>` instances using the constructor of the `List` class with and without the optional argument.</span></span>

[!code-csharp[ListExample1](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]

<span data-ttu-id="e2309-289">Diğer üyeleri aksine örnek oluşturucuları devralınmaz ve bir sınıf dışında bu gerçekte bildirilen örnek oluşturucusu sınıfında yok.</span><span class="sxs-lookup"><span data-stu-id="e2309-289">Unlike other members, instance constructors are not inherited, and a class has no instance constructors other than those actually declared in the class.</span></span> <span data-ttu-id="e2309-290">Hiçbir örnek oluşturucu için bir sınıf sağlanırsa, sonra boş bir parametre olmadan otomatik olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="e2309-290">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="e2309-291">Özellikler</span><span class="sxs-lookup"><span data-stu-id="e2309-291">Properties</span></span>

<span data-ttu-id="e2309-292">*Özellikler* alanlarının doğal bir uzantıdır.</span><span class="sxs-lookup"><span data-stu-id="e2309-292">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="e2309-293">Her ikisi de ilişkili türlerini üyeleriyle adlandırılır ve alanlar ve Özellikler erişmek için söz dizimi aynıdır.</span><span class="sxs-lookup"><span data-stu-id="e2309-293">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="e2309-294">Ancak, alanları özellikleri depolama konumları belirtmek değil.</span><span class="sxs-lookup"><span data-stu-id="e2309-294">However, unlike fields, properties do not denote storage locations.</span></span> <span data-ttu-id="e2309-295">Bunun yerine, özelliklere sahip *erişimciler* değerlerine okunabilir veya yazılabilir zaman yürütülecek deyimleri belirtin.</span><span class="sxs-lookup"><span data-stu-id="e2309-295">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="e2309-296">Bildirim alma erişimcisi ve/veya sınırlayıcıları yazılmış bir set erişimcisi ile biten dışında bir özelliği bir alan gibi bildirildiği `{` ve `}` noktalı virgül bitiş yerine.</span><span class="sxs-lookup"><span data-stu-id="e2309-296">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="e2309-297">Bir get erişimcisine ve bir set erişimcisine sahip bir özellik olan bir *okuma-yazma özelliği*, yalnızca bir get erişimcisine sahip bir özellik olan bir *salt okunur özelliği*, ve yalnızca bir set erişimcisine sahip bir özellik bir *salt yazılır özellik*.</span><span class="sxs-lookup"><span data-stu-id="e2309-297">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="e2309-298">Get erişimcisi özellik türü dönüş değeri parametresiz bir yöntemle karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="e2309-298">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="e2309-299">Bir özelliği bir ifadede başvurulduğunda dışında bir atama hedef olarak özelliğinin get erişimcisine özelliğin değerini hesaplamak için çağrılır.</span><span class="sxs-lookup"><span data-stu-id="e2309-299">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="e2309-300">Bir set erişimcisi değeri ve dönüş türü adlı için tek bir parametre için bir yöntem karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="e2309-300">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="e2309-301">Ne zaman bir özellik başvurulan atama hedefi veya işleneni olarak ++ veya--, yeni değer sağlayan bir bağımsız değişken set erişimcisine çağrılır.</span><span class="sxs-lookup"><span data-stu-id="e2309-301">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="e2309-302">`List<T>` Sınıfı salt okunur ve okuma-yazma, sırasıyla sayısı ve kapasite, iki özelliği bildirir.</span><span class="sxs-lookup"><span data-stu-id="e2309-302">The `List<T>` class declares two properties, Count and Capacity, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="e2309-303">Bu özelliklerin kullanımı bir örnek verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="e2309-303">The following is an example of use of these properties.</span></span>

[!code-csharp[ListExample2](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]

<span data-ttu-id="e2309-304">Alanları ve yöntemleri benzer, C# örnek özelliklerini ve statik özellikleri destekler.</span><span class="sxs-lookup"><span data-stu-id="e2309-304">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="e2309-305">Statik özellikler statik değiştirici ile bildirilir ve örnek özelliklerini olmadan bildirilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-305">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="e2309-306">Bir özelliğin accessor(s) sanal olabilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-306">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="e2309-307">Ne zaman bir özellik bildirimi içeren bir `virtual`, `abstract`, veya `override` değiştiricisi, özellik accessor(s) için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="e2309-307">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="e2309-308">Dizin Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="e2309-308">Indexers</span></span>

<span data-ttu-id="e2309-309">Bir *dizin oluşturucu* bir dizi aynı şekilde dizine nesneler sağlayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="e2309-309">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="e2309-310">Üyenin adını bu arasında sınırlayıcıları yazılmış bir parametre listesine ve ardından olması dışında bir dizin oluşturucu özelliği gibi bildirilmiş `[` ve `]`.</span><span class="sxs-lookup"><span data-stu-id="e2309-310">An indexer is declared like a property except that the name of the member is this followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="e2309-311">Parametreleri dizin oluşturucu accessor(s) içinde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-311">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="e2309-312">Benzer özellikleri için dizin oluşturucular okuma-yazma, salt okunur ve yalnızca yazma olabilir ve bir dizinleyici accessor(s) sanal olabilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-312">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="e2309-313">`List` Sınıf gereken tek bir okuma-yazma dizin oluşturucu bildiren bir `int` parametresi.</span><span class="sxs-lookup"><span data-stu-id="e2309-313">The `List` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="e2309-314">Dizin Oluşturucu, dizine mümkün kılar `List` ile örnekleri `int` değerleri.</span><span class="sxs-lookup"><span data-stu-id="e2309-314">The indexer makes it possible to index `List` instances with `int` values.</span></span> <span data-ttu-id="e2309-315">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="e2309-315">For example:</span></span>

[!code-csharp[ListExample3](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]

<span data-ttu-id="e2309-316">Dizin Oluşturucular, sayı veya kendi parametre türlerini farklı sürece bir sınıfın birden çok dizin oluşturucu bildirebilir anlamı aşırı yüklenmiş.</span><span class="sxs-lookup"><span data-stu-id="e2309-316">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="e2309-317">Olaylar</span><span class="sxs-lookup"><span data-stu-id="e2309-317">Events</span></span>

<span data-ttu-id="e2309-318">Bir *olay* bir sınıf veya nesne bildirimleri sağlamak üzere etkinleştirir bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="e2309-318">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="e2309-319">Bir olay türü bir temsilci türü olmalıdır ve bir event anahtar sözcüğü bildirimi içerir ancak bu gibi bir alan bildirildi.</span><span class="sxs-lookup"><span data-stu-id="e2309-319">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="e2309-320">(Olay Özet olmayan ve erişimciler bildirmiyor sağlanan) bir olay üye bildiren bir sınıf içinde olay yalnızca bir temsilci türü bir alan gibi davranır.</span><span class="sxs-lookup"><span data-stu-id="e2309-320">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event is not abstract and does not declare accessors).</span></span> <span data-ttu-id="e2309-321">Alan olaya eklenmiş olan olay işleyicileri temsil eden bir temsilci başvuru depolar.</span><span class="sxs-lookup"><span data-stu-id="e2309-321">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="e2309-322">Olay işleyicileri mevcut olup olmadığını alandır `null`.</span><span class="sxs-lookup"><span data-stu-id="e2309-322">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="e2309-323">`List<T>` Sınıfı bildirir adlı tek bir olay üyeye `Changed`, belirten yeni bir öğeyi listeye eklendi.</span><span class="sxs-lookup"><span data-stu-id="e2309-323">The `List<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="e2309-324">Değiştirilen olay tarafından tetiklenir `OnChanged` hangi ilk olay olup olmadığını denetler, sanal bir yöntem `null` (hiçbir işleyicileri mevcut olduğu anlamına gelir).</span><span class="sxs-lookup"><span data-stu-id="e2309-324">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="e2309-325">Bir olayı tetiklenmeden tanımlanmaları olayı tarafından temsil edilen temsilci çağırmak için tam olarak eşittir; Bu nedenle, olaylar oluşturma için hiçbir özel dil yapıları vardır.</span><span class="sxs-lookup"><span data-stu-id="e2309-325">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="e2309-326">İstemcileri tepki olayları *olay işleyicileri*.</span><span class="sxs-lookup"><span data-stu-id="e2309-326">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="e2309-327">Olay işleyicileri kullanarak bağlı `+=` işleci ve kaldırılan kullanarak `-=` işleci.</span><span class="sxs-lookup"><span data-stu-id="e2309-327">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="e2309-328">Aşağıdaki örnekte bir olay işleyicisi ekler `Changed` olayı bir `List<string>`.</span><span class="sxs-lookup"><span data-stu-id="e2309-328">The following example attaches an event handler to the `Changed` event of a `List<string>`.</span></span>

[!code-csharp[EventExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]

<span data-ttu-id="e2309-329">Bir olayın temel alınan depolama biriminin denetimi istenen burada Gelişmiş senaryolar için bir olay bildirimi açıkça sağlayabilir `add` ve `remove` biraz benzer erişimciler `set` bir özellik erişimcisi.</span><span class="sxs-lookup"><span data-stu-id="e2309-329">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are somewhat similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="e2309-330">İşleçler</span><span class="sxs-lookup"><span data-stu-id="e2309-330">Operators</span></span>

<span data-ttu-id="e2309-331">Bir *işleci* bir sınıfın bir örneği için belirli ifade işleci uygulama anlamı tanımlayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="e2309-331">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="e2309-332">Üç tür işleçleri tanımlanabilir: birli işleç, ikili işleçler ve dönüştürme işleçleri.</span><span class="sxs-lookup"><span data-stu-id="e2309-332">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="e2309-333">Tüm işleçleri olarak bildirilmelidir `public` ve `static`.</span><span class="sxs-lookup"><span data-stu-id="e2309-333">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="e2309-334">`List<T>` Sınıfı bildirir iki işleç `operator ==` ve `operator !=`ve bu nedenle bu işleç geçerli ifadeler için yeni anlamı verir `List` örnekleri.</span><span class="sxs-lookup"><span data-stu-id="e2309-334">The `List<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `List` instances.</span></span> <span data-ttu-id="e2309-335">Özellikle, işleçler iki eşitliği tanımlama `List<T>` örnekleri kendi eşittir yöntemlerini kullanarak içerdiği nesnelerin her biri karşılaştırma olarak.</span><span class="sxs-lookup"><span data-stu-id="e2309-335">Specifically, the operators define equality of two `List<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="e2309-336">Aşağıdaki örnek kullanır `==` iki Karşılaştırılacak işleci `List<int>` örnekleri.</span><span class="sxs-lookup"><span data-stu-id="e2309-336">The following example uses the `==` operator to compare two `List<int>` instances.</span></span>

[!code-csharp[OperatorExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]

<span data-ttu-id="e2309-337">İlk `Console.WriteLine` çıkarır `True` listelerini aynı değerleri aynı sırayla nesnelerle aynı sayıda içerdiğinden.</span><span class="sxs-lookup"><span data-stu-id="e2309-337">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="e2309-338">Vardı `List<T>` tanımlanmamış `operator ==`, ilk `Console.WriteLine` çıkış `False` çünkü `a` ve `b` başvuru farklı `List<int>` örnekleri.</span><span class="sxs-lookup"><span data-stu-id="e2309-338">Had `List<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `List<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="e2309-339">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="e2309-339">Finalizers</span></span>

<span data-ttu-id="e2309-340">A *sonlandırıcıyı* sınıfının bir örneği sonlandırmaya gerekli eylemleri uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="e2309-340">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="e2309-341">Sonlandırıcılar parametrelere sahip olamaz, erişilebilirlik değiştiricileri sahip olamaz ve açıkça çağrılamaz.</span><span class="sxs-lookup"><span data-stu-id="e2309-341">Finalizers cannot have parameters, they cannot have accessibility modifiers, and they cannot be invoked explicitly.</span></span> <span data-ttu-id="e2309-342">Bir örneği için sonlandırıcıyı çöp toplama sırasında otomatik olarak çağrılır.</span><span class="sxs-lookup"><span data-stu-id="e2309-342">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="e2309-343">Çöp toplayıcı nesneler toplamak ve sonlandırıcılar çalıştırmak karar verme, geniş enlem izin verilir.</span><span class="sxs-lookup"><span data-stu-id="e2309-343">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="e2309-344">Özellikle, sonlandırıcıyı çağrılarını zamanlama belirleyici değil ve sonlandırıcılar hiçbir iş parçacığı üzerinde yürütülen.</span><span class="sxs-lookup"><span data-stu-id="e2309-344">Specifically, the timing of finalizer invocations is not deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="e2309-345">Sınıfları, bunlar ve diğer nedenler için yalnızca başka bir çözüm uygun olduğunda sonlandırıcılar uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="e2309-345">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="e2309-346">`using` Deyimi nesne yok etme daha iyi bir yaklaşım sağlar.</span><span class="sxs-lookup"><span data-stu-id="e2309-346">The `using` statement provides a better approach to object destruction.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="e2309-347">[Önceki](statements.md)
[sonraki](structs.md)</span><span class="sxs-lookup"><span data-stu-id="e2309-347">[Previous](statements.md)
[Next](structs.md)</span></span>

---
title: .NET Framework XAML Hizmetlerinde Kullanılacak Özel Türleri Tanımlama
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 9edc7baa1a540a71997cf5b1ed010ad5c7960d17
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33566502"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="8b18e-102">.NET Framework XAML Hizmetlerinde Kullanılacak Özel Türleri Tanımlama</span><span class="sxs-lookup"><span data-stu-id="8b18e-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="8b18e-103">İş nesneleri özel türler tanımlamak ya da bir bağımlılık belirli çerçevesinde yok türleri, izleyebilirsiniz XAML için bazı en iyi yöntemler vardır.</span><span class="sxs-lookup"><span data-stu-id="8b18e-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="8b18e-104">Bu yöntemler, .NET Framework XAML hizmetlerinde izleyin ve kendi XAML okuyucuları ve XAML yazıcıları türünüz XAML özelliklerini bulmak ve XAML tür sistemi kullanarak bir XAML düğüm akış uygun gösterimi vermek istiyorsanız.</span><span class="sxs-lookup"><span data-stu-id="8b18e-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="8b18e-105">Bu konu için tür tanımları, üye tanımları ve CLR türleri veya üyeleri öznitelik atanıyor en iyi uygulamaları açıklar.</span><span class="sxs-lookup"><span data-stu-id="8b18e-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="8b18e-106">Oluşturucu desenler ve XAML için tür tanımları</span><span class="sxs-lookup"><span data-stu-id="8b18e-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="8b18e-107">XAML'de object öğesi olarak örneğinin oluşturulması için özel bir sınıf aşağıdaki gereksinimleri karşılamalıdır:</span><span class="sxs-lookup"><span data-stu-id="8b18e-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="8b18e-108">Özel bir sınıf genel olmalıdır ve bir varsayılan (parametresiz) ortak oluşturucu kullanıma gerekir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="8b18e-109">(Bölüm yapıları ilgili notları aşağıdaki bakın.)</span><span class="sxs-lookup"><span data-stu-id="8b18e-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="8b18e-110">Özel bir sınıf, bir iç içe geçmiş sınıf olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="8b18e-111">Tam ad yolundaki "nokta" ek sınıfı-namespace bölme belirsiz yapar ve ekli özellikler gibi diğer XAML özellikleriyle uğratır.</span><span class="sxs-lookup"><span data-stu-id="8b18e-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="8b18e-112">Bir nesne bir nesne öğesi olarak oluşturulabilir, oluşturulan nesnesi nesneyi kendi temel alınan türü olarak ele herhangi bir özellik özellik öğesi formunu doldurabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8b18e-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="8b18e-113">Değer dönüştürücüsü etkinleştirirseniz, nesne değerleri için bu ölçütü karşılamayan türleri sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8b18e-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="8b18e-114">Daha fazla bilgi için bkz: [tür dönüştürücüleri ve İşaretleme uzantıları XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="8b18e-114">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="8b18e-115">Yapılar</span><span class="sxs-lookup"><span data-stu-id="8b18e-115">Structures</span></span>  
 <span data-ttu-id="8b18e-116">Yapıları her zaman XAML'de, CLR tanımı tarafından oluşturulması mümkün olur.</span><span class="sxs-lookup"><span data-stu-id="8b18e-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="8b18e-117">Bir CLR derleyici örtük olarak bir yapı için varsayılan bir oluşturucu oluşturmasıdır.</span><span class="sxs-lookup"><span data-stu-id="8b18e-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="8b18e-118">Bu oluşturucu, tüm özellik değerlerini varsayılanlarına başlatır.</span><span class="sxs-lookup"><span data-stu-id="8b18e-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="8b18e-119">Bazı durumlarda, bir yapı için varsayılan yapım davranış arzu değil.</span><span class="sxs-lookup"><span data-stu-id="8b18e-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="8b18e-120">Bu yapı değerleri ve işlevi UNION olarak kavramsal olarak doldurmak için tasarlandığından olabilir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="8b18e-121">Bir birleşim olarak içerilen değerleri dışlayan yorumlar olabilir ve bu nedenle, özelliklerini hiçbiri ayarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="8b18e-122">Böyle bir yapı içinde WPF sözlüğü örneğidir <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="8b18e-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="8b18e-123">Böylece farklı yorumlar veya modları yapısı değerlerin oluşturma dize kurallarını kullanarak özniteliği formunda değerleri belirtilebilir böyle yapıları tür dönüştürücüsünü uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="8b18e-124">Yapı Ayrıca varsayılan olmayan bir oluşturucu aracılığıyla kod oluşturma için benzer davranış maruz bırakmamalısınız.</span><span class="sxs-lookup"><span data-stu-id="8b18e-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="8b18e-125">Arabirimler</span><span class="sxs-lookup"><span data-stu-id="8b18e-125">Interfaces</span></span>  
 <span data-ttu-id="8b18e-126">Arabirim üyeleri temel türleri olarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="8b18e-127">XAML tür sistemi atanabilir listesini denetler ve değeri olarak sağlanan nesne arabirimine atanabilir bekliyor.</span><span class="sxs-lookup"><span data-stu-id="8b18e-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="8b18e-128">XAML yapı gereksinimleri ilgili atanabilir tür desteklediği sürece arabirimi XAML türü olarak nasıl sunulmalıdır hiçbir kavramı yoktur.</span><span class="sxs-lookup"><span data-stu-id="8b18e-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="8b18e-129">Fabrika yöntemleri</span><span class="sxs-lookup"><span data-stu-id="8b18e-129">Factory Methods</span></span>  
 <span data-ttu-id="8b18e-130">Fabrika yöntemleri bir XAML 2009 özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="8b18e-131">Bunlar nesneleri varsayılan oluşturucular olmalıdır XAML ilkesini değiştirin.</span><span class="sxs-lookup"><span data-stu-id="8b18e-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="8b18e-132">Fabrika yöntemleri, bu konuda açıklanmamıştır.</span><span class="sxs-lookup"><span data-stu-id="8b18e-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="8b18e-133">Bkz: [x: FactoryMethod yönergesi](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="8b18e-133">See [x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="8b18e-134">Numaralandırmalar</span><span class="sxs-lookup"><span data-stu-id="8b18e-134">Enumerations</span></span>  
 <span data-ttu-id="8b18e-135">Numaralandırmalar XAML yerel tür dönüştürme davranışına sahip.</span><span class="sxs-lookup"><span data-stu-id="8b18e-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="8b18e-136">XAML'de belirtilen numaralandırması sabit adları karşı temel numaralandırma türü çözümlenir ve bir XAML nesne yazıcısı numaralandırma değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="8b18e-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="8b18e-137">XAML sabit listeleri için bayrakları stili kullanım destekleyen <xref:System.FlagsAttribute> uygulanır.</span><span class="sxs-lookup"><span data-stu-id="8b18e-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="8b18e-138">Daha fazla bilgi için bkz: [içinde XAML sözdizimi ayrıntı](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="8b18e-138">For more information, see [XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="8b18e-139">([İçinde XAML sözdizimi ayrıntı](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) WPF kitlesi yazılır, ancak çoğu bu konu başlığı altındaki bilgiler, belirli bir uygulama çerçevesi için belirli değil XAML için ilgili.)</span><span class="sxs-lookup"><span data-stu-id="8b18e-139">([XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="8b18e-140">Üye tanımları</span><span class="sxs-lookup"><span data-stu-id="8b18e-140">Member Definitions</span></span>  
 <span data-ttu-id="8b18e-141">XAML kullanımı için üyeleri türleri tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8b18e-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="8b18e-142">Bu belirli tür XAML kullanılabilir olsa bile, XAML kullanılabilen üyeleri tanımlayan türleri için mümkündür.</span><span class="sxs-lookup"><span data-stu-id="8b18e-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="8b18e-143">Bu CLR devralma nedeniyle mümkündür.</span><span class="sxs-lookup"><span data-stu-id="8b18e-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="8b18e-144">XAML kullanım türü olarak üye devralan bazı tür destekler ve üye XAML kullanımı temel alınan türü için destekleyen veya kullanılabilir yerel XAML sözdizimine sahip olduğu sürece, bu XAML kullanılabilir bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="8b18e-145">Özellikler</span><span class="sxs-lookup"><span data-stu-id="8b18e-145">Properties</span></span>  
 <span data-ttu-id="8b18e-146">Tipik CLR kullanan ortak bir CLR özellik özellikleri tanımlarsanız `get` ve `set` erişimci desenleri ve dil uygun keywording, XAML tür sistemi raporlama yapabilir özelliği uygun bilgilerle bir üye olarak sağlanan için <xref:System.Xaml.XamlMember> özellikleri gibi <xref:System.Xaml.XamlMember.IsReadPublic%2A> ve <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="8b18e-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="8b18e-147">Belirli özellikler, bir metin sözdizimi uygulayarak etkinleştirebilir <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="8b18e-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="8b18e-148">Daha fazla bilgi için bkz: [tür dönüştürücüleri ve İşaretleme uzantıları XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="8b18e-148">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="8b18e-149">Bir metin sözdizimini veya yerel XAML dönüştürme yokluğu ve biçimlendirme uzantısı kullanımı, bir özellik türü gibi daha fazla yöneltme yokluğu (<xref:System.Xaml.XamlMember.TargetType%2A> XAML'de type system) t düşünerek XAML nesne yazıcısı için bir örnek döndürmeyi kurabiliyor olması gerekir Hedef türü bir CLR türü.</span><span class="sxs-lookup"><span data-stu-id="8b18e-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="8b18e-150">XAML 2009 kullanıyorsanız [x: Reference işaretleme uzantısı](../../../docs/framework/xaml-services/x-reference-markup-extension.md) önceki konuları karşılanmazsa değerlerini sağlamak için kullanılabilir; ancak, bu kullanım bir sorun türü tanımı sorun'den daha fazla bilgi.</span><span class="sxs-lookup"><span data-stu-id="8b18e-150">If using XAML 2009, [x:Reference Markup Extension](../../../docs/framework/xaml-services/x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="8b18e-151">Olaylar</span><span class="sxs-lookup"><span data-stu-id="8b18e-151">Events</span></span>  
 <span data-ttu-id="8b18e-152">Ortak bir CLR olayı olarak olayları tanımlarsanız, XAML tür sistemi olay sahip bir üye olarak bildirebilirsiniz <xref:System.Xaml.XamlMember.IsEvent%2A> olarak `true`.</span><span class="sxs-lookup"><span data-stu-id="8b18e-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="8b18e-153">Olay işleyicileri geriye .NET Framework XAML Hizmetleri özellikleri kapsamında değildir; Bu, belirli çerçeveler ve uygulamaları bırakılır.</span><span class="sxs-lookup"><span data-stu-id="8b18e-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="8b18e-154">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="8b18e-154">Methods</span></span>  
 <span data-ttu-id="8b18e-155">Satır içi kod yöntemleri için bir varsayılan XAML özelliği değil.</span><span class="sxs-lookup"><span data-stu-id="8b18e-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="8b18e-156">Çoğu durumda, doğrudan yöntemi üyeleri referans değil ve XAML yöntemlerinde rolü yalnızca desteği için belirli XAML desenleri sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="8b18e-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="8b18e-157">[x: FactoryMethod yönergesi](../../../docs/framework/xaml-services/x-factorymethod-directive.md) bir özel durumdur.</span><span class="sxs-lookup"><span data-stu-id="8b18e-157">[x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="8b18e-158">Alanlar</span><span class="sxs-lookup"><span data-stu-id="8b18e-158">Fields</span></span>  
 <span data-ttu-id="8b18e-159">CLR tasarım yönergeleri statik olmayan alanlar önleyin.</span><span class="sxs-lookup"><span data-stu-id="8b18e-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="8b18e-160">Statik alanları için statik alan değerlerini erişebilirsiniz yalnızca aracılığıyla [x: Static işaretleme uzantısı](../../../docs/framework/xaml-services/x-static-markup-extension.md); bu durumda, bir alan için kullanıma sunmak için CLR tanımında özel bir şey yapmakta olduğunuz değil [x: Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) kullanımları.</span><span class="sxs-lookup"><span data-stu-id="8b18e-160">For static fields, you can access static field values only through [x:Static Markup Extension](../../../docs/framework/xaml-services/x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="8b18e-161">Takılabilir üyeleri</span><span class="sxs-lookup"><span data-stu-id="8b18e-161">Attachable Members</span></span>  
 <span data-ttu-id="8b18e-162">Takılabilir üyeleri XAML için bir erişimci yöntemi desen tanımlama türündeki aracılığıyla sunulur.</span><span class="sxs-lookup"><span data-stu-id="8b18e-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="8b18e-163">Tanımlayıcı türü XAML-kullanılabilir bir nesne olarak olması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="8b18e-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="8b18e-164">Aslında, genel bir desen, rol hizmeti sınıfı bildirmektir takılabilir üye kendi ve ilgili davranışları uygulamak, ancak bir UI gösterimi gibi diğer bir işlev hizmet.</span><span class="sxs-lookup"><span data-stu-id="8b18e-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="8b18e-165">Aşağıdaki bölümler, yer tutucu için *PropertyName* takılabilir üyenin adını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="8b18e-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="8b18e-166">Bu adı geçerli [XamlName Dilbilgisi](../../../docs/framework/xaml-services/xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="8b18e-166">That name must be valid in the [XamlName Grammar](../../../docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="8b18e-167">Bu düzenleri ve diğer yöntemleri türünün arasındaki ad çakışma dikkatli olun.</span><span class="sxs-lookup"><span data-stu-id="8b18e-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="8b18e-168">Desenler biriyle eşleşen bir üye zaten varsa, amacınız değildi olsa bile, takılabilir üye kullanım izlediğiniz XAML işlemcisi tarafından yorumlanabilir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="8b18e-169">GetPropertyName erişimcisi</span><span class="sxs-lookup"><span data-stu-id="8b18e-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="8b18e-170">İmza için `Get` *PropertyName* erişimci olması gerekir:</span><span class="sxs-lookup"><span data-stu-id="8b18e-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="8b18e-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span><span class="sxs-lookup"><span data-stu-id="8b18e-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
-   <span data-ttu-id="8b18e-172">`target` Nesnesi, uygulamanızda daha belirli bir tür olarak belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="8b18e-173">Bu, takılabilir üye kullanımını kapsamını belirlemek için kullanabilirsiniz; hedeflenen kapsamı dışında kullanımları sonra bir XAML ayrıştırma hatası ortaya çıkmış geçersiz yayın özel durum atar.</span><span class="sxs-lookup"><span data-stu-id="8b18e-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="8b18e-174">Parametre adı `target` zorunlu değildir, ancak adlı `target` çoğu uygulamalarında kural tarafından.</span><span class="sxs-lookup"><span data-stu-id="8b18e-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="8b18e-175">Dönüş değeri, uygulamanızda daha belirli bir tür olarak belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="8b18e-176">Desteklemek için bir <xref:System.ComponentModel.TypeConverter> takılabilir üyesinin özniteliği kullanım için etkin metin sözdizimi geçerli <xref:System.ComponentModel.TypeConverterAttribute> için `Get` *PropertyName* erişimcisi.</span><span class="sxs-lookup"><span data-stu-id="8b18e-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="8b18e-177">Uygulama `get` yerine `set` nonintuitive; görünebilir ancak, bu kural kavramı destekleyebilir seri hale getirilebilir salt okunur takılabilir üyelerinin, olduğu Tasarımcı senaryolarda kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="8b18e-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="8b18e-178">SetPropertyName erişimcisi</span><span class="sxs-lookup"><span data-stu-id="8b18e-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="8b18e-179">İmza kümesi için*PropertyName* erişimci olması gerekir:</span><span class="sxs-lookup"><span data-stu-id="8b18e-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="8b18e-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="8b18e-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
-   <span data-ttu-id="8b18e-181">`target` Nesnesi olarak belirtilebilir aynı mantığı ve sonuçları ile uygulamanızda daha belirli bir tür önceki bölümde açıklandığı gibi.</span><span class="sxs-lookup"><span data-stu-id="8b18e-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="8b18e-182">`value` Nesnesi, uygulamanızda daha belirli bir tür olarak belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="8b18e-183">Bu yöntem için değerinin XAML kullanımdan özniteliği formunda genellikle gelen giriş olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="8b18e-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="8b18e-184">Öznitelik formundan olmalıdır değer dönüştürücüsü metin sözdizimi desteği ve üzerinde öznitelik `Get` *PropertyName* erişimcisi.</span><span class="sxs-lookup"><span data-stu-id="8b18e-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="8b18e-185">Takılabilir üye depolar</span><span class="sxs-lookup"><span data-stu-id="8b18e-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="8b18e-186">Erişimci yöntemleri genellikle takılabilir üye değerlerinin bir nesne grafiğinin yerleştirin veya nesne grafiğinin dışında değerleri almak ve düzgün şekilde serileştirmek için bir yol sağlamak yeterli değildir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="8b18e-187">Bu işlevselliği sağlayacak şekilde `target` önceki erişimcisi imzaları nesneleri değerlerini depolama yeteneğine sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8b18e-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="8b18e-188">Depolama mekanizmasını tutarlı takılabilir üye Üyeler listesinde olduğu hedefleri takılabilir bir üyesidir takılabilir üye ilkesine sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8b18e-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="8b18e-189">.NET framework XAML hizmetleri sağlar. bir uygulama teknik takılabilir üye API'leri aracılığıyla depolar <xref:System.Xaml.IAttachedPropertyStore> ve <xref:System.Xaml.AttachablePropertyServices>.</span><span class="sxs-lookup"><span data-stu-id="8b18e-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="8b18e-190"><xref:System.Xaml.IAttachedPropertyStore> XAML yazarlar tarafından deposu uygulaması bulmak için kullanılır ve türü üzerinde uygulanmadı `target` erişimciler.</span><span class="sxs-lookup"><span data-stu-id="8b18e-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="8b18e-191">Statik <xref:System.Xaml.AttachablePropertyServices> API'leri erişimciler gövdesi içinde kullanılır ve takılabilir üyesi tarafından başvurmak kendi <xref:System.Xaml.AttachableMemberIdentifier>.</span><span class="sxs-lookup"><span data-stu-id="8b18e-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="8b18e-192">XAML ilişkili CLR öznitelikleri</span><span class="sxs-lookup"><span data-stu-id="8b18e-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="8b18e-193">Doğru türleri, üyeleri ve derlemeler öznitelik atanıyor rapor .NET Framework XAML Hizmetleri için XAML tür sistem bilgileri sırada önemlidir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="8b18e-194">Bu, .NET Framework XAML Hizmetleri XAML okuyucuları ve XAML yazıcılarının doğrudan bağlı XAML sistemleri ile kullanmak için türlerinizi düşünüyorsanız veya tanımlayın veya bu XAML okuyucuları ve XAML yazıcılarının temel XAML kullanılarak bir Framework'te kullanıyorsanız geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="8b18e-195">Özel türler XAML desteği için uygun olan her XAML ilişkili bir öznitelik listesi için bkz: [özel türler ve Kitaplıkar için XAML-Related CLR öznitelikleri](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="8b18e-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="8b18e-196">Kullanım</span><span class="sxs-lookup"><span data-stu-id="8b18e-196">Usage</span></span>  
 <span data-ttu-id="8b18e-197">Özel türler kullanımını biçimlendirme Yazar özel türü içeren derleme ve CLR ad alanı için bir önek eşlenmelidir gerektirir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="8b18e-198">Bu yordam, bu konudaki belgelenmemiştir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="8b18e-199">Erişim düzeyi</span><span class="sxs-lookup"><span data-stu-id="8b18e-199">Access Level</span></span>  
 <span data-ttu-id="8b18e-200">XAML yükleme ve türleri örneği için bir yol sağlayan bir `internal` erişim düzeyi.</span><span class="sxs-lookup"><span data-stu-id="8b18e-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="8b18e-201">Bu özellik, kullanıcı kodu kendi türlerini tanımlayın ve ardından aynı kullanıcı kod kapsamını parçası olduğunu da biçimlendirme bu sınıflardan örneği sağlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="8b18e-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="8b18e-202">Kullanıcı kodu tanımlayan her bir örnektir WPF gelen bir <xref:System.Windows.Controls.UserControl> UI davranışı yeniden düzenlemeniz için bir yöntem olarak, ancak destekleyen sınıfı bildirerek kapsanan herhangi bir olası uzantısı mekanizma parçası olarak değil hedeflenen `public` erişim düzeyi.</span><span class="sxs-lookup"><span data-stu-id="8b18e-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="8b18e-203">Bu tür bir <xref:System.Windows.Controls.UserControl> ile bildirilen `internal` yedekleme kodunun içinden, başvurulan bir XAML tür olarak aynı bütünleştirilmiş derlenir erişme.</span><span class="sxs-lookup"><span data-stu-id="8b18e-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="8b18e-204">XAML altında tam güven yükler ve kullanan bir uygulama için <xref:System.Xaml.XamlObjectWriter>, sınıflarıyla yüklenirken `internal` erişim düzeyi her zaman etkindir.</span><span class="sxs-lookup"><span data-stu-id="8b18e-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="8b18e-205">Kısmi güven altında XAML yükleyen bir uygulama için erişim düzeyi özelliklerini kullanarak denetleyebilirsiniz <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span><span class="sxs-lookup"><span data-stu-id="8b18e-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="8b18e-206">Ayrıca, erteleme mekanizmaları (örneğin, WPF şablon sistemi) tüm erişim düzeyi izinleri yaymak ve son çalıştırma değerlendirmeleri için korumak olması gerekir; Bu geçirerek dahili olarak işlenir <xref:System.Xaml.Permissions.XamlAccessLevel> bilgi.</span><span class="sxs-lookup"><span data-stu-id="8b18e-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="8b18e-207">WPF uygulaması</span><span class="sxs-lookup"><span data-stu-id="8b18e-207">WPF Implementation</span></span>  
 <span data-ttu-id="8b18e-208">WPF XAML BAML altında kısmi güven yüklerse, erişimin sınırlı olduğu bir kısmi güven erişim modeli kullanan <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> BAML kaynak assembly için.</span><span class="sxs-lookup"><span data-stu-id="8b18e-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="8b18e-209">WPF erteleme için kullandığı <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> erişim düzeyi bilgi geçirme için bir mekanizma olarak.</span><span class="sxs-lookup"><span data-stu-id="8b18e-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="8b18e-210">WPF XAML terminoloji içinde bir *iç tür* de başvuru XAML içeren aynı derlemesi tarafından tanımlanan bir tür.</span><span class="sxs-lookup"><span data-stu-id="8b18e-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="8b18e-211">Bu tür bir türü kasıtlı olarak derleme atlar XAML ad uzayı eşlenebilir bir bu gibi bir durumda eşleme kısmı = `xmlns:local="clr-namespace:WPFApplication1"`.</span><span class="sxs-lookup"><span data-stu-id="8b18e-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="8b18e-212">BAML iç tür başvuran varsa ve türü olduğunu `internal` erişim düzeyi, bu oluşturur bir `GeneratedInternalTypeHelper` derleme için sınıf.</span><span class="sxs-lookup"><span data-stu-id="8b18e-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="8b18e-213">Önlemek istiyorsanız `GeneratedInternalTypeHelper`, ya da kullanmalıdır `public` erişim düzeyini veya gerekir ilgili sınıfı ayrı bir derleme faktörü ve bu derleme kaynağına bağımlı kılın.</span><span class="sxs-lookup"><span data-stu-id="8b18e-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8b18e-214">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="8b18e-214">See Also</span></span>  
 [<span data-ttu-id="8b18e-215">Özel Türler ve Kitaplıklar İçin XAML İlişkili CLR Öznitelikleri</span><span class="sxs-lookup"><span data-stu-id="8b18e-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)  
 [<span data-ttu-id="8b18e-216">XAML Hizmetleri</span><span class="sxs-lookup"><span data-stu-id="8b18e-216">XAML Services</span></span>](../../../docs/framework/xaml-services/index.md)

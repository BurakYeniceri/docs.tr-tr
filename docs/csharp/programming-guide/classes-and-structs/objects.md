---
title: "Nesneler (C# Programlama Kılavuzu)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- objects [C#], about objects
- variables [C#]
ms.assetid: af4a5230-fbf3-4eea-95e1-8b883c2f845c
caps.latest.revision: "26"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: f8a8e283b42b27a40780068be42c03fc5047a511
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/21/2017
---
# <a name="objects-c-programming-guide"></a><span data-ttu-id="4ac59-102">Nesneler (C# Programlama Kılavuzu)</span><span class="sxs-lookup"><span data-stu-id="4ac59-102">Objects (C# Programming Guide)</span></span>
<span data-ttu-id="4ac59-103">Bir sınıf veya yapı türü neler yapabileceğinizi belirten şeması gibi tanımıdır.</span><span class="sxs-lookup"><span data-stu-id="4ac59-103">A class or struct definition is like a blueprint that specifies what the type can do.</span></span> <span data-ttu-id="4ac59-104">Bir nesne temelde ayrılmış ve şeması göre yapılandırılmış bellek bloğudur.</span><span class="sxs-lookup"><span data-stu-id="4ac59-104">An object is basically a block of memory that has been allocated and configured according to the blueprint.</span></span> <span data-ttu-id="4ac59-105">Bir program aynı sınıfın birçok nesne oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="4ac59-105">A program may create many objects of the same class.</span></span> <span data-ttu-id="4ac59-106">Nesnelerin örneklerini de denir ve bir adlandırılmış değişkeninde veya bir dizi ya da koleksiyon depolanabilir.</span><span class="sxs-lookup"><span data-stu-id="4ac59-106">Objects are also called instances, and they can be stored in either a named variable or in an array or collection.</span></span> <span data-ttu-id="4ac59-107">İstemci, bu değişkenleri yöntemlerini çağırın ve nesneyi genel özelliklerine erişmek için kullandığı kodu kodudur.</span><span class="sxs-lookup"><span data-stu-id="4ac59-107">Client code is the code that uses these variables to call the methods and access the public properties of the object.</span></span> <span data-ttu-id="4ac59-108">Bir nesne yönelimli dil C# gibi tipik bir program dinamik olarak etkileşim birden çok nesnelerin oluşur.</span><span class="sxs-lookup"><span data-stu-id="4ac59-108">In an object-oriented language such as C#, a typical program consists of multiple objects interacting dynamically.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ac59-109">Statik türleri burada açıklanan daha farklı şekilde davranır.</span><span class="sxs-lookup"><span data-stu-id="4ac59-109">Static types behave differently than what is described here.</span></span> <span data-ttu-id="4ac59-110">Daha fazla bilgi için bkz: [statik sınıflar ve statik sınıf üyeleri](../../../csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="4ac59-110">For more information, see [Static Classes and Static Class Members](../../../csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members.md).</span></span>  
  
## <a name="struct-instances-vs-class-instances"></a><span data-ttu-id="4ac59-111">Yapı örnekleri vs. Sınıf örnekleri</span><span class="sxs-lookup"><span data-stu-id="4ac59-111">Struct Instances vs. Class Instances</span></span>  
 <span data-ttu-id="4ac59-112">Sınıflar başvuru türleri olduğundan, bir sınıf nesnesi bir değişken nesne adresine başvuru yönetilen yığında tutar.</span><span class="sxs-lookup"><span data-stu-id="4ac59-112">Because classes are reference types, a variable of a class object holds a reference to the address of the object on the managed heap.</span></span> <span data-ttu-id="4ac59-113">İlk nesneyi ikinci nesneden aynı türde atanırsa, her iki değişken adresi nesnede başvurun.</span><span class="sxs-lookup"><span data-stu-id="4ac59-113">If a second object of the same type is assigned to the first object, then both variables refer to the object at that address.</span></span> <span data-ttu-id="4ac59-114">Bu nokta, bu konunun ilerleyen bölümlerinde daha ayrıntılı ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="4ac59-114">This point is discussed in more detail later in this topic.</span></span>  
  
 <span data-ttu-id="4ac59-115">Sınıfların örneklerini kullanarak oluşturulur [yeni işleç](../../../csharp/language-reference/keywords/new-operator.md).</span><span class="sxs-lookup"><span data-stu-id="4ac59-115">Instances of classes are created by using the [new operator](../../../csharp/language-reference/keywords/new-operator.md).</span></span> <span data-ttu-id="4ac59-116">Aşağıdaki örnekte, `Person` türü ve `person1` ve `person 2` örnekleri ya da nesnelerin türü.</span><span class="sxs-lookup"><span data-stu-id="4ac59-116">In the following example, `Person` is the type and `person1` and `person 2` are instances, or objects, of that type.</span></span>  
  
 [!code-csharp[csProgGuideStatements#30](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/objects_1.cs)]  
  
 <span data-ttu-id="4ac59-117">Yapılar değer türleri olduğundan, bir değişken yapısı nesnesinin tüm nesnesinin bir kopyasını tutar.</span><span class="sxs-lookup"><span data-stu-id="4ac59-117">Because structs are value types, a variable of a struct object holds a copy of the entire object.</span></span> <span data-ttu-id="4ac59-118">Yapılar örneklerini de oluşturulabilir kullanarak `new` işleci, ancak bu zorunlu değildir, aşağıdaki örnekte gösterildiği gibi:</span><span class="sxs-lookup"><span data-stu-id="4ac59-118">Instances of structs can also be created by using the `new` operator, but this is not required, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#31](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/objects_2.cs)]  
  
 <span data-ttu-id="4ac59-119">Her ikisi için de bellek `p1` ve `p2` iş parçacığı yığında ayrılmış.</span><span class="sxs-lookup"><span data-stu-id="4ac59-119">The memory for both `p1` and `p2` is allocated on the thread stack.</span></span> <span data-ttu-id="4ac59-120">Bu bellek türü veya yöntemi içinde bildirilmiş birlikte alınmadan.</span><span class="sxs-lookup"><span data-stu-id="4ac59-120">That memory is reclaimed along with the type or method in which it is declared.</span></span> <span data-ttu-id="4ac59-121">Yapılar atamada neden kopyalanır bir neden de budur.</span><span class="sxs-lookup"><span data-stu-id="4ac59-121">This is one reason why structs are copied on assignment.</span></span> <span data-ttu-id="4ac59-122">Nesne yapılan tüm başvuruları fazlası kapsam dışında aksine, bir sınıf örneği için ayrılan bellek (otomatik olarak geri çöp toplama) ortak dil çalışma zamanı tarafından durumdur.</span><span class="sxs-lookup"><span data-stu-id="4ac59-122">By contrast, the memory that is allocated for a class instance is automatically reclaimed (garbage collected) by the common language runtime when all references to the object have gone out of scope.</span></span> <span data-ttu-id="4ac59-123">C++'ta yapabildiğiniz gibi bir sınıf nesnesi belirleyici biçimde yok etmek mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="4ac59-123">It is not possible to deterministically destroy a class object like you can in C++.</span></span> <span data-ttu-id="4ac59-124">Çöp toplama hakkında daha fazla bilgi için [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], bkz: [çöp toplama](../../../standard/garbage-collection/index.md).</span><span class="sxs-lookup"><span data-stu-id="4ac59-124">For more information about garbage collection in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], see [Garbage Collection](../../../standard/garbage-collection/index.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ac59-125">Ayırma ve yönetilen yığında bellek ayırmayı kaldırma ortak dil çalışma zamanı'nda yüksek oranda iyileştirilmiş.</span><span class="sxs-lookup"><span data-stu-id="4ac59-125">The allocation and deallocation of memory on the managed heap is highly optimized in the common language runtime.</span></span> <span data-ttu-id="4ac59-126">Çoğu durumda bir sınıf örneği yığında yapısı örneği ayırma karşı yığınındaki ayırma performans maliyetini önemli fark yoktur.</span><span class="sxs-lookup"><span data-stu-id="4ac59-126">In most cases there is no significant difference in the performance cost of allocating a class instance on the heap versus allocating a struct instance on the stack.</span></span>  
  
## <a name="object-identity-vs-value-equality"></a><span data-ttu-id="4ac59-127">Nesne Kimliği vs. Değer eşitliği</span><span class="sxs-lookup"><span data-stu-id="4ac59-127">Object Identity vs. Value Equality</span></span>  
 <span data-ttu-id="4ac59-128">İki nesnenin eşitlik için karşılaştırdığınızda olup bellek aynı nesne iki değişken temsil eder ve bir veya daha fazla alanlarının değerleri eşdeğer olup bilmek istediğinizi ilk ayırdetmek.</span><span class="sxs-lookup"><span data-stu-id="4ac59-128">When you compare two objects for equality, you must first distinguish whether you want to know whether the two variables represent the same object in memory, or whether the values of one or more of their fields are equivalent.</span></span> <span data-ttu-id="4ac59-129">Değerleri Karşılaştır amaçlanıyorsa nesneleri değer türleri (yapılar) veya başvuru türleri (sınıfları, temsilciler, diziler) örneği olup olmadığını dikkate almanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="4ac59-129">If you are intending to compare values, you must consider whether the objects are instances of value types (structs) or reference types (classes, delegates, arrays).</span></span>  
  
-   <span data-ttu-id="4ac59-130">İki sınıf örneklerini bellek aynı konumda başvurmak olup olmadığını belirlemek için (aynı sahip oldukları anlamına gelir *kimlik*), statik kullanmak <xref:System.Object.Equals%2A> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="4ac59-130">To determine whether two class instances refer to the same location in memory (which means that they have the same *identity*), use the static <xref:System.Object.Equals%2A> method.</span></span> <span data-ttu-id="4ac59-131">(<xref:System.Object?displayProperty=nameWithType> tüm değer türleri ve başvuru türleri, kullanıcı tanımlı yapıları ve sınıfları dahil olmak üzere örtük temel sınıftır.)</span><span class="sxs-lookup"><span data-stu-id="4ac59-131">(<xref:System.Object?displayProperty=nameWithType> is the implicit base class for all value types and reference types, including user-defined structs and classes.)</span></span>  
  
-   <span data-ttu-id="4ac59-132">İki yapısı örneği örneği alanları aynı değerlere sahip olup olmadığını belirlemek için <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="4ac59-132">To determine whether the instance fields in two struct instances have the same values, use the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4ac59-133">Tüm yapılar örtük olarak öğesinden devraldığı <xref:System.ValueType?displayProperty=nameWithType>, doğrudan nesne üzerinde aşağıdaki örnekte gösterildiği gibi yöntemini çağırın:</span><span class="sxs-lookup"><span data-stu-id="4ac59-133">Because all structs implicitly inherit from <xref:System.ValueType?displayProperty=nameWithType>, you call the method directly on your object as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#32](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/objects_3.cs)]  
  
 <span data-ttu-id="4ac59-134"><xref:System.ValueType?displayProperty=nameWithType> Uyarlamasını `Equals` herhangi yapıda alanlar nelerdir belirlemek mümkün olması nedeniyle yansıma kullanır.</span><span class="sxs-lookup"><span data-stu-id="4ac59-134">The <xref:System.ValueType?displayProperty=nameWithType> implementation of `Equals` uses reflection because it must be able to determine what the fields are in any struct.</span></span> <span data-ttu-id="4ac59-135">Kendi yapılar oluştururken, geçersiz kılma `Equals` türünüz için belirli bir verimli eşitlik algoritma sağlamak için yöntem.</span><span class="sxs-lookup"><span data-stu-id="4ac59-135">When creating your own structs, override the `Equals` method to provide an efficient equality algorithm that is specific to your type.</span></span>  
  
-   <span data-ttu-id="4ac59-136">İki sınıf durumlarda alanlarına ait değerlerin eşit olup olmadığını belirlemek için kullanılacak olabilir <xref:System.Object.Equals%2A> yöntemi veya [== işleci](../../../csharp/language-reference/operators/equality-comparison-operator.md).</span><span class="sxs-lookup"><span data-stu-id="4ac59-136">To determine whether the values of the fields in two class instances are equal, you might be able to use the <xref:System.Object.Equals%2A> method or the [== operator](../../../csharp/language-reference/operators/equality-comparison-operator.md).</span></span> <span data-ttu-id="4ac59-137">Sınıf geçersiz veya bu türündeki nesneler için hangi "eşitlik" anlamına gelir, özel bir tanımını sağlamak için aşırı yüklü, ancak yalnızca kullanın.</span><span class="sxs-lookup"><span data-stu-id="4ac59-137">However, only use them if the class has overridden or overloaded them to provide a custom definition of what "equality" means for objects of that type.</span></span> <span data-ttu-id="4ac59-138">Sınıf ayrıca uygulayabilir <xref:System.IEquatable%601> arabirimi veya <xref:System.Collections.Generic.IEqualityComparer%601> arabirimi.</span><span class="sxs-lookup"><span data-stu-id="4ac59-138">The class might also implement the <xref:System.IEquatable%601> interface or the <xref:System.Collections.Generic.IEqualityComparer%601> interface.</span></span> <span data-ttu-id="4ac59-139">Her iki arabirimde değer eşitliği test etmek için kullanılan yöntemleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="4ac59-139">Both interfaces provide methods that can be used to test value equality.</span></span> <span data-ttu-id="4ac59-140">Ne zaman kendi tasarlama izin ver sınıfları bu geçersiz kılma `Equals`, belirtilen yönergeleri izlediğinizden emin olun [nasıl yapılır: bir tür için değer eşitliği tanımlama](../../../csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md) ve <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ac59-140">When designing your own classes that override `Equals`, make sure to follow the guidelines stated in [How to: Define Value Equality for a Type](../../../csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md) and <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span>  
  
## <a name="related-sections"></a><span data-ttu-id="4ac59-141">İlgili Bölümler</span><span class="sxs-lookup"><span data-stu-id="4ac59-141">Related Sections</span></span>  
 <span data-ttu-id="4ac59-142">Daha fazla bilgi için:</span><span class="sxs-lookup"><span data-stu-id="4ac59-142">For more information:</span></span>  
  
-   [<span data-ttu-id="4ac59-143">Sınıfları</span><span class="sxs-lookup"><span data-stu-id="4ac59-143">Classes</span></span>](../../../csharp/programming-guide/classes-and-structs/classes.md)  
  
-   [<span data-ttu-id="4ac59-144">Yapılar</span><span class="sxs-lookup"><span data-stu-id="4ac59-144">Structs</span></span>](../../../csharp/programming-guide/classes-and-structs/structs.md)  
  
-   [<span data-ttu-id="4ac59-145">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="4ac59-145">Constructors</span></span>](../../../csharp/programming-guide/classes-and-structs/constructors.md)  
  
-   [<span data-ttu-id="4ac59-146">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="4ac59-146">Finalizers</span></span>](../../../csharp/programming-guide/classes-and-structs/destructors.md)  
  
-   [<span data-ttu-id="4ac59-147">Olayları</span><span class="sxs-lookup"><span data-stu-id="4ac59-147">Events</span></span>](../../../csharp/programming-guide/events/index.md)  
  
## <a name="see-also"></a><span data-ttu-id="4ac59-148">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="4ac59-148">See Also</span></span>  
 [<span data-ttu-id="4ac59-149">C# programlama kılavuzu</span><span class="sxs-lookup"><span data-stu-id="4ac59-149">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="4ac59-150">Nesne</span><span class="sxs-lookup"><span data-stu-id="4ac59-150">object</span></span>](../../../csharp/language-reference/keywords/object.md)  
 [<span data-ttu-id="4ac59-151">Devralma</span><span class="sxs-lookup"><span data-stu-id="4ac59-151">Inheritance</span></span>](../../../csharp/programming-guide/classes-and-structs/inheritance.md)  
 [<span data-ttu-id="4ac59-152">sınıfı</span><span class="sxs-lookup"><span data-stu-id="4ac59-152">class</span></span>](../../../csharp/language-reference/keywords/class.md)  
 [<span data-ttu-id="4ac59-153">yapısı</span><span class="sxs-lookup"><span data-stu-id="4ac59-153">struct</span></span>](../../../csharp/language-reference/keywords/struct.md)  
 [<span data-ttu-id="4ac59-154">New işleci</span><span class="sxs-lookup"><span data-stu-id="4ac59-154">new Operator</span></span>](../../../csharp/language-reference/keywords/new-operator.md)  
 [<span data-ttu-id="4ac59-155">Ortak tür sistemi</span><span class="sxs-lookup"><span data-stu-id="4ac59-155">Common Type System</span></span>](../../../standard/base-types/common-type-system.md)

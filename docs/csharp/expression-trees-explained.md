---
title: "İfade ağaçları açıklanmıştır"
description: "İfade ağaçları ve nasıl yürütmeden önce dış yürütme ve İnceleme kod çevirme algoritmaları yararlı oldukları hakkında bilgi edinin."
keywords: .NET, .NET core
author: BillWagner
ms.author: wiwagn
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: 1de856a139ac7a6dee25f1dae54924e33f14a33b
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/18/2017
---
# <a name="expression-trees-explained"></a><span data-ttu-id="d9b45-104">İfade ağaçları açıklanmıştır</span><span class="sxs-lookup"><span data-stu-id="d9b45-104">Expression Trees Explained</span></span>

[<span data-ttu-id="d9b45-105">Önceki--genel bakış</span><span class="sxs-lookup"><span data-stu-id="d9b45-105">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="d9b45-106">Bir ifade ağacına kodu tanımlayan bir veri yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="d9b45-106">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="d9b45-107">Bunlar, bir derleyici kodu çözümlemek ve derlenmiş çıktı üretmek için kullandığı aynı yapıları temel alır.</span><span class="sxs-lookup"><span data-stu-id="d9b45-107">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="d9b45-108">Bu öğreticide okurken oldukça biraz benzerlik ifade ağaçları Roslyn API'leri oluşturmak için kullanılan türleri arasındaki fark edeceksiniz [Çözümleyicileri ve CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span><span class="sxs-lookup"><span data-stu-id="d9b45-108">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="d9b45-109">(Çözümleyicileri ve CodeFixes kodu statik çözümlemesi ve olası düzeltmeler için bir geliştirici önerebilir NuGet paketlerdir.) Kavram benzer ve sonuç anlamlı bir şekilde kaynak kodunu incelenmesi izin veren bir veri yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="d9b45-109">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="d9b45-110">Ancak, ifade ağaçları sınıfları ve API'leri Roslyn API'ları daha farklı bir dizi temel alır.</span><span class="sxs-lookup"><span data-stu-id="d9b45-110">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>
    
<span data-ttu-id="d9b45-111">Basit bir örneğe bakalım.</span><span class="sxs-lookup"><span data-stu-id="d9b45-111">Let's look at a simple example.</span></span>
<span data-ttu-id="d9b45-112">Bir kod satırı şöyledir:</span><span class="sxs-lookup"><span data-stu-id="d9b45-112">Here's a line of code:</span></span>
```csharp
var sum = 1 + 2;
```
<span data-ttu-id="d9b45-113">Bu bir ifade ağacına çözümlemek için olsaydı, ağaç birçok düğümlerini içerir.</span><span class="sxs-lookup"><span data-stu-id="d9b45-113">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="d9b45-114">Atama değişken bildirimi deyimiyle en dıştaki düğümdür (`var sum = 1 + 2;`) o en dıştaki düğüm birkaç alt düğümleri içerir: bir değişken bildirimi, bir atama işleci ve sağ tarafındaki eşittir işareti temsil eden bir ifade.</span><span class="sxs-lookup"><span data-stu-id="d9b45-114">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="d9b45-115">İfade başka ek işlemi ve ayrıca sol ve sağ işlenenleri temsil eden ifadelere bölünmüştür.</span><span class="sxs-lookup"><span data-stu-id="d9b45-115">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="d9b45-116">Şimdi biraz daha sağ tarafındaki eşittir işareti olun ifadeleri detaya.</span><span class="sxs-lookup"><span data-stu-id="d9b45-116">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="d9b45-117">İfade `1 + 2`.</span><span class="sxs-lookup"><span data-stu-id="d9b45-117">The expression is `1 + 2`.</span></span> <span data-ttu-id="d9b45-118">Bu ikili bir ifadedir.</span><span class="sxs-lookup"><span data-stu-id="d9b45-118">That's a binary expression.</span></span> <span data-ttu-id="d9b45-119">Daha açık belirtmek gerekirse bir ikili Toplama ifadesi değil.</span><span class="sxs-lookup"><span data-stu-id="d9b45-119">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="d9b45-120">Bir ikili Toplama ifadesi toplama ifadesinin sol ve sağ düğümleri temsil eden iki alt sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d9b45-120">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="d9b45-121">Her iki düğüm sabit ifadeler şunlardır: sol işleneni değerdir `1`, ve sağ işleneni değerdir `2`.</span><span class="sxs-lookup"><span data-stu-id="d9b45-121">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="d9b45-122">Görsel olarak, tüm deyimi bir ağacıdır: kök düğümde başlatın ve ağacında deyimi yapar kodu görmek için her düğüme seyahat:</span><span class="sxs-lookup"><span data-stu-id="d9b45-122">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="d9b45-123">Atama deyimiyle değişken bildirimi (`var sum = 1 + 2;`)</span><span class="sxs-lookup"><span data-stu-id="d9b45-123">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
    * <span data-ttu-id="d9b45-124">Örtük değişken türü bildirimi (`var sum`)</span><span class="sxs-lookup"><span data-stu-id="d9b45-124">Implicit variable type declaration (`var sum`)</span></span>
        - <span data-ttu-id="d9b45-125">Örtük var anahtar sözcüğü (`var`)</span><span class="sxs-lookup"><span data-stu-id="d9b45-125">Implicit var keyword (`var`)</span></span>
        - <span data-ttu-id="d9b45-126">Değişken adı bildirimi (`sum`)</span><span class="sxs-lookup"><span data-stu-id="d9b45-126">Variable name declaration (`sum`)</span></span>
    * <span data-ttu-id="d9b45-127">Atama işleci (`=`)</span><span class="sxs-lookup"><span data-stu-id="d9b45-127">Assignment operator (`=`)</span></span>
    * <span data-ttu-id="d9b45-128">İkili Toplama ifadesi (`1 + 2`)</span><span class="sxs-lookup"><span data-stu-id="d9b45-128">Binary addition expression (`1 + 2`)</span></span>
        - <span data-ttu-id="d9b45-129">Sol işleneni (`1`)</span><span class="sxs-lookup"><span data-stu-id="d9b45-129">Left operand (`1`)</span></span>
        - <span data-ttu-id="d9b45-130">Toplama işleci (`+`)</span><span class="sxs-lookup"><span data-stu-id="d9b45-130">Addition operator (`+`)</span></span>
        - <span data-ttu-id="d9b45-131">Sağ işleneni (`2`)</span><span class="sxs-lookup"><span data-stu-id="d9b45-131">Right operand (`2`)</span></span>

<span data-ttu-id="d9b45-132">Bu karmaşık görünebilir, ancak çok güçlü bir özelliktir.</span><span class="sxs-lookup"><span data-stu-id="d9b45-132">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="d9b45-133">Aynı işlemi çok daha karmaşık ifadeler bozabilir.</span><span class="sxs-lookup"><span data-stu-id="d9b45-133">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="d9b45-134">Bu ifade göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="d9b45-134">Consider this expression:</span></span>
```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="d9b45-135">Yukarıdaki aynı zamanda bir atamasına sahip bir değişken bildirimi ifadesidir.</span><span class="sxs-lookup"><span data-stu-id="d9b45-135">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="d9b45-136">Bu örnekte, sağ taraftaki atamasının çok daha karmaşık bir ağacıdır.</span><span class="sxs-lookup"><span data-stu-id="d9b45-136">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="d9b45-137">Bu ifade parçalayın, ancak ne farklı düğümler olabilir göz önünde bulundurun yapacağım değil.</span><span class="sxs-lookup"><span data-stu-id="d9b45-137">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="d9b45-138">Geçerli nesneyi kullanarak bir alıcı, açık olan bir yöntem çağrıları vardır `this` alıcı, mevcut bir.</span><span class="sxs-lookup"><span data-stu-id="d9b45-138">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="d9b45-139">Yöntem çağrıları diğer alıcı nesneleri kullanarak, farklı türlerde sabit bir bağımsız değişken.</span><span class="sxs-lookup"><span data-stu-id="d9b45-139">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="d9b45-140">Ve son olarak, bir ikili Toplama işleci yok.</span><span class="sxs-lookup"><span data-stu-id="d9b45-140">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="d9b45-141">Dönüş türüne bağlı olarak `SecretSauceFunction()` veya `MoreSecretSauce()`, bu ikili Toplama işleci sınıfı için tanımlanmış ikili Toplama işleci için bir statik yöntem çağrısı çözümleme bir geçersiz kılınan Toplama işleci için bir yöntem çağrısı olabilir.</span><span class="sxs-lookup"><span data-stu-id="d9b45-141">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="d9b45-142">Algılanan bu karmaşıklıktan rağmen yukarıdaki ifadeyi ilk örnek olarak kolayca olarak gittiğinizde bir ağaç yapısı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="d9b45-142">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="d9b45-143">İfade yaprak düğümlerin bulmak için alt düğümleri geçme tutmak.</span><span class="sxs-lookup"><span data-stu-id="d9b45-143">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="d9b45-144">Üst düğüm kendi alt öğelerine başvurular varsa ve her düğüm ne tür bir düğümü tanımlar bir özelliğe sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d9b45-144">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="d9b45-145">Bir ifade ağacına yapısını çok tutarlıdır.</span><span class="sxs-lookup"><span data-stu-id="d9b45-145">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="d9b45-146">Temel bilgileri öğrendiğinize sonra bir ifade ağacına temsil edilir olduğunda bile en karmaşık kod anlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d9b45-146">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="d9b45-147">Veri yapısı içinde şıklık nasıl C# Derleyici en karmaşık C# programları çözümleyebilir ve bu karmaşık kaynak kodundan uygun çıkış oluşturma açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="d9b45-147">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="d9b45-148">İfade ağaçları yapısıyla tanıdık sonra hızlı bir şekilde elde bilgi, pek çok daha Gelişmiş senaryolar ile çalışmanıza olanak sağlar bulacaksınız.</span><span class="sxs-lookup"><span data-stu-id="d9b45-148">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="d9b45-149">İfade ağaçları inanılmaz gücü yoktur.</span><span class="sxs-lookup"><span data-stu-id="d9b45-149">There is incredible power to expression trees.</span></span>

<span data-ttu-id="d9b45-150">Diğer ortamlarda yürütmek için algoritmaları çevirme ek olarak, ifade ağaçları yürütmeden önce kodu incelemek algoritmaları yazmayı kolaylaştırmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="d9b45-150">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="d9b45-151">Bir yöntemi olan bağımsız değişkenler ifadelerini ve kod çalıştırmadan önce bu ifadeleri inceleyin yazabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d9b45-151">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="d9b45-152">İfade ağacına kodu tam gösterimidir: herhangi bir alt ifade değerlerini görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d9b45-152">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="d9b45-153">Yöntem ve özellik adları görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d9b45-153">You can see method and property names.</span></span> <span data-ttu-id="d9b45-154">Tüm sabit ifadeler değerini görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d9b45-154">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="d9b45-155">Bir ifade ağacına yürütülebilir bir temsilci dönüştürmek ve kod yürütebilir.</span><span class="sxs-lookup"><span data-stu-id="d9b45-155">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="d9b45-156">İfade ağaçları API'leri neredeyse tüm geçerli kod yapısını temsil eden ağaçları oluşturmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="d9b45-156">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="d9b45-157">Ancak, işleri olabildiğince basit tutmak için bazı C# deyimleri bir ifade ağacına olarak oluşturulamıyor.</span><span class="sxs-lookup"><span data-stu-id="d9b45-157">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="d9b45-158">Bir örnektir zaman uyumsuz ifadeleri (kullanarak `async` ve `await` anahtar sözcükler).</span><span class="sxs-lookup"><span data-stu-id="d9b45-158">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="d9b45-159">Zaman uyumsuz algoritmaları gereksinimlerinizi ihtiyacınız varsa işlemek gerekir `Task` derleyici desteği kullanan yerine doğrudan nesneleri.</span><span class="sxs-lookup"><span data-stu-id="d9b45-159">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="d9b45-160">Başka bir döngüler oluşturmada olur.</span><span class="sxs-lookup"><span data-stu-id="d9b45-160">Another is in creating loops.</span></span> <span data-ttu-id="d9b45-161">Bunlar kullanarak oluşturduğunuz genellikle `for`, `foreach`, `while` veya `do` döngüler.</span><span class="sxs-lookup"><span data-stu-id="d9b45-161">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="d9b45-162">Gördüğünüz gibi [bu serideki sonraki](expression-trees-building.md), ile tek döngü ifade için ifade ağaçları API'lerini destekleyen `break` ve `continue` döngü yinelenen denetim ifadeleri.</span><span class="sxs-lookup"><span data-stu-id="d9b45-162">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="d9b45-163">Yapamayacağınız tek şey, bir ifade ağacına Değiştir ' dir.</span><span class="sxs-lookup"><span data-stu-id="d9b45-163">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="d9b45-164">İfade ağaçları değişmez veri yapılarını ' dir.</span><span class="sxs-lookup"><span data-stu-id="d9b45-164">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="d9b45-165">(Değiştirin) bir ifade ağacına kesilecek istiyorsanız, bir kopyası özgün, ancak istenen değişikliklerinizi içeren yeni bir ağaç oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="d9b45-165">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span> 

[<span data-ttu-id="d9b45-166">Sonraki--Framework destekleyen ifade ağaçları türleri</span><span class="sxs-lookup"><span data-stu-id="d9b45-166">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)

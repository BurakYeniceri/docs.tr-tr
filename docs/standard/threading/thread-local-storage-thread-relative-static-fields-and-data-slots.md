---
title: 'İş Parçacığı Yerel Deposu: İş Parçacığı Göreli Statik Alanları ve Veri Yuvaları'
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], local storage
- threading [.NET Framework], thread-relative static fields
- local thread storage
- TLS
ms.assetid: c633a4dc-a790-4ed1-96b5-f72bd968b284
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: a17bc509c8c82bfb30811ec3511207ca2d823e5b
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33589860"
---
# <a name="thread-local-storage-thread-relative-static-fields-and-data-slots"></a><span data-ttu-id="45d75-102">İş Parçacığı Yerel Deposu: İş Parçacığı Göreli Statik Alanları ve Veri Yuvaları</span><span class="sxs-lookup"><span data-stu-id="45d75-102">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span>
<span data-ttu-id="45d75-103">İş parçacığı ve uygulama etki alanı için benzersiz olan yönetilen iş parçacığı yerel depolaması (TLS) verileri depolamak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="45d75-103">You can use managed thread local storage (TLS) to store data that is unique to a thread and application domain.</span></span> <span data-ttu-id="45d75-104">.NET Framework kullanmanın iki yolu yönetilen TLS sağlar: iş parçacığı göreli statik alanları ve veri yuvaları.</span><span class="sxs-lookup"><span data-stu-id="45d75-104">The .NET Framework provides two ways to use managed TLS: thread-relative static fields and data slots.</span></span>  
  
-   <span data-ttu-id="45d75-105">İş parçacığı göreli statik alanları kullanın (iş parçacığı göreli `Shared` alanları Visual Basic'te) tam ihtiyaçlarınıza derleme zamanında öngörüyorsanız.</span><span class="sxs-lookup"><span data-stu-id="45d75-105">Use thread-relative static fields (thread-relative `Shared` fields in Visual Basic) if you can anticipate your exact needs at compile time.</span></span> <span data-ttu-id="45d75-106">İş parçacığı göreli statik alanları en iyi performans sağlar.</span><span class="sxs-lookup"><span data-stu-id="45d75-106">Thread-relative static fields provide the best performance.</span></span> <span data-ttu-id="45d75-107">Bunlar ayrıca, derleme zamanı tür denetimi avantajlarını sağlar.</span><span class="sxs-lookup"><span data-stu-id="45d75-107">They also give you the benefits of compile-time type checking.</span></span>  
  
-   <span data-ttu-id="45d75-108">Gerçek gereksinimler yalnızca çalışma zamanında bulunan veri yuvaları kullanın.</span><span class="sxs-lookup"><span data-stu-id="45d75-108">Use data slots when your actual requirements might be discovered only at run time.</span></span> <span data-ttu-id="45d75-109">Veri yuvaları daha yavaş ve daha iş parçacığı göreli statik alanları kullanmak garip ve veri türü olarak depolanan <xref:System.Object>, bu nedenle, kullanmadan önce doğru türüne dönüştürmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="45d75-109">Data slots are slower and more awkward to use than thread-relative static fields, and data is stored as type <xref:System.Object>, so you must cast it to the correct type before you use it.</span></span>  
  
 <span data-ttu-id="45d75-110">Yönetilmeyen C++'da, kullandığınız `TlsAlloc` yuvaları dinamik olarak ayırabilir ve `__declspec(thread)` bir değişken iş parçacığı göreli depoda ayrılmalıdır bildirmek için.</span><span class="sxs-lookup"><span data-stu-id="45d75-110">In unmanaged C++, you use `TlsAlloc` to allocate slots dynamically and `__declspec(thread)` to declare that a variable should be allocated in thread-relative storage.</span></span> <span data-ttu-id="45d75-111">İş parçacığı göreli statik alanları ve veri yuvaları Bu davranış yönetilen bir sürümünü sağlayın.</span><span class="sxs-lookup"><span data-stu-id="45d75-111">Thread-relative static fields and data slots provide the managed version of this behavior.</span></span>  
  
 <span data-ttu-id="45d75-112">İçinde [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], kullanabileceğiniz <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> nesne ilk kullanıldığında gevşek başlatılmış iş parçacığı yerel nesneleri oluşturmak için sınıf.</span><span class="sxs-lookup"><span data-stu-id="45d75-112">In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> class to create thread-local objects that are initialized lazily when the object is first consumed.</span></span> <span data-ttu-id="45d75-113">Daha fazla bilgi için bkz: [geç başlatma](../../../docs/framework/performance/lazy-initialization.md).</span><span class="sxs-lookup"><span data-stu-id="45d75-113">For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="uniqueness-of-data-in-managed-tls"></a><span data-ttu-id="45d75-114">Yönetilen TLS veri benzersizliği</span><span class="sxs-lookup"><span data-stu-id="45d75-114">Uniqueness of Data in Managed TLS</span></span>  
 <span data-ttu-id="45d75-115">İş parçacığı göreli statik alanları veya veri yuvaları kullanıp yönetilen TLS veriler iş parçacığı ve uygulama etki alanı birleşimi benzersiz bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="45d75-115">Whether you use thread-relative static fields or data slots, data in managed TLS is unique to the combination of thread and application domain.</span></span>  
  
-   <span data-ttu-id="45d75-116">Her iki iş parçacığı aynı alan veya yuva kullandığınızda da bir uygulama etki alanı içinde başka bir iş parçacığı, verileri bir iş parçacığı değiştiremezsiniz.</span><span class="sxs-lookup"><span data-stu-id="45d75-116">Within an application domain, one thread cannot modify data from another thread, even when both threads use the same field or slot.</span></span>  
  
-   <span data-ttu-id="45d75-117">Bir iş parçacığı birden çok uygulama etki alanından aynı alan veya yuvası eriştiğinde, ayrı bir değeri her uygulama etki alanında korunur.</span><span class="sxs-lookup"><span data-stu-id="45d75-117">When a thread accesses the same field or slot from multiple application domains, a separate value is maintained in each application domain.</span></span>  
  
 <span data-ttu-id="45d75-118">Örneğin, bir iş parçacığı ayarlarsa iş parçacığı göreli statik alanının değeri başka bir uygulama etki alanı girer ve alanın değerini alır, ikinci uygulama etki alanında alınan değeri ilk uygulama etki alanı değeri farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="45d75-118">For example, if a thread sets the value of a thread-relative static field, enters another application domain, and then retrieves the value of the field, the value retrieved in the second application domain differs from the value in the first application domain.</span></span> <span data-ttu-id="45d75-119">İkinci uygulama etki alanı için yeni bir değer ayarı ilk uygulama etki alanın değerini etkilemez.</span><span class="sxs-lookup"><span data-stu-id="45d75-119">Setting a new value for the field in the second application domain does not affect the field's value in the first application domain.</span></span>  
  
 <span data-ttu-id="45d75-120">Benzer şekilde, bir iş parçacığı iki farklı uygulama etki alanları aynı adlandırılmış veri yuvasında aldığında, ilk uygulama etki alanı veriler ikinci uygulama etki alanındaki verilerden bağımsız olarak kalır.</span><span class="sxs-lookup"><span data-stu-id="45d75-120">Similarly, when a thread gets the same named data slot in two different application domains, the data in the first application domain remains independent of the data in the second application domain.</span></span>  
  
## <a name="thread-relative-static-fields"></a><span data-ttu-id="45d75-121">İş parçacığı göreli statik alanları</span><span class="sxs-lookup"><span data-stu-id="45d75-121">Thread-Relative Static Fields</span></span>  
 <span data-ttu-id="45d75-122">Veri parçası her zaman bir iş parçacığı ve uygulama etki alanı birleşimi benzersiz olduğunu biliyorsanız, uygulama <xref:System.ThreadStaticAttribute> özniteliği statik alan.</span><span class="sxs-lookup"><span data-stu-id="45d75-122">If you know that a piece of data is always unique to a thread and application-domain combination, apply the <xref:System.ThreadStaticAttribute> attribute to the static field.</span></span> <span data-ttu-id="45d75-123">Herhangi bir statik alan kullanacağınız alan kullanın.</span><span class="sxs-lookup"><span data-stu-id="45d75-123">Use the field as you would use any other static field.</span></span> <span data-ttu-id="45d75-124">Alan verileri kullanan her bir iş parçacığı için benzersizdir.</span><span class="sxs-lookup"><span data-stu-id="45d75-124">The data in the field is unique to each thread that uses it.</span></span>  
  
 <span data-ttu-id="45d75-125">İş parçacığı göreli statik alanları veri yuvaları daha iyi performans sağlar ve derleme zamanı tür denetimi avantajına sahiptir.</span><span class="sxs-lookup"><span data-stu-id="45d75-125">Thread-relative static fields provide better performance than data slots and have the benefit of compile-time type checking.</span></span>  
  
 <span data-ttu-id="45d75-126">Herhangi bir sınıf oluşturucu kodu alan erişen ilk bağlamında ilk iş parçacığı üzerinde çalışacağını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="45d75-126">Be aware that any class constructor code will run on the first thread in the first context that accesses the field.</span></span> <span data-ttu-id="45d75-127">İçin tüm diğer iş parçacıkları veya aynı uygulama etki alanı bağlamlarda, alanları başlatılacak `null` (`Nothing` Visual Basic'te) başvuru türleri oldukları veya türleri olmaları durumunda değerleri için varsayılan değer.</span><span class="sxs-lookup"><span data-stu-id="45d75-127">In all other threads or contexts in the same application domain, the fields will be initialized to `null` (`Nothing` in Visual Basic) if they are reference types, or to their default values if they are value types.</span></span> <span data-ttu-id="45d75-128">Bu nedenle, iş parçacığı göreli statik alanları başlatmak için sınıf oluşturucular güvenmemelisiniz.</span><span class="sxs-lookup"><span data-stu-id="45d75-128">Therefore, you should not rely on class constructors to initialize thread-relative static fields.</span></span> <span data-ttu-id="45d75-129">Bunun yerine, iş parçacığı göreli statik alanları başlatma önlemek ve bunlar için başlatılır varsayın `null` (`Nothing`) veya varsayılan değerlerine.</span><span class="sxs-lookup"><span data-stu-id="45d75-129">Instead, avoid initializing thread-relative static fields and assume that they are initialized to `null` (`Nothing`) or to their default values.</span></span>  
  
## <a name="data-slots"></a><span data-ttu-id="45d75-130">Veri yuvaları</span><span class="sxs-lookup"><span data-stu-id="45d75-130">Data Slots</span></span>  
 <span data-ttu-id="45d75-131">.NET Framework birleşimi iş parçacığı ve uygulama etki alanı için benzersiz dinamik veri yuvaları sağlar.</span><span class="sxs-lookup"><span data-stu-id="45d75-131">The .NET Framework provides dynamic data slots that are unique to a combination of thread and application-domain.</span></span> <span data-ttu-id="45d75-132">İki tür veri yuvaları: yuvaları ve adsız yuvaları adlı.</span><span class="sxs-lookup"><span data-stu-id="45d75-132">There are two types of data slots: named slots and unnamed slots.</span></span> <span data-ttu-id="45d75-133">Her ikisi de kullanılarak uygulanan <xref:System.LocalDataStoreSlot> yapısı.</span><span class="sxs-lookup"><span data-stu-id="45d75-133">Both are implemented by using the <xref:System.LocalDataStoreSlot> structure.</span></span>  
  
-   <span data-ttu-id="45d75-134">Bir adlandırılmış veri yuva oluşturmak üzere kullanmanız <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> veya <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="45d75-134">To create a named data slot, use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="45d75-135">Varolan bir yuva adlı bir başvuru almak için adının geçirmek <xref:System.Threading.Thread.GetNamedDataSlot%2A> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="45d75-135">To get a reference to an existing named slot, pass its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method.</span></span>  
  
-   <span data-ttu-id="45d75-136">Adlandırılmamış yuvası oluşturmak üzere kullanmanız <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="45d75-136">To create an unnamed data slot, use the <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="45d75-137">Hem adlandırılmış ve adlandırılmamış yuvaları için kullanmak <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> ve <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> ayarlamak ve yuva bilgileri almak için yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="45d75-137">For both named and unnamed slots, use the <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> methods to set and retrieve the information in the slot.</span></span> <span data-ttu-id="45d75-138">Bunları şu anda yürütülmekte iş parçacığı için veriler her zaman hareket statik yöntemler şunlardır.</span><span class="sxs-lookup"><span data-stu-id="45d75-138">These are static methods that always act on the data for the thread that is currently executing them.</span></span>  
  
 <span data-ttu-id="45d75-139">Adının geçirerek ihtiyacınız olduğunda, yuva alabilirsiniz çünkü adlandırılmış yuvaları uygun, olabilir <xref:System.Threading.Thread.GetNamedDataSlot%2A> adlandırılmamış yuvası başvuru koruma yerine yöntemi.</span><span class="sxs-lookup"><span data-stu-id="45d75-139">Named slots can be convenient, because you can retrieve the slot when you need it by passing its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method, instead of maintaining a reference to an unnamed slot.</span></span> <span data-ttu-id="45d75-140">Ancak, başka bir bileşenin iş parçacığı göreli depolama alanı için aynı adı kullanan ve bir iş parçacığı bileşeniniz hem diğer bileşeni kodu yürütür, iki bileşenden diğer kişilerin veri bozulmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="45d75-140">However, if another component uses the same name for its thread-relative storage and a thread executes code from both your component and the other component, the two components might corrupt each other's data.</span></span> <span data-ttu-id="45d75-141">(Bu senaryoda, her iki bileşenin aynı uygulama etki alanında çalıştığından ve bunlar aynı veri paylaşmak için tasarlanmamıştır varsayar.)</span><span class="sxs-lookup"><span data-stu-id="45d75-141">(This scenario assumes that both components are running in the same application domain, and that they are not designed to share the same data.)</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="45d75-142">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="45d75-142">See Also</span></span>  
 <xref:System.ContextStaticAttribute>  
 <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType>  
 <xref:System.ThreadStaticAttribute>  
 <xref:System.Runtime.Remoting.Messaging.CallContext>  
 [<span data-ttu-id="45d75-143">İş parçacığı oluşturma</span><span class="sxs-lookup"><span data-stu-id="45d75-143">Threading</span></span>](../../../docs/standard/threading/index.md)

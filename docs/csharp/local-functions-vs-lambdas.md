---
title: Lambda ifadeleri ve yerel işlevler
description: Lambda ifadeleri daha iyi bir seçim yerel işlevler neden olabilecek bilgi edinin.
ms.date: 06/27/2016
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 5280605a7101a5b89c062fcf736909173bebf78c
ms.sourcegitcommit: 43924acbdbb3981d103e11049bbe460457d42073
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/23/2018
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="7a5f1-103">Lambda ifadeleri karşılaştırma yerel işlevler</span><span class="sxs-lookup"><span data-stu-id="7a5f1-103">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="7a5f1-104">İlk bakışta, [yerel işlevler](programming-guide/classes-and-structs/local-functions.md) ve [lambda ifadeleri](lambda-expressions.md) çok benzer.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-104">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="7a5f1-105">Çoğu durumda, lambda ifadeleri ve yerel işlevlerini kullanma arasında seçim, stil ve kişisel tercih bir konudur.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-105">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="7a5f1-106">Ancak, burada birini veya diğerini farkında olmanız gereken kullanabilirsiniz gerçek farklar vardır.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-106">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="7a5f1-107">Lambda ifadesi uygulamaları Faktöriyel algoritmasının ve yerel işlevi arasındaki farkları inceleyelim.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-107">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="7a5f1-108">İlk yerel işlevini kullanarak sürüm:</span><span class="sxs-lookup"><span data-stu-id="7a5f1-108">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="7a5f1-109">Bu uygulama lambda ifadeleri kullanan bir sürüm ile karşılaştırın.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-109">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="7a5f1-110">Yerel işlevler adlara sahip.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-110">The local functions have names.</span></span> <span data-ttu-id="7a5f1-111">Lambda ifadeleri değişkenler için atanan anonim yöntemlerdir `Func` veya `Action` türleri.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-111">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="7a5f1-112">Yerel bir işlev bildirirken bağımsız değişken türleri ve dönüş türü, işlev bildirimi parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-112">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="7a5f1-113">Lambda gövde bölümü yerine ifadesi, bağımsız değişken türleri ve dönüş türü, lambda ifadenin değişken türü bildirimi parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-113">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="7a5f1-114">Bu iki fark daha anlaşılır kod oluşturulmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-114">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="7a5f1-115">Yerel işlevler lambda ifadeleri daha kesin atamaya ilişkin farklı kuralları vardır.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-115">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="7a5f1-116">Yerel işlev bildirimi kapsamında olduğu herhangi bir kod konumdan başvurulabilir.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-116">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="7a5f1-117">Bunu erişileceği (veya lambda ifadesi başvuran delgate adlı önce.) bir lambda ifadesi bir temsilci değişkenine atanan gerekir Lambda ifadesi kullanarak sürüm bildirme gerekir ve lambda ifadesi başlatma Uyarısı `nthFactorial` kendisini tanımlayan önce.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-117">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delgate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="7a5f1-118">Bunu yapmazsanız sonuçlanıyor başvuran bir derleme zamanı hatası `nthFactorial` atayarak önce.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-118">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="7a5f1-119">Bu farklılıklar, yinelemeli algoritmalar yerel işlevler kullanılarak oluşturmak kolaydır anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-119">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="7a5f1-120">Bildirme ve kendi kendini çağıran yerel bir işlev tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-120">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="7a5f1-121">Lambda ifadeleri gerekir bildirilen ve aynı lambda ifadesi başvuruda bulunan bir gövde yeniden atandığında kullanılabilmesi için öncelikle bir varsayılan değer atanmış.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-121">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="7a5f1-122">Kesin atama kurallarının yerel işlevi veya lamdba ifade tarafından yakalanan tüm değişkenleri de etkiler.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-122">Definite assignment rules also affect any variables that are captured by the local function or lamdba expression.</span></span> <span data-ttu-id="7a5f1-123">Yerel işlevler ve lambda ifadesi kuralları yerel işlevi veya lambda ifadesi bir temsilciye dönüştürüldüğünde yakalanan değişkenlerin kesinlikle bir noktada atanan talep.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-123">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="7a5f1-124">Bunlar bildirirken lambda ifadeleri temsilcileri dönüştürülür farktır.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-124">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="7a5f1-125">Yerel işlevler yalnızca bir temsilci olarak kullanıldığında temsilciler dönüştürülür.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-125">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="7a5f1-126">Yerel bir işlev bildirme ve yalnızca gibi bir yöntemini çağırarak başvuru, bir temsilci dönüştürülmez.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-126">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="7a5f1-127">Bu kural, yerel bir işlev kapsayan kapsamı uygun bir konumda bildirmek sağlar.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-127">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="7a5f1-128">Tüm return deyimlerinde sonra yerel işlevler üst yöntemi sonunda bildirmek için yaygın bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-128">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="7a5f1-129">Üçüncü derleyici kesinlikle yakalanan değişkenleri çevreleyen kapsamdaki atamak yerel işlevler sağlayan statik çözümleme gerçekleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-129">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="7a5f1-130">Bu örneği göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="7a5f1-130">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="7a5f1-131">Derleyici, belirleyebilirsiniz `LocalFunction` kesinlikle atar `y` çağrıldığında.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-131">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="7a5f1-132">Çünkü `LocalFunction` önce adlı `return` deyimi, `y` definitiely atanmıştır `return` deyimi.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-132">Because `LocalFunction` is called before the `return` statement, `y` is definitiely assigned at the `return` statement.</span></span>

<span data-ttu-id="7a5f1-133">Örnek analiz etkinleştirir analiz dördüncü fark sağlar.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-133">The analysis that enables the example analysis enables the fourth difference.</span></span>
<span data-ttu-id="7a5f1-134">Kullanımlarını bağlı olarak, her zaman lambda ifadeleri için gerekli olan yığın ayırmaları yerel işlevler önleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-134">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="7a5f1-135">Yerel bir işlev hiçbir zaman bir temsilciye dönüştürülür ve yerel işlevi tarafından yakalanan değişkenleri hiçbiri diğer Lambda'lar veya temsilcileri dönüştürülür yerel işlevler tarafından yakalanır, derleyici yığın ayırmaları önleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-135">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span> 

<span data-ttu-id="7a5f1-136">Bu zaman uyumsuz örneği göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="7a5f1-136">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="7a5f1-137">Kapatılmak üzere bu lambda ifadesi içeriyor `address`, `index` ve `name` değişkenleri.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-137">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="7a5f1-138">Yerel işlevler söz konusu olduğunda, kapatma uygulayan nesnenin olabilir bir `struct` türü.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-138">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="7a5f1-139">Bu yapı türü, yerel işlev başvurusunu tarafından aktarılabilecek.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-139">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="7a5f1-140">Uygulamasında bu farkı bir ayırma işleminde kaydeder.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-140">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="7a5f1-141">Lambda ifadeleri için gerekli örneklemesi performans faktörü zaman açısından kritik kod yollarda olabilir ek bellek ayırmaları anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-141">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="7a5f1-142">Yerel işlevler bu zahmetine değil.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-142">Local functions do not incur this overhead.</span></span> <span data-ttu-id="7a5f1-143">Yukarıdaki örnekte, yerel işlevler sürüm 2 daha az ayırmaları lambda ifadesi sürümden sahiptir.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-143">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="7a5f1-144">Bu yöntem yerel işlevi denk bir sınıf Kapatılmak üzere de kullanır.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-144">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="7a5f1-145">Kapatılmak üzere yerel bir işlev olarak uygulanıp bir `class` veya `struct` bir uygulama ayrıntısı.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-145">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="7a5f1-146">Yerel bir işlev kullanabilir bir `struct` bir lambda her zaman kullanır ancak bir `class`.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-146">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "Task returning method with local function")]

<span data-ttu-id="7a5f1-147">Bu örnekte gösterilmez son avantajlarından biri yerel işlevler kullanılarak yineleyiciler uygulanabilir `yield return` sözdizimi değerleri dizisi üretir.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-147">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="7a5f1-148">`yield return` Deyimi lambda ifadelerde izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-148">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="7a5f1-149">Yerel işlevler lambda ifadeleri yedekli görünebilir, ancak bunlar aslında farklı amaçlara hizmet ve farklı kullanımlar sahip.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-149">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="7a5f1-150">Yalnızca başka bir yöntem bağlamından adlı bir işlev yazdığınızda istediğinizde yerel işlevler söz konusu daha verimlidir.</span><span class="sxs-lookup"><span data-stu-id="7a5f1-150">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

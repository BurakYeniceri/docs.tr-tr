---
title: "Gönderilmiş Olayları İşlenmiş Olarak İşaretleme ve Sınıf İşlemesi"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
caps.latest.revision: "19"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 0ec6bd76b6254b44dfacfd7f3d29341ece0a78f3
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/21/2017
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a><span data-ttu-id="c0bef-102">Gönderilmiş Olayları İşlenmiş Olarak İşaretleme ve Sınıf İşlemesi</span><span class="sxs-lookup"><span data-stu-id="c0bef-102">Marking Routed Events as Handled, and Class Handling</span></span>
<span data-ttu-id="c0bef-103">Yönlendirilmiş olay işleyicileri içinde olay verilerini işlenen olay işaretleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c0bef-103">Handlers for a routed event can mark the event handled within the event data.</span></span> <span data-ttu-id="c0bef-104">Olay işleme rota etkili bir şekilde kısaltacak.</span><span class="sxs-lookup"><span data-stu-id="c0bef-104">Handling the event will effectively shorten the route.</span></span> <span data-ttu-id="c0bef-105">Sınıf işleme yönlendirilmiş olaylar tarafından desteklenen programlama bir kavramdır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-105">Class handling is a programming concept that is supported by routed events.</span></span> <span data-ttu-id="c0bef-106">Sınıf işleyicisi sınıf düzeyinde sınıfının hiçbir örneği üzerinde herhangi bir örnek işleyicisini önce çağrılan bir işleyici ile belirli bir yönlendirilmiş olay işleme fırsatına sahip.</span><span class="sxs-lookup"><span data-stu-id="c0bef-106">A class handler has the opportunity to handle a particular routed event at a class level with a handler that is invoked before any instance handler on any instance of the class.</span></span>  
  

  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="c0bef-107">Önkoşullar</span><span class="sxs-lookup"><span data-stu-id="c0bef-107">Prerequisites</span></span>  
 <span data-ttu-id="c0bef-108">Bu konuda sunulan kavramlarla ilgili elaborates [yönlendirilmiş olaylara genel bakış](../../../../docs/framework/wpf/advanced/routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="c0bef-108">This topic elaborates on concepts introduced in the [Routed Events Overview](../../../../docs/framework/wpf/advanced/routed-events-overview.md).</span></span>  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a><span data-ttu-id="c0bef-109">Olayları işlenmiş olarak işaretlemek ne zaman</span><span class="sxs-lookup"><span data-stu-id="c0bef-109">When to Mark Events as Handled</span></span>  
 <span data-ttu-id="c0bef-110">Değeri ayarlandığında <xref:System.Windows.RoutedEventArgs.Handled%2A> özelliğine `true` olay verileri yönlendirilmiş olay için bu olarak adlandırılır "işlenen olay işaretleme".</span><span class="sxs-lookup"><span data-stu-id="c0bef-110">When you set the value of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data for a routed event, this is referred to as "marking the event handled".</span></span> <span data-ttu-id="c0bef-111">Yönlendirilmiş olaylar işlenmiş olarak işaretlediğinizde mutlak bir kuralı, bir uygulama yazarı olarak ya da bir denetim olarak var olan yönlendirilmiş olaylara yanıt verir ya da yeni uygulayan Yazar yönlendirilmiş olaylar.</span><span class="sxs-lookup"><span data-stu-id="c0bef-111">There is no absolute rule for when you should mark routed events as handled, either as an application author, or as a control author who responds to existing routed events or implements new routed events.</span></span> <span data-ttu-id="c0bef-112">Çoğunlukla, "yönlendirilmiş olayın olay verilerde taşınan gibi ele" kavramı sınırlı bir protokol olarak kendi uygulamanın yanıtlarını de sağlanmaktadır çeşitli yönlendirilmiş olaylar için kullanılması gereken [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] yönlendirilmiş herhangi bir özel olarak için olaylar.</span><span class="sxs-lookup"><span data-stu-id="c0bef-112">For the most part, the concept of "handled" as carried in the routed event's event data should be used as a limited protocol for your own application's responses to the various routed events exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] as well as for any custom routed events.</span></span> <span data-ttu-id="c0bef-113">"İşlenmiş" sorunu dikkate alınması gereken başka bir kodunuzu yönlendirilmiş olay önemli ve görece eksiksiz bir şekilde yanıt, işlenen yönlendirilmiş olay genellikle işaretlemelisiniz yoludur.</span><span class="sxs-lookup"><span data-stu-id="c0bef-113">Another way to consider the "handled" issue is that you should generally mark a routed event handled if your code responded to the routed event in a significant and relatively complete way.</span></span> <span data-ttu-id="c0bef-114">Genellikle, olmamalıdır ayrı işleyicisi uygulamaları için tek yönlendirilmiş olay olayı gerektirir birden çok önemli yanıt.</span><span class="sxs-lookup"><span data-stu-id="c0bef-114">Typically, there should not be more than one significant response that requires separate handler implementations for any single routed event occurrence.</span></span> <span data-ttu-id="c0bef-115">Daha fazla yanıtları gerekirse, gerekli kodu tek bir işleyici içinde yerine yönlendirilmiş olay sistemi iletme için zincirleme uygulama mantığını aracılığıyla uygulanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-115">If more responses are needed, then the necessary code should be implemented through application logic that is chained within a single handler rather than by using the routed event system for forwarding.</span></span> <span data-ttu-id="c0bef-116">"Önemli" nedir kavramı da öznel ve kullanıcılarınızın bir uygulama veya kod bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-116">The concept of what is "significant" is also subjective, and depends on your application or code.</span></span> <span data-ttu-id="c0bef-117">Genel bir yönerge olarak bazı "önemli yanıt" örnekler: odak ayarlama, genel durumu değiştirme, görsel gösterimi etkileyen özellikleri ayarlama ve diğer yeni olaylar oluşturma.</span><span class="sxs-lookup"><span data-stu-id="c0bef-117">As general guidance, some "significant response" examples include: setting focus, modifying public state, setting properties that affect the visual representation, and raising other new events.</span></span> <span data-ttu-id="c0bef-118">Önemli olmayan yanıtları örnekler: özel durumu (hiçbir visual etkisi, veya programlama gösterimi ile) değiştirerek, olaylarını, veya bir olay bağımsız değişkenleri arama ve ona yanıt vermeyecek biçimde seçme.</span><span class="sxs-lookup"><span data-stu-id="c0bef-118">Examples of nonsignificant responses include: modifying private state (with no visual impact, or programmatic representation), logging of events, or looking at arguments of an event and choosing not to respond to it.</span></span>  
  
 <span data-ttu-id="c0bef-119">Yönlendirilmiş olay sistem davranışını işleyicileri eklenen çünkü yönlendirilmiş olay işlenmiş durumunu kullanmak için bu "önemli yanıt" model eklenir [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] veya ortak imzası <xref:System.Windows.UIElement.AddHandler%2A> yönlendirilmiş bir olaya yanıt olarak çağrılmaz burada olay verileri zaten işlenmiş işaretlenir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-119">The routed event system behavior reinforces this "significant response" model for using handled state of a routed event, because handlers added in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or the common signature of <xref:System.Windows.UIElement.AddHandler%2A> are not invoked in response to a routed event where the event data is already marked handled.</span></span> <span data-ttu-id="c0bef-120">Sahip bir işleyici ekleme ek çaba aracılığıyla gitmelidir `handledEventsToo` parametresi sürüm (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) rota olay önceki katılımcıları tarafından işlenmiş olarak işaretlenmiş yönlendirilmiş olayları işlemek için.</span><span class="sxs-lookup"><span data-stu-id="c0bef-120">You must go through the extra effort of adding a handler with the `handledEventsToo` parameter version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) in order to handle routed events that are marked handled by earlier participants in the event route.</span></span>  
  
 <span data-ttu-id="c0bef-121">Bazı durumlarda, denetimleri kendilerini belirli yönlendirilmiş olaylar işlenmiş olarak işaretleyin.</span><span class="sxs-lookup"><span data-stu-id="c0bef-121">In some circumstances, controls themselves mark certain routed events as handled.</span></span> <span data-ttu-id="c0bef-122">İşlenmiş yönlendirilmiş olay tarafından kararı temsil eden [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] kontrol denetim uygulaması ve olay parçası hiçbir daha fazla işleme gibi önemli veya tam denetim eylemleri yönlendirilmiş olaya yanıt olarak yazar.</span><span class="sxs-lookup"><span data-stu-id="c0bef-122">A handled routed event represents a decision by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control authors that the control's actions in response to the routed event are significant or complete as part of the control implementation, and the event needs no further handling.</span></span> <span data-ttu-id="c0bef-123">Genellikle bu olay için bir sınıf işleyicisi ekleme ya da bir taban sınıf üzerinde mevcut sınıfı işleyici sanalların biri geçersiz kılma gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-123">Usually this is done by adding a class handler for an event, or by overriding one of the class handler virtuals that exist on a base class.</span></span> <span data-ttu-id="c0bef-124">Bu olay gerekirse işleme hala çalışabilir; bkz: [çalışma geçici denetimler tarafından olay bastırma](#WorkingAroundEventSuppressionByControls) bu konuda daha sonra.</span><span class="sxs-lookup"><span data-stu-id="c0bef-124">You can still work around this event handling if necessary; see [Working Around Event Suppression by Controls](#WorkingAroundEventSuppressionByControls) later in this topic.</span></span>  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a><span data-ttu-id="c0bef-125">"Önizleme" (tünel) olayları vs. Olayların ve olay işleme tırmanmasını</span><span class="sxs-lookup"><span data-stu-id="c0bef-125">"Preview" (Tunneling) Events vs. Bubbling Events, and Event Handling</span></span>  
 <span data-ttu-id="c0bef-126">Yönlendirilmiş önizleme olayları öğe ağacı üzerinden tünel yolu izleyin olaylardır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-126">Preview routed events are events that follow a tunneling route through the element tree.</span></span> <span data-ttu-id="c0bef-127">"Adlandırma kuralında ifade Önizleme" göstergesi Genel İlkesi giriş olayları (Tünelleme) önizleme yönlendirilmiş olaylar önce eşdeğer kabarcıklanma yönlendirilmiş olay oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="c0bef-127">The "Preview" expressed in the naming convention is indicative of the general principle for input events that preview (tunneling) routed events are raised prior to the equivalent bubbling routed event.</span></span> <span data-ttu-id="c0bef-128">Ayrıca, bir tünel oluşturma ve kabarcıklanma çifti giriş yönlendirilmiş olayları ayrı işleme mantığı vardır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-128">Also, input routed events that have a tunneling and bubbling pair have a distinct handling logic.</span></span> <span data-ttu-id="c0bef-129">Tünel/yönlendirilmiş Önizleme olay bir olay dinleyicisi tarafından işlenmiş olarak işaretlenmişse, hatta tüm dinleyiciler kabarcıklanma yönlendirilmiş olay almadan önce onu sonra yönlendirilmiş olay işaretlenecek tırmanmasını işlenir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-129">If the tunneling/preview routed event is marked as handled by an event listener, then the bubbling routed event will be marked handled even before any listeners of the bubbling routed event receive it.</span></span> <span data-ttu-id="c0bef-130">Tünel oluşturma ve kabarcıklanma yönlendirilmiş olaylar için teknik olarak ayrı olayları olsa da, bunlar kasıtlı olarak olay verisi bu davranışı etkinleştirmek için aynı kopyasını paylaştığında.</span><span class="sxs-lookup"><span data-stu-id="c0bef-130">The tunneling and bubbling routed events are technically separate events, but they deliberately share the same instance of event data to enable this behavior.</span></span>  
  
 <span data-ttu-id="c0bef-131">Tünel oluşturma ve kabarcıklanma yönlendirilmiş olaylar arasındaki bağlantıyı tarafından iç uygulanması herhangi nasıl verilen gerçekleştirilir [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] sınıf kendi bildirilen yönlendirilmiş olayları başlatır ve bu eşleştirilmiş giriş yönlendirilmiş olaylarını geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-131">The connection between the tunneling and bubbling routed events is accomplished by the internal implementation of how any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class raises its own declared routed events, and this is true of the paired input routed events.</span></span> <span data-ttu-id="c0bef-132">Ancak bu sınıf düzeyi uygulama olmadığı sürece tünel yönlendirilmiş olay adlandırma şeması paylaşan kabarcıklanma yönlendirilmiş olay arasındaki bağlantı yoktur: Böyle uygulama olmadan bunlar iki tamamen ayrı yönlendirilmiş olay olacaktır ve değil olacaktır Olay verileri dizisi veya paylaşımı oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="c0bef-132">But unless this class-level implementation exists, there is no connection between a tunneling routed event and a bubbling routed event that share the naming scheme: without such implementation they would be two entirely separate routed events and would not be raised in sequence or share event data.</span></span>  
  
 <span data-ttu-id="c0bef-133">Özel bir sınıf içinde tünel/Kabarcık giriş yönlendirilmiş olay çiftlerini gerçekleştirme hakkında daha fazla bilgi için bkz: [özel yönlendirilmiş olay oluşturma](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).</span><span class="sxs-lookup"><span data-stu-id="c0bef-133">For more information about how to implement tunnel/bubble input routed event pairs in a custom class, see [Create a Custom Routed Event](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).</span></span>  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a><span data-ttu-id="c0bef-134">Sınıf işleyicileri ve örnek işleyicileri</span><span class="sxs-lookup"><span data-stu-id="c0bef-134">Class Handlers and Instance Handlers</span></span>  
 <span data-ttu-id="c0bef-135">Yönlendirilmiş olaylar, iki farklı türde olay dinleyicileri göz önünde bulundurun: sınıf dinleyicileri ve örnek dinleyiciler.</span><span class="sxs-lookup"><span data-stu-id="c0bef-135">Routed events consider two different types of listeners to the event: class listeners and instance listeners.</span></span> <span data-ttu-id="c0bef-136">Sınıf dinleyicileri var türleri belirli bir adlı olduğundan <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, kendi statik oluşturucuda ya da bir sınıf işleyicisi sanal yönteminden öğesi ana sınıfı geçersiz.</span><span class="sxs-lookup"><span data-stu-id="c0bef-136">Class listeners exist because types have called a particular <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in their static constructor, or have overridden a class handler virtual method from an element base class.</span></span> <span data-ttu-id="c0bef-137">Örnek dinleyiciler öğeleridir belirli sınıf örnekleri/burada bir veya daha fazla işleyicileri, yönlendirilmiş olay için bir çağrı tarafından eklenmiş olan <xref:System.Windows.UIElement.AddHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0bef-137">Instance listeners are particular class instances/elements where one or more handlers have been attached for that routed event by a call to <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="c0bef-138">Varolan [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] yönlendirilmiş olaylar olun çağrıları <xref:System.Windows.UIElement.AddHandler%2A> parçası olarak [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] olay sarmalayıcı ekleme {} ve {} uygulamaları nasıl olan olayın Kaldır basit [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mekanizması bir öznitelik aracılığıyla olay işleyicileri ekleme sözdizimi etkinleştirilir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-138">Existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events make calls to <xref:System.Windows.UIElement.AddHandler%2A> as part of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] event wrapper add{} and remove{} implementations of the event, which is also how the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanism of attaching event handlers via an attribute syntax is enabled.</span></span> <span data-ttu-id="c0bef-139">Bu nedenle basit bile [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] kullanım sonuçta karşılık gelir için bir <xref:System.Windows.UIElement.AddHandler%2A> çağırın.</span><span class="sxs-lookup"><span data-stu-id="c0bef-139">Therefore even the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] usage ultimately equates to an <xref:System.Windows.UIElement.AddHandler%2A> call.</span></span>  
  
 <span data-ttu-id="c0bef-140">Görsel ağaç içinde öğelerin kayıtlı işleyici uygulamaları için denetlenir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-140">Elements within the visual tree are checked for registered handler implementations.</span></span> <span data-ttu-id="c0bef-141">Yönlendirilmiş olay yönlendirme stratejisi türünde devralınır sırada yol boyunca işleyicileri potansiyel olarak çağrılır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-141">Handlers are potentially invoked throughout the route, in the order that is inherent in the type of the routing strategy for that routed event.</span></span> <span data-ttu-id="c0bef-142">Örneğin, kabarcıklanma yönlendirilmiş olaylar ilk yönlendirilmiş olayı aynı öğeye bağlı bu işleyicilerini başlatacaktır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-142">For instance, bubbling routed events will first invoke those handlers that are attached to the same element that raised the routed event.</span></span> <span data-ttu-id="c0bef-143">Ardından yönlendirilmiş olay vb. uygulama kök öğesi ulaşılana kadar sonraki üst öğeye "balonları".</span><span class="sxs-lookup"><span data-stu-id="c0bef-143">Then the routed event "bubbles" to the next parent element and so on until the application root element is reached.</span></span>  
  
 <span data-ttu-id="c0bef-144">Sınıf işleme veya herhangi bir öğeye yakın yönlendirilmiş olay kaynağı olarak işlenen, olay bağımsız işaretlemek işleyicileri çağırma varsa kabarcıklanma yolunun kök öğesinde perspektifinden sonra öğeleri çağrılamaz kök işleyicileri ve olay yönlendirme Bu kök öğesi ulaşmadan önce etkili bir şekilde kısaltılır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-144">From the perspective of the root element in a bubbling route, if class handling or any element closer to the source of the routed event invoke handlers that mark the event arguments as being handled, then handlers on the root elements are not invoked, and the event route is effectively shortened before reaching that root element.</span></span> <span data-ttu-id="c0bef-145">İşleyicileri işleyicisi sınıfı veya örneği işleyicisi yönlendirilmiş olay işlenmiş olarak işaretlenmiş olsa bile kullanıcılar hala çağrılması gerektiğini, özel bir koşullu kullanılarak eklenebilir olduğundan ancak, rota tamamen, durdurulur değil.</span><span class="sxs-lookup"><span data-stu-id="c0bef-145">However, the route is not completely halted, because handlers can be added using a special conditional that they should still be invoked, even if a class handler or instance handler has marked the routed event as handled.</span></span> <span data-ttu-id="c0bef-146">Bu bölümünde açıklanır [ekleme örneği işleyicileri emin olan yükseltilmiş bile olduğunda olayları işaretli işlenir](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), bu konunun devamındaki.</span><span class="sxs-lookup"><span data-stu-id="c0bef-146">This is explained in [Adding Instance Handlers That Are Raised Even When Events Are Marked Handled](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), later in this topic.</span></span>  
  
 <span data-ttu-id="c0bef-147">Olay yolu daha derin bir düzeyinde de belirli bir sınıfın örneklerini üzerinde çalışan büyük olasılıkla birden çok sınıf işleyicileri vardır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-147">At a deeper level than the event route, there are also potentially multiple class handlers acting on any given instance of a class.</span></span> <span data-ttu-id="c0bef-148">Bu olduğu sınıf işleme modeli yönlendirilmiş olaylar için her bir sınıf hiyerarşideki tüm olası sınıfları sağladığından kaydetmeniz yönlendirilmiş her olay için kendi sınıf işleyicisi.</span><span class="sxs-lookup"><span data-stu-id="c0bef-148">This is because the class handling model for routed events enables all possible classes in a class hierarchy to each register its own class handler for each routed event.</span></span> <span data-ttu-id="c0bef-149">Her sınıf işleyicisi bir iç depoya eklenir ve sınıf işleyicileri bir uygulama için olay yolu oluşturulduğunda, tüm olay rotaya eklenir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-149">Each class handler is added to an internal store, and when the event route for an application is constructed, the class handlers are all added to the event route.</span></span> <span data-ttu-id="c0bef-150">Sınıf işleyicileri yolu en çok türetilen sınıfı işleyici önce çağrılır ve sınıf işleyicileri art arda gelen her temel sınıfından sonraki çağrılır gibi eklenir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-150">Class handlers are added to the route such that the most-derived class handler is invoked first, and class handlers from each successive base class are invoked next.</span></span> <span data-ttu-id="c0bef-151">Genellikle, bunlar da ele zaten işaretlenen yönlendirilmiş olaylara yanıt şekilde sınıf işleyicileri kayıtlı değil.</span><span class="sxs-lookup"><span data-stu-id="c0bef-151">Generally, class handlers are not registered such that they also respond to routed events that were already marked handled.</span></span> <span data-ttu-id="c0bef-152">Bu nedenle, işleme mekanizması Bu sınıf bir iki seçenek sağlar:</span><span class="sxs-lookup"><span data-stu-id="c0bef-152">Therefore, this class handling mechanism enables one of two choices:</span></span>  
  
-   <span data-ttu-id="c0bef-153">Türetilmiş sınıflar temel sınıf işleyicisi süre türetilmiş sınıf işleyicisi sonra çağrılacak bulunduğundan yönlendirilmiş olayı işlenmiş, işaretlemez bir işleyici ekleyerek temel sınıfından devralınan sınıf işleme destekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c0bef-153">Derived classes can supplement the class handling that is inherited from the base class by adding a handler that does not mark the routed event handled, because the base class handler will be invoked sometime after the derived class handler.</span></span>  
  
-   <span data-ttu-id="c0bef-154">Türetilen sınıflar yönlendirilmiş olayı işlenmiş işaretler sınıfı işleyici ekleyerek temel sınıfından işleme sınıfı değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c0bef-154">Derived classes can replace the class handling from the base class by adding a class handler that marks the routed event handled.</span></span> <span data-ttu-id="c0bef-155">Görsel görünümünü ve durum mantığı, giriş işleme ve komut işleme gibi alanlarda hedeflenen temel denetimi tasarım potansiyel olarak değişir olduğundan bu yaklaşımda, dikkatli olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-155">You should be cautious with this approach, because it will potentially change the intended base control design in areas such as visual appearance, state logic, input handling, and command handling.</span></span>  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a><span data-ttu-id="c0bef-156">Yönlendirilmiş olay işleme denetim temel sınıflar tarafından sınıfı</span><span class="sxs-lookup"><span data-stu-id="c0bef-156">Class Handling of Routed Events by Control Base Classes</span></span>  
 <span data-ttu-id="c0bef-157">Bir olay rotadaki her verilen öğe düğümde sınıf dinleyicileri herhangi örnek dinleyici öğesi can önce yönlendirilmiş olay yanıt verecek şekilde fırsatınız.</span><span class="sxs-lookup"><span data-stu-id="c0bef-157">On each given element node in an event route, class listeners have the opportunity to respond to the routed event before any instance listener on the element can.</span></span> <span data-ttu-id="c0bef-158">Bu nedenle, sınıf işleyicileri bazen belirli denetim sınıf uygulamasını daha fazla yayılması veya özel bir özelliktir sınıfının bu yönlendirilmiş olayı işlenmesini sağlamak için istemediğini yönlendirilmiş olaylar gizlemek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-158">For this reason, class handlers are sometimes used to suppress routed events that a particular control class implementation does not wish to propagate further, or to provide special handling of that routed event that is a feature of the class.</span></span> <span data-ttu-id="c0bef-159">Örneğin, bir sınıf o sınıfın bağlamında bazı kullanıcı giriş koşulu anlamı hakkında daha fazla ayrıntı içeren kendi sınıfı özgü olay tetikleyebilir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-159">For instance, a class might raise its own class-specific event that contains more specifics about what some user input condition means in the context of that particular class.</span></span> <span data-ttu-id="c0bef-160">Sınıf uygulamasını sonra işlenmiş olarak daha genel yönlendirilmiş olay işareti.</span><span class="sxs-lookup"><span data-stu-id="c0bef-160">The class implementation might then mark the more general routed event as handled.</span></span> <span data-ttu-id="c0bef-161">Sınıf işleyicileri genellikle eklenir sağlayacak şekilde yönlendirilen için çağrılmaz burada paylaşılan olay verileri zaten işaretlenen olayları ele, ancak alışılmadık durumlarda yok ayrıca bir <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> bile yönlendirilmiş olaylar olduğunda çağrılacak sınıf işleyicileri kaydeder imza işlenmiş olarak işaretlenmiş.</span><span class="sxs-lookup"><span data-stu-id="c0bef-161">Class handlers are typically added such that they are not invoked for routed events where shared event data was already marked handled, but for atypical cases there is also a <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that registers class handlers to invoke even when routed events are marked handled.</span></span>  
  
### <a name="class-handler-virtuals"></a><span data-ttu-id="c0bef-162">İşleyici sanalların sınıfı</span><span class="sxs-lookup"><span data-stu-id="c0bef-162">Class Handler Virtuals</span></span>  
 <span data-ttu-id="c0bef-163">Özellikle temel öğeleri gibi bazı öğeler <xref:System.Windows.UIElement>, sunmaya boş "üzerinde * olay" ve "OnPreview\*olay" kendi ortak yönlendirilmiş olaylar listesine karşılık gelen sanal yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="c0bef-163">Some elements, particularly the base elements such as <xref:System.Windows.UIElement>, expose empty "On*Event" and "OnPreview\*Event" virtual methods that correspond to their list of public routed events.</span></span> <span data-ttu-id="c0bef-164">Yönlendirilmiş olay işleyicisi sınıfı uygulamak için bu sanal yöntemleri geçersiz kılınabilir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-164">These virtual methods can be overridden to implement a class handler for that routed event.</span></span> <span data-ttu-id="c0bef-165">Her örneğin kendi sınıfı işleyicisi olayını kullanarak yönlendirilen gibi temel öğe sınıfları bu sanal yöntemler kaydetmek <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> daha önce açıklandığı gibi.</span><span class="sxs-lookup"><span data-stu-id="c0bef-165">The base element classes register these virtual methods as their class handler for each such routed event using <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> as described earlier.</span></span> <span data-ttu-id="c0bef-166">On\*her tür için statik oluşturucular özel başlatma gerektirmeden olayları, yönlendirilmiş olay sanal yöntemler kolaylaştırır sınıfı için ilgili işleme uygulamak çok daha kolaydır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-166">The On\*Event virtual methods make it much simpler to implement class handling for the relevant routed events, without requiring special initialization in static constructors for each type.</span></span> <span data-ttu-id="c0bef-167">Sınıfı için işleme örneği için ekleyebilirsiniz <xref:System.Windows.UIElement.DragEnter> herhangi bir olay <xref:System.Windows.UIElement> kılarak türetilmiş sınıf <xref:System.Windows.UIElement.OnDragEnter%2A> sanal yöntemi.</span><span class="sxs-lookup"><span data-stu-id="c0bef-167">For instance, you can add class handling for the <xref:System.Windows.UIElement.DragEnter> event in any <xref:System.Windows.UIElement> derived class by overriding the <xref:System.Windows.UIElement.OnDragEnter%2A> virtual method.</span></span> <span data-ttu-id="c0bef-168">Geçersiz kılma içinde yönlendirilmiş olay işleme, diğer olayları yükseltmek, örnekleri veya bu eylemleri herhangi bir bileşimini öğesi özelliklerini değişebilir sınıfı özgü mantığı başlatmak.</span><span class="sxs-lookup"><span data-stu-id="c0bef-168">Within the override, you could handle the routed event, raise other events, initiate class-specific logic that might change element properties on instances, or any combination of those actions.</span></span> <span data-ttu-id="c0bef-169">İşlenen olayı işaretlemek olsa bile bu tür geçersiz kılmaları temel uygulamasında genellikle çağırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-169">You should generally call the base implementation in such overrides even if you mark the event handled.</span></span> <span data-ttu-id="c0bef-170">Sanal yöntemi temel sınıf üzerinde olduğundan temel uygulamayı çağırma önemle tavsiye edilir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-170">Calling the base implementation is strongly recommended because the virtual method is on the base class.</span></span> <span data-ttu-id="c0bef-171">Temel uygulamaları temelde her sanal çağırma standart korumalı sanal desenini yerini alır ve bir sınıf hiyerarşisindeki tüm sınıflar için sınıf işleyicileri aslına sınıfı yönlendirilmiş olay işleme için yerel bir benzer mekanizma parallels Çoğu türetilmiş sınıf işleyicisi ile başlayan ve temel sınıf işleyicisine etmeden tüm verilen örneğinde çağrılır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-171">The standard protected virtual pattern of calling the base implementations from each virtual essentially replaces and parallels a similar mechanism that is native to routed event class handling, whereby class handlers for all classes in a class hierarchy are called on any given instance, starting with the most-derived class' handler and continuing to the base class handler.</span></span> <span data-ttu-id="c0bef-172">Sınıfınızda mantığı işleme temel sınıf değiştirmek için kasıtlı bir gereksinimi varsa yalnızca temel uygulamayı çağrısı atlayın.</span><span class="sxs-lookup"><span data-stu-id="c0bef-172">You should only omit the base implementation call if your class has a deliberate requirement to change the base class handling logic.</span></span> <span data-ttu-id="c0bef-173">Önce veya sonra geçersiz kılma kodunuzu temel uygulamayı çağırması olup uygulamanızı doğasına bağlı olacaktır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-173">Whether you call the base implementation before or after your overriding code will depend on the nature of your implementation.</span></span>  
  
#### <a name="input-event-class-handling"></a><span data-ttu-id="c0bef-174">Giriş olay işleme sınıfı</span><span class="sxs-lookup"><span data-stu-id="c0bef-174">Input Event Class Handling</span></span>  
 <span data-ttu-id="c0bef-175">Yalnızca işlenmiş olduğu herhangi bir paylaşılan olay veri zaten işaretlenmemiş durumlarda çağrılır şekilde sınıfı işleyici sanal yöntemler tüm kaydedilir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-175">The class handler virtual methods are all registered such that they are only invoked in cases where any shared event data are not already marked handled.</span></span> <span data-ttu-id="c0bef-176">Ayrıca, giriş olaylar için benzersiz olarak tünel oluşturma ve kabarcıklanma sürümleri genellikle sırayla gerçekleştirilen ve olay verilerini paylaşır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-176">Also, for the input events uniquely, the tunneling and bubbling versions typically are raised in sequence and share event data.</span></span> <span data-ttu-id="c0bef-177">Bu, burada bir tünel sürüm ve diğer kabarcıklanma sürümü giriş olayların sınıf işleyicileri için bir verilen çifti hemen işlenen olayı işaretlemek istemeyebilirsiniz olduğunu kapsar.</span><span class="sxs-lookup"><span data-stu-id="c0bef-177">This entails that for a given pair of class handlers of input events where one is the tunneling version and the other is the bubbling version, you may not want to mark the event handled immediately.</span></span> <span data-ttu-id="c0bef-178">İşlenen olayı işaretlemek için sanal bir yöntem işleme tünel sınıfı uygularsanız, kabarcıklanma işleyicisi sınıfı (her iki tünel veya kabarcıklanma olayı için herhangi bir normalde kayıtlı örnek işleyicileri önleme yanı sıra çağrılmasını engeller. çağrılan).</span><span class="sxs-lookup"><span data-stu-id="c0bef-178">If you implement the tunneling class handling virtual method to mark the event handled, that will prevent the bubbling class handler from being invoked (as well as preventing any normally registered instance handlers for either the tunneling or bubbling event from being invoked).</span></span>  
  
 <span data-ttu-id="c0bef-179">Bir düğümde işleme sınıfı tamamlandıktan sonra örnek dinleyiciler olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-179">Once class handling on a node is complete, the instance listeners are considered.</span></span>  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a><span data-ttu-id="c0bef-180">İşlenen bile olayları işaretlendiğinde ortaya örneği işleyicileri ekleme</span><span class="sxs-lookup"><span data-stu-id="c0bef-180">Adding Instance Handlers That Are Raised Even When Events Are Marked Handled</span></span>  
 <span data-ttu-id="c0bef-181"><xref:System.Windows.UIElement.AddHandler%2A> Yöntemi bir olay rota işleme öğesinde eriştiğinde başka bir işleyici zaten, işaretlemek için olay verilerini ayarladı olsa bile olay sistem tarafından çağrılan işleyicileri eklemenize olanak sağlayan belirli bir aşırı yüklemesini sağlar işlenmiş olarak olay.</span><span class="sxs-lookup"><span data-stu-id="c0bef-181">The <xref:System.Windows.UIElement.AddHandler%2A> method supplies a particular overload that allows you to add handlers that will be invoked by the event system whenever an event reaches the handling element in the route, even if some other handler has already adjusted the event data to mark that event as handled.</span></span> <span data-ttu-id="c0bef-182">Bu genellikle belirtilmez.</span><span class="sxs-lookup"><span data-stu-id="c0bef-182">This is not typically done.</span></span> <span data-ttu-id="c0bef-183">Genellikle, tüm alanları birden çok bitiş sonuçları istenen olsa bile bir öğe ağacında, burada yürütüldü bağımsız olarak bir olay tarafından etkilenebileceğinden uygulama kodu ayarlamak için işleyiciler yazılabilir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-183">Generally, handlers can be written to adjust all areas of application code that might be influenced by an event, regardless of where it was handled in an element tree, even if multiple end results are desired.</span></span> <span data-ttu-id="c0bef-184">Ayrıca, genellikle yoktur gerçekten bu olaya yanıt vermesi yalnızca tek bir öğe ve uygun uygulama mantığını oldu.</span><span class="sxs-lookup"><span data-stu-id="c0bef-184">Also, typically there is really only one element that needs to respond to that event, and the appropriate application logic had already happened.</span></span> <span data-ttu-id="c0bef-185">Ancak `handledEventsToo` aşırı yüklemesi, burada diğer öğesinde bir öğe ağaç veya denetim birleştirme zaten işaretledi bir olay işlenmiş gibi olağanüstü durumlarda, ancak daha yüksek veya düşük hala öğe ağacında (yol) bağlı olarak diğer öğeler için kullanılabilir çağrılan kendi işleyicileri olmasını istiyor.</span><span class="sxs-lookup"><span data-stu-id="c0bef-185">But the `handledEventsToo` overload is available for the exceptional cases where some other element in an element tree or control compositing has already marked an event as handled, but other elements either higher or lower in the element tree (depending on route) still wish to have their own handlers invoked.</span></span>  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a><span data-ttu-id="c0bef-186">İşaretlemek ne zaman olaylar işlenmemiş olarak işlenen</span><span class="sxs-lookup"><span data-stu-id="c0bef-186">When to Mark Handled Events as Unhandled</span></span>  
 <span data-ttu-id="c0bef-187">Genellikle, işlenmiş olarak işaretlenmiş yönlendirilmiş olaylar işlenmemiş işaretlenmelidir değil (<xref:System.Windows.RoutedEventArgs.Handled%2A> döndürülmek `false`) bile hareket işleyiciler tarafından `handledEventsToo`.</span><span class="sxs-lookup"><span data-stu-id="c0bef-187">Generally, routed events that are marked handled should not be marked unhandled (<xref:System.Windows.RoutedEventArgs.Handled%2A> set back to `false`) even by handlers that act on `handledEventsToo`.</span></span> <span data-ttu-id="c0bef-188">Ancak, bazı giriş olaylar konumunda bir ağaç ve alt düzey olay başka bir konuma, üst düzey olay görülen yükleyen binebilir üst düzey ve alt düzey olay Beyanları sahiptir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-188">However, some input events have high-level and lower-level event representations that can overlap when the high-level event is seen at one position in the tree and the low-level event at another position.</span></span> <span data-ttu-id="c0bef-189">Örneğin, burada bir alt öğesi dinleyen bir üst düzey anahtar olayı gibi bir durum düşünün <xref:System.Windows.UIElement.TextInput> gibi bir üst öğesi bir alt düzey olayı dinleyen sırada <xref:System.Windows.UIElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="c0bef-189">For instance, consider the case where a child element listens to a high-level key event such as <xref:System.Windows.UIElement.TextInput> while a parent element listens to a low-level event such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="c0bef-190">Üst öğe alt düzey olayını işler, üst düzey olay bile olayını işlemek için ilk fırsat sezgisel olmalıdır alt öğesi gizlenebilir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-190">If the parent element handles the low-level event, the higher-level event can be suppressed even in the child element that intuitively should have first opportunity to handle the event.</span></span>  
  
 <span data-ttu-id="c0bef-191">Bu durumlarda üst öğeler ve alt öğeleri için alt düzey olay işleyicileri eklemek gerekli olabilir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-191">In these situations it may be necessary to add handlers to both parent elements and child elements for the low-level event.</span></span> <span data-ttu-id="c0bef-192">Alt öğe işleyicisi uygulamasına alt düzey olay işlenmiş, üst öğesi işleyicisi uygulamasına öğeleri ağaç (yanı sıra üst düzey olay) daha fazla yukarı böylece yeniden işlenmemiş kümesi yanıt fırsatı olabilir olarak işaretleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c0bef-192">The child element handler implementation can mark the low-level event as handled, but the parent element handler implementation would set it unhandled again so that further elements up the tree (as well as the high-level event) can have the opportunity to respond.</span></span> <span data-ttu-id="c0bef-193">Bu durumda oldukça seyrek olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-193">This situation is should be fairly rare.</span></span>  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a><span data-ttu-id="c0bef-194">Giriş olayları denetim birleştirmesini için kasıtlı olarak gizleme</span><span class="sxs-lookup"><span data-stu-id="c0bef-194">Deliberately Suppressing Input Events for Control Compositing</span></span>  
 <span data-ttu-id="c0bef-195">Giriş olayları ve bileşik denetimler yönlendirilmiş olayların sınıf işleme kullanıldığı ana senaryo içindir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-195">The main scenario where class handling of routed events is used is for input events and composited controls.</span></span> <span data-ttu-id="c0bef-196">Birden çok pratik denetimleri veya denetim temel sınıfları oluşan tanımına göre bir bileşik denetimdir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-196">A composited control is by definition composed of multiple practical controls or control base classes.</span></span> <span data-ttu-id="c0bef-197">Denetim yazarı genellikle tüm olası giriş olaylar katıştırma istediği her alt bileşenler, tekil olay kaynağı olarak tüm denetim bildirmek üzere tetikleyebilir olduğunu.</span><span class="sxs-lookup"><span data-stu-id="c0bef-197">Often the author of the control wishes to amalgamate all of the possible input events that each of the subcomponents might raise, in order to report the entire control as the singular event source.</span></span> <span data-ttu-id="c0bef-198">Bazı durumlarda denetim yazarı bileşenleri olayların tamamen gizlemek ya da daha fazla bilgi taşıyan veya daha fazla belirli bir davranışı olan bileşenle tanımlanan bir olayın yerine isteyebilir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-198">In some cases the control author might wish to suppress the events from components entirely, or substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="c0bef-199">Hiçbir bileşen yazarının hemen görülebilir kurallı örnek nasıl bir [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> tüm düğmeleri olduğunu sezgisel olay sonunda çözümleyecek herhangi fare olayını işler: bir <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olay.</span><span class="sxs-lookup"><span data-stu-id="c0bef-199">The canonical example that is immediately visible to any component author is how a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> handles any mouse event that will eventually resolve to the intuitive event that all buttons have: a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 <span data-ttu-id="c0bef-200"><xref:System.Windows.Controls.Button> Temel sınıfı (<xref:System.Windows.Controls.Primitives.ButtonBase>) türetilen <xref:System.Windows.Controls.Control> hangi sırayla türetilen <xref:System.Windows.FrameworkElement> ve <xref:System.Windows.UIElement>ve denetim giriş işleme şu adresten edinilebilir için gereken olay altyapıyı çoğunu <xref:System.Windows.UIElement> düzeyi.</span><span class="sxs-lookup"><span data-stu-id="c0bef-200">The <xref:System.Windows.Controls.Button> base class (<xref:System.Windows.Controls.Primitives.ButtonBase>) derives from <xref:System.Windows.Controls.Control> which in turn derives from <xref:System.Windows.FrameworkElement> and <xref:System.Windows.UIElement>, and much of the event infrastructure needed for control input processing is available at the <xref:System.Windows.UIElement> level.</span></span> <span data-ttu-id="c0bef-201">Özellikle, <xref:System.Windows.UIElement> genel işler <xref:System.Windows.Input.Mouse> fare imleci sınırlarının içinde isabet testi işleyen ve en yaygın için ayrı olayları sağlar olayları düğmesini eylemler gibi <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="c0bef-201">In particular, <xref:System.Windows.UIElement> processes general <xref:System.Windows.Input.Mouse> events that handle hit testing for the mouse cursor within its bounds, and provides distinct events for the most common button actions, such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="c0bef-202"><xref:System.Windows.UIElement>Ayrıca, boş bir sanal sağlar <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> için preregistered sınıfı işleyici olarak <xref:System.Windows.UIElement.MouseLeftButtonDown>, ve <xref:System.Windows.Controls.Primitives.ButtonBase> bunu geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="c0bef-202"><xref:System.Windows.UIElement> also provides an empty virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> as the preregistered class handler for <xref:System.Windows.UIElement.MouseLeftButtonDown>, and <xref:System.Windows.Controls.Primitives.ButtonBase> overrides it.</span></span> <span data-ttu-id="c0bef-203">Benzer şekilde, <xref:System.Windows.Controls.Primitives.ButtonBase> kullandığı sınıf için işleyiciler <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="c0bef-203">Similarly, <xref:System.Windows.Controls.Primitives.ButtonBase> uses class handlers for <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="c0bef-204">Olay verileri iletilen, bir geçersiz kılma, uygulamaları, işaretlemek <xref:System.Windows.RoutedEventArgs> örnek ayarlanarak işlenmiş olarak <xref:System.Windows.RoutedEventArgs.Handled%2A> için `true`, ve aynı olay verilerini ne diğer sınıf işleyicileri rotaya geri kalanı boyunca devam eder ve örnek işleyicileri ya da olay ayarlayıcıları için.</span><span class="sxs-lookup"><span data-stu-id="c0bef-204">In the overrides, which are passed the event data, the implementations mark that <xref:System.Windows.RoutedEventArgs> instance as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`, and that same event data is what continues along the remainder of the route to other class handlers and also to instance handlers or event setters.</span></span> <span data-ttu-id="c0bef-205">Ayrıca, <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> geçersiz kılma sonraki yükseltme <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olay.</span><span class="sxs-lookup"><span data-stu-id="c0bef-205">Also, the <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override will next raise the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="c0bef-206">Çoğu dinleyiciler için sonuç olacaktır <xref:System.Windows.UIElement.MouseLeftButtonDown> ve <xref:System.Windows.UIElement.MouseLeftButtonUp> olayları "kayboluyor" ve bunun yerine değiştirilir <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, onu bu olay geldiğini true düğmesi ve olmayan bazı bilindiğinden daha fazla anlamı tutan bir olay Bileşik parçası düğmesinin veya başka bir öğenin tamamen.</span><span class="sxs-lookup"><span data-stu-id="c0bef-206">The end result for most listeners will be that the <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseLeftButtonUp> events "disappear" and are replaced instead by <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, an event that holds more meaning because it is known that this event originated from a true button and not some composite piece of the button or from some other element entirely.</span></span>  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="c0bef-207">Denetimleri tarafından olay bastırma çevresinde çalışma</span><span class="sxs-lookup"><span data-stu-id="c0bef-207">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="c0bef-208">Bazen bu olay gizleme davranış tek denetimleri içinde mantığı uygulamanız için işleme olayın daha genel bazı amaçları ile etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-208">Sometimes this event suppression behavior within individual controls can interfere with some more general intentions of event handling logic for your application.</span></span> <span data-ttu-id="c0bef-209">Örneğin, herhangi bir nedenden dolayı uygulamanız için bir işleyici sahip <xref:System.Windows.UIElement.MouseLeftButtonDown> uygulama kök öğede bulunan, size herhangi bir düğme fare tıklatıldığında değil çağıracaktır fark etmesi <xref:System.Windows.UIElement.MouseLeftButtonDown> veya <xref:System.Windows.UIElement.MouseLeftButtonUp> kök düzeyinde işleyicileri.</span><span class="sxs-lookup"><span data-stu-id="c0bef-209">For instance, if for some reason your application had a handler for <xref:System.Windows.UIElement.MouseLeftButtonDown> located at the application root element, you would notice that any mouse click on a button would not invoke <xref:System.Windows.UIElement.MouseLeftButtonDown> or <xref:System.Windows.UIElement.MouseLeftButtonUp> handlers at the root level.</span></span> <span data-ttu-id="c0bef-210">Olay gerçekte yukarı Kabarcık (yeniden olay yollar gerçekten Sonlandırılmamış ancak işlenmiş işaretlenmiş sonra işleyicisi çağırma davranışlarını yönlendirilmiş olay sistem değişiklikleri).</span><span class="sxs-lookup"><span data-stu-id="c0bef-210">The event itself actually did bubble up (again, event routes are not truly ended, but the routed event system changes their handler invocation behavior after being marked handled).</span></span> <span data-ttu-id="c0bef-211">Yönlendirilmiş olay düğmesi erişildiğinde <xref:System.Windows.Controls.Primitives.ButtonBase> sınıf işleme işaretli <xref:System.Windows.UIElement.MouseLeftButtonDown> yerine onlardan çünkü işlenen <xref:System.Windows.Controls.Primitives.ButtonBase.Click> daha anlamlı olayla.</span><span class="sxs-lookup"><span data-stu-id="c0bef-211">When the routed event reached the button, the <xref:System.Windows.Controls.Primitives.ButtonBase> class handling marked the <xref:System.Windows.UIElement.MouseLeftButtonDown> handled because it wished to substitute the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with more meaning.</span></span> <span data-ttu-id="c0bef-212">Bu nedenle, herhangi bir standart <xref:System.Windows.UIElement.MouseLeftButtonDown> rota daha fazla işleyicisini değil çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="c0bef-212">Therefore, any standard <xref:System.Windows.UIElement.MouseLeftButtonDown> handler further up the route would not be invoked.</span></span> <span data-ttu-id="c0bef-213">Bu durumda, işleyicileri çağrıldığı emin olmak için kullanabileceğiniz iki tekniği vardır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-213">There are two techniques you can use to ensure that your handlers would be invoked in this circumstance.</span></span>  
  
 <span data-ttu-id="c0bef-214">İşleyici kullanarak kasıtlı olarak eklemek için ilk tekniktir `handledEventsToo` imzası <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span><span class="sxs-lookup"><span data-stu-id="c0bef-214">The first technique is to deliberately add the handler using the `handledEventsToo` signature of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="c0bef-215">Bu yaklaşımın bir sınırlama olay işleyicisi iliştirmek için bu tekniği yalnızca kodundan, biçimlendirme değil, olası olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-215">A limitation of this approach is that this technique for attaching an event handler is only possible from code, not from markup.</span></span> <span data-ttu-id="c0bef-216">Olay işleyicisi adı olay öznitelik değeri olarak belirtmenin basit sözdizimi [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] bu davranışı etkinleştirmez.</span><span class="sxs-lookup"><span data-stu-id="c0bef-216">The simple syntax of specifying the event handler name as an event attribute value via [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] does not enable that behavior.</span></span>  
  
 <span data-ttu-id="c0bef-217">İkinci teknik yönlendirilmiş olay tünel oluşturma ve kabarcıklanma sürümleri burada eşleştirilmelidir yalnızca giriş olayları için çalışır.</span><span class="sxs-lookup"><span data-stu-id="c0bef-217">The second technique works only for input events, where the tunneling and bubbling versions of the routed event are paired.</span></span> <span data-ttu-id="c0bef-218">Bu yönlendirilmiş olaylar için bunun yerine Önizleme/tünel eşdeğer yönlendirilmiş işleyicileri olayı ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c0bef-218">For these routed events, you can add handlers to the preview/tunneling equivalent routed event instead.</span></span> <span data-ttu-id="c0bef-219">Yönlendirilmiş olay işleme kodunu button sınıfı, uygulamanın öğe ağacında üst öğe düzeyinde Önizleme işleyicisi bağlı pek fazla müdahale olmayan şekilde kökünden başlayarak rota üzerinden tünel oluşturur.</span><span class="sxs-lookup"><span data-stu-id="c0bef-219">That routed event will tunnel through the route starting from the root, so the button class handling code would not intercept it, presuming that you attached the Preview handler at some ancestor element level in the application's element tree.</span></span> <span data-ttu-id="c0bef-220">Bu yaklaşımı kullanırsanız, işlenen herhangi Önizleme olay işaretleme hakkında dikkatli olun.</span><span class="sxs-lookup"><span data-stu-id="c0bef-220">If you use this approach, be cautious about marking any Preview event handled.</span></span> <span data-ttu-id="c0bef-221">İle verilen örneğin <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> olayı olarak işaretlenmiş durumunda Kök öğede işlenen <xref:System.Windows.RoutedEventArgs.Handled%2A> gerçekten bastırır işleyici uygulamasında <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olay.</span><span class="sxs-lookup"><span data-stu-id="c0bef-221">For the example given with <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> being handled at the root element, if you marked the event as <xref:System.Windows.RoutedEventArgs.Handled%2A> in the handler implementation, you would actually suppress the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="c0bef-222">Bu genellikle tercih davranışı değil.</span><span class="sxs-lookup"><span data-stu-id="c0bef-222">That is typically not desirable behavior.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c0bef-223">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="c0bef-223">See Also</span></span>  
 <xref:System.Windows.EventManager>  
 [<span data-ttu-id="c0bef-224">Önizleme olayları</span><span class="sxs-lookup"><span data-stu-id="c0bef-224">Preview Events</span></span>](../../../../docs/framework/wpf/advanced/preview-events.md)  
 [<span data-ttu-id="c0bef-225">Özel yönlendirilmiş olay oluşturma</span><span class="sxs-lookup"><span data-stu-id="c0bef-225">Create a Custom Routed Event</span></span>](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)  
 [<span data-ttu-id="c0bef-226">Yönlendirilmiş olaylara genel bakış</span><span class="sxs-lookup"><span data-stu-id="c0bef-226">Routed Events Overview</span></span>](../../../../docs/framework/wpf/advanced/routed-events-overview.md)

---
title: "İş Parçacıkları ve İş Parçacığı Oluşturma"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- multiple threads
- threading [.NET Framework]
- threading [.NET Framework], multiple threads
ms.assetid: 5baac3aa-e603-4fa6-9f89-0f2c1084e6b1
caps.latest.revision: "14"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 91db5cf75053f7a9b343036345a97d8084ae38fb
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 12/23/2017
---
# <a name="threads-and-threading"></a><span data-ttu-id="fd3cc-102">İş Parçacıkları ve İş Parçacığı Oluşturma</span><span class="sxs-lookup"><span data-stu-id="fd3cc-102">Threads and Threading</span></span>
<span data-ttu-id="fd3cc-103">İşletim sistemleri işlemleri yürütülmekte olduğunu farklı uygulamaları ayırmak için kullanır.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-103">Operating systems use processes to separate the different applications that they are executing.</span></span> <span data-ttu-id="fd3cc-104">İş parçacığı bir işletim sistemi işlemci zamanı tarafından ayrılan temel birimi olan ve birden çok iş parçacığı işlem içinde kod yürütme.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-104">Threads are the basic unit to which an operating system allocates processor time, and more than one thread can be executing code inside that process.</span></span> <span data-ttu-id="fd3cc-105">Her iş parçacığı, özel durum işleyicileri, bir zamanlama önceliği ve sistem zamanlandığı süreye kadar iş parçacığı içeriği kaydetmek için kullandığı yapıları kümesi tutar.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-105">Each thread maintains exception handlers, a scheduling priority, and a set of structures the system uses to save the thread context until it is scheduled.</span></span> <span data-ttu-id="fd3cc-106">İş parçacığı bağlamını sorunsuz bir şekilde yürütme iş parçacığının ana bilgisayar işlemi adres alanında CPU kaydeder ve yığını, iş parçacığının kümesi de dahil olmak üzere, devam etmek için iş parçacığı gereken tüm bilgileri içerir.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-106">The thread context includes all the information the thread needs to seamlessly resume execution, including the thread's set of CPU registers and stack, in the address space of the thread's host process.</span></span>  
  
 <span data-ttu-id="fd3cc-107">Daha fazla .NET Framework tarafından temsil edilen uygulama etki alanı adı verilen hafif yönetilen alt içine bir işletim sistemi işlemi subdivides <xref:System.AppDomain?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-107">The .NET Framework further subdivides an operating system process into lightweight managed subprocesses, called application domains, represented by <xref:System.AppDomain?displayProperty=nameWithType>.</span></span> <span data-ttu-id="fd3cc-108">Bir veya daha fazla yönetilen iş parçacığı (tarafından temsil edilen <xref:System.Threading.Thread?displayProperty=nameWithType>) birini veya bunların sayısı aynı yönetilen işlemi içinde uygulama etki alanları olarak çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-108">One or more managed threads (represented by <xref:System.Threading.Thread?displayProperty=nameWithType>) can run in one or any number of application domains within the same managed process.</span></span> <span data-ttu-id="fd3cc-109">Her uygulama etki alanı ile tek bir iş parçacığı çalışmaya olsa da, bu uygulama etki alanı kodunda ek uygulama etki alanları ve ek iş parçacığı oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-109">Although each application domain is started with a single thread, code in that application domain can create additional application domains and additional threads.</span></span> <span data-ttu-id="fd3cc-110">Yönetilen iş parçacığı aynı yönetilen işlem içinde uygulama etki alanları arasında serbestçe taşıyabilirsiniz sonucudur; birçok uygulama etki alanları arasında taşıma yalnızca tek bir iş parçacığı olabilir.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-110">The result is that a managed thread can move freely between application domains inside the same managed process; you might have only one thread moving among several application domains.</span></span>  
  
 <span data-ttu-id="fd3cc-111">PreEmptive tarafından görevli destekleyen bir işletim sistemi aynı anda birden çok iş parçacığı yürütülmesi etkisini birden çok işlemlerini oluşturur.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-111">An operating system that supports preemptive multitasking creates the effect of simultaneous execution of multiple threads from multiple processes.</span></span> <span data-ttu-id="fd3cc-112">Bunu yapar kullanılabilir işlemci zamanı ihtiyaç iş parçacıkları arasında bölünmesi, her iş parçacığı için işlemci zaman dilimi birbiri ardından ayrılıyor.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-112">It does this by dividing the available processor time among the threads that need it, allocating a processor time slice to each thread one after another.</span></span> <span data-ttu-id="fd3cc-113">Dilim sona erdiğinde, saat ve başka sürdürür çalışan iş parçacığı, şu anda yürütülen iş parçacığı askıya alındı.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-113">The currently executing thread is suspended when its time slice elapses, and another thread resumes running.</span></span> <span data-ttu-id="fd3cc-114">Sistem bir iş parçacığından diğerine geçtiğinde, iş parçacığı içeriği preempted iş parçacığının kaydeder ve iş parçacığı sırasındaki sonraki iş parçacığı kaydedilmiş iş parçacığı bağlamı yeniden yükler.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-114">When the system switches from one thread to another, it saves the thread context of the preempted thread and reloads the saved thread context of the next thread in the thread queue.</span></span>  
  
 <span data-ttu-id="fd3cc-115">Zaman dilimi uzunluğu işletim sistemi ve işlemci bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-115">The length of the time slice depends on the operating system and the processor.</span></span> <span data-ttu-id="fd3cc-116">Her zaman dilimi küçük olduğundan, sadece bir işlemci olsa bile birden çok iş parçacığı aynı anda yürütülen görünür.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-116">Because each time slice is small, multiple threads appear to be executing at the same time, even if there is only one processor.</span></span> <span data-ttu-id="fd3cc-117">Bu gerçekten çok işlemcili sistemlerde yürütülebilir iş parçacıkları arasında kullanılabilir işlemci dağıtıldığı bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-117">This is actually the case on multiprocessor systems, where the executable threads are distributed among the available processors.</span></span>  
  
## <a name="when-to-use-multiple-threads"></a><span data-ttu-id="fd3cc-118">Birden çok iş parçacığı kullanma zamanı</span><span class="sxs-lookup"><span data-stu-id="fd3cc-118">When To Use Multiple Threads</span></span>  
 <span data-ttu-id="fd3cc-119">Kullanıcı etkileşimi gerektiren yazılım, kullanıcının etkinlikler için zengin bir kullanıcı deneyimi sağlamak için mümkün olduğunca hızlı bir şekilde tepki gerekir.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-119">Software that requires user interaction must react to the user's activities as rapidly as possible to provide a rich user experience.</span></span> <span data-ttu-id="fd3cc-120">Aynı anda ancak bunu kadar hızlı kullanıcıya verileri sunmak gerekli hesaplama yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-120">At the same time, however, it must do the calculations necessary to present data to the user as fast as possible.</span></span> <span data-ttu-id="fd3cc-121">Uygulamanızı yürütme yalnızca bir iş parçacığı kullanıyorsa, birleştirebilirsiniz [zaman uyumsuz programlama](../../../docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md) ile[.NET Framework remoting](http://msdn.microsoft.com/en-us/eccb1d31-0a22-417a-97fd-f4f1f3aa4462) veya [XML Web Hizmetleri](http://msdn.microsoft.com/en-us/1e64af78-d705-4384-b08d-591a45f4379c) ASP kullanılarak oluşturulan Diğer bilgisayarların işleme süresi ek olarak, artırmak için kendi yanıtlama hızı azaltma, uygulamanızın veri işleme süresini ve kullanıcı için kullanılacak .NET.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-121">If your application uses only one thread of execution, you can combine [asynchronous programming](../../../docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md) with[.NET Framework remoting](http://msdn.microsoft.com/en-us/eccb1d31-0a22-417a-97fd-f4f1f3aa4462) or [XML Web services](http://msdn.microsoft.com/en-us/1e64af78-d705-4384-b08d-591a45f4379c) created using ASP.NET to use the processing time of other computers in addition to that of your own to increase responsiveness to the user and decrease the data processing time of your application.</span></span> <span data-ttu-id="fd3cc-122">Yoğun giriş/çıkış iş yapıyorsanız, g/ç tamamlama bağlantı noktaları, uygulamanızın yanıt hızını artırmak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-122">If you are doing intensive input/output work, you can also use I/O completion ports to increase your application's responsiveness.</span></span>  
  
### <a name="advantages-of-multiple-threads"></a><span data-ttu-id="fd3cc-123">Birden çok iş parçacığı avantajları</span><span class="sxs-lookup"><span data-stu-id="fd3cc-123">Advantages of Multiple Threads</span></span>  
 <span data-ttu-id="fd3cc-124">Birden çok iş parçacığı kullanan, ancak en güçlü kullanıcı yanıt verme hızını artırmak ve neredeyse aynı anda işin tamamlanması gereken verileri işlemek kullanılabilir tekniğidir.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-124">Using more than one thread, however, is the most powerful technique available to increase responsiveness to the user and process the data necessary to get the job done at almost the same time.</span></span> <span data-ttu-id="fd3cc-125">Bir işlemciye sahip bir bilgisayar üzerinde birden çok iş parçacığı arka planda verileri işlemek için kullanıcı olaylarını Between kısa sürelerle yararlanarak, bu etkiyi oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-125">On a computer with one processor, multiple threads can create this effect, taking advantage of the small periods of time in between user events to process the data in the background.</span></span> <span data-ttu-id="fd3cc-126">Örneğin, başka bir iş parçacığı aynı uygulama içinde elektronik tablo diğer bölümleri yeniden hesaplama sırasında bir kullanıcı bir elektronik tablo düzenleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-126">For example, a user can edit a spreadsheet while another thread is recalculating other parts of the spreadsheet within the same application.</span></span>  
  
 <span data-ttu-id="fd3cc-127">Değişiklik yapılmadan, aynı uygulamanın önemli ölçüde birden çok işlemciye sahip bir bilgisayar üzerinde çalıştırdığınızda, kullanıcı memnuniyetini artırır.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-127">Without modification, the same application would dramatically increase user satisfaction when run on a computer with more than one processor.</span></span> <span data-ttu-id="fd3cc-128">Tek bir uygulama etki alanınızın birden çok iş parçacığı aşağıdaki görevleri gerçekleştirmek için kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="fd3cc-128">Your single application domain could use multiple threads to accomplish the following tasks:</span></span>  
  
-   <span data-ttu-id="fd3cc-129">Bir Web sunucusu ve veritabanı için bir ağ üzerinden iletişim kurar.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-129">Communicate over a network, to a Web server, and to a database.</span></span>  
  
-   <span data-ttu-id="fd3cc-130">Büyük bir zaman miktarıdır ele işlemleri gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-130">Perform operations that take a large amount of time.</span></span>  
  
-   <span data-ttu-id="fd3cc-131">Değişen öncelikli görevler ayırt etmek.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-131">Distinguish tasks of varying priority.</span></span> <span data-ttu-id="fd3cc-132">Örneğin, yüksek öncelikli iş parçacığı zaman açısından kritik görevleri yönetir ve düşük öncelikli iş parçacığı diğer görevleri gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-132">For example, a high-priority thread manages time-critical tasks, and a low-priority thread performs other tasks.</span></span>  
  
-   <span data-ttu-id="fd3cc-133">Arka plan görevleri süresi ayrılırken yanıt verebilir durumda, kalması için kullanıcı arabirimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-133">Allow the user interface to remain responsive, while allocating time to background tasks.</span></span>  
  
### <a name="disadvantages-of-multiple-threads"></a><span data-ttu-id="fd3cc-134">Birden çok iş parçacığı dezavantajları</span><span class="sxs-lookup"><span data-stu-id="fd3cc-134">Disadvantages of Multiple Threads</span></span>  
 <span data-ttu-id="fd3cc-135">En az iş parçacığı olası, böylece işletim sistemi kaynaklarının kullanımını en aza indirmenizi ve performans artırılır olarak kullanmanız önerilir.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-135">It is recommended that you use as few threads as possible, thereby minimizing the use of operating-system resources and improving performance.</span></span> <span data-ttu-id="fd3cc-136">İş parçacığı oluşturma Ayrıca kaynak gereksinimlerini ve olası çakışmaları uygulamanızı tasarlarken göz önünde bulundurulması gerekir.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-136">Threading also has resource requirements and potential conflicts to be considered when designing your application.</span></span> <span data-ttu-id="fd3cc-137">Kaynak gereksinimleri aşağıdaki gibidir:</span><span class="sxs-lookup"><span data-stu-id="fd3cc-137">The resource requirements are as follows:</span></span>  
  
-   <span data-ttu-id="fd3cc-138">Sistem belleğini işlemler tarafından gereken bağlam bilgilerini tükettiğini **AppDomain** nesneleri ve iş parçacığı sayısı.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-138">The system consumes memory for the context information required by processes, **AppDomain** objects, and threads.</span></span> <span data-ttu-id="fd3cc-139">Bu nedenle, işlem, sayısı **AppDomain** nesneleri ve oluşturulabilir iş parçacıkları tarafından kullanılabilen bellek sınırlandırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-139">Therefore, the number of processes, **AppDomain** objects, and threads that can be created is limited by available memory.</span></span>  
  
-   <span data-ttu-id="fd3cc-140">Çok sayıda iş parçacığı izlemek önemli ölçüde işlemci zamanı tüketir.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-140">Keeping track of a large number of threads consumes significant processor time.</span></span> <span data-ttu-id="fd3cc-141">Çok fazla iş parçacığı varsa, bunların çoğu önemli ilerleme yapmaz.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-141">If there are too many threads, most of them will not make significant progress.</span></span> <span data-ttu-id="fd3cc-142">Geçerli iş parçacığı çoğunu tek bir işlemde varsa, diğer işlemlerin iş parçacıklarında daha az sıklıkta zamanlanır.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-142">If most of the current threads are in one process, threads in other processes are scheduled less frequently.</span></span>  
  
-   <span data-ttu-id="fd3cc-143">Kod yürütmeyi birçok iş parçacığı ile denetleme karmaşıktır ve çoğu hataların bir kaynak olabilir.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-143">Controlling code execution with many threads is complex, and can be a source of many bugs.</span></span>  
  
-   <span data-ttu-id="fd3cc-144">İş parçacıklarını yok etme meydana gelebilir bilerek ve bu sorunları işleme gerektirir.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-144">Destroying threads requires knowing what could happen and handling those issues.</span></span>  
  
 <span data-ttu-id="fd3cc-145">Paylaşılan kaynaklara erişim sağlayan çakışmaları oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-145">Providing shared access to resources can create conflicts.</span></span> <span data-ttu-id="fd3cc-146">Çakışmaları önlemek için eşitleme veya, paylaşılan kaynaklara erişimi denetlemek.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-146">To avoid conflicts, you must synchronize, or control the access to, shared resources.</span></span> <span data-ttu-id="fd3cc-147">Erişim düzgün (aynı veya farklı uygulama etki alanları) eşitlemek için hata kilitlenmeler (iki hangi iş parçacıkları her diğer tamamlanmasını beklerken vermiyor) gibi sorunlara yol açabilir ve (nedeniyle anormal bir sonuç ortaya çıktığında koşullar izler bir beklenmeyen kritik bağımlılığı iki olay zamanlaması).</span><span class="sxs-lookup"><span data-stu-id="fd3cc-147">Failure to synchronize access properly (in the same or different application domains) can lead to problems such as deadlocks (in which two threads stop responding while each waits for the other to complete) and race conditions (when an anomalous result occurs due to an unexpected critical dependence on the timing of two events).</span></span> <span data-ttu-id="fd3cc-148">Sistem kaynak arasında birden çok iş parçacığı paylaşımı koordine etmek için kullanılan eşitleme nesneleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-148">The system provides synchronization objects that can be used to coordinate resource sharing among multiple threads.</span></span> <span data-ttu-id="fd3cc-149">İş parçacığı sayısını azaltarak kaynakları eşitlemek kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-149">Reducing the number of threads makes it easier to synchronize resources.</span></span>  
  
 <span data-ttu-id="fd3cc-150">Eşitleme gerektiren kaynaklara şunları içerir:</span><span class="sxs-lookup"><span data-stu-id="fd3cc-150">Resources that require synchronization include:</span></span>  
  
-   <span data-ttu-id="fd3cc-151">Sistem kaynakları (örneğin, iletişim bağlantı noktaları).</span><span class="sxs-lookup"><span data-stu-id="fd3cc-151">System resources (such as communications ports).</span></span>  
  
-   <span data-ttu-id="fd3cc-152">Birden çok işlemler (örneğin, dosya tanıtıcıları) tarafından paylaşılan kaynaklar.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-152">Resources shared by multiple processes (such as file handles).</span></span>  
  
-   <span data-ttu-id="fd3cc-153">Kaynakları tek bir uygulama etki alanı üyesi (Genel, statik gibi ve örneği alanları) birden çok iş parçacığı tarafından erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-153">The resources of a single application domain (such as global, static, and instance fields) accessed by multiple threads.</span></span>  
  
### <a name="threading-and-application-design"></a><span data-ttu-id="fd3cc-154">İş parçacığı oluşturma ve uygulama tasarımı</span><span class="sxs-lookup"><span data-stu-id="fd3cc-154">Threading and Application Design</span></span>  
 <span data-ttu-id="fd3cc-155">Genel olarak, kullanarak <xref:System.Threading.ThreadPool> en kolay yolu, değil engeller başka bir iş parçacığı ve ne zaman değil beklediğiniz herhangi belirli görevlerin zamanlamasını görece kısa görevler için birden çok iş parçacığı işlemek için bir sınıftır.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-155">In general, using the <xref:System.Threading.ThreadPool> class is the easiest way to handle multiple threads for relatively short tasks that will not block other threads and when you do not expect any particular scheduling of the tasks.</span></span> <span data-ttu-id="fd3cc-156">Ancak, bir sayı kendi iş parçacığı oluşturma nedenleri vardır:</span><span class="sxs-lookup"><span data-stu-id="fd3cc-156">However, there are a number of reasons to create your own threads:</span></span>  
  
-   <span data-ttu-id="fd3cc-157">Belirli bir önceliği olan bir görev gerekiyorsa.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-157">If you need a task to have a particular priority.</span></span>  
  
-   <span data-ttu-id="fd3cc-158">Uzun süre çalışan (ve bu nedenle diğer görevleri engelleme) bir görev varsa.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-158">If you have a task that might run a long time (and therefore block other tasks).</span></span>  
  
-   <span data-ttu-id="fd3cc-159">İş parçacığı bir tek iş parçacıklı yerleştirilecek gerekir (tüm **Threadpool'u** iş parçacığı sayısı olan birden çok iş parçacıklı grupta).</span><span class="sxs-lookup"><span data-stu-id="fd3cc-159">If you need to place threads into a single-threaded apartment (all **ThreadPool** threads are in the multithreaded apartment).</span></span>  
  
-   <span data-ttu-id="fd3cc-160">İş parçacığı ile ilişkili kararlı bir kimlik gerekiyorsa.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-160">If you need a stable identity associated with the thread.</span></span> <span data-ttu-id="fd3cc-161">Örneğin, o iş parçacığı durdurmak, askıya veya ada göre bulmak için adanmış bir iş parçacığı kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-161">For example, you should use a dedicated thread to abort that thread, suspend it, or discover it by name.</span></span>  
  
-   <span data-ttu-id="fd3cc-162">Kullanıcı arabirimiyle etkileşim arka plan iş parçacıkları çalıştırmanız gerekiyorsa, .NET Framework sürüm 2.0 sağlayan bir <xref:System.ComponentModel.BackgroundWorker> olayları, kullanıcı arabirimi iş parçacığı için iş parçacıkları arası sıralama ile kullanarak iletişim kurar bileşeni.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-162">If you need to run background threads that interact with the user interface, the .NET Framework version 2.0 provides a <xref:System.ComponentModel.BackgroundWorker> component that communicates using events, with cross-thread marshaling to the user-interface thread.</span></span>  
  
### <a name="threading-and-exceptions"></a><span data-ttu-id="fd3cc-163">Parçacıkları ve özel durumlar</span><span class="sxs-lookup"><span data-stu-id="fd3cc-163">Threading and Exceptions</span></span>  
 <span data-ttu-id="fd3cc-164">İş parçacıklarında özel durumlar işleyin.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-164">Do handle exceptions in threads.</span></span> <span data-ttu-id="fd3cc-165">İş parçacığı, hatta arka plan iş parçacıkları, işlenmemiş özel durumlardan genellikle işlemi sonlandırın.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-165">Unhandled exceptions in threads, even background threads, generally terminate the process.</span></span> <span data-ttu-id="fd3cc-166">Bu kural için üç özel durum vardır:</span><span class="sxs-lookup"><span data-stu-id="fd3cc-166">There are three exceptions to this rule:</span></span>  
  
-   <span data-ttu-id="fd3cc-167">A <xref:System.Threading.ThreadAbortException> bir iş parçacığı, çünkü atılır <xref:System.Threading.Thread.Abort%2A> çağrıldı.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-167">A <xref:System.Threading.ThreadAbortException> is thrown in a thread because <xref:System.Threading.Thread.Abort%2A> was called.</span></span>  
  
-   <span data-ttu-id="fd3cc-168">Bir <xref:System.AppDomainUnloadedException> uygulama etki alanı bellekten olduğundan bir iş parçacığında oluşturuldu.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-168">An <xref:System.AppDomainUnloadedException> is thrown in a thread because the application domain is being unloaded.</span></span>  
  
-   <span data-ttu-id="fd3cc-169">Ortak dil çalışma zamanı ya da bir ana bilgisayar işlemi iş parçacığı sonlanır.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-169">The common language runtime or a host process terminates the thread.</span></span>  
  
 <span data-ttu-id="fd3cc-170">Daha fazla bilgi için bkz: [yönetilen iş parçacıklarında özel durumlar](../../../docs/standard/threading/exceptions-in-managed-threads.md).</span><span class="sxs-lookup"><span data-stu-id="fd3cc-170">For more information, see [Exceptions in Managed Threads](../../../docs/standard/threading/exceptions-in-managed-threads.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fd3cc-171">.NET Framework sürüm 1.0 ve 1.1, ortak dil çalışma zamanı sessizce bazı durumlar, örneğin iş parçacığı havuzu iş parçacıkları yakalar.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-171">In the .NET Framework versions 1.0 and 1.1, the common language runtime silently traps some exceptions, for example in thread pool threads.</span></span> <span data-ttu-id="fd3cc-172">Bu uygulama durumu bozuk ve hata ayıklamak oldukça zor olabilir askıda kalmasına uygulamaları neden.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-172">This may corrupt application state and eventually cause applications to hang, which might be very difficult to debug.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="fd3cc-173">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="fd3cc-173">See Also</span></span>  
 <xref:System.Threading.ThreadPool>  
 <xref:System.ComponentModel.BackgroundWorker>  
 [<span data-ttu-id="fd3cc-174">Çoklu İş Parçacığı Kullanımı için Veri Eşitleme</span><span class="sxs-lookup"><span data-stu-id="fd3cc-174">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
 [<span data-ttu-id="fd3cc-175">Yönetilen İş Parçacığı Havuzu</span><span class="sxs-lookup"><span data-stu-id="fd3cc-175">The Managed Thread Pool</span></span>](../../../docs/standard/threading/the-managed-thread-pool.md)

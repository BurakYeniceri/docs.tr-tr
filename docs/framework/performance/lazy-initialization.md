---
title: "Yavaş Başlatma"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
caps.latest.revision: 
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: f4998cc0c836cf46d79d854ad9a85e7eacf70d7f
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 12/22/2017
---
# <a name="lazy-initialization"></a><span data-ttu-id="1f728-102">Yavaş Başlatma</span><span class="sxs-lookup"><span data-stu-id="1f728-102">Lazy Initialization</span></span>
<span data-ttu-id="1f728-103">*Geç başlatma* bir nesnenin anlamına gelir oluşturulduktan ilk kullanılan kadar ertelenir.</span><span class="sxs-lookup"><span data-stu-id="1f728-103">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="1f728-104">(Bu konu için koşulları *geç başlatma* ve *yavaş örneklemesi* eşanlamlıdır.) Geç Başlatma öncelikle performansı, kayıp hesaplama önlemek ve program bellek gereksinimlerini azaltmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="1f728-104">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="1f728-105">En yaygın senaryolar şunlardır:</span><span class="sxs-lookup"><span data-stu-id="1f728-105">These are the most common scenarios:</span></span>  
  
-   <span data-ttu-id="1f728-106">Ne zaman oluşturulacağını pahalı bir nesne varsa ve program kullanamayabilir.</span><span class="sxs-lookup"><span data-stu-id="1f728-106">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="1f728-107">Örneğin, belleğe sahip olduğunuzu varsayın bir `Customer` olan nesneyi bir `Orders` içeren büyük bir dizi özelliği `Order` başlatılması için bir veritabanı bağlantısı gerektiren nesneleri.</span><span class="sxs-lookup"><span data-stu-id="1f728-107">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="1f728-108">Kullanıcı hiçbir zaman siparişleri görüntülemek veya verileri bir hesaplama kullanmak isterse, sistem belleği veya döngüleri bilgisayar oluşturmak için kullanmak için bir neden yoktur.</span><span class="sxs-lookup"><span data-stu-id="1f728-108">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="1f728-109">Kullanarak `Lazy<Orders>` bildirmek için `Orders` nesne geç başlatma için nesne kullanılmadığında İsraf sistem kaynaklarını özen gösterin.</span><span class="sxs-lookup"><span data-stu-id="1f728-109">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
-   <span data-ttu-id="1f728-110">Ne zaman oluşturulacağını pahalı bir nesne varsa ve pahalı diğer işlemleri tamamlandıktan sonra oluşturulduktan kadar erteleme istiyorsanız.</span><span class="sxs-lookup"><span data-stu-id="1f728-110">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="1f728-111">Örneğin, programınız başlar, ancak bazı yalnızca hemen gereken birkaç nesne örneklerini yükler varsayın.</span><span class="sxs-lookup"><span data-stu-id="1f728-111">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="1f728-112">Gerekli nesnelerden oluşturana kadar gerekli olmayan nesnelerin başlatılması ertelemeyi tarafından program başlatma performansını artırabilir.</span><span class="sxs-lookup"><span data-stu-id="1f728-112">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="1f728-113">Geç Başlatma gerçekleştirmek için kendi kodunuzu yazabilirsiniz rağmen kullanmanız önerilir <xref:System.Lazy%601> yerine.</span><span class="sxs-lookup"><span data-stu-id="1f728-113">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="1f728-114"><xref:System.Lazy%601>ve ilgili türlerinden de iş parçacığı güvenliği desteklemek ve tutarlı bir özel durum yayma İlkesi sağlayın.</span><span class="sxs-lookup"><span data-stu-id="1f728-114"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="1f728-115">Aşağıdaki tabloda farklı senaryolar yavaş başlatma etkinleştirmek için .NET Framework sürüm 4 sağlar türlerini listeler.</span><span class="sxs-lookup"><span data-stu-id="1f728-115">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="1f728-116">Tür</span><span class="sxs-lookup"><span data-stu-id="1f728-116">Type</span></span>|<span data-ttu-id="1f728-117">Açıklama</span><span class="sxs-lookup"><span data-stu-id="1f728-117">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="1f728-118">Geç Başlatma semantiği herhangi bir sınıf kitaplığı veya kullanıcı tanımlı tür için sağlayan bir sarmalayıcı sınıfı.</span><span class="sxs-lookup"><span data-stu-id="1f728-118">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="1f728-119">Benzer <xref:System.Lazy%601> bir iş parçacığı yerel temelinde geç başlatma semantiği sağlar ancak bu.</span><span class="sxs-lookup"><span data-stu-id="1f728-119">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="1f728-120">Her iş parçacığı kendi benzersiz değer erişebilir.</span><span class="sxs-lookup"><span data-stu-id="1f728-120">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="1f728-121">Sağlayan gelişmiş `static` (`Shared` Visual Basic'te) için bir sınıf yükü olmadan nesnelerin yavaş başlatılmasını yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="1f728-121">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="1f728-122">Temel yavaş başlatma</span><span class="sxs-lookup"><span data-stu-id="1f728-122">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="1f728-123">Bir geç başlatılan türü, örneğin, tanımlamak için `MyType`, kullanın `Lazy<MyType>` (`Lazy(Of MyType)` Visual Basic'te), aşağıdaki örnekte gösterildiği gibi.</span><span class="sxs-lookup"><span data-stu-id="1f728-123">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="1f728-124">Hiçbir temsilci geçtiyse <xref:System.Lazy%601> oluşturucusu, Sarmalanan türü kullanılarak oluşturulur tarafından <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> zaman değer özelliği ilk erişilir.</span><span class="sxs-lookup"><span data-stu-id="1f728-124">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="1f728-125">Türü varsayılan bir oluşturucu yoksa, bir çalışma zamanı özel durum oluşur.</span><span class="sxs-lookup"><span data-stu-id="1f728-125">If the type does not have a default constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="1f728-126">Aşağıdaki örnekte, varsayımında `Orders` bir dizi içeren bir sınıf `Order` nesnelerini bir veritabanından alınır.</span><span class="sxs-lookup"><span data-stu-id="1f728-126">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="1f728-127">A `Customer` nesne örneği içeren `Orders`, ancak kullanıcı eylemlerini, verilerden bağlı olarak `Orders` nesne gerekli olabilir.</span><span class="sxs-lookup"><span data-stu-id="1f728-127">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="1f728-128">Bir temsilci geçebilen <xref:System.Lazy%601> belirli bir oluşturucu çağırır Oluşturucu oluşturma zamanında Sarmalanan türünde aşırı ve aşağıdaki örnekte gösterildiği gibi gerekli, diğer başlatma adımları gerçekleştirin.</span><span class="sxs-lookup"><span data-stu-id="1f728-128">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="1f728-129">Yavaş nesnesi oluşturulur sonra hiçbir örneği `Orders` kadar oluşturulan <xref:System.Lazy%601.Value%2A> yavaş değişkenin özelliği ilk kez erişilir.</span><span class="sxs-lookup"><span data-stu-id="1f728-129">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="1f728-130">İlk erişimde Sarmalanan türü oluşturulur ve döndürülen ve gelecekteki tüm erişimi için depolanan.</span><span class="sxs-lookup"><span data-stu-id="1f728-130">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="1f728-131">A <xref:System.Lazy%601> nesne her zaman aynı nesne veya ile başlatıldı değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="1f728-131">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="1f728-132">Bu nedenle, <xref:System.Lazy%601.Value%2A> özelliği salt okunur durumdadır.</span><span class="sxs-lookup"><span data-stu-id="1f728-132">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="1f728-133">Varsa <xref:System.Lazy%601.Value%2A> başvuru depoları yazın, yeni bir nesne kendisine atadığınız olamaz.</span><span class="sxs-lookup"><span data-stu-id="1f728-133">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="1f728-134">(Ancak, kendi ayarlanabilir genel alanlar ve Özellikler değeri değiştirebilirsiniz.) Varsa <xref:System.Lazy%601.Value%2A> depoları bir değer yazın, değeri değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="1f728-134">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="1f728-135">Bununla birlikte, değişken Oluşturucusu yeniden yeni bağımsız değişkenleri kullanarak çağırarak yeni bir değişken oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1f728-135">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="1f728-136">Yeni yavaş, önceki bir gibi değil örneği `Orders` kadar kendi <xref:System.Lazy%601.Value%2A> özelliği ilk erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="1f728-136">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="1f728-137">İş parçacığı başlatma</span><span class="sxs-lookup"><span data-stu-id="1f728-137">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="1f728-138">Varsayılan olarak, <xref:System.Lazy%601> iş parçacığı nesneleridir.</span><span class="sxs-lookup"><span data-stu-id="1f728-138">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="1f728-139">Diğer bir deyişle, Oluşturucusu iş parçacığı güvenliği tür belirlemezse <xref:System.Lazy%601> oluşturduğu iş parçacığı nesneleridir.</span><span class="sxs-lookup"><span data-stu-id="1f728-139">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="1f728-140">Çok iş parçacıklı senaryolarda erişmek için ilk iş parçacığı <xref:System.Lazy%601.Value%2A> bir iş parçacığı özelliğinin <xref:System.Lazy%601> nesnesi üzerinde tüm iş parçacıklarının tüm sonraki erişimler için bunu başlatır ve tüm iş parçacıkları aynı veri paylaşır.</span><span class="sxs-lookup"><span data-stu-id="1f728-140">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="1f728-141">Bu nedenle, hangi iş parçacığı nesnesini başlatır önemli değildir ve yarış durumları zararsız.</span><span class="sxs-lookup"><span data-stu-id="1f728-141">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1f728-142">Özel durum önbelleği kullanarak bu tutarlılık hata koşulları için genişletebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1f728-142">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="1f728-143">Daha fazla bilgi için sonraki bölüme bakın [yavaş nesneleri durumlar](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects).</span><span class="sxs-lookup"><span data-stu-id="1f728-143">For more information, see the next section, [Exceptions in Lazy Objects](../../../docs/framework/performance/lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="1f728-144">Aşağıdaki örnek, aynı gösterir `Lazy<int>` örneği üç ayrı iş parçacığı için aynı değere sahiptir.</span><span class="sxs-lookup"><span data-stu-id="1f728-144">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="1f728-145">Her iş parçacığı üzerinde ayrı veri gerekiyorsa kullanın <xref:System.Threading.ThreadLocal%601> , bu konunun ilerleyen bölümlerinde açıklandığı gibi yazın.</span><span class="sxs-lookup"><span data-stu-id="1f728-145">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="1f728-146">Bazı <xref:System.Lazy%601> oluşturucular sahip adlı bir Boolean parametresiyle `isThreadSafe` belirtmek için kullanılan olup olmadığını <xref:System.Lazy%601.Value%2A> özelliği birden çok iş parçacığı tarafından erişilen.</span><span class="sxs-lookup"><span data-stu-id="1f728-146">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="1f728-147">Yalnızca bir iş parçacığından özelliğine erişmek istiyorsanız, geçirin `false` uygun performans avantajı elde edilir.</span><span class="sxs-lookup"><span data-stu-id="1f728-147">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="1f728-148">Birden çok iş parçacığından özelliğine erişmek istiyorsanız, geçirin `true` istemek üzere <xref:System.Lazy%601> örneğinin düzgün bir şekilde bir iş parçacığı başlatma sırasında bir özel durum oluşturur yarış durumları işler.</span><span class="sxs-lookup"><span data-stu-id="1f728-148">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="1f728-149">Bazı <xref:System.Lazy%601> oluşturucular sahip bir <xref:System.Threading.LazyThreadSafetyMode> adlı parametre `mode`.</span><span class="sxs-lookup"><span data-stu-id="1f728-149">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="1f728-150">Bu oluşturucu ek iş parçacığı güvenliği modu sağlar.</span><span class="sxs-lookup"><span data-stu-id="1f728-150">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="1f728-151">Aşağıdaki tabloda nasıl, iş parçacığı güvenliği bir <xref:System.Lazy%601> nesnesi, iş parçacığı güvenliği belirtin Oluşturucu parametreleri tarafından etkilenir.</span><span class="sxs-lookup"><span data-stu-id="1f728-151">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="1f728-152">Her Oluşturucusu en çok bir tür parametresi var.</span><span class="sxs-lookup"><span data-stu-id="1f728-152">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="1f728-153">Nesnenin iş parçacığı güvenliği</span><span class="sxs-lookup"><span data-stu-id="1f728-153">Thread safety of the object</span></span>|<span data-ttu-id="1f728-154">`LazyThreadSafetyMode``mode` parametresi</span><span class="sxs-lookup"><span data-stu-id="1f728-154">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="1f728-155">Boolean `isThreadSafe` parametresi</span><span class="sxs-lookup"><span data-stu-id="1f728-155">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="1f728-156">Hiçbir iş parçacığı güvenliği parametreleri</span><span class="sxs-lookup"><span data-stu-id="1f728-156">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="1f728-157">Tam olarak iş parçacığı açısından güvenli; bir seferde yalnızca bir iş parçacığı değeriyle dener.</span><span class="sxs-lookup"><span data-stu-id="1f728-157">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="1f728-158">Evet.</span><span class="sxs-lookup"><span data-stu-id="1f728-158">Yes.</span></span>|  
|<span data-ttu-id="1f728-159">İş parçacığı-güvenli değil.</span><span class="sxs-lookup"><span data-stu-id="1f728-159">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="1f728-160">Yok.</span><span class="sxs-lookup"><span data-stu-id="1f728-160">Not applicable.</span></span>|  
|<span data-ttu-id="1f728-161">Tam olarak iş parçacığı açısından güvenli; iş parçacığı yarış'değeri başlatılamadı.</span><span class="sxs-lookup"><span data-stu-id="1f728-161">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="1f728-162">Yok.</span><span class="sxs-lookup"><span data-stu-id="1f728-162">Not applicable.</span></span>|<span data-ttu-id="1f728-163">Yok.</span><span class="sxs-lookup"><span data-stu-id="1f728-163">Not applicable.</span></span>|  
  
 <span data-ttu-id="1f728-164">Tabloda gösterildiği gibi belirtme <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> için `mode` parametresi aynıdır belirtme `true` için `isThreadSafe` parametre ve belirterek <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> belirtme aynı `false`.</span><span class="sxs-lookup"><span data-stu-id="1f728-164">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="1f728-165">Belirtme <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> başlatma girişimi birden çok iş parçacığı sağlar <xref:System.Lazy%601> örneği.</span><span class="sxs-lookup"><span data-stu-id="1f728-165">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="1f728-166">Yalnızca bir iş parçacığı bu yarış kazanabilirsiniz ve tüm diğer iş parçacıklarından başarılı iş parçacığı tarafından başlatıldı değeri alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1f728-166">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="1f728-167">Başlatma sırasında bir iş parçacığında özel durum oluşur, o iş parçacığı başarılı iş parçacığı tarafından ayarlanan değer almaz.</span><span class="sxs-lookup"><span data-stu-id="1f728-167">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="1f728-168">Özel durumlar önbelleğe alınmaz, bu nedenle bir sonraki erişim girişiminde <xref:System.Lazy%601.Value%2A> özelliği başarılı başlatma neden olur.</span><span class="sxs-lookup"><span data-stu-id="1f728-168">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="1f728-169">Bu aşağıdaki bölümde açıklanan özel durumlar diğer modlarında nasıl işleneceğini farklıdır.</span><span class="sxs-lookup"><span data-stu-id="1f728-169">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="1f728-170">Daha fazla bilgi için bkz: <xref:System.Threading.LazyThreadSafetyMode> numaralandırması.</span><span class="sxs-lookup"><span data-stu-id="1f728-170">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>   
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="1f728-171">Yavaş nesneleri özel durumları</span><span class="sxs-lookup"><span data-stu-id="1f728-171">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="1f728-172">Daha önce belirtildiği gibi bir <xref:System.Lazy%601> nesne her zaman döndürür aynı nesne veya, ile başlatıldı değeri ve bu nedenle <xref:System.Lazy%601.Value%2A> özelliği salt okunur durumdadır.</span><span class="sxs-lookup"><span data-stu-id="1f728-172">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="1f728-173">Özel durum önbelleğe almayı etkinleştirirseniz bu girişi aynı zamanda özel durum davranışını genişletir.</span><span class="sxs-lookup"><span data-stu-id="1f728-173">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="1f728-174">Geç başlatılan bir nesne özel durum etkinleştirildi ve onun başlatma yönteminden aykırı zaman <xref:System.Lazy%601.Value%2A> özelliği ilk erişilen, o aynı erişmeye sonraki her çalışırken özel durum <xref:System.Lazy%601.Value%2A> özelliği .</span><span class="sxs-lookup"><span data-stu-id="1f728-174">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="1f728-175">Diğer bir deyişle, Sarmalanan türü Oluşturucusu hiçbir zaman, hatta birden çok iş parçacıklı senaryolarda yeniden çağrılır.</span><span class="sxs-lookup"><span data-stu-id="1f728-175">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="1f728-176">Bu nedenle, <xref:System.Lazy%601> nesne üzerinde bir erişim bir özel durum ve bir sonraki erişimi bir değer döndürür.</span><span class="sxs-lookup"><span data-stu-id="1f728-176">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="1f728-177">Özel durum önbelleğe alma etkinse kullandığınızda <xref:System.Lazy%601?displayProperty=nameWithType> başlatma yöntemini alan oluşturucu (`valueFactory` parametresi); Örneğin, kullandığınızda etkin `Lazy(T)(Func(T))`Oluşturucusu.</span><span class="sxs-lookup"><span data-stu-id="1f728-177">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="1f728-178">Oluşturucusu da uzun sürerse bir <xref:System.Threading.LazyThreadSafetyMode> değeri (`mode` parametresi), belirtin <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> veya <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1f728-178">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1f728-179">Başlatma yöntemini belirtmek için bu iki moddan özel durum önbelleğe alınmasını etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="1f728-179">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="1f728-180">Başlatma yöntemi çok basit olabilir.</span><span class="sxs-lookup"><span data-stu-id="1f728-180">The initialization method can be very simple.</span></span> <span data-ttu-id="1f728-181">Örneğin, varsayılan oluşturucusu çağırabilirsiniz `T`: `new Lazy<Contents>(() => new Contents(), mode)` C# veya `New Lazy(Of Contents)(Function() New Contents())` Visual Basic'te.</span><span class="sxs-lookup"><span data-stu-id="1f728-181">For example, it might call the default constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="1f728-182">Kullanırsanız, bir <xref:System.Lazy%601?displayProperty=nameWithType> başlatma yöntemini belirtmiyor oluşturucusu, varsayılan oluşturucusu tarafından oluşturulan özel durumları `T` önbelleğe alınmaz.</span><span class="sxs-lookup"><span data-stu-id="1f728-182">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the default constructor for `T` are not cached.</span></span> <span data-ttu-id="1f728-183">Daha fazla bilgi için bkz: <xref:System.Threading.LazyThreadSafetyMode> numaralandırması.</span><span class="sxs-lookup"><span data-stu-id="1f728-183">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1f728-184">Oluşturursanız, bir <xref:System.Lazy%601> nesnesi ile `isThreadSafe` Oluşturucusu parametre kümesine `false` veya `mode` Oluşturucusu parametre kümesine <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, erişmesi gereken <xref:System.Lazy%601> nesnesi tek bir iş parçacığından ya da kendi sağlayın Eşitleme.</span><span class="sxs-lookup"><span data-stu-id="1f728-184">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="1f728-185">Bu, tüm yönlerini özel durumu önbelleğe alma dahil olmak üzere bu nesne için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="1f728-185">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="1f728-186">Önceki bölümünde belirtildiği gibi <xref:System.Lazy%601> belirterek oluşturulan nesneler <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> özel durumlar farklı şekilde ele alın.</span><span class="sxs-lookup"><span data-stu-id="1f728-186">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="1f728-187">İle <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, birden çok iş parçacığı başlatılamadı rekabet <xref:System.Lazy%601> örneği.</span><span class="sxs-lookup"><span data-stu-id="1f728-187">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="1f728-188">Bu durumda, özel durumlar önbelleğe alınmaz ve erişmeyi denediği <xref:System.Lazy%601.Value%2A> özelliği başlatma başarılı olana kadar devam edebilir.</span><span class="sxs-lookup"><span data-stu-id="1f728-188">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="1f728-189">Yol aşağıdaki tabloda özetlenmiştir <xref:System.Lazy%601> oluşturucular denetim özel durumu önbelleğe alma.</span><span class="sxs-lookup"><span data-stu-id="1f728-189">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="1f728-190">Oluşturucu</span><span class="sxs-lookup"><span data-stu-id="1f728-190">Constructor</span></span>|<span data-ttu-id="1f728-191">İş parçacığı güvenliği modu</span><span class="sxs-lookup"><span data-stu-id="1f728-191">Thread safety mode</span></span>|<span data-ttu-id="1f728-192">Başlatma yöntemini kullanır</span><span class="sxs-lookup"><span data-stu-id="1f728-192">Uses initialization method</span></span>|<span data-ttu-id="1f728-193">Özel durumlar önbelleğe alınır</span><span class="sxs-lookup"><span data-stu-id="1f728-193">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="1f728-194">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="1f728-194">Lazy(T)()</span></span>|<span data-ttu-id="1f728-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="1f728-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="1f728-196">Hayır</span><span class="sxs-lookup"><span data-stu-id="1f728-196">No</span></span>|<span data-ttu-id="1f728-197">Hayır</span><span class="sxs-lookup"><span data-stu-id="1f728-197">No</span></span>|  
|<span data-ttu-id="1f728-198">Lazy(T)(FUNC(T))</span><span class="sxs-lookup"><span data-stu-id="1f728-198">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="1f728-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="1f728-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="1f728-200">Evet</span><span class="sxs-lookup"><span data-stu-id="1f728-200">Yes</span></span>|<span data-ttu-id="1f728-201">Evet</span><span class="sxs-lookup"><span data-stu-id="1f728-201">Yes</span></span>|  
|<span data-ttu-id="1f728-202">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="1f728-202">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="1f728-203">`True`(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) veya `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="1f728-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="1f728-204">Hayır</span><span class="sxs-lookup"><span data-stu-id="1f728-204">No</span></span>|<span data-ttu-id="1f728-205">Hayır</span><span class="sxs-lookup"><span data-stu-id="1f728-205">No</span></span>|  
|<span data-ttu-id="1f728-206">Lazy(T)(FUNC(T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="1f728-206">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="1f728-207">`True`(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) veya `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="1f728-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="1f728-208">Evet</span><span class="sxs-lookup"><span data-stu-id="1f728-208">Yes</span></span>|<span data-ttu-id="1f728-209">Evet</span><span class="sxs-lookup"><span data-stu-id="1f728-209">Yes</span></span>|  
|<span data-ttu-id="1f728-210">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="1f728-210">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="1f728-211">Kullanıcı tanımlı</span><span class="sxs-lookup"><span data-stu-id="1f728-211">User-specified</span></span>|<span data-ttu-id="1f728-212">Hayır</span><span class="sxs-lookup"><span data-stu-id="1f728-212">No</span></span>|<span data-ttu-id="1f728-213">Hayır</span><span class="sxs-lookup"><span data-stu-id="1f728-213">No</span></span>|  
|<span data-ttu-id="1f728-214">Lazy(T)(FUNC(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="1f728-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="1f728-215">Kullanıcı tanımlı</span><span class="sxs-lookup"><span data-stu-id="1f728-215">User-specified</span></span>|<span data-ttu-id="1f728-216">Evet</span><span class="sxs-lookup"><span data-stu-id="1f728-216">Yes</span></span>|<span data-ttu-id="1f728-217">Kullanıcı belirtiyorsa Hayır <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; Aksi halde, Evet.</span><span class="sxs-lookup"><span data-stu-id="1f728-217">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="1f728-218">Geç başlatılan bir özellik uygulama</span><span class="sxs-lookup"><span data-stu-id="1f728-218">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="1f728-219">Geç Başlatma kullanarak genel özelliği uygulamak için yedekleme alanı özelliğinin tanımlarsınız bir <xref:System.Lazy%601>ve geri dönüp <xref:System.Lazy%601.Value%2A> özelliğinden `get` özelliği erişimcisi.</span><span class="sxs-lookup"><span data-stu-id="1f728-219">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="1f728-220"><xref:System.Lazy%601.Value%2A> Özelliği salt okunur; bu nedenle, onu gösteren özelliği sahip olmayan `set` erişimcisi.</span><span class="sxs-lookup"><span data-stu-id="1f728-220">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="1f728-221">Tarafından yedeklenen bir okuma/yazma özelliği gerekliyse bir <xref:System.Lazy%601> nesnesi `set` erişimci yeni oluşturmalısınız <xref:System.Lazy%601> nesne ve yedekleme deposu atayın.</span><span class="sxs-lookup"><span data-stu-id="1f728-221">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="1f728-222">`set` Erişimci geçirilmedi yeni özellik değeri döndüren bir lambda ifadesi oluşturmalısınız `set` erişimci ve o lambda ifadesi oluşturucuya için yeni geçirin <xref:System.Lazy%601> nesnesi.</span><span class="sxs-lookup"><span data-stu-id="1f728-222">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="1f728-223">Sonraki erişim <xref:System.Lazy%601.Value%2A> özelliği başlatma yeni neden olacak <xref:System.Lazy%601>ve kendi <xref:System.Lazy%601.Value%2A> özelliği bundan sonra özelliğine atanan yeni değerini döndür.</span><span class="sxs-lookup"><span data-stu-id="1f728-223">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="1f728-224">Bu karışık düzenleme yerleşik çoklu iş parçacığı kullanımı korumaları korumak için nedeni <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="1f728-224">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="1f728-225">Aksi takdirde, özellik erişimcisi tarafından döndürülen değerin ilk önbelleğe gerekirdi <xref:System.Lazy%601.Value%2A> özelliği yalnızca önbelleğe alınan değeri değiştirin ve bunu yapmak için kendi iş parçacığı kod yazmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="1f728-225">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="1f728-226">Tarafından yedeklenen bir okuma/yazma özelliği gerektirdiği ek başlatmaları nedeniyle bir <xref:System.Lazy%601> nesnesi, performansı kabul edilebilir olabilir.</span><span class="sxs-lookup"><span data-stu-id="1f728-226">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="1f728-227">Ayrıca, belirli bir senaryoyu bağlı olarak, ek koordinasyon ayarlayıcılar alıcılar arasındaki yarış durumları önlemek için gerekli olabilir.</span><span class="sxs-lookup"><span data-stu-id="1f728-227">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="1f728-228">İş parçacığı yerel yavaş başlatma</span><span class="sxs-lookup"><span data-stu-id="1f728-228">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="1f728-229">Birden çok iş parçacıklı bazı senaryolarda, her iş parçacığının kendi özel veri vermek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1f728-229">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="1f728-230">Bu tür veriler adlı *iş parçacığı yerel veri*.</span><span class="sxs-lookup"><span data-stu-id="1f728-230">Such data is called *thread-local data*.</span></span> <span data-ttu-id="1f728-231">.NET Framework sürüm 3.5 ve önceki sürümlerde, uyguladığınız `ThreadStatic` iş parçacığı yerel yapmak için statik bir değişkene özniteliği.</span><span class="sxs-lookup"><span data-stu-id="1f728-231">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="1f728-232">Ancak, kullanarak `ThreadStatic` özniteliği Zarif hatalarına yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="1f728-232">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="1f728-233">Örneğin, hatta temel başlatma ifadeleri, erişen yalnızca ilk iş parçacığı üzerinde aşağıdaki örnekte gösterildiği gibi başlatılması değişken neden olur.</span><span class="sxs-lookup"><span data-stu-id="1f728-233">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="1f728-234">Varsayılan değer (sıfır) kullanarak diğer tüm parçacıklarında değişkeni başlatılır.</span><span class="sxs-lookup"><span data-stu-id="1f728-234">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="1f728-235">.NET Framework sürüm 4 alternatif olarak, kullandığınız <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> tüm iş parçacıkları tarafından başlatılan bir örnek tabanlı, iş parçacığı yerel değişken oluşturmak için türü <xref:System.Action%601> sağladığınız temsilci.</span><span class="sxs-lookup"><span data-stu-id="1f728-235">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="1f728-236">Aşağıdaki örnekte, tüm iş parçacıklarının, erişim `counter` başlangıç değeri 1 olarak görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="1f728-236">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="1f728-237"><xref:System.Threading.ThreadLocal%601>çok aynı şekilde kendi nesne sarmalar <xref:System.Lazy%601>, bu temel farklılıklar ile:</span><span class="sxs-lookup"><span data-stu-id="1f728-237"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
-   <span data-ttu-id="1f728-238">Her iş parçacığı, diğer iş parçacığı tarafından erişilebilir durumda değil, kendi özel veri kullanarak iş parçacığı yerel değişken başlatır.</span><span class="sxs-lookup"><span data-stu-id="1f728-238">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
-   <span data-ttu-id="1f728-239"><xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> Özelliği okuma-yazma ve bir kez herhangi bir sayıda değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="1f728-239">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="1f728-240">Bu örneğin, bir özel durum yayma etkileyebilir `get` işlemi özel durum Yükselt ancak bir sonraki başarılı bir şekilde değeri başlatabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1f728-240">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
-   <span data-ttu-id="1f728-241">Hiçbir başlatma temsilci sağlanırsa, <xref:System.Threading.ThreadLocal%601> Sarmalanan türü türünün varsayılan değerini kullanarak başlatılır.</span><span class="sxs-lookup"><span data-stu-id="1f728-241">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="1f728-242">Bu bağlamda <xref:System.Threading.ThreadLocal%601> tutarlıdır <xref:System.ThreadStaticAttribute> özniteliği.</span><span class="sxs-lookup"><span data-stu-id="1f728-242">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="1f728-243">Aşağıdaki örnek, her iş parçacığı erişen gösterir `ThreadLocal<int>` örneğini kendi benzersiz verilerin kopyasını alır.</span><span class="sxs-lookup"><span data-stu-id="1f728-243">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="1f728-244">Parallel.For ve ForEach iş parçacığı yerel değişkenler</span><span class="sxs-lookup"><span data-stu-id="1f728-244">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="1f728-245">Kullandığınızda <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> yöntemi veya <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> yöntemi yinelemek için veri kaynakları paralel olarak üzerinden iş parçacığı yerel verileri için yerleşik destek sahip aşırı kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1f728-245">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="1f728-246">Bu yöntemler, yerleşim yeri iş parçacığı oluşturma, erişim ve veriyi temizlemek için yerel temsilciler kullanarak elde edilir.</span><span class="sxs-lookup"><span data-stu-id="1f728-246">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="1f728-247">Daha fazla bilgi için bkz: [nasıl yapılır: iş parçacığı yerel değişkenleriyle bir Parallel.For döngüsü yazma](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) ve [nasıl yapılır: iş parçacığı yerel değişkenleriyle bir Parallel.ForEach döngüsü yazma](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-thread-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="1f728-247">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Thread-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-thread-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="1f728-248">Düşük yükünü senaryoları için geç başlatma kullanarak</span><span class="sxs-lookup"><span data-stu-id="1f728-248">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="1f728-249">Çok sayıda nesneleri geç başlatma için sahip olduğu senaryolarda, her nesne kaydırma karar verebilirsiniz bir <xref:System.Lazy%601> çok fazla bellek veya çok sayıda bilgi işlem kaynaklarını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="1f728-249">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="1f728-250">Veya, katı gereksinimlere sahip olabilir hakkında nasıl geç başlatma sunulur.</span><span class="sxs-lookup"><span data-stu-id="1f728-250">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="1f728-251">Böyle durumlarda, kullandığınız `static` (`Shared` Visual Basic'te) yöntemlerinin <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> yavaş-her nesne bir örnekte kaydırma olmadan başlatma için sınıf <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="1f728-251">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="1f728-252">Aşağıdaki örnekte, tüm kaydırma yerine varsayımında `Orders` bir nesne <xref:System.Lazy%601> nesnesi başlatılmadı yavaş tek sahip `Order` yalnızca gerekli olup olmadığını nesneleri.</span><span class="sxs-lookup"><span data-stu-id="1f728-252">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="1f728-253">Bu örnekte, başlatma yordamı her döngü tekrarında üzerinde çağrılan dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="1f728-253">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="1f728-254">Çok iş parçacıklı senaryolarda başlatma yordamı çağırmak için ilk değeri tüm iş parçacıkları tarafından görülen bir iş parçacığıdır.</span><span class="sxs-lookup"><span data-stu-id="1f728-254">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="1f728-255">Sonraki iş parçacığı sayısı ayrıca başlatma yordamı çağırma ancak sonuçları kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="1f728-255">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="1f728-256">Bu tür bir olası yarış durumu kabul edilebilir değilse kullanın <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> Boolean bağımsız değişkeni ve eşitleme nesnesi alır.</span><span class="sxs-lookup"><span data-stu-id="1f728-256">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1f728-257">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="1f728-257">See Also</span></span>  
 [<span data-ttu-id="1f728-258">Yönetilen İş Parçacığı Oluşturma Temelleri</span><span class="sxs-lookup"><span data-stu-id="1f728-258">Managed Threading Basics</span></span>](../../../docs/standard/threading/managed-threading-basics.md)  
 [<span data-ttu-id="1f728-259">İş Parçacıkları ve İş Parçacığı Oluşturma</span><span class="sxs-lookup"><span data-stu-id="1f728-259">Threads and Threading</span></span>](../../../docs/standard/threading/threads-and-threading.md)  
 [<span data-ttu-id="1f728-260">Görev Paralel Kitaplığı (TPL)</span><span class="sxs-lookup"><span data-stu-id="1f728-260">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)  
 [<span data-ttu-id="1f728-261">Nasıl yapılır: Nesnelerin Geç Başlatılmasını Gerçekleştirme</span><span class="sxs-lookup"><span data-stu-id="1f728-261">How to: Perform Lazy Initialization of Objects</span></span>](../../../docs/framework/performance/how-to-perform-lazy-initialization-of-objects.md)

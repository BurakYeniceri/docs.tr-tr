---
title: Etki alanı olayları. Tasarım ve uygulama
description: Kapsayıcılı .NET uygulamaları için .NET mikro hizmet mimarisi | Etki alanı olayları, tasarım ve uygulama
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 12/11/2017
ms.openlocfilehash: 3daab93a97c57521ae6f16ea2498c3f36f30d795
ms.sourcegitcommit: 60645077dc4b62178403145f8ef691b13ffec28e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/10/2018
ms.locfileid: "37937133"
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="5452e-104">Etki alanı olayları: tasarım ve uygulama</span><span class="sxs-lookup"><span data-stu-id="5452e-104">Domain events: design and implementation</span></span>

<span data-ttu-id="5452e-105">Açıkça yan etkilerini etki alanınız içindeki değişiklikler, uygulama için etki alanı olaylarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="5452e-105">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="5452e-106">Başka bir deyişle ve DDD terminolojiyi kullanarak, yan etkileri arasında birden çok toplamalar açıkça uygulamak için etki alanı olaylarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="5452e-106">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="5452e-107">İsteğe bağlı olarak daha iyi ölçeklenebilirlik ve veritabanı kilitlerini etkileri daha az nihai tutarlılık arasında aynı etki alanı içinde toplamlar kullanın.</span><span class="sxs-lookup"><span data-stu-id="5452e-107">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="5452e-108">Bir etki alanı olayı nedir?</span><span class="sxs-lookup"><span data-stu-id="5452e-108">What is a domain event?</span></span>

<span data-ttu-id="5452e-109">Bir olay geçmişte gerçekleşen bir şeydir.</span><span class="sxs-lookup"><span data-stu-id="5452e-109">An event is something that has happened in the past.</span></span> <span data-ttu-id="5452e-110">Bir etki alanı olayı, mantıksal olarak, belirli bir etki alanında gerçekleşen bir şeydir ve diğer bölümleri farkında olmanız ve olası tepki aynı etki alanının (işlem içi) istediğiniz bir şey.</span><span class="sxs-lookup"><span data-stu-id="5452e-110">A domain event is, logically, something that happened in a particular domain, and something you want other parts of the same domain (in-process) to be aware of and potentially react to.</span></span>

<span data-ttu-id="5452e-111">Önemli bir avantajı, etki alanı olayları, bir etki alanında bir sorun oluştu sonra etkilere açıkça yerine örtük olarak ifade edilebilir ' dir.</span><span class="sxs-lookup"><span data-stu-id="5452e-111">An important benefit of domain events is that side effects after something happened in a domain can be expressed explicitly instead of implicitly.</span></span> <span data-ttu-id="5452e-112">Bu yan etkileri iş görevle ilgili ya da tüm işlemler gerçekleştirilir böylece tutarlı olmalıdır, ya da bunların hiçbiri.</span><span class="sxs-lookup"><span data-stu-id="5452e-112">Those side effects must be consistent so either all the operations related to the business task happen, or none of them.</span></span> <span data-ttu-id="5452e-113">Ayrıca, bir daha iyi görev ayrımı nettir sınıfların aynı etki alanındaki etki alanı olayları etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="5452e-113">In addition, domain events enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="5452e-114">Var. varsa, yan etkileri bir kullanım örneği tarafından provoked olmasını sadece Entity Framework ve varlıklar veya hatta toplamalar kullanıyorsanız, bir sorun oluştu sonra Örneğin, bu bağlı kod içinde örtük bir kavram olarak uygulanacaktır.</span><span class="sxs-lookup"><span data-stu-id="5452e-114">For example, if you're just using Entity Framework and entities or even aggregates, if there have to be side effects provoked by a use case, those will be implemented as an implicit concept in the coupled code after something happened.</span></span> <span data-ttu-id="5452e-115">Ancak, yalnızca bu kodu bilmiyor (yan etkisi) kodu ana işleminin bir parçası ise ya da bir yan etkisi gerçekten ise görürseniz.</span><span class="sxs-lookup"><span data-stu-id="5452e-115">But, if you just see that code, you might not know if that code (the side effect) is part of the main operation or if it really is a side effect.</span></span> <span data-ttu-id="5452e-116">Öte yandan, etki alanı olaylarını kullanarak kavramı açık ve bulunabilen dil parçası olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="5452e-116">On the other hand, using domain events makes the concept explicit and part of the ubiquitous language.</span></span> <span data-ttu-id="5452e-117">Örneğin, hizmetine uygulamada, bir sipariş oluşturma konusunda sırası değildir; yerinde bir sipariş kadar kullanıcı bir alıcısı olmadığından, özgün kullanıcıya, bağlı bir alıcı toplama oluşturur veya güncelleştirir.</span><span class="sxs-lookup"><span data-stu-id="5452e-117">For example, in the eShopOnContainers application, creating an order is not just about the order; it updates or creates a buyer aggregate based on the original user, because the user is not a buyer until there is an order in place.</span></span> <span data-ttu-id="5452e-118">Etki alanı olayları kullanırsanız, etki alanı uzmanları tarafından sağlanan bulunabilen dilde dayalı olarak, etki alanı kuralı açıkça ifade edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5452e-118">If you use domain events, you can explicitly express that domain rule based in the ubiquitous language provided by the domain experts.</span></span>

<span data-ttu-id="5452e-119">Etki alanı olayları, önemli bir farkla Mesajlaşma stili olayları biraz benzerdir.</span><span class="sxs-lookup"><span data-stu-id="5452e-119">Domain events are somewhat similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="5452e-120">Gerçek Mesajlaşma, message queuing, ileti aracıları veya AMPQ kullanarak service bus ile bir ileti her zaman zaman uyumsuz olarak gönderilen ve işlemleri ve makineler iletilir.</span><span class="sxs-lookup"><span data-stu-id="5452e-120">With real messaging, message queuing, message brokers, or a service bus using AMPQ, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="5452e-121">Bu, birden çok sınırlanmış Bağlamlar, mikro hizmetler veya hatta farklı uygulamalara tümleştirmek için kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-121">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="5452e-122">Ancak, etki alanı olayları, çalışmakta olan etki alanı işlemi bir olaydan yükseltmek istediğiniz, ancak aynı etki alanı içinde gerçekleşmesi için tüm yan etkileri istediğiniz.</span><span class="sxs-lookup"><span data-stu-id="5452e-122">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="5452e-123">Etki alanı olayları ve yan etkileri (olay işleyicileri tarafından yönetilen daha sonra tetiklenen eylemler) neredeyse anında gerçekleşmelidir genellikle işlem içinde ve aynı etki alanı içinde.</span><span class="sxs-lookup"><span data-stu-id="5452e-123">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="5452e-124">Bu nedenle, etki alanı olayları zaman uyumlu veya zaman uyumsuz olabilir.</span><span class="sxs-lookup"><span data-stu-id="5452e-124">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="5452e-125">Tümleştirme olayları, ancak her zaman uyumsuz olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5452e-125">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="5452e-126">Etki alanı olayları tümleştirme olayları karşılaştırması</span><span class="sxs-lookup"><span data-stu-id="5452e-126">Domain events versus integration events</span></span>

<span data-ttu-id="5452e-127">Anlamsal olarak, etki alanı ve tümleştirme olayları aynı şeydir: hakkında bir şey mi oldu bildirimleri.</span><span class="sxs-lookup"><span data-stu-id="5452e-127">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="5452e-128">Ancak, kendi uygulama farklı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-128">However, their implementation must be different.</span></span> <span data-ttu-id="5452e-129">Etki alanı, bir bellek içi Dünyası IOC kapsayıcı veya başka bir yöntem dayalı olarak uygulanabilir bir etki alanı olay dağıtıcısı depoya yalnızca iletileri olaylardır.</span><span class="sxs-lookup"><span data-stu-id="5452e-129">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="5452e-130">Öte yandan, diğer mikro hizmetler, sınırlanmış Bağlamlar veya hatta dış uygulama olup olmadığını kaydedilen işlem sayısı ve ek alt sistemler, güncelleştirmeleri yayılması tümleştirme olayları amacı olan.</span><span class="sxs-lookup"><span data-stu-id="5452e-130">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="5452e-131">Bu nedenle, gerçekleşmesi gerektiğini yalnızca varlık başarıyla kalıcıysa beri pek çok senaryoda bu başarısız olursa tüm operasyon etkili bir şekilde hiçbir zaman oldu.</span><span class="sxs-lookup"><span data-stu-id="5452e-131">Hence, they should occur only if the entity is successfully persisted, since in many scenarios if this fails, the entire operation effectively never happened.</span></span>

<span data-ttu-id="5452e-132">Buna ek olarak ve belirtilen, tümleştirme olayları birden çok mikro hizmetler (diğer sınırlanmış Bağlamlar) veya hatta dış sistemler/uygulamalar arasında zaman uyumsuz iletişim temel gerekir.</span><span class="sxs-lookup"><span data-stu-id="5452e-132">In addition, and as mentioned, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span> <span data-ttu-id="5452e-133">Bu nedenle, olay veri yolu arabirimini arası işlem sağlar ve potansiyel olarak uzak hizmetler arasındaki iletişimi dağıtılan bazı altyapı gerekir.</span><span class="sxs-lookup"><span data-stu-id="5452e-133">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="5452e-134">Ticari bir service bus, kuyruklar, bir posta kutusu kullanılan paylaşılan bir veritabanı veya diğer dağıtılmış temel alabilir ve ideal tabanlı bir Mesajlaşma sistemi gönderin.</span><span class="sxs-lookup"><span data-stu-id="5452e-134">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="5452e-135">Aynı etki alanı içinde birden çok toplamları arasında yan etkileri tetiklemek için tercih edilen yol olarak etki alanı olayları</span><span class="sxs-lookup"><span data-stu-id="5452e-135">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="5452e-136">Toplama örneği bir veya daha fazla ek toplamalarda çalıştırılacak ek bir etki alanına yönelik kurallardan gerektirir birine ilgili komut yürütme, tasarım ve uygulama etki alanı olayları tarafından tetiklenmesi için bu yan etkileri gerekir.</span><span class="sxs-lookup"><span data-stu-id="5452e-136">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="5452e-137">Şekil 9-14 gösterilen şekilde ve en önemli biri olarak kullanım örnekleri, aynı etki alanı modeli içinde birden çok toplamları arasında durum değişikliklerinin yayılması bir etki alanı olayı kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-137">As shown in Figure 9-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![](./media/image15.png)

<span data-ttu-id="5452e-138">**Şekil 9-14**.</span><span class="sxs-lookup"><span data-stu-id="5452e-138">**Figure 9-14**.</span></span> <span data-ttu-id="5452e-139">Aynı etki alanı içinde birden çok toplamları arasında tutarlılığı zorlamak için etki alanı olayları</span><span class="sxs-lookup"><span data-stu-id="5452e-139">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="5452e-140">Kullanıcı, bir sipariş başlattığında şekilde, özgün kimlik mikro hizmet kullanıcı bilgisi (bilgilerle CreateOrder komutunda sağlanan) göre sıralama mikro hizmet, bir alıcı nesnesinde oluşturulmasını OrderStarted etki alanı olayı tetikler.</span><span class="sxs-lookup"><span data-stu-id="5452e-140">In the figure, when the user initiates an order, the OrderStarted domain event triggers creation of a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span> <span data-ttu-id="5452e-141">Başlangıçta oluşturulduğunda, etki alanı olay sırası toplama tarafından oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="5452e-141">The domain event is generated by the order aggregate when it is created in the first place.</span></span>

<span data-ttu-id="5452e-142">Alternatif olarak, toplama kök alt toplamlar (alt varlıklar) bir üyesi tarafından oluşturulan olaylara abone olabilir.</span><span class="sxs-lookup"><span data-stu-id="5452e-142">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="5452e-143">Örneğin, her Orderıtem alt varlık öğesi fiyat belirli bir miktar alt sınırından daha yüksek olduğunda veya ürün öğesi miktarı çok yüksek olduğunda bir olay yükseltebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5452e-143">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="5452e-144">Toplama kök bu olayları alma ve genel hesaplama veya toplama gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="5452e-144">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="5452e-145">Bu olay tabanlı iletişim doğrudan içinde toplamlar uygulanmadı anlaşılması önemlidir; etki alanı olay işleyicileri uygulanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5452e-145">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span> <span data-ttu-id="5452e-146">Etki alanı olaylarını işleme bir uygulamanın konusudur.</span><span class="sxs-lookup"><span data-stu-id="5452e-146">Handling the domain events is an application concern.</span></span> <span data-ttu-id="5452e-147">Etki alanı model katmanında yalnızca etki alanı mantığı üzerinde durmalısınız — bir etki alanı uzmanı öğrenmesi şey, işleyiciler ve depolarını kullanarak yan etkisi Kalıcılık eylemler gibi uygulama altyapıya değil.</span><span class="sxs-lookup"><span data-stu-id="5452e-147">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="5452e-148">Bu nedenle, uygulama katmanı düzeyinde, bir etki alanı olayı ortaya çıktığında eylemleri tetikleyen etki alanı olay işleyicileri burada olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-148">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="5452e-149">Etki alanı olayları herhangi bir sayıda uygulama eylemleri tetiklemek için de kullanılabilir ve daha önemli bir ayrılmış şekilde gelecekte bu sayıyı artırmak için açık olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-149">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="5452e-150">Örneği için sipariş başlatıldığında, bu bilgileri diğer toplamalara yayılması veya hatta bildirimleri gibi uygulama eylemleri yükseltmek için bir etki alanı olayı yayımlamak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5452e-150">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="5452e-151">Açık bir etki alanı olay meydana geldiğinde yürütülecek eylemlerin sayısını anahtar noktasıdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-151">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="5452e-152">Sonuç olarak, etki alanınızı ve uygulama kuralları ve eylemleri çıkarılır.</span><span class="sxs-lookup"><span data-stu-id="5452e-152">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="5452e-153">"Yapıştırıcı" ile kodunuzu bağlantısı varsa ancak bir şey olduğunda yan etkisi işlemlerinin sayısı ve karmaşıklığı, büyüyecektir (diğer bir deyişle, yalnızca yeni C anahtar sözcüğüyle nesneleri örnekleme\#), sonra da yeni bir eylem eklemek için gereken her zaman gerekecektir özgün koda değiştirin.</span><span class="sxs-lookup"><span data-stu-id="5452e-153">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, just instantiating objects with the new keyword in C\#), then every time you needed to add a new action you would need to change the original code.</span></span> <span data-ttu-id="5452e-154">Her yeni gereksinimi özgün kod akışını değiştirmeniz gerekir çünkü bu yeni hataları neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="5452e-154">This could result in new bugs, because with each new requirement you would need to change the original code flow.</span></span> <span data-ttu-id="5452e-155">Bu karşı gider [açık/kapalı İlkesi](https://en.wikipedia.org/wiki/Open/closed_principle) gelen [DÜZ](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span><span class="sxs-lookup"><span data-stu-id="5452e-155">This goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span></span> <span data-ttu-id="5452e-156">Karşı ase'nizden yalnızca, işlemleri işlemlerini özgün sınıf ve büyüme büyütün, not [tek sorumluluk İlkesi'ni (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span><span class="sxs-lookup"><span data-stu-id="5452e-156">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="5452e-157">Öte yandan, etki alanı olayları kullanırsanız, bu yaklaşımı kullanarak sorumlulukları ayrıştırarak ayrıntılı ve ayrılmış bir uygulama oluşturabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="5452e-157">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1.  <span data-ttu-id="5452e-158">(Örneğin, CreateOrder) komut gönderebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5452e-158">Send a command (for example, CreateOrder).</span></span>
2.  <span data-ttu-id="5452e-159">Komutu komut işleyici alır.</span><span class="sxs-lookup"><span data-stu-id="5452e-159">Receive the command in a command handler.</span></span>
    -   <span data-ttu-id="5452e-160">Tek bir toplamada ait işlem yürütün.</span><span class="sxs-lookup"><span data-stu-id="5452e-160">Execute a single aggregate’s transaction.</span></span>
    -   <span data-ttu-id="5452e-161">(İsteğe bağlı) Yan etkiler (örneğin, OrderStartedDomainEvent) için etki alanı olayları tetikleyebilir.</span><span class="sxs-lookup"><span data-stu-id="5452e-161">(Optional) Raise domain events for side effects (for example, OrderStartedDomainEvent).</span></span>
1.  <span data-ttu-id="5452e-162">Açık bir yan etkileri sayısı birden çok toplamalar veya uygulama eylemleri yürütülür (geçerli işlemdeki) etki alanı olayları işleyin.</span><span class="sxs-lookup"><span data-stu-id="5452e-162">Handle domain events (within the current process) that will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="5452e-163">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="5452e-163">For example:</span></span>
    -   <span data-ttu-id="5452e-164">Doğrulayın veya alıcı ve ödeme yöntemini oluşturun.</span><span class="sxs-lookup"><span data-stu-id="5452e-164">Verify or create buyer and payment method.</span></span>
    -   <span data-ttu-id="5452e-165">Oluşturup durumları alıcıya e-posta gönderme gibi mikro hizmetler veya tetikleyici dış eylemler arasında yaymak için olay veri yolu için ilgili tümleştirme olay gönderebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5452e-165">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
    -   <span data-ttu-id="5452e-166">Diğer yan etkileri işleyin.</span><span class="sxs-lookup"><span data-stu-id="5452e-166">Handle other side effects.</span></span>

<span data-ttu-id="5452e-167">Şekil 9-15'te gösterildiği gibi aynı etki alanı olayından başlayarak birden fazla eylem bağlama tümleştirme olayları ve olay veri yolu ile mikro hizmetler arasında gerçekleştirmeniz gereken ek uygulama eylemleri ve etki alanı içinde başka toplamalar ilgili işleyebilir.</span><span class="sxs-lookup"><span data-stu-id="5452e-167">As shown in Figure 9-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![](./media/image16.png)

<span data-ttu-id="5452e-168">**Şekil 9-15**.</span><span class="sxs-lookup"><span data-stu-id="5452e-168">**Figure 9-15**.</span></span> <span data-ttu-id="5452e-169">Etki alanı başına birden fazla eylem işleme</span><span class="sxs-lookup"><span data-stu-id="5452e-169">Handling multiple actions per domain</span></span>

<span data-ttu-id="5452e-170">Mikro hizmet'ın davranışını depoları veya bir uygulama API gibi altyapı nesnelerinden kullanacağınız için olay işleyicileri, genellikle uygulama katmanında cihazlardır.</span><span class="sxs-lookup"><span data-stu-id="5452e-170">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior.</span></span> <span data-ttu-id="5452e-171">Her ikisi de uygulama katmanının bir parçası olduğundan bu anlamda olay işleyicileri komut işleyicilerine benzer.</span><span class="sxs-lookup"><span data-stu-id="5452e-171">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="5452e-172">Bir komutu yalnızca bir kez işlenmesi gerektiğini önemli fark vardır.</span><span class="sxs-lookup"><span data-stu-id="5452e-172">The important difference is that a command should be processed just once.</span></span> <span data-ttu-id="5452e-173">Bir etki alanı olayı olabilir işlenen sıfır veya *n* zaman birden çok alıcılar veya farklı bir amaç için her işleyicisi ile olay işleyicileri tarafından alınabilir olduğundan.</span><span class="sxs-lookup"><span data-stu-id="5452e-173">A domain event could be processed zero or *n* times, because it can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="5452e-174">Olasılığını başına etki alanı olay işleyicileri açık bir dizi geçerli kodunuzu etkilemeden çok daha fazla etki alanı kuralları eklemenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="5452e-174">The possibility of an open number of handlers per domain event allows you to add many more domain rules without impacting your current code.</span></span> <span data-ttu-id="5452e-175">Örneğin, bir olaydan sonra sağ gerçekleştirilecek olan aşağıdaki iş kuralı uygulama birkaç olay işleyicileri (veya hatta yalnızca bir tane) eklemek kadar kolaydır olabilir:</span><span class="sxs-lookup"><span data-stu-id="5452e-175">For instance, implementing the following business rule that has to happen right after an event might be as easy as adding a few event handlers (or even just one):</span></span>

<span data-ttu-id="5452e-176">$6.000 deposundaki bir müşteriye göre siparişler, herhangi bir sayıda satın alınan toplam tutarı aşarsa, indirim % bir 10 her yeni sipariş için geçerlidir ve müşteri bu indirim tarihteki siparişlere hakkında bir e-posta ile bildir.</span><span class="sxs-lookup"><span data-stu-id="5452e-176">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implementing-domain-events"></a><span data-ttu-id="5452e-177">Uygulama etki alanı olayları</span><span class="sxs-lookup"><span data-stu-id="5452e-177">Implementing domain events</span></span>

<span data-ttu-id="5452e-178">C# içinde bir etki alanı olayı yalnızca bir veri bekletme yapısı sınıfına, aşağıdaki örnekte gösterildiği gibi yalnızca etki alanında ne için ilgili tüm bilgileri içeren bir DTO gibi mı:</span><span class="sxs-lookup"><span data-stu-id="5452e-178">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : INotification
{
    public string UserId { get; }
    public int CardTypeId { get; }
    public string CardNumber { get; }
    public string CardSecurityNumber { get; }
    public string CardHolderName { get; }
    public DateTime CardExpiration { get; }
    public Order Order { get; }

    public OrderStartedDomainEvent(Order order,
                                   int cardTypeId, string cardNumber,
                                   string cardSecurityNumber, string cardHolderName,
                                   DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="5452e-179">Aslında OrderStarted olayla ilişkili tüm verileri içeren bir sınıf budur.</span><span class="sxs-lookup"><span data-stu-id="5452e-179">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="5452e-180">Bir olay geçmişte gerçekleşen bir sorun olduğundan açısından bulunabilen dil etki alanının OrderStartedDomainEvent veya OrderShippedDomainEvent gibi bir geçmiş şimdiki fiili olarak olay sınıfı adını temsil edilmelidir.</span><span class="sxs-lookup"><span data-stu-id="5452e-180">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="5452e-181">Etki alanı olay sıralama mikro hizmetine nasıl uygulandığını olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-181">That is how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="5452e-182">Bir olay değil değiştirmelisiniz geçmişte gerçekleşen bir sorun olduğundan daha önce belirtildiği gibi bir önemli olayları, özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="5452e-182">As noted earlier, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="5452e-183">Bu nedenle sabit bir sınıf olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5452e-183">Therefore it must be an immutable class.</span></span> <span data-ttu-id="5452e-184">Önceki kodda dışında nesne salt okunur yerine özellikleri görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5452e-184">You can see in the previous code that the properties are read-only from outside of the object.</span></span> <span data-ttu-id="5452e-185">Olay nesnesi oluşturduğunuzda, nesneyi güncelleştirmek için yalnızca Oluşturucu üzerinden yoludur.</span><span class="sxs-lookup"><span data-stu-id="5452e-185">The only way to update the object is through the constructor when you create the event object.</span></span>

### <a name="raising-domain-events"></a><span data-ttu-id="5452e-186">Etki alanı olayları oluşturma</span><span class="sxs-lookup"><span data-stu-id="5452e-186">Raising domain events</span></span>

<span data-ttu-id="5452e-187">Sonraki soruya kendi ilgili olay işleyicileri ulaşacak şekilde bir etki alanı olayı Tetikle bağlanmasıdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-187">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="5452e-188">Birden çok yaklaşımın kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5452e-188">You can use multiple approaches.</span></span>

<span data-ttu-id="5452e-189">UDI Dahan Başlangıçta önerilen (örneğin, çeşitli gönderileri, gibi ilgili [etki alanı etkinlikleri alın 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) olaylar oluşturma ve yönetme için statik bir sınıf kullanarak.</span><span class="sxs-lookup"><span data-stu-id="5452e-189">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="5452e-190">Bu DomainEvents.Raise (Event myEvent) gibi bir söz dizimi kullanarak hemen çağrıldığında, etki alanı olayları oluşturacak DomainEvents adlı statik bir sınıf içerebilir.</span><span class="sxs-lookup"><span data-stu-id="5452e-190">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like DomainEvents.Raise(Event myEvent).</span></span> <span data-ttu-id="5452e-191">Jimmy Bogard yazdığı blog gönderisini ([etki alanınızı güçlendirme: etki alanı olayları](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) benzer bir yaklaşım önerir.</span><span class="sxs-lookup"><span data-stu-id="5452e-191">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="5452e-192">Etki alanı olayları sınıfı statik olduğunda, ancak bunu ayrıca işleyicilerini hemen gönderir.</span><span class="sxs-lookup"><span data-stu-id="5452e-192">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="5452e-193">Olay işleyicileri yan etkileri mantığı ile olay oluştuktan hemen sonra yürütülür çünkü bu test ve hata ayıklama daha zor hale getirir.</span><span class="sxs-lookup"><span data-stu-id="5452e-193">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="5452e-194">Test ve hata ayıklama odaklanır ve geçerli toplama sınıflarda neler olduğunu yalnızca istediğiniz; aniden yan etkileri diğer toplamalar veya uygulama mantığı ile ilgili diğer olay işleyicileri yeniden yönlendirilmesini istediğiniz değil.</span><span class="sxs-lookup"><span data-stu-id="5452e-194">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="5452e-195">Diğer yaklaşımlar gelişim göstermiştir nedeni, sonraki bölümde açıklandığı gibi budur.</span><span class="sxs-lookup"><span data-stu-id="5452e-195">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-for-raising-and-dispatching-events"></a><span data-ttu-id="5452e-196">Ertelenmiş bir yaklaşım oluşturma ve olayları gönderme</span><span class="sxs-lookup"><span data-stu-id="5452e-196">The deferred approach for raising and dispatching events</span></span>

<span data-ttu-id="5452e-197">Bir etki alanı olay işleyicisine hemen gönderme yerine etki alanı olayları bir koleksiyona eklemek için daha iyi bir yaklaşım olan ve bu etki alanı olayları gönderme *hemen önce* veya *doğru*  *sonra* (ile gibi SaveChanges EF içinde) işlemi yürütülüyor.</span><span class="sxs-lookup"><span data-stu-id="5452e-197">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="5452e-198">(Bu yaklaşım Jimmy Bogard tarafından bu gönderisinde açıklanan [daha iyi bir etki alanı olayları deseni](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span><span class="sxs-lookup"><span data-stu-id="5452e-198">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="5452e-199">Farklı işlemlerde veya aynı işlemin parçası olarak yan etkileri içerecektir olup olmadığını belirler. bu yana etki alanı olayları göndermek, karar sonra işlem Sistemi'ne sağ önce veya sağ önemlidir.</span><span class="sxs-lookup"><span data-stu-id="5452e-199">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="5452e-200">İkinci durumda, nihai tutarlılık arasında birden çok toplamalar işlem gerekir.</span><span class="sxs-lookup"><span data-stu-id="5452e-200">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="5452e-201">Bu konu, sonraki bölümde ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="5452e-201">This topic is discussed in the next section.</span></span>

<span data-ttu-id="5452e-202">Hangi hizmetine kullanan ertelenmiş yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-202">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="5452e-203">İlk olarak, bir koleksiyonunu veya varlık başına olayların listesi, varlıklarda geçekleşmiş olaylar ekleyin.</span><span class="sxs-lookup"><span data-stu-id="5452e-203">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="5452e-204">Bu liste, varlık temel sınıfın aşağıdaki örnekte gösterildiği gibi varlık nesnesinin bir parçası veya daha da iyi temel varlık sınıfınızın bir parçası olmalıdır:</span><span class="sxs-lookup"><span data-stu-id="5452e-204">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example of the Entity base class:</span></span>

```csharp
public abstract class Entity
{
     //... 
    private List<INotification> _domainEvents;
    public List<INotification> DomainEvents => _domainEvents;

    public void AddDomainEvent(INotification eventItem)
    {
        _domainEvents = _domainEvents ?? new List<INotification>();
        _domainEvents.Add(eventItem);
    }

    public void RemoveDomainEvent(INotification eventItem)
    {
        if (_domainEvents is null) return;
        _domainEvents.Remove(eventItem);
    }
    // ...
}
```

<span data-ttu-id="5452e-205">Bir olayı oluşturmak istediğinizde, bu olay toplaması için toplama kök varlığın herhangi bir yöntemi en koddan eklemeniz yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="5452e-205">When you want to raise an event, you just add it to the event collection from code at any method of the aggregate-root entity.</span></span>

<span data-ttu-id="5452e-206">Aşağıdaki kod, parçası [toplama kök hizmetine sipariş](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), bir örnek gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="5452e-206">The following code, part of the [Order aggregate-root at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), shows an example:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
                                                          cardTypeId, cardNumber,
                                                          cardSecurityNumber,
                                                          cardHolderName,
                                                          cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="5452e-207">AddDomainEvent yöntemi yapılması gereken tek şey listesine olay ekleme dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="5452e-207">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="5452e-208">Hiçbir olay henüz gönderilir ve hiçbir olay işleyicisi henüz çağrılır.</span><span class="sxs-lookup"><span data-stu-id="5452e-208">No event is dispatched yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="5452e-209">Aslında, işlem veritabanına yaparsanız olayları daha sonra gönderme istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="5452e-209">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="5452e-210">Entity Framework Core kullanıyorsanız, aşağıdaki kodda gösterildiği gibi EF DbContext SaveChanges yöntemi içinde anlamına gelir:</span><span class="sxs-lookup"><span data-stu-id="5452e-210">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.        
        await _mediator.DispatchDomainEventsAsync(this);

        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be committed
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="5452e-211">Bu kod ile ilgili olay işleyicilerini varlık olaylara gönderme.</span><span class="sxs-lookup"><span data-stu-id="5452e-211">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="5452e-212">Genel sonuç, (basit bir ekleme bellekte listeye) bir etki alanı olayı oluşturma, bir olay işleyicisi gönderme ayrılmış emin olur.</span><span class="sxs-lookup"><span data-stu-id="5452e-212">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="5452e-213">Ayrıca, ne tür bir dağıtıcı kullanmakta olduğunuz bağlı olarak, olayları zaman uyumlu veya zaman uyumsuz olarak gönderme.</span><span class="sxs-lookup"><span data-stu-id="5452e-213">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="5452e-214">İşlem sınırları içine önemli gelen buradan Oynat dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="5452e-214">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="5452e-215">Varsa, iş ve işlem birimi, birden fazla toplama kapsayabilir (olarak EF Core ve ilişkisel bir veritabanı kullanılırken), bu iyi çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="5452e-215">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="5452e-216">Ancak işlem toplamalar, Azure DocumentDB gibi NoSQL veritabanı kullanırken olduğu gibi dağıtılamaz, tutarlılık elde etmek için ek adımlar uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="5452e-216">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure DocumentDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="5452e-217">Neden Kalıcılık ignorance Evrensel değil başka bir nedeni budur; Bu, kullandığınız depolama sistemine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-217">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="5452e-218">Toplamlar ve nihai tutarlılık arasında toplamalar arasında tek bir işlem</span><span class="sxs-lookup"><span data-stu-id="5452e-218">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="5452e-219">Tek bir işlem üzerinde nihai tutarlılık arasında bu toplamalara bağlı olan ve toplamları arasında gerçekleştirilip soru tartışmalı bir bilgisayardır.</span><span class="sxs-lookup"><span data-stu-id="5452e-219">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="5452e-220">Eric Evans ve Vaughn Vernon kural, bir işlem Danışmanı gibi birçok DDD yazarları bir toplama = ve bu nedenle için nihai tutarlılık arasında toplamalar buna.</span><span class="sxs-lookup"><span data-stu-id="5452e-220">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="5452e-221">Örneğin, kendi kitaptaki *etki alanı Odaklı Tasarım*, Eric Evans belirten bu:</span><span class="sxs-lookup"><span data-stu-id="5452e-221">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

<span data-ttu-id="5452e-222">Toplamlar yayılan herhangi bir kural her zaman güncel olması beklenen değil.</span><span class="sxs-lookup"><span data-stu-id="5452e-222">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="5452e-223">Olay işleme, toplu işlem veya diğer güncelleştirme mekanizmaları, belirli bir süre içinde diğer bağımlılıkları çözülebilir.</span><span class="sxs-lookup"><span data-stu-id="5452e-223">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="5452e-224">(128 sayfa)</span><span class="sxs-lookup"><span data-stu-id="5452e-224">(page 128)</span></span>

<span data-ttu-id="5452e-225">Vaughn Vernon bildiren aşağıdaki [etkili toplama tasarımı. Kısım II: Yapma toplayan iş birlikte](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="5452e-225">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

<span data-ttu-id="5452e-226">Bu nedenle, bir toplama örneği gerektirir ek iş kuralları üzerinde bir veya daha fazla toplamalar yürütme komut yürütme, son tutarlılık kullanın \[...\] DDD modelinde nihai tutarlılığı destekleyecek şekilde pratik bir yolu yoktur.</span><span class="sxs-lookup"><span data-stu-id="5452e-226">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="5452e-227">Bir toplama yöntemi, bir veya daha fazla zaman uyumsuz abonelere teslim zaman içinde bir etki alanı olayı yayımlar.</span><span class="sxs-lookup"><span data-stu-id="5452e-227">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="5452e-228">Bu stratejinin birçok toplamalar veya varlıkları kapsayan işlemler yerine ayrıntılı işlemler benimsemenin üzerinde temel alır.</span><span class="sxs-lookup"><span data-stu-id="5452e-228">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="5452e-229">İkinci durumda, veritabanı kilit sayısı yüksek ölçeklenebilirlik gereksinimlerini ile büyük ölçekli uygulamalarda önemli olacağını olur.</span><span class="sxs-lookup"><span data-stu-id="5452e-229">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="5452e-230">Yüksek düzeyde ölçeklenebilir uygulamalar birden çok toplamları arasında anlık bir işlem tutarlılığı sahip olmaması gereken olgu benimsemenin kavramı, son tutarlılık kabul ile yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="5452e-230">Embracing the fact that high-scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="5452e-231">Atomik değişikliklerin iş için gerekli değildir ve herhangi bir durumda, belirli işlemler atomik işlemler olmadığını gerektiğini söylüyor için etki alanı uzmanları sorumluluğundadır.</span><span class="sxs-lookup"><span data-stu-id="5452e-231">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="5452e-232">Her zaman bir işlem birden çok toplamları arasında atomik bir işlem gerekiyorsa, toplama daha büyük olmalıdır veya doğru şekilde tasarlanmamış isteyebilir.</span><span class="sxs-lookup"><span data-stu-id="5452e-232">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="5452e-233">Diğer geliştiriciler ve mimarlara Jimmy Bogard gibi ancak birkaç toplamları arasında tek bir işlem yayma ile sorunsuz — ancak yalnızca zaman bu ek toplamalar yan etkileri aynı özgün komutu için ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="5452e-233">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="5452e-234">Örneğin, [daha iyi bir etki alanı olayları deseni](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard belirten bu:</span><span class="sxs-lookup"><span data-stu-id="5452e-234">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

<span data-ttu-id="5452e-235">Genellikle, aynı mantıksal işlem içinde ancak etki alanı olayı, aynı kapsamda gerçekleşmesi için bir etki alanı olayı yan etkilerini istiyorum \[...\] Sadece biz bizim işlem göndermeden önce size sunduğumuz ilgili işleyicilerini olaylara gönderme.</span><span class="sxs-lookup"><span data-stu-id="5452e-235">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="5452e-236">Etki alanı olayları sağ gönderme, *önce* aynı işlemde dahil edilecek olayların yan etkileri istediğiniz özgün işlemlerinin, olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-236">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="5452e-237">EF DbContext SaveChanges yöntem başarısız olursa, örneğin, işlem sonucu ilgili etki alanı olay işleyicileri tarafından uygulanan herhangi bir yan etkisi işlemi dahil olmak üzere tüm değişiklikleri geri döner.</span><span class="sxs-lookup"><span data-stu-id="5452e-237">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="5452e-238">DbContext ömrü kapsam olarak tanımlanan varsayılan olduğundan bu "kapsamlıdır."</span><span class="sxs-lookup"><span data-stu-id="5452e-238">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="5452e-239">Bu nedenle, DbContext nesnesini örneği oluşturulan nesne grafiği ve aynı kapsam içinde birden çok depo nesneleri arasında paylaşılır.</span><span class="sxs-lookup"><span data-stu-id="5452e-239">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="5452e-240">Bu, Web API'si ve MVC uygulamaları geliştirirken HttpRequest kapsamı ile örtüşür.</span><span class="sxs-lookup"><span data-stu-id="5452e-240">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="5452e-241">Gerçekte (tek bir atomik işlem ve nihai tutarlılık) her iki yaklaşım uygun olabilir.</span><span class="sxs-lookup"><span data-stu-id="5452e-241">In reality, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="5452e-242">Ayrıca, etki alanı veya iş gereksinimlerinize ve etki alanı uzmanları, ne yapacağımı gerçekten bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-242">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="5452e-243">Ayrıca nasıl ölçeklenebilir hizmeti yapmanız gereken bağlıdır (daha ayrıntılı işlemler sahip veritabanı kilitlerini göre daha az etkileyebilir).</span><span class="sxs-lookup"><span data-stu-id="5452e-243">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="5452e-244">Ve bunu ne kadar yatırım, nihai tutarlılık, olası tutarsızlıklar toplamalara ve telafi izin eylemlerini uygulamak için gereken arasında saptamak amacıyla daha karmaşık kod gerektirdiğinden, kodunuzda olun iradeye sahip olduğunuza bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-244">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="5452e-245">Özgün toplama ve olayların ne zaman gönderilen için daha sonra değişiklikleri, bir sorun olduğunun dikkate alın ve olay işleyicileri yan etkileri tamamlanamaz, tutarsızlıklar toplamalara arasında olacaktır.</span><span class="sxs-lookup"><span data-stu-id="5452e-245">Take into account that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="5452e-246">Özgün işlemin bir parçası olmaları için etki alanı olayları ek veritabanı tablolarında depolama telafi izin eylemleri izin vermenin bir yolu olabilir.</span><span class="sxs-lookup"><span data-stu-id="5452e-246">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="5452e-247">Daha sonra tutarsızlıklarını algılayan ve olayların geçerli durumdaki bir toplama listesini karşılaştırarak telafi izin eylemleri çalıştıran bir toplu işlem olabilir.</span><span class="sxs-lookup"><span data-stu-id="5452e-247">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="5452e-248">Telafi izin eylemleri ayrıntılı analiz iş kullanıcısı ve etki alanı uzmanları ile görüştükten içerir, taraftan gerektiren karmaşık bir konu bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-248">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="5452e-249">Herhangi bir durumda, gereksinim duyduğunuz yaklaşımı seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5452e-249">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="5452e-250">Ancak ilk yaklaşım ertelenmiş — tek bir işlem kullanmak için olayları kaydetmeden önce oluşturma — en basit EF Core ve ilişkisel bir veritabanı kullanılırken yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-250">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="5452e-251">Bu uygulama daha kolay ve birçok iş durumlarda geçerli olur.</span><span class="sxs-lookup"><span data-stu-id="5452e-251">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="5452e-252">Ayrıca sıralama mikro hizmetine kullanılan yaklaşım değildir.</span><span class="sxs-lookup"><span data-stu-id="5452e-252">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="5452e-253">Ancak nasıl aslında bu olaylarla ilgili olay işleyicilerini gönderme?</span><span class="sxs-lookup"><span data-stu-id="5452e-253">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="5452e-254">Nedir \_önceki örnekte gördüğünüz Dünyası nesne?</span><span class="sxs-lookup"><span data-stu-id="5452e-254">What is the \_mediator object that you see in the previous example?</span></span> <span data-ttu-id="5452e-255">Olayları ve olay işleyicilerini arasında eşleme için kullanmanız yapıtlar ve teknikleri ile yapmak, sahip.</span><span class="sxs-lookup"><span data-stu-id="5452e-255">That has to do with the techniques and artifacts you can use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="5452e-256">Etki alanı olay dağıtıcısı rolü: olayları için olay işleyicileri eşleme</span><span class="sxs-lookup"><span data-stu-id="5452e-256">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="5452e-257">Gönderme veya olayları yayımlayabilirsiniz, böylece her ilgili işleyici alın ve bu olayı temel alan yan etkileri işlem bu olayı yayımlar yapıt tür gerekir.</span><span class="sxs-lookup"><span data-stu-id="5452e-257">Once you're able to dispatch or publish the events, you need some kind of artifact that will publish the event, so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="5452e-258">Bir gerçek bir Mesajlaşma sistemi veya muhtemelen bellek içi olayları aksine service bus temel bile bir olay veri yolu, bunun bir yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="5452e-258">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="5452e-259">Ancak, ilk örneği için gerçek Mesajlaşma aynı işlem içinde bu cihazdaki olayları işlemeye olması gerektiğinden, etki alanı olaylarını işlemek için düşünülecek olacaktır (diğer bir deyişle, aynı etki alanınızı ve uygulama katmanı içinde).</span><span class="sxs-lookup"><span data-stu-id="5452e-259">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="5452e-260">Birden çok olay işleyicilerine olayları eşleştirmek için başka bir yol olayları gönderme nerede dinamik olarak çıkarabilir, bir IOC kapsayıcısındaki türleri kayıt kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="5452e-260">Another way to map events to multiple event handlers is by using types registration in an IoC container so that you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="5452e-261">Diğer bir deyişle, belirli bir olay almak olay işleyicileri gerekenler bilmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="5452e-261">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="5452e-262">Şekil 9-16 için basitleştirilmiş bir yaklaşım gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="5452e-262">Figure 9-16 shows a simplified approach for that.</span></span>

![](./media/image17.png)

<span data-ttu-id="5452e-263">**Şekil 9-16**.</span><span class="sxs-lookup"><span data-stu-id="5452e-263">**Figure 9-16**.</span></span> <span data-ttu-id="5452e-264">Etki alanı olay dağıtıcısı rolü IOC kullanma</span><span class="sxs-lookup"><span data-stu-id="5452e-264">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="5452e-265">Teknik işlemleri ve yapıtları kendiniz bu yaklaşımı uygulamak için oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5452e-265">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="5452e-266">Ancak, ayrıca gibi kullanılabilir kitaplıkları kullanabilirsiniz [MediatR](https://github.com/jbogard/MediatR), IOC kapsayıcınızı, aslında kullanır.</span><span class="sxs-lookup"><span data-stu-id="5452e-266">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR), which underneath the covers uses your IoC container.</span></span> <span data-ttu-id="5452e-267">Bu nedenle doğrudan önceden tanımlanmış arabirimler ve Dünyası nesnenin yayımlama/dağıtma yöntemleri kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5452e-267">You can therefore directly use the predefined interfaces and the mediator object’s publish/dispatch methods.</span></span>

<span data-ttu-id="5452e-268">Kod içinde ilk olay işleyici türlerini IOC kapsayıcınızı kaydetmek aşağıdaki örnekte gösterildiği gibi ihtiyacınız [hizmetine sıralama mikro hizmet](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span><span class="sxs-lookup"><span data-stu-id="5452e-268">In code, you first need to register the event handler types in your IoC container, as shown in the following example at [eShopOnContainers Ordering microservice](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement IAsyncNotificationHandler<>)
        // in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
                                       .GetTypeInfo().Assembly)
                                         .AsClosedTypesOf(typeof(IAsyncNotificationHandler<>));
        // Other registrations ...
    }
}
```

<span data-ttu-id="5452e-269">Kod ilk etki alanı olay işleyicileri işleyicilerin tutan derleme bularak içeren derlemeyi tanımlar (typeof(ValidateOrAddBuyerAggregateWhenXxxx), ancak kullanarak seçebilirdiniz diğer tüm olay işleyicisi derlemeyi bulmak için).</span><span class="sxs-lookup"><span data-stu-id="5452e-269">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="5452e-270">Tüm olay işleyicilerine IAsyncNotificationHandler arabirimini uygulama olduğundan, kod ardından yalnızca bu arar türleri ve tüm olay işleyicilerine kaydeder.</span><span class="sxs-lookup"><span data-stu-id="5452e-270">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="5452e-271">Etki alanı olaylarına abone olma</span><span class="sxs-lookup"><span data-stu-id="5452e-271">How to subscribe to domain events</span></span>

<span data-ttu-id="5452e-272">MediatR kullandığınızda, aşağıdaki kodda gördüğünüz gibi her bir olay işleyicisi INotificationHandler arabirimin genel parametresinde sağlanan bir olay türü kullanmanız gerekir:</span><span class="sxs-lookup"><span data-stu-id="5452e-272">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the INotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="5452e-273">Olay aboneliği kabul edilebilir, olay işleyicisi, arasındaki ilişkiye bağlı MediatR yapıt, tüm olay işleyicilerine her olay için keşfetmek ve her biri bu olay işleyicileri tetikleyin.</span><span class="sxs-lookup"><span data-stu-id="5452e-273">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="5452e-274">Etki alanı olaylarını işlemek nasıl</span><span class="sxs-lookup"><span data-stu-id="5452e-274">How to handle domain events</span></span>

<span data-ttu-id="5452e-275">Son olarak, olay işleyicisi genellikle yan etkisi etki alanı mantığı yürütmek için gerekli ek toplamları elde etmek için altyapı depoları kullanan uygulama katmanı kodu uygular.</span><span class="sxs-lookup"><span data-stu-id="5452e-275">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="5452e-276">Aşağıdaki [hizmetine etki alanı olay işleyici kodu](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), bir uygulama örneği gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="5452e-276">The following [domain event handler code at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), shows an implementation example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
                   : INotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;

    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // ...Parameter validations...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ? orderStartedEvent.CardTypeId : 1;        
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;

        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }

        buyer.VerifyOrAddPaymentMethod(cardTypeId,
                                       $"Payment Method on {DateTime.UtcNow}",
                                       orderStartedEvent.CardNumber,
                                       orderStartedEvent.CardSecurityNumber,
                                       orderStartedEvent.CardHolderName,
                                       orderStartedEvent.CardExpiration,
                                       orderStartedEvent.Order.Id);

        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer) 
                                                                      : _buyerRepository.Add(buyer);

        await _buyerRepository.UnitOfWork
                .SaveEntitiesAsync();

        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="5452e-277">Altyapı depoları kullandığından önceki etki alanı olay işleyici kodunu uygulama katmanı kod üzerinde altyapı Kalıcılık katmanını sonraki bölümde açıklandığı gibi değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="5452e-277">The previous domain event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="5452e-278">Olay işleyicileri, diğer altyapı bileşenlerini de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5452e-278">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="5452e-279">Etki alanı olayları mikro hizmet sınırları dışına yayımlanacak tümleştirme olayları oluşturmak</span><span class="sxs-lookup"><span data-stu-id="5452e-279">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="5452e-280">Son olarak, bazı durumlarda olayları birden çok mikro hizmetler yaymak isteyebileceğiniz, bahsetmek önemlidir.</span><span class="sxs-lookup"><span data-stu-id="5452e-280">Finally, it is important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="5452e-281">Bir tümleştirme olay kabul edilir ve hiçbir özel etki alanı olay işleyicisinden bir olay veri yolu üzerinden yayınlanabilir.</span><span class="sxs-lookup"><span data-stu-id="5452e-281">That is considered an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="5452e-282">Etki alanı olayları sonuçları</span><span class="sxs-lookup"><span data-stu-id="5452e-282">Conclusions on domain events</span></span>

<span data-ttu-id="5452e-283">Belirtildiği gibi açıkça yan etkilerini, etki alanınızda değişiklikleri uygulamak için etki alanı olaylarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="5452e-283">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="5452e-284">DDD terminolojisi kullanmak için açıkça bir veya birden çok toplamları arasında yan etkileri uygulamak için etki alanı olayları kullanın.</span><span class="sxs-lookup"><span data-stu-id="5452e-284">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="5452e-285">Ayrıca, daha iyi ölçeklendirilebilirlik için ve veritabanı kilitlerini etkisini daha az nihai tutarlılık arasında aynı etki alanı içinde toplamlar kullanın.</span><span class="sxs-lookup"><span data-stu-id="5452e-285">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="5452e-286">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="5452e-286">Additional resources</span></span>

-   <span data-ttu-id="5452e-287">**Greg Young. Bir etki alanı olayı nedir?**
    [*http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span><span class="sxs-lookup"><span data-stu-id="5452e-287">**Greg Young. What is a Domain Event?**
[*http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span></span>

-   <span data-ttu-id="5452e-288">**Jan Stenberg. Etki alanı olayları ve nihai tutarlılık**
    [*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span><span class="sxs-lookup"><span data-stu-id="5452e-288">**Jan Stenberg. Domain Events and Eventual Consistency**
[*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span></span>

-   <span data-ttu-id="5452e-289">**Jimmy Bogard. Daha iyi bir etki alanı olay deseni**
    [*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span><span class="sxs-lookup"><span data-stu-id="5452e-289">**Jimmy Bogard. A better domain events pattern**
[*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span></span>

-   <span data-ttu-id="5452e-290">**Vaughn Vernon. Etkili toplama tasarımı Bölüm II: Birlikte yapma toplamalar çalışma**
    [*http://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf*](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span><span class="sxs-lookup"><span data-stu-id="5452e-290">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together**
[*http://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf*](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span></span>

-   <span data-ttu-id="5452e-291">**Jimmy Bogard. Etki alanınızı güçlendirme: etki alanı olayları**
    *<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/> *</span><span class="sxs-lookup"><span data-stu-id="5452e-291">**Jimmy Bogard. Strengthening your domain: Domain Events**
*<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/> *</span></span>

-   <span data-ttu-id="5452e-292">**Tony Truong. Etki alanı olayları desen örneği**
    [*https://www.tonytruong.net/domain-events-pattern-example/*](https://www.tonytruong.net/domain-events-pattern-example/)</span><span class="sxs-lookup"><span data-stu-id="5452e-292">**Tony Truong. Domain Events Pattern Example**
[*https://www.tonytruong.net/domain-events-pattern-example/*](https://www.tonytruong.net/domain-events-pattern-example/)</span></span>

-   <span data-ttu-id="5452e-293">**UDI Dahan. Etki alanı modellerini oluşturma tam olarak kapsüllenmiş**
    [*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span><span class="sxs-lookup"><span data-stu-id="5452e-293">**Udi Dahan. How to create fully encapsulated Domain Models**
[*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span></span>

-   <span data-ttu-id="5452e-294">**UDI Dahan. Etki alanı etkinlikleri alın 2**
    [*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span><span class="sxs-lookup"><span data-stu-id="5452e-294">**Udi Dahan. Domain Events – Take 2**
[*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span></span>

-   <span data-ttu-id="5452e-295">**UDI Dahan. Etki alanı etkinlikleri Salvation**
    [*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span><span class="sxs-lookup"><span data-stu-id="5452e-295">**Udi Dahan. Domain Events – Salvation**
[*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span></span>

-   <span data-ttu-id="5452e-296">**Jan Kronquist. Yoksa, etki alanı olayları yayımlama, döndürülmeleri!**
    [*https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span><span class="sxs-lookup"><span data-stu-id="5452e-296">**Jan Kronquist. Don't publish Domain Events, return them!**
[*https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span></span>

-   <span data-ttu-id="5452e-297">**Cesar de la Torre. Etki alanı olayları vs. DDD ve mikro hizmet mimarileri tümleştirme olayları**
    [*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span><span class="sxs-lookup"><span data-stu-id="5452e-297">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures**
[*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="5452e-298">[Önceki](client-side-validation.md)
[İleri](infrastructure-persistence-layer-design.md)</span><span class="sxs-lookup"><span data-stu-id="5452e-298">[Previous](client-side-validation.md)
[Next](infrastructure-persistence-layer-design.md)</span></span>

---
title: "Kısmi hata işleme stratejileri"
description: "Kapsayıcılı .NET uygulamaları için .NET mikro mimarisi | Kısmi hata işleme stratejileri"
keywords: Docker, Microservices, ASP.NET, Container
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: baeeb47dde77ceaa461214f55482d2312d67ccec
ms.sourcegitcommit: c0dd436f6f8f44dc80dc43b07f6841a00b74b23f
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/19/2018
---
# <a name="strategies-for-handling-partial-failure"></a><span data-ttu-id="9b881-104">Kısmi hata işleme stratejileri</span><span class="sxs-lookup"><span data-stu-id="9b881-104">Strategies for handling partial failure</span></span>

<span data-ttu-id="9b881-105">Kısmi hatalar postalarla stratejileri arasında şunlar yer alır.</span><span class="sxs-lookup"><span data-stu-id="9b881-105">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="9b881-106">**Zaman uyumsuz iletişim (örneğin, ileti tabanlı iletişim) iç mikro kullanmak**.</span><span class="sxs-lookup"><span data-stu-id="9b881-106">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="9b881-107">Bu yanlış tasarımı sonunda hatalı kesintileri ana neden olacak çünkü uzun zincirleri zaman uyumlu HTTP çağrıları arasında iç mikro oluşturun değil yüksek oranda önerilir.</span><span class="sxs-lookup"><span data-stu-id="9b881-107">It is highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="9b881-108">Tersine, istemci uygulamaları mikro veya hassas API ağ geçitleri ilk düzeyi arasında ön uç iletişim dışında yalnızca zaman uyumsuz (ileti tabanlı) iletişim ilk istek geçmiş kez kullanmak için önerilir / İç mikro arasında yanıt döngüsü.</span><span class="sxs-lookup"><span data-stu-id="9b881-108">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it is recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="9b881-109">Nihai tutarlılık ve olay denetimli mimarileri ripple etkileri en aza indirmek için yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="9b881-109">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="9b881-110">Bu yaklaşım mikro hizmet otonomisi daha yüksek düzeyde zorlamak ve bu nedenle burada bahsedilen sorun karşı engelleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9b881-110">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="9b881-111">**Yeniden deneme üstel geri alma ile kullanmak**.</span><span class="sxs-lookup"><span data-stu-id="9b881-111">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="9b881-112">Bu teknik kısa önlenmesine yardımcı olur ve çağrı yaparak aralıklı hatalar yeniden deneme zaman, belirli bir sayıda hizmet yalnızca kısa bir süre için kullanılamadığı durumda.</span><span class="sxs-lookup"><span data-stu-id="9b881-112">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="9b881-113">Bu, zaman zaman ortaya çıkan ağ sorunları nedeniyle veya mikro hizmet/kapsayıcı farklı bir düğüme bir küme içinde taşındığında ortaya çıkabilir.</span><span class="sxs-lookup"><span data-stu-id="9b881-113">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="9b881-114">Bu deneme hattı ayırıcıları ile düzgün şekilde tasarlanmamıştır, ancak bunu ripple etkilerini aggravate sonuçta bile neden olan bir [hizmet reddi (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span><span class="sxs-lookup"><span data-stu-id="9b881-114">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="9b881-115">**Ağ zaman aşımı geçici**.</span><span class="sxs-lookup"><span data-stu-id="9b881-115">**Work around network timeouts**.</span></span> <span data-ttu-id="9b881-116">Genel olarak, istemciler süresiz olarak engellemeyi değil ve her zaman için bir yanıt beklenirken zaman aşımı kullanmak üzere tasarlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="9b881-116">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="9b881-117">Zaman aşımları kullanarak kaynakları hiçbir zaman süresiz olarak bağlıdır olduğunu sağlar.</span><span class="sxs-lookup"><span data-stu-id="9b881-117">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="9b881-118">**Devre kesici desenini kullanan**.</span><span class="sxs-lookup"><span data-stu-id="9b881-118">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="9b881-119">Bu yaklaşımda, istemci işleminin başarısız isteklerin sayısını izler.</span><span class="sxs-lookup"><span data-stu-id="9b881-119">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="9b881-120">Böylece hemen başka denemeleri başarısız hata oranı "devre kesici" dönüşleri yapılandırılmış bir sınır aşarsa.</span><span class="sxs-lookup"><span data-stu-id="9b881-120">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="9b881-121">(Çok sayıda isteği başarısız oluyorsa, hizmet kullanılamıyor ve istekleri gönderirken bir durum olduğunu önerir.) Zaman aşımı süresinden sonra istemci yeniden deneyin ve, yeni istekleri başarılı olup olmadığını devre kesici kapatın.</span><span class="sxs-lookup"><span data-stu-id="9b881-121">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="9b881-122">**Geri dönüşler sağlamak**.</span><span class="sxs-lookup"><span data-stu-id="9b881-122">**Provide fallbacks**.</span></span> <span data-ttu-id="9b881-123">Önbelleğe alınan veriler veya varsayılan değeri döndüren gibi bir isteği başarısız olduğunda bu yaklaşım, geri dönüş mantığı istemci işlemini gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="9b881-123">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="9b881-124">Bu sorguları için uygun bir yaklaşım ve güncelleştirmeleri veya komutları için daha karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="9b881-124">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="9b881-125">**Sıraya alınan istek sayısı sınırı**.</span><span class="sxs-lookup"><span data-stu-id="9b881-125">**Limit the number of queued requests**.</span></span> <span data-ttu-id="9b881-126">İstemciler ayrıca bir istemci mikro hizmet belirli bir hizmet gönderebilirsiniz bekleyen istek sayısı üst sınırı zorunlu tuttukları.</span><span class="sxs-lookup"><span data-stu-id="9b881-126">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="9b881-127">Sınıra ulaştıysanız ek istekler yapmasını büyük olasılıkla bir durum ve bu girişimler hemen başarısız olması.</span><span class="sxs-lookup"><span data-stu-id="9b881-127">If the limit has been reached, it is probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="9b881-128">Uygulama, Polly açısından [Bulkhead yalıtım](https://github.com/App-vNext/Polly/wiki/Bulkhead) İlkesi, bu gereksinimi karşılamak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="9b881-128">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfil this requirement.</span></span> <span data-ttu-id="9b881-129">Bu yaklaşım temelde paralelleştirme azaltma ile olan [SemaphoreSlim](https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-1.1) uygulaması olarak.</span><span class="sxs-lookup"><span data-stu-id="9b881-129">This approach is essentially a parallelization throttle with [SemaphoreSlim](https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-1.1) as the implementation.</span></span> <span data-ttu-id="9b881-130">Ayrıca, bulkhead dışında bir "sıra" verir.</span><span class="sxs-lookup"><span data-stu-id="9b881-130">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="9b881-131">(Örneğin, kapasite tam kabul edilir çünkü) yürütmeden önce bile aşırı yük proaktif olarak shed.</span><span class="sxs-lookup"><span data-stu-id="9b881-131">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="9b881-132">Bu yanıt belirli hata senaryoları için devre kesici hataları için bekleyeceği beri devre kesici olması durumuna göre hızlandırır.</span><span class="sxs-lookup"><span data-stu-id="9b881-132">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="9b881-133">Polly BulkheadPolicy nesnesinde nasıl tam bulkhead gösterir ve sıra olan ve taşma teklifleri olaylarına bu nedenle de Otomatik yatay ölçekleme sürücü için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="9b881-133">The BulkheadPolicy object in Polly exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="9b881-134">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="9b881-134">Additional resources</span></span>

-   <span data-ttu-id="9b881-135">**Dayanıklılık desenleri**
    [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span><span class="sxs-lookup"><span data-stu-id="9b881-135">**Resiliency patterns**
[*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span></span>

-   <span data-ttu-id="9b881-136">**Esnekliği ekleme ve performansı en iyi duruma getirme**
    [*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span><span class="sxs-lookup"><span data-stu-id="9b881-136">**Adding Resilience and Optimizing Performance**
[*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span></span>

-   <span data-ttu-id="9b881-137">**Bulkhead.**</span><span class="sxs-lookup"><span data-stu-id="9b881-137">**Bulkhead.**</span></span> <span data-ttu-id="9b881-138">GitHub depo.</span><span class="sxs-lookup"><span data-stu-id="9b881-138">GitHub repo.</span></span> <span data-ttu-id="9b881-139">Uygulama Polly ilkesiyle. \\</span><span class="sxs-lookup"><span data-stu-id="9b881-139">Implementation with Polly policy.\\</span></span>
    [<span data-ttu-id="9b881-140">*https://github.com/App-vNext/Polly/wiki/Bulkhead*</span><span class="sxs-lookup"><span data-stu-id="9b881-140">*https://github.com/App-vNext/Polly/wiki/Bulkhead*</span></span>](https://github.com/App-vNext/Polly/wiki/Bulkhead)

-   <span data-ttu-id="9b881-141">**Azure için esnek uygulamalar tasarlama**
    [*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span><span class="sxs-lookup"><span data-stu-id="9b881-141">**Designing resilient applications for Azure**
[*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span></span>

-   <span data-ttu-id="9b881-142">**Geçici hata işleme**
    <https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span><span class="sxs-lookup"><span data-stu-id="9b881-142">**Transient fault handling**
<https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span></span>


>[!div class="step-by-step"]
<span data-ttu-id="9b881-143">[Önceki] (tanıtıcı-kısmi-failure.md) [sonraki] (uygulama-yeniden deneme-üstel-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="9b881-143">[Previous] (handle-partial-failure.md) [Next] (implement-retries-exponential-backoff.md)</span></span>

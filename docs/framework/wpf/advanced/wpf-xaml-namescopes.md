---
title: "WPF XAML Ad Kapsamları"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
caps.latest.revision: "19"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: c4caaa9453cb3cec76a8606afb5601919eba607a
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 12/22/2017
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="08a67-102">WPF XAML Ad Kapsamları</span><span class="sxs-lookup"><span data-stu-id="08a67-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="08a67-103">XAML ad kapsamları tanımlayan bir kavram XAML içinde tanımlanan nesneler var.</span><span class="sxs-lookup"><span data-stu-id="08a67-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="08a67-104">XAML isim alanı adları, bir nesne ağacında nesneleri XAML tanımlanan adlarını ve örnek eşdeğerlerine arasındaki ilişkileri oluşturmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="08a67-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="08a67-105">Genellikle, XAML ad kapsamları içinde [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] yönetilen kod XAML uygulama için ayrı ayrı XAML sayfası yükleniyor kökleri olduğunda oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="08a67-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="08a67-106">XAML ad kapsamları programlama nesnesi olarak tarafından tanımlanan <xref:System.Windows.Markup.INameScope> arabirim ve ayrıca pratik sınıfı tarafından uygulanan <xref:System.Windows.NameScope>.</span><span class="sxs-lookup"><span data-stu-id="08a67-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  
  
  
  
<a name="Namescopes_in_Loaded_XAML_Applications"></a>   
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="08a67-107">Yüklenen XAML uygulamaları içindeki ad kapsamları</span><span class="sxs-lookup"><span data-stu-id="08a67-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="08a67-108">Daha geniş programlama veya bilgisayar bilimi bağlamı programlama kavramları, genellikle benzersiz bir kimlik veya bir nesneye erişmek için kullanılan ad ilkesini içerir.</span><span class="sxs-lookup"><span data-stu-id="08a67-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="08a67-109">Tanımlayıcıları veya adlarını kullanan sistemleri için sınırlar içinde isim alanı tanımlayan bir nesne adının isteniyorsa hangi işlemin veya teknik arama veya adları tanımlamanın benzersizlik; burada görüntülerle zorlanır sınırlar.</span><span class="sxs-lookup"><span data-stu-id="08a67-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="08a67-110">Bu ilkeler için XAML ad kapsamları true.</span><span class="sxs-lookup"><span data-stu-id="08a67-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="08a67-111">Sayfa yüklendiğinde, WPF XAML ad kapsamları XAML sayfası için kök öğesi oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="08a67-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="08a67-112">Sayfa kökte başlayan XAML sayfası içinde belirtilen her ad için ilgili bir XAML isim alanı eklenir.</span><span class="sxs-lookup"><span data-stu-id="08a67-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="08a67-113">WPF XAML, sık kullanılan kök öğe olan öğeler içinde (gibi <xref:System.Windows.Controls.Page>, ve <xref:System.Windows.Window>) her zaman bir XAML isim alanı denetim.</span><span class="sxs-lookup"><span data-stu-id="08a67-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="08a67-114">Bir öğe gibi <xref:System.Windows.FrameworkElement> veya <xref:System.Windows.FrameworkContentElement> sayfanın biçimlendirmede, kök öğe bir [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] işlemcisi ekler bir <xref:System.Windows.Controls.Page> örtük olarak kök böylece <xref:System.Windows.Controls.Page> çalışma XAML isim alanı sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="08a67-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08a67-115">WPF yapı eylemleri XAML isim alanı XAML üretim için yoksa bile oluşturmak `Name` veya `x:Name` öznitelikleri herhangi bir öğe üzerinde tanımlanan [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] biçimlendirme.</span><span class="sxs-lookup"><span data-stu-id="08a67-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="08a67-116">Aynı adı iki kez herhangi XAML isim alanı içinde kullanmaya çalışırsa, bir özel durum oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="08a67-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="08a67-117">WPF arka plan kod ve derlenmiş bir uygulamanın parçası olan XAML için özel durum derleme zamanında WPF yapı eylemleri tarafından oluşturulan sınıf sayfası için ilk biçimlendirmesi derleme sırasında oluştururken oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="08a67-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="08a67-118">XAML yüklendiğinde bir yapı eylemi tarafından biçimlendirme derlenmiş değil XAML için XAML isim alanı sorunlarıyla ilgili özel durumlar ortaya.</span><span class="sxs-lookup"><span data-stu-id="08a67-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="08a67-119">XAML tasarımcıları tasarım zamanında XAML isim alanı sorunları tahmin.</span><span class="sxs-lookup"><span data-stu-id="08a67-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="08a67-120">Çalışma zamanı nesne ağaçları nesneler ekleme</span><span class="sxs-lookup"><span data-stu-id="08a67-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="08a67-121">XAML ayrıştırılır şu anda bir WPF XAML isim alanı oluşturulup tanımlı zaman birazdan temsil eder.</span><span class="sxs-lookup"><span data-stu-id="08a67-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="08a67-122">Bir nesne bir nesne ağacına bir noktada ağacı üretilen XAML ayrıştırıldığında sonra zamanında eklerseniz bir `Name` veya `x:Name` yeni bir nesne değeri XAML isim alanı bilgileri otomatik olarak güncelleştirilmez.</span><span class="sxs-lookup"><span data-stu-id="08a67-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="08a67-123">XAML yüklendikten sonra bir WPF XAML isim alanı bir nesne için bir ad eklemek için uygun uygulanması çağrı <xref:System.Windows.Markup.INameScope.RegisterName%2A> XAML isim alanı tanımlar nesnede olduğu genellikle XAML sayfası kök.</span><span class="sxs-lookup"><span data-stu-id="08a67-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="08a67-124">Adı kayıtlı değilse, eklenen nesne adına göre yöntemlerle gibi başvurulamaz <xref:System.Windows.FrameworkElement.FindName%2A>, ve animasyon hedefleme için bu adı kullanamazsınız.</span><span class="sxs-lookup"><span data-stu-id="08a67-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="08a67-125">Uygulama geliştiricilerinin en yaygın bir senaryo, kullanmasıdır <xref:System.Windows.FrameworkElement.RegisterName%2A> sayfasının geçerli kökündeki XAML isim alanı içine adlarını kaydetmek için.</span><span class="sxs-lookup"><span data-stu-id="08a67-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="08a67-126"><xref:System.Windows.FrameworkElement.RegisterName%2A>Bu hedef nesneler için animasyonları film şeritleri için önemli bir senaryo parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="08a67-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="08a67-127">Daha fazla bilgi için bkz: [film şeritleri genel bakış](../../../../docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="08a67-127">For more information, see [Storyboards Overview](../../../../docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="08a67-128">Çağırırsanız <xref:System.Windows.FrameworkElement.RegisterName%2A> çağrısı yaptığını sanki XAML isim alanı tanımlayan nesnesi başka bir nesnede adı hala çağıran nesne içinde tutulur XAML isim alanı için kayıtlı <xref:System.Windows.FrameworkElement.RegisterName%2A> nesnesi tanımlayarak XAML isim alanı üzerinde.</span><span class="sxs-lookup"><span data-stu-id="08a67-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="08a67-129">XAML ad kapsamları kodu</span><span class="sxs-lookup"><span data-stu-id="08a67-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="08a67-130">Oluşturun ve ardından kodda XAML ad kapsamları kullanın.</span><span class="sxs-lookup"><span data-stu-id="08a67-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="08a67-131">API'ler ve kavramları XAML isim alanı oluşturmada yer alan bir saf kod kullanımı için bile aynı olduğu için XAML İşlemci [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML kendisini işlerken bu API'ları ve kavramları kullanır.</span><span class="sxs-lookup"><span data-stu-id="08a67-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="08a67-132">Kavramlar ve API çoğunlukla genellikle XAML'de kısmen veya tamamen tanımlanan bir nesne ağacına içinde ada göre nesneleri bulmak bölümlemeye amacıyla mevcut.</span><span class="sxs-lookup"><span data-stu-id="08a67-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="08a67-133">Program aracılığıyla oluşturulan uygulamaları için ve yüklenen XAML değil, XAML isim alanı tanımlayan nesnesi uygulamalıdır <xref:System.Windows.Markup.INameScope>, veya bir <xref:System.Windows.FrameworkElement> veya <xref:System.Windows.FrameworkContentElement> XAML isim alanı oluşturulmasını desteklemek için türetilmiş sınıf, kendi örnekleri.</span><span class="sxs-lookup"><span data-stu-id="08a67-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="08a67-134">Ayrıca, değil yüklenen ve XAML processor tarafından işlenen herhangi bir öğe için nesne için XAML isim alanı oluşturulamadı veya varsayılan olarak başlatıldı.</span><span class="sxs-lookup"><span data-stu-id="08a67-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="08a67-135">Açıkça adlarına sonradan kaydetmek istediğiniz herhangi bir nesne için yeni bir XAML isim alanı oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="08a67-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="08a67-136">XAML isim alanı oluşturmak için statik çağırın <xref:System.Windows.NameScope.SetNameScope%2A> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="08a67-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="08a67-137">Olarak sahip olacağını nesnesi belirtin `dependencyObject` parametresi ve yeni bir <xref:System.Windows.NameScope.%23ctor%2A> Oluşturucusu araması olarak `value` parametresi.</span><span class="sxs-lookup"><span data-stu-id="08a67-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="08a67-138">Nesne olarak sağladıysanız `dependencyObject` için <xref:System.Windows.NameScope.SetNameScope%2A> değil bir <xref:System.Windows.Markup.INameScope> uygulaması, <xref:System.Windows.FrameworkElement> veya <xref:System.Windows.FrameworkContentElement>, arama <xref:System.Windows.FrameworkElement.RegisterName%2A> tüm alt öğeleri hiçbir etkisi olmaz.</span><span class="sxs-lookup"><span data-stu-id="08a67-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="08a67-139">Yeni XAML isim alanı açıkça oluşturmak başarısız olursa, ardından çağrılar <xref:System.Windows.FrameworkElement.RegisterName%2A> bir özel durum oluşturacak.</span><span class="sxs-lookup"><span data-stu-id="08a67-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="08a67-140">Code XAML isim alanı API'lerini kullanarak bir örnek için bkz: [ad kapsamı tanımlama](../../../../docs/framework/wpf/graphics-multimedia/how-to-define-a-name-scope.md).</span><span class="sxs-lookup"><span data-stu-id="08a67-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../../../../docs/framework/wpf/graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>   
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="08a67-141">XAML ad kapsamları stilleri ve şablonları</span><span class="sxs-lookup"><span data-stu-id="08a67-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="08a67-142">Stilleri ve şablonlar [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] yeniden kullanmak ve içeriği kolay bir şekilde yeniden yeteneği sağlar.</span><span class="sxs-lookup"><span data-stu-id="08a67-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="08a67-143">Ancak, stil ve Şablonlar ayrıca öğeleri şablon düzeyinde tanımlanan XAML adlarıyla içerebilir.</span><span class="sxs-lookup"><span data-stu-id="08a67-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="08a67-144">Aynı şablon bir sayfa birden çok kez kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="08a67-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="08a67-145">Bu nedenle, kendi XAML ad kapsamları, burada stil veya şablon uygulanan herhangi bir nesne ağacındaki konumdan bağımsız stilleri ve şablonları tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="08a67-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="08a67-146">Aşağıdaki örnek göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="08a67-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="08a67-147">Burada, aynı şablonu için iki farklı düğmeler uygulanır.</span><span class="sxs-lookup"><span data-stu-id="08a67-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="08a67-148">Şablonları ayrık XAML ad kapsamları değilse `TheBorder` şablonda kullanılan adın XAML isim alanı içinde bir ad çakışması neden.</span><span class="sxs-lookup"><span data-stu-id="08a67-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="08a67-149">Şablonun her örneklemesi kendi XAML isim alanı sahiptir, bu nedenle bu örnekte her örneklenen şablonun XAML isim alanı tam olarak bir ad içerecektir.</span><span class="sxs-lookup"><span data-stu-id="08a67-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="08a67-150">Çoğunlukla film şeritleri bölümlerini atanan belirli adları böylece stilleri de kendi XAML isim alanı tanımlar.</span><span class="sxs-lookup"><span data-stu-id="08a67-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="08a67-151">Şablon denetim özelleştirme bir parçası olarak yeniden tanımlandı olsa bile bu adlar, bu adı öğeleri hedeflediğini denetim belirli davranışları etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="08a67-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="08a67-152">Nedeniyle ayrı XAML ad kapsamları bir şablonda adlandırılmış öğeleri bulma, bir oluşturulmamış bir sayfa öğesinde adlı bulma değerinden daha zorlu olur.</span><span class="sxs-lookup"><span data-stu-id="08a67-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="08a67-153">İlk alarak uygulanan şablon belirlemek gereken <xref:System.Windows.Controls.Control.Template%2A> şablon uygulanan burada denetimin özellik değeri.</span><span class="sxs-lookup"><span data-stu-id="08a67-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="08a67-154">Ardından, şablon sürümü çağıran <xref:System.Windows.FrameworkTemplate.FindName%2A>, şablon ikinci parametre olarak uygulandığı denetimi geçirme.</span><span class="sxs-lookup"><span data-stu-id="08a67-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="08a67-155">Bir denetim yazar ve uygulanan şablon öğesinde adlı belirli bir denetim tarafından tanımlanan bir davranış için hedef olduğu bir kural oluşturmak, kullanabileceğiniz <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> denetim uygulama kodunuzdan yöntemi.</span><span class="sxs-lookup"><span data-stu-id="08a67-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="08a67-156"><xref:System.Windows.FrameworkElement.GetTemplateChild%2A> Yöntem korunur, böylece yalnızca denetim yazarı erişimi vardır.</span><span class="sxs-lookup"><span data-stu-id="08a67-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="08a67-157">Bir şablon ve burada şablonun için XAML isim alanı almak için gerek içinde çalışıyorsanız, değerini alın <xref:System.Windows.FrameworkElement.TemplatedParent%2A>ve ardından arama <xref:System.Windows.FrameworkElement.FindName%2A> vardır.</span><span class="sxs-lookup"><span data-stu-id="08a67-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="08a67-158">Şablonu içindeki çalışma örneği olay işleyicisinin uygulaması yazma varsa, uygulanan bir şablonda bir öğeden olay burada gerçekleştirilecektir olacaktır.</span><span class="sxs-lookup"><span data-stu-id="08a67-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>   
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="08a67-159">XAML ad kapsamları ve ad ile ilgili API'ler</span><span class="sxs-lookup"><span data-stu-id="08a67-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="08a67-160"><xref:System.Windows.FrameworkElement>sahip <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> ve <xref:System.Windows.FrameworkElement.UnregisterName%2A> yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="08a67-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="08a67-161">Bu yöntemleri çağırmak nesne XAML isim alanı sahipse, ilgili XAML isim alanı yöntemlerin içine yöntemlerini çağırın.</span><span class="sxs-lookup"><span data-stu-id="08a67-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="08a67-162">Aksi takdirde, üst öğenin XAML isim alanı sahibi ve XAML isim alanı bulunana kadar yinelemeli olarak bu işlem devam görmek için kontrol edilir (XAML işlemci davranışı nedeniyle var bir XAML isim alanı kökünde olması garanti).</span><span class="sxs-lookup"><span data-stu-id="08a67-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="08a67-163"><xref:System.Windows.FrameworkContentElement>özel durum ile benzer davranışları sahip, hiçbir <xref:System.Windows.FrameworkContentElement> hiç XAML isim alanı sahibi.</span><span class="sxs-lookup"><span data-stu-id="08a67-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="08a67-164">Yöntemleri mevcut <xref:System.Windows.FrameworkContentElement> çağrıları sonunda çok iletilebilir böylece bir <xref:System.Windows.FrameworkElement> üst öğesi.</span><span class="sxs-lookup"><span data-stu-id="08a67-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="08a67-165"><xref:System.Windows.NameScope.SetNameScope%2A>var olan bir nesne için yeni bir XAML isim alanı eşlemek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="08a67-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="08a67-166">Çağırabilirsiniz <xref:System.Windows.NameScope.SetNameScope%2A> birden çok kez sıfırlama veya XAML temizlemek için isim alanı değildir, ancak, ortak kullanım.</span><span class="sxs-lookup"><span data-stu-id="08a67-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="08a67-167">Ayrıca, <xref:System.Windows.NameScope.GetNameScope%2A> koddan genellikle kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="08a67-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="08a67-168">XAML isim alanı uygulamaları</span><span class="sxs-lookup"><span data-stu-id="08a67-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="08a67-169">Aşağıdaki sınıflar uygulama <xref:System.Windows.Markup.INameScope> doğrudan:</span><span class="sxs-lookup"><span data-stu-id="08a67-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
-   <xref:System.Windows.NameScope>  
  
-   <xref:System.Windows.Style>  
  
-   <xref:System.Windows.ResourceDictionary>  
  
-   <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="08a67-170"><xref:System.Windows.ResourceDictionary>XAML adları veya ad kapsamları kullanmaz; bir sözlük uygulaması olduğu için bunun yerine, anahtarları kullanır.</span><span class="sxs-lookup"><span data-stu-id="08a67-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="08a67-171">Yalnızca neden <xref:System.Windows.ResourceDictionary> uygulayan <xref:System.Windows.Markup.INameScope> true XAML isim alanı arasında ayrım açıklamak yardımcı özel durumlar kullanıcı kodu oluşturabilir ve nasıl olduğu bir <xref:System.Windows.ResourceDictionary> anahtarları, işler ve ayrıca XAML ad kapsamları için uygulanmaz güvence altına almak için bir <xref:System.Windows.ResourceDictionary> üst öğeler tarafından.</span><span class="sxs-lookup"><span data-stu-id="08a67-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="08a67-172"><xref:System.Windows.FrameworkTemplate>ve <xref:System.Windows.Style> uygulamak <xref:System.Windows.Markup.INameScope> açık arabirim tanımları aracılığıyla.</span><span class="sxs-lookup"><span data-stu-id="08a67-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="08a67-173">Açık uygulamaları bu XAML ad kapsamları üzerinden zaman erişilen standart olarak davranmasına izin <xref:System.Windows.Markup.INameScope> XAML ad kapsamları nasıl bildirilir olduğu arabirimi tarafından [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] iç işlemler.</span><span class="sxs-lookup"><span data-stu-id="08a67-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="08a67-174">Ancak açık arabirim tanımları geleneksel API yüzeyi parçası olmayan <xref:System.Windows.FrameworkTemplate> ve <xref:System.Windows.Style>, nadiren çağırmanız gerekir çünkü <xref:System.Windows.Markup.INameScope> yöntemlere <xref:System.Windows.FrameworkTemplate> ve <xref:System.Windows.Style> doğrudan ve bunun yerine diğer API kullanır gibi <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span><span class="sxs-lookup"><span data-stu-id="08a67-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="08a67-175">Aşağıdaki sınıflar kullanarak kendi XAML isim alanı tanımlayın <xref:System.Windows.NameScope?displayProperty=nameWithType> yardımcı sınıfı ve XAML isim alanı uygulaması bağlanma <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> özelliği eklenmiş:</span><span class="sxs-lookup"><span data-stu-id="08a67-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
-   <xref:System.Windows.FrameworkElement>  
  
-   <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="08a67-176">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="08a67-176">See Also</span></span>  
 [<span data-ttu-id="08a67-177">WPF XAML için XAML Ad Alanları ve Ad Alanı Eşlemesi</span><span class="sxs-lookup"><span data-stu-id="08a67-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)  
 [<span data-ttu-id="08a67-178">x:Name Yönergesi</span><span class="sxs-lookup"><span data-stu-id="08a67-178">x:Name Directive</span></span>](../../../../docs/framework/xaml-services/x-name-directive.md)

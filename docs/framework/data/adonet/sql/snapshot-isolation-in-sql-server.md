---
title: "SQL Server'da anlık görüntü yalıtımı"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-ado
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
caps.latest.revision: "6"
author: JennieHubbard
ms.author: jhubbard
manager: jhubbard
ms.openlocfilehash: 101b8b444287102cbf8ed48891cc9d98df25283f
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/21/2017
---
# <a name="snapshot-isolation-in-sql-server"></a><span data-ttu-id="c6616-102">SQL Server'da anlık görüntü yalıtımı</span><span class="sxs-lookup"><span data-stu-id="c6616-102">Snapshot Isolation in SQL Server</span></span>
<span data-ttu-id="c6616-103">Anlık görüntü yalıtımı OLTP uygulamalar için eşzamanlılık geliştirir.</span><span class="sxs-lookup"><span data-stu-id="c6616-103">Snapshot isolation enhances concurrency for OLTP applications.</span></span>  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a><span data-ttu-id="c6616-104">Anlık görüntü yalıtımı ve satır sürüm anlama</span><span class="sxs-lookup"><span data-stu-id="c6616-104">Understanding Snapshot Isolation and Row Versioning</span></span>  
 <span data-ttu-id="c6616-105">Anlık görüntü yalıtımı etkinleştirildiğinde, her işlem için güncelleştirilmiş satır sürümleri içinde korunur **tempdb**.</span><span class="sxs-lookup"><span data-stu-id="c6616-105">Once snapshot isolation is enabled, updated row versions for each transaction are maintained in **tempdb**.</span></span> <span data-ttu-id="c6616-106">Her işlem benzersiz işlem sırası numarası tanımlar ve bu benzersiz numaraları her satır sürümü için kaydedilir.</span><span class="sxs-lookup"><span data-stu-id="c6616-106">A unique transaction sequence number identifies each transaction, and these unique numbers are recorded for each row version.</span></span> <span data-ttu-id="c6616-107">İşlem, işlem sırası sayısı önce sıra numarasına sahip en son satır sürümleri ile çalışır.</span><span class="sxs-lookup"><span data-stu-id="c6616-107">The transaction works with the most recent row versions having a sequence number before the sequence number of the transaction.</span></span> <span data-ttu-id="c6616-108">İşlem başladıktan sonra oluşturulan yeni satır sürümleri işlem tarafından göz ardı edilir.</span><span class="sxs-lookup"><span data-stu-id="c6616-108">Newer row versions created after the transaction has begun are ignored by the transaction.</span></span>  
  
 <span data-ttu-id="c6616-109">"Anlık görüntü" terimi işlemdeki tüm sorgular aynı sürüm veya anda işlem başladığı veritabanının durumuna bağlı veritabanının anlık görüntü bakın olgu yansıtır.</span><span class="sxs-lookup"><span data-stu-id="c6616-109">The term "snapshot" reflects the fact that all queries in the transaction see the same version, or snapshot, of the database, based on the state of the database at the moment in time when the transaction begins.</span></span> <span data-ttu-id="c6616-110">Temel alınan veri satırları veya veri sayfaları önceki tamamlanmamış bir işlem tarafından engellenen olmadan yürütmek için diğer işlemleri izin veren bir anlık görüntü işlemde alınan kilit yok.</span><span class="sxs-lookup"><span data-stu-id="c6616-110">No locks are acquired on the underlying data rows or data pages in a snapshot transaction, which permits other transactions to execute without being blocked by a prior uncompleted transaction.</span></span> <span data-ttu-id="c6616-111">Verileri değiştirme işlemleri veri okuma işlemleri engellemez ve bunlar varsayılan READ COMMITTED yalıtım düzeyi SQL Server'ın altında normalde yaptığınız gibi veri okuma işlemleri veri yazma işlemleri engellemez.</span><span class="sxs-lookup"><span data-stu-id="c6616-111">Transactions that modify data do not block transactions that read data, and transactions that read data do not block transactions that write data, as they normally would under the default READ COMMITTED isolation level in SQL Server.</span></span> <span data-ttu-id="c6616-112">Engelleyici olmayan bu davranış, ayrıca önemli ölçüde kilitlenmeleri karmaşık işlemleri için olasılığını azaltır.</span><span class="sxs-lookup"><span data-stu-id="c6616-112">This non-blocking behavior also significantly reduces the likelihood of deadlocks for complex transactions.</span></span>  
  
 <span data-ttu-id="c6616-113">Anlık görüntü yalıtımı iyimser eşzamanlılık modeli kullanır.</span><span class="sxs-lookup"><span data-stu-id="c6616-113">Snapshot isolation uses an optimistic concurrency model.</span></span> <span data-ttu-id="c6616-114">İşlemin başlamasından bu yana değişti veri değişiklikleri gerçekleştirmek bir anlık görüntü işlemi çalışırsa, işlem döndürülmesine neden olur ve bir hata oluşur.</span><span class="sxs-lookup"><span data-stu-id="c6616-114">If a snapshot transaction attempts to commit modifications to data that has changed since the transaction began, the transaction will roll back and an error will be raised.</span></span> <span data-ttu-id="c6616-115">Bu, değiştirilecek verilere erişmek için SELECT deyimleri UPDLOCK ipuçlarını kullanarak önleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c6616-115">You can avoid this by using UPDLOCK hints for SELECT statements that access data to be modified.</span></span> <span data-ttu-id="c6616-116">SQL Server Books Online'da "kilitleme ipuçları" daha fazla bilgi için bkz.</span><span class="sxs-lookup"><span data-stu-id="c6616-116">See "Locking Hints" in SQL Server Books Online for more information.</span></span>  
  
 <span data-ttu-id="c6616-117">Anlık görüntü yalıtımı işlemlerinde kullanılmadan önce allow_snapshot_ısolatıon açık veritabanı seçeneğini ayarlayarak etkinleştirilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="c6616-117">Snapshot isolation must be enabled by setting the ALLOW_SNAPSHOT_ISOLATION ON database option before it is used in transactions.</span></span> <span data-ttu-id="c6616-118">Bu geçici bir veritabanında satır sürümlerini depolamak için mekanizması etkinleştirir (**tempdb**).</span><span class="sxs-lookup"><span data-stu-id="c6616-118">This activates the mechanism for storing row versions in the temporary database (**tempdb**).</span></span> <span data-ttu-id="c6616-119">İle Transact-SQL ALTER DATABASE deyimini kullanan her veritabanında anlık görüntü yalıtımını etkinleştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="c6616-119">You must enable snapshot isolation in each database that uses it with the Transact-SQL ALTER DATABASE statement.</span></span> <span data-ttu-id="c6616-120">Bu bakımdan, anlık görüntü yalıtımı READ COMMITTED, REPEATABLE READ, seri hale GETİRİLEBİLİR ve READ UNCOMMITTED yapılandırma gerektiren geleneksel yalıtım düzeyi arasından farklıdır.</span><span class="sxs-lookup"><span data-stu-id="c6616-120">In this respect, snapshot isolation differs from the traditional isolation levels of READ COMMITTED, REPEATABLE READ, SERIALIZABLE, and READ UNCOMMITTED, which require no configuration.</span></span> <span data-ttu-id="c6616-121">Aşağıdaki deyimleri anlık görüntü yalıtımını etkinleştirmeniz ve READ COMMITTED varsayılan davranışı anlık görüntü ile değiştirin:</span><span class="sxs-lookup"><span data-stu-id="c6616-121">The following statements activate snapshot isolation and replace the default READ COMMITTED behavior with SNAPSHOT:</span></span>  
  
```  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
 <span data-ttu-id="c6616-122">Read_commıtted_snapshot ON seçeneği varsayılan READ COMMITTED yalıtım düzeyi altında sürümlü satır erişmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="c6616-122">Setting the READ_COMMITTED_SNAPSHOT ON option allows access to versioned rows under the default READ COMMITTED isolation level.</span></span> <span data-ttu-id="c6616-123">Read_commıtted_snapshot seçeneği OFF olarak ayarlarsanız, her oturum için anlık görüntü yalıtım düzeyi sürümlü satır erişmek için açıkça ayarlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="c6616-123">If the READ_COMMITTED_SNAPSHOT option is set to OFF, you must explicitly set the Snapshot isolation level for each session in order to access versioned rows.</span></span>  
  
## <a name="managing-concurrency-with-isolation-levels"></a><span data-ttu-id="c6616-124">Eşzamanlılık yalıtım düzeyi ile yönetme</span><span class="sxs-lookup"><span data-stu-id="c6616-124">Managing Concurrency with Isolation Levels</span></span>  
 <span data-ttu-id="c6616-125">Altında bir Transact-SQL deyimini yürütür yalıtım düzeyi kilitleme ve satır sürüm davranışını belirler.</span><span class="sxs-lookup"><span data-stu-id="c6616-125">The isolation level under which a Transact-SQL statement executes determines its locking and row versioning behavior.</span></span> <span data-ttu-id="c6616-126">Bir yalıtım düzeyi bağlantı genelinde kapsama sahip ve işlem YALITIM düzeyi AYARLANAN ifadesiyle bağlantı ayarlandıktan etkin bağlantı kapalı veya başka bir yalıtım düzeyi kadar kalır.</span><span class="sxs-lookup"><span data-stu-id="c6616-126">An isolation level has connection-wide scope, and once set for a connection with the SET TRANSACTION ISOLATION LEVEL statement, it remains in effect until the connection is closed or another isolation level is set.</span></span> <span data-ttu-id="c6616-127">Bir bağlantı kapatılır ve havuza geri döner etkinleştirildiğinde, son işlem YALITIM düzeyi AYARLANAN deyimden yalıtım düzeyi korunur.</span><span class="sxs-lookup"><span data-stu-id="c6616-127">When a connection is closed and returned to the pool, the isolation level from the last SET TRANSACTION ISOLATION LEVEL statement is retained.</span></span> <span data-ttu-id="c6616-128">Sonraki bağlantılar yürürlükte olan zaman bağlantısı yalıtım düzeyi havuza alınmış bir havuza alınan bağlantı kullanımı yeniden kullanma.</span><span class="sxs-lookup"><span data-stu-id="c6616-128">Subsequent connections reusing a pooled connection use the isolation level that was in effect at the time the connection is pooled.</span></span>  
  
 <span data-ttu-id="c6616-129">İçinde bir bağlantı verilen tek tek sorguları, tek bir deyimde veya işlem yalıtımını değiştirir, ancak bağlantı yalıtım düzeyini etkilemez kilit ipuçlarına içerebilir.</span><span class="sxs-lookup"><span data-stu-id="c6616-129">Individual queries issued within a connection can contain lock hints that modify the isolation for a single statement or transaction but do not affect the isolation level of the connection.</span></span> <span data-ttu-id="c6616-130">Yalıtım düzeylerinde veya kilit ipuçlarına saklı yordamlarda ayarlayın veya İşlevler onları çağıran bağlantının yalıtım düzeyi değiştirmeyin ve yalnızca saklı yordam veya işlev çağrısı süresince etkindir.</span><span class="sxs-lookup"><span data-stu-id="c6616-130">Isolation levels or lock hints set in stored procedures or functions do not change the isolation level of the connection that calls them and are in effect only for the duration of the stored procedure or function call.</span></span>  
  
 <span data-ttu-id="c6616-131">SQL-92 standardında tanımlanan dört yalıtım düzeyi erken SQL Server'ın sürümlerinde desteklenen:</span><span class="sxs-lookup"><span data-stu-id="c6616-131">Four isolation levels defined in the SQL-92 standard were supported in early versions of SQL Server:</span></span>  
  
-   <span data-ttu-id="c6616-132">Diğer işlemler tarafından yerleştirilen kilitleri yok sayar READ UNCOMMITTED yalıtım düzeyini en az kısıtlayıcı olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="c6616-132">READ UNCOMMITTED is the least restrictive isolation level because it ignores locks placed by other transactions.</span></span> <span data-ttu-id="c6616-133">READ UNCOMMITTED altında yürütülen işlemler henüz diğer işlemler tarafından taahhüt değil değiştirilmiş veri değerleri okuyabilirsiniz. Bunlar, "kirli" okuma olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="c6616-133">Transactions executing under READ UNCOMMITTED can read modified data values that have not yet been committed by other transactions; these are called "dirty" reads.</span></span>  
  
-   <span data-ttu-id="c6616-134">READ COMMITTED SQL Server için varsayılan yalıtım düzeyi olur.</span><span class="sxs-lookup"><span data-stu-id="c6616-134">READ COMMITTED is the default isolation level for SQL Server.</span></span> <span data-ttu-id="c6616-135">Kirli okuma deyimleri değiştirildi, ancak henüz diğer işlemler tarafından yürütülen veri değerleri okunamıyor belirterek engeller.</span><span class="sxs-lookup"><span data-stu-id="c6616-135">It prevents dirty reads by specifying that statements cannot read data values that have been modified but not yet committed by other transactions.</span></span> <span data-ttu-id="c6616-136">Hala diğer işlemleri değiştirmek, eklemek veya tek tek deyimleri geçerli işlem tekrarlanabilir olmayan okuma veya "hayalet" veri kaynaklanan içinde yürütmeleri arasında verileri silme.</span><span class="sxs-lookup"><span data-stu-id="c6616-136">Other transactions can still modify, insert, or delete data between executions of individual statements within the current transaction, resulting in non-repeatable reads, or "phantom" data.</span></span>  
  
-   <span data-ttu-id="c6616-137">REPEATABLE READ READ COMMITTED daha daha kısıtlayıcı bir yalıtım düzeyi değil.</span><span class="sxs-lookup"><span data-stu-id="c6616-137">REPEATABLE READ is a more restrictive isolation level than READ COMMITTED.</span></span> <span data-ttu-id="c6616-138">READ COMMITTED kapsar ve ayrıca başka bir işlem değiştirin veya geçerli işlem tamamlandıktan kadar geçerli hareket tarafından okunur verilerini silmek belirtir.</span><span class="sxs-lookup"><span data-stu-id="c6616-138">It encompasses READ COMMITTED and additionally specifies that no other transactions can modify or delete data that has been read by the current transaction until the current transaction commits.</span></span> <span data-ttu-id="c6616-139">Eşzamanlılık okuma KAYDEDİLEN değerinden daha düşük olduğundan veri okuma paylaşılan kilit her deyimi sonunda yayımlanan yerine işlem boyunca tutulur.</span><span class="sxs-lookup"><span data-stu-id="c6616-139">Concurrency is lower than for READ COMMITTED because shared locks on read data are held for the duration of the transaction instead of being released at the end of each statement.</span></span>  
  
-   <span data-ttu-id="c6616-140">Anahtarların tüm aralıkları kilitler ve işlem tamamlanana kadar kilitler tutan en kısıtlayıcı yalıtım düzeyi seri hale GETİRİLEBİLİR olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="c6616-140">SERIALIZABLE is the most restrictive isolation level, because it locks entire ranges of keys and holds the locks until the transaction is complete.</span></span> <span data-ttu-id="c6616-141">YİNELENEBİLİR okuma kapsar ve diğer işlemleri yeni satırlar işlem tamamlanana kadar işlem tarafından okuma aralıkları INSERT yapılamıyor kısıtlama ekler.</span><span class="sxs-lookup"><span data-stu-id="c6616-141">It encompasses REPEATABLE READ and adds the restriction that other transactions cannot insert new rows into ranges that have been read by the transaction until the transaction is complete.</span></span>  
  
 <span data-ttu-id="c6616-142">Daha fazla bilgi için SQL Server Books Online'da "yalıtım düzeyi" konusuna bakın.</span><span class="sxs-lookup"><span data-stu-id="c6616-142">For more information, see "Isolation Levels" in SQL Server Books Online.</span></span>  
  
### <a name="snapshot-isolation-level-extensions"></a><span data-ttu-id="c6616-143">Anlık görüntü yalıtım düzeyi uzantıları</span><span class="sxs-lookup"><span data-stu-id="c6616-143">Snapshot Isolation Level Extensions</span></span>  
 <span data-ttu-id="c6616-144">SQL Server Uzantıları anlık görüntü yalıtım düzeyi giriş ve ek READ COMMITTED uygulaması ile SQL 92 yalıtım düzeyi kullanıma sunuldu.</span><span class="sxs-lookup"><span data-stu-id="c6616-144">SQL Server introduced extensions to the SQL-92 isolation levels with the introduction of the SNAPSHOT isolation level and an additional implementation of READ COMMITTED.</span></span> <span data-ttu-id="c6616-145">Read_commıtted_snapshot yalıtım düzeyi saydam READ COMMITTED tüm işlemler için değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c6616-145">The READ_COMMITTED_SNAPSHOT isolation level can transparently replace READ COMMITTED for all transactions.</span></span>  
  
-   <span data-ttu-id="c6616-146">Anlık görüntü yalıtımı, bir işlem içinde okunan veriler hiçbir zaman eş zamanlı başka işlemler tarafından yapılan değişiklikleri yansıtacak belirtir.</span><span class="sxs-lookup"><span data-stu-id="c6616-146">SNAPSHOT isolation specifies that data read within a transaction will never reflect changes made by other simultaneous transactions.</span></span> <span data-ttu-id="c6616-147">İşlem, işlem başladığında, mevcut veri satır sürümleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="c6616-147">The transaction uses the data row versions that exist when the transaction begins.</span></span> <span data-ttu-id="c6616-148">Okunduğunda, anlık işlemleri verileri yazmasını diğer işlemleri engellemez şekilde kilit yok verileri yerleştirilir.</span><span class="sxs-lookup"><span data-stu-id="c6616-148">No locks are placed on the data when it is read, so SNAPSHOT transactions do not block other transactions from writing data.</span></span> <span data-ttu-id="c6616-149">Veri yazma işlemleri verileri okuma anlık görüntü hareketlerin engellemez.</span><span class="sxs-lookup"><span data-stu-id="c6616-149">Transactions that write data do not block snapshot transactions from reading data.</span></span> <span data-ttu-id="c6616-150">Bunu kullanmak için allow_snapshot_ısolatıon veritabanı seçeneği ayarlayarak anlık görüntü yalıtımını etkinleştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="c6616-150">You need to enable snapshot isolation by setting the ALLOW_SNAPSHOT_ISOLATION database option in order to use it.</span></span>  
  
-   <span data-ttu-id="c6616-151">Bir veritabanında anlık görüntü yalıtımı etkinleştirildiğinde read_commıtted_snapshot veritabanı seçeneği varsayılan READ COMMITTED yalıtım düzeyi davranışını belirler.</span><span class="sxs-lookup"><span data-stu-id="c6616-151">The READ_COMMITTED_SNAPSHOT database option determines the behavior of the default READ COMMITTED isolation level when snapshot isolation is enabled in a database.</span></span> <span data-ttu-id="c6616-152">READ COMMITTED read_commıtted_snapshot ON açıkça belirtmezseniz, tüm örtük işlemlere uygulanır.</span><span class="sxs-lookup"><span data-stu-id="c6616-152">If you do not explicitly specify READ_COMMITTED_SNAPSHOT ON, READ COMMITTED is applied to all implicit transactions.</span></span> <span data-ttu-id="c6616-153">Bu read_commıtted_snapshot devre dışı (varsayılan) ayarı olarak aynı davranışı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="c6616-153">This produces the same behavior as setting READ_COMMITTED_SNAPSHOT OFF (the default).</span></span> <span data-ttu-id="c6616-154">Veritabanı altyapısı paylaşılan kilit read_commıtted_snapshot kapalı etkin olduğunda, varsayılan yalıtım düzeyi zorlamak için kullanır.</span><span class="sxs-lookup"><span data-stu-id="c6616-154">When READ_COMMITTED_SNAPSHOT OFF is in effect, the Database Engine uses shared locks to enforce the default isolation level.</span></span> <span data-ttu-id="c6616-155">Veritabanı altyapısı satır sürüm oluşturma ve anlık görüntü yalıtım read_commıtted_snapshot veritabanı seçeneği ON olarak ayarlarsanız, verileri korumak için kilitler kullanmak yerine varsayılan olarak kullanır.</span><span class="sxs-lookup"><span data-stu-id="c6616-155">If you set the READ_COMMITTED_SNAPSHOT database option to ON, the database engine uses row versioning and snapshot isolation as the default, instead of using locks to protect the data.</span></span>  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a><span data-ttu-id="c6616-156">Nasıl anlık görüntü yalıtımı ve satır sürüm oluşturma çalışma</span><span class="sxs-lookup"><span data-stu-id="c6616-156">How Snapshot Isolation and Row Versioning Work</span></span>  
 <span data-ttu-id="c6616-157">Anlık görüntü yalıtım düzeyi, bir satır güncelleştirilir, her zaman etkin olduğunda ilk satırda bir kopyasını SQL Server veritabanı altyapısı depolar **tempdb**ve satır için bir işlem sıra numarası ekler.</span><span class="sxs-lookup"><span data-stu-id="c6616-157">When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in **tempdb**, and adds a transaction sequence number to the row.</span></span> <span data-ttu-id="c6616-158">Ortaya çıkan olayların sırası verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="c6616-158">The following is the sequence of events that occurs:</span></span>  
  
-   <span data-ttu-id="c6616-159">Yeni bir işlemi başlatılır ve bir işlem sıra numarası atanır.</span><span class="sxs-lookup"><span data-stu-id="c6616-159">A new transaction is initiated, and it is assigned a transaction sequence number.</span></span>  
  
-   <span data-ttu-id="c6616-160">Veritabanı altyapısı işlem içinde bir satır okur ve satır sürümünden alır **tempdb** , sıra numarası en yakın ve işlem sırası numarası değerinden daha düşük.</span><span class="sxs-lookup"><span data-stu-id="c6616-160">The Database Engine reads a row within the transaction and retrieves the row version from **tempdb** whose sequence number is closest to, and lower than, the transaction sequence number.</span></span>  
  
-   <span data-ttu-id="c6616-161">Veritabanı altyapısı işlem sıra numarası kaydedilmemiş işlemleri etkin işlem sırası numaralarını listesinde değil anlık görüntü işlemi başlatıldığında olup olmadığını denetler.</span><span class="sxs-lookup"><span data-stu-id="c6616-161">The Database Engine checks to see if the transaction sequence number is not in the list of transaction sequence numbers of the uncommitted transactions active when the snapshot transaction started.</span></span>  
  
-   <span data-ttu-id="c6616-162">İşlem satırdaki sürümü okur **tempdb** , işlem başlangıç itibariyle geçerli.</span><span class="sxs-lookup"><span data-stu-id="c6616-162">The transaction reads the version of the row from **tempdb** that was current as of the start of the transaction.</span></span> <span data-ttu-id="c6616-163">Bu sıra numarası değerleri işlem sırası numarası değerinden yüksek olduğundan işlem başlatıldıktan sonra eklenen yeni satırlar görmezsiniz.</span><span class="sxs-lookup"><span data-stu-id="c6616-163">It will not see new rows inserted after the transaction was started because those sequence number values will be higher than the value of the transaction sequence number.</span></span>  
  
-   <span data-ttu-id="c6616-164">Geçerli işlem işlemin başlamasından sonra bir satır sürümü olacağından silinen satır görürsünüz **tempdb** daha düşük bir sıra numarası değere sahip.</span><span class="sxs-lookup"><span data-stu-id="c6616-164">The current transaction will see rows that were deleted after the transaction began, because there will be a row version in **tempdb** with a lower sequence number value.</span></span>  
  
 <span data-ttu-id="c6616-165">Net anlık görüntü yalıtım uygularken veya kilitleri temel tabloya yerleştirmek olmadan işlem başlangıcında var gibi işlem tüm verileri görmemesini etkisidir.</span><span class="sxs-lookup"><span data-stu-id="c6616-165">The net effect of snapshot isolation is that the transaction sees all of the data as it existed at the start of the transaction, without honoring or placing any locks on the underlying tables.</span></span> <span data-ttu-id="c6616-166">Bu durumlarda performans geliştirmeleri sonuçlanabilir Çekişme olduğunda.</span><span class="sxs-lookup"><span data-stu-id="c6616-166">This can result in performance improvements in situations where there is contention.</span></span>  
  
 <span data-ttu-id="c6616-167">Her zaman bir anlık görüntü işlemi satırları güncelleştirme diğer hareketlerin önleyen kilitleri tutma iyimser eşzamanlılık denetimini kullanır.</span><span class="sxs-lookup"><span data-stu-id="c6616-167">A snapshot transaction always uses optimistic concurrency control, withholding any locks that would prevent other transactions from updating rows.</span></span> <span data-ttu-id="c6616-168">Bir anlık görüntü işlemi işlemin başlamasından sonra değiştirildi bir satır için bir güncelleştirme yürütme kullanmaya çalışırsa, işlem geri alındı ve bir hata oluşur.</span><span class="sxs-lookup"><span data-stu-id="c6616-168">If a snapshot transaction attempts to commit an update to a row that was changed after the transaction began, the transaction is rolled back, and an error is raised.</span></span>  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a><span data-ttu-id="c6616-169">Anlık görüntü yalıtımı ADO.NET ile çalışma</span><span class="sxs-lookup"><span data-stu-id="c6616-169">Working with Snapshot Isolation in ADO.NET</span></span>  
 <span data-ttu-id="c6616-170">Anlık görüntü yalıtımı ADO.NET tarafından desteklenir <xref:System.Data.SqlClient.SqlTransaction> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="c6616-170">Snapshot isolation is supported in ADO.NET by the <xref:System.Data.SqlClient.SqlTransaction> class.</span></span> <span data-ttu-id="c6616-171">Bir veritabanı için anlık görüntü yalıtım etkin, ancak read_commıtted_snapshot ON için yapılandırılmamış başlatmalıdır bir <xref:System.Data.SqlClient.SqlTransaction> kullanarak **IsolationLevel.Snapshot** çağrılırken numaralandırma değeri <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> yöntem.</span><span class="sxs-lookup"><span data-stu-id="c6616-171">If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <xref:System.Data.SqlClient.SqlTransaction> using the **IsolationLevel.Snapshot** enumeration value when calling the <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> method.</span></span> <span data-ttu-id="c6616-172">Bu kod parçası bağlantı açık olduğunu varsayar <xref:System.Data.SqlClient.SqlConnection> nesnesi.</span><span class="sxs-lookup"><span data-stu-id="c6616-172">This code fragment assumes that connection is an open <xref:System.Data.SqlClient.SqlConnection> object.</span></span>  
  
```vb  
Dim sqlTran As SqlTransaction = _  
  connection.BeginTransaction(IsolationLevel.Snapshot)  
```  
  
```csharp  
SqlTransaction sqlTran =   
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a><span data-ttu-id="c6616-173">Örnek</span><span class="sxs-lookup"><span data-stu-id="c6616-173">Example</span></span>  
 <span data-ttu-id="c6616-174">Aşağıdaki örnek, farklı yalıtım düzeylerinde kilitli verilerinize erişmeye çalışan tarafından nasıl davranacağını gösterir ve üretim kodunda kullanılmak üzere tasarlanmamıştır.</span><span class="sxs-lookup"><span data-stu-id="c6616-174">The following example demonstrates how the different isolation levels behave by attempting to access locked data, and it is not intended to be used in production code.</span></span>  
  
 <span data-ttu-id="c6616-175">Kod bağlandığı **AdventureWorks** adlı bir tablo oluşturur ve örnek SQL Server veritabanında **TestSnapshot** ve verilerin bir satır ekler.</span><span class="sxs-lookup"><span data-stu-id="c6616-175">The code connects to the **AdventureWorks** sample database in SQL Server and creates a table named **TestSnapshot** and inserts one row of data.</span></span> <span data-ttu-id="c6616-176">Veritabanı için anlık görüntü yalıtımını açmak için ALTER DATABASE Transact-SQL deyimi kod kullanır, ancak varsayılan READ COMMITTED yalıtım düzeyi davranışını yürürlükte bırakarak read_commıtted_snapshot seçeneği ayarlı değil.</span><span class="sxs-lookup"><span data-stu-id="c6616-176">The code uses the ALTER DATABASE Transact-SQL statement to turn on snapshot isolation for the database, but it does not set the READ_COMMITTED_SNAPSHOT option, leaving the default READ COMMITTED isolation-level behavior in effect.</span></span> <span data-ttu-id="c6616-177">Kod, ardından aşağıdaki eylemleri gerçekleştirir:</span><span class="sxs-lookup"><span data-stu-id="c6616-177">The code then performs the following actions:</span></span>  
  
-   <span data-ttu-id="c6616-178">Başlar, ancak tamamlamaz, bir güncelleştirme işlemi başlatmak için SERIALIZABLE yalıtım düzeyi kullandığı sqlTransaction1.</span><span class="sxs-lookup"><span data-stu-id="c6616-178">It begins, but does not complete, sqlTransaction1, which uses the SERIALIZABLE isolation level to start an update transaction.</span></span> <span data-ttu-id="c6616-179">Bu tablo kilitleme etkisi vardır.</span><span class="sxs-lookup"><span data-stu-id="c6616-179">This has the effect of locking the table.</span></span>  
  
-   <span data-ttu-id="c6616-180">İkinci bir bağlantı açar ve verileri okumak için anlık görüntü yalıtım düzeyi kullanılarak ikinci bir işlem başlatır **TestSnapshot** tablo.</span><span class="sxs-lookup"><span data-stu-id="c6616-180">It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the **TestSnapshot** table.</span></span> <span data-ttu-id="c6616-181">Anlık görüntü yalıtımı etkin olmadığından bu işlem sqlTransaction1 başlatmadan önce var olan verileri okuyabilir.</span><span class="sxs-lookup"><span data-stu-id="c6616-181">Because snapshot isolation is enabled, this transaction can read the data that existed before sqlTransaction1 started.</span></span>  
  
-   <span data-ttu-id="c6616-182">Üçüncü bir bağlantı açar ve tablosunda veri okuma girişimi için READ COMMITTED yalıtım düzeyi kullanılarak bir işlem başlatır.</span><span class="sxs-lookup"><span data-stu-id="c6616-182">It opens a third connection and initiates a transaction using the READ COMMITTED isolation level to attempt to read the data in the table.</span></span> <span data-ttu-id="c6616-183">Bu durumda, ilk işlem ve zaman aşımına tabloda getirilen kilitler geçti okunamıyor çünkü kod veri okunamıyor. YİNELENEBİLİR okuma ve SERIALIZABLE yalıtım düzeylerinde bu yalıtım düzeylerinde de ilk işlemde yerleşen kilitler geçti okunamıyor çünkü kullandıysanız aynı sonucu oluşacak.</span><span class="sxs-lookup"><span data-stu-id="c6616-183">In this case, the code cannot read the data because it cannot read past the locks placed on the table in the first transaction and times out. The same result would occur if the REPEATABLE READ and SERIALIZABLE isolation levels were used because these isolation levels also cannot read past the locks placed in the first transaction.</span></span>  
  
-   <span data-ttu-id="c6616-184">Dördüncü bir bağlantı açar ve kaydedilmemiş değerinin kirli okuma sqlTransaction1 içinde gerçekleştirir READ UNCOMMITTED yalıtım düzeyi kullanılarak bir işlem başlatır.</span><span class="sxs-lookup"><span data-stu-id="c6616-184">It opens a fourth connection and initiates a transaction using the READ UNCOMMITTED isolation level, which performs a dirty read of the uncommitted value in sqlTransaction1.</span></span> <span data-ttu-id="c6616-185">Birinci işlem taahhüt değilse bu değeri aslında hiç veritabanında mevcut olabilir.</span><span class="sxs-lookup"><span data-stu-id="c6616-185">This value may never actually exist in the database if the first transaction is not committed.</span></span>  
  
-   <span data-ttu-id="c6616-186">Birinci işlem geri alınır ve silerek temizler **TestSnapshot** tablo ve kapatma anlık görüntü yalıtımı için **AdventureWorks** veritabanı.</span><span class="sxs-lookup"><span data-stu-id="c6616-186">It rolls back the first transaction and cleans up by deleting the **TestSnapshot** table and turning off snapshot isolation for the **AdventureWorks** database.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c6616-187">Aşağıdaki örnekler aynı bağlantı dizesini bağlantı havuzu ile kapalı kullanın.</span><span class="sxs-lookup"><span data-stu-id="c6616-187">The following examples use the same connection string with connection pooling turned off.</span></span> <span data-ttu-id="c6616-188">Bir bağlantı havuza, yalıtım düzeyi sıfırlama sunucu yalıtım düzeyinde sıfırlamaz.</span><span class="sxs-lookup"><span data-stu-id="c6616-188">If a connection is pooled, resetting its isolation level does not reset the isolation level at the server.</span></span> <span data-ttu-id="c6616-189">Sonuç olarak, aynı havuza alınmış iç bağlantı kullanan sonraki bağlantılar, havuza alınan bağlantı düzeylerini ayarlamak kullanıcıların yalıtım başlayın.</span><span class="sxs-lookup"><span data-stu-id="c6616-189">As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection.</span></span> <span data-ttu-id="c6616-190">Bağlantı havuzu devre dışı kapatma açıkça her bağlantı için yalıtım düzeyini ayarlamak için alternatiftir.</span><span class="sxs-lookup"><span data-stu-id="c6616-190">An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  
  
### <a name="example"></a><span data-ttu-id="c6616-191">Örnek</span><span class="sxs-lookup"><span data-stu-id="c6616-191">Example</span></span>  
 <span data-ttu-id="c6616-192">Aşağıdaki örnek, veri değiştirildiğinde anlık görüntü yalıtım davranışını gösterir.</span><span class="sxs-lookup"><span data-stu-id="c6616-192">The following example demonstrates the behavior of snapshot isolation when data is being modified.</span></span> <span data-ttu-id="c6616-193">Kod aşağıdaki eylemleri gerçekleştirir:</span><span class="sxs-lookup"><span data-stu-id="c6616-193">The code performs the following actions:</span></span>  
  
-   <span data-ttu-id="c6616-194">Bağlandığı **AdventureWorks** örnek anlık görüntü yalıtımı veritabanı ve etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="c6616-194">Connects to the **AdventureWorks** sample database and enables SNAPSHOT isolation.</span></span>  
  
-   <span data-ttu-id="c6616-195">Adlı bir tablo oluşturur **TestSnapshotUpdate** ve üç örnek veri satırı ekler.</span><span class="sxs-lookup"><span data-stu-id="c6616-195">Creates a table named **TestSnapshotUpdate** and inserts three rows of sample data.</span></span>  
  
-   <span data-ttu-id="c6616-196">Başlar, ancak tamamlamaz, sqlTransaction1 anlık görüntü yalıtımını kullanarak.</span><span class="sxs-lookup"><span data-stu-id="c6616-196">Begins, but does not complete, sqlTransaction1 using SNAPSHOT isolation.</span></span> <span data-ttu-id="c6616-197">Üç veri satırı işlemde seçilir.</span><span class="sxs-lookup"><span data-stu-id="c6616-197">Three rows of data are selected in the transaction.</span></span>  
  
-   <span data-ttu-id="c6616-198">İkinci bir oluşturur **SqlConnection** için **AdventureWorks** ve sqlTransaction1 içinde seçilen satır birindeki bir değer güncelleştirmeleri READ COMMITTED yalıtım düzeyi kullanılarak ikinci bir hareket oluşturur.</span><span class="sxs-lookup"><span data-stu-id="c6616-198">Creates a second **SqlConnection** to **AdventureWorks** and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1.</span></span>  
  
-   <span data-ttu-id="c6616-199">SqlTransaction2 kaydeder.</span><span class="sxs-lookup"><span data-stu-id="c6616-199">Commits sqlTransaction2.</span></span>  
  
-   <span data-ttu-id="c6616-200">SqlTransaction1 ve aynı satır güncelleştirme denemeleri zaten kaydedilmiş bu sqlTransaction1 döndürür.</span><span class="sxs-lookup"><span data-stu-id="c6616-200">Returns to sqlTransaction1 and attempts to update the same row that sqlTransaction1 already committed.</span></span> <span data-ttu-id="c6616-201">Hata 3960 tetiklenir ve sqlTransaction1 geri otomatik olarak alınır.</span><span class="sxs-lookup"><span data-stu-id="c6616-201">Error 3960 is raised, and sqlTransaction1 is rolled back automatically.</span></span> <span data-ttu-id="c6616-202">**SqlException.Number** ve **SqlException.Message** konsol penceresinde görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="c6616-202">The **SqlException.Number** and **SqlException.Message** are displayed in the Console window.</span></span>  
  
-   <span data-ttu-id="c6616-203">Anlık görüntü yalıtım modunda devre dışı bırakmak için temizleme kodu yürütür **AdventureWorks** ve silme **TestSnapshotUpdate** tablo.</span><span class="sxs-lookup"><span data-stu-id="c6616-203">Executes clean-up code to turn off snapshot isolation in **AdventureWorks** and delete the **TestSnapshotUpdate** table.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  
  
### <a name="using-lock-hints-with-snapshot-isolation"></a><span data-ttu-id="c6616-204">Anlık görüntü yalıtımıyla kilit ipuçlarına kullanma</span><span class="sxs-lookup"><span data-stu-id="c6616-204">Using Lock Hints with Snapshot Isolation</span></span>  
 <span data-ttu-id="c6616-205">Önceki örnekte, birinci işlem verileri seçer ve birinci işlem tamamlamak açmadan önce ikinci bir hareket verileri birinci işlem aynı satır güncelleştirmeye çalıştığında bir güncelleme çakışması neden güncelleştirir.</span><span class="sxs-lookup"><span data-stu-id="c6616-205">In the previous example, the first transaction selects data, and a second transaction updates the data before the first transaction is able to complete, causing an update conflict when the first transaction tries to update the same row.</span></span> <span data-ttu-id="c6616-206">İşlem başına kilit ipuçlarına sağlayarak uzun süre çalışan anlık işlemleri güncelleştirme çakışma olasılığı azaltabilir.</span><span class="sxs-lookup"><span data-stu-id="c6616-206">You can reduce the chance of update conflicts in long-running snapshot transactions by supplying lock hints at the beginning of the transaction.</span></span> <span data-ttu-id="c6616-207">Aşağıdaki SELECT deyimi UPDLOCK ipucu seçili satırları kilitlemek için kullanır:</span><span class="sxs-lookup"><span data-stu-id="c6616-207">The following SELECT statement uses the UPDLOCK hint to lock the selected rows:</span></span>  
  
```  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)   
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
 <span data-ttu-id="c6616-208">UPDLOCK kilit ipucuna bloğu birinci işlem tamamlanmadan önce satırları güncelleştirme girişimi herhangi bir satır kullanma.</span><span class="sxs-lookup"><span data-stu-id="c6616-208">Using the UPDLOCK lock hint blocks any rows attempting to update the rows before the first transaction completes.</span></span> <span data-ttu-id="c6616-209">Bu işlem içinde güncelleştirildiği seçili satırları çakışmalar olmasını güvence altına alır.</span><span class="sxs-lookup"><span data-stu-id="c6616-209">This guarantees that the selected rows have no conflicts when they are updated later in the transaction.</span></span> <span data-ttu-id="c6616-210">SQL Server Books Online içindeki "kilitleme ipuçları" konusuna bakın.</span><span class="sxs-lookup"><span data-stu-id="c6616-210">See "Locking Hints" in SQL Server Books Online.</span></span>  
  
 <span data-ttu-id="c6616-211">Uygulamanız çok fazla çakışma varsa, anlık görüntü yalıtımı en iyi seçenek olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="c6616-211">If your application has many conflicts, snapshot isolation may not be the best choice.</span></span> <span data-ttu-id="c6616-212">İpuçları yalnızca gerçekten gerekli olduğunda kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="c6616-212">Hints should only be used when really needed.</span></span> <span data-ttu-id="c6616-213">Sürekli olarak çalışması için kilit ipuçlarına kullanır. böylece uygulamanız tasarlanmalıdır değil.</span><span class="sxs-lookup"><span data-stu-id="c6616-213">Your application should not be designed so that it constantly relies on lock hints for its operation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c6616-214">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="c6616-214">See Also</span></span>  
 [<span data-ttu-id="c6616-215">SQL Server ve ADO.NET</span><span class="sxs-lookup"><span data-stu-id="c6616-215">SQL Server and ADO.NET</span></span>](../../../../../docs/framework/data/adonet/sql/index.md)  
 [<span data-ttu-id="c6616-216">ADO.NET yönetilen sağlayıcıları ve veri kümesi Geliştirici Merkezi</span><span class="sxs-lookup"><span data-stu-id="c6616-216">ADO.NET Managed Providers and DataSet Developer Center</span></span>](http://go.microsoft.com/fwlink/?LinkId=217917)

---
title: Altyapı saklama katmanını tasarlama
description: Kapsayıcılı .NET uygulamaları için .NET mikro mimarisi | Altyapı saklama katmanını tasarlama
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 11/08/2017
ms.openlocfilehash: 9da1020ac5b43971a8f976c518f4537bec866c26
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/29/2018
ms.locfileid: "37105852"
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="458a1-103">Altyapı saklama katmanını tasarlama</span><span class="sxs-lookup"><span data-stu-id="458a1-103">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="458a1-104">Veri kalıcılığı bileşenleri mikro hizmet (diğer bir deyişle, bir mikro 's veritabanı) sınırları içinde barındırılan verilere erişim sağlar.</span><span class="sxs-lookup"><span data-stu-id="458a1-104">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="458a1-105">Depoları gibi bileşenlerinin gerçek uygulamayı içerir ve [iş birimi](https://martinfowler.com/eaaCatalog/unitOfWork.html) özel EF DBContexts gibi sınıflara.</span><span class="sxs-lookup"><span data-stu-id="458a1-105">They contain the actual implementation of components such as repositories and [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom EF DBContexts.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="458a1-106">Depo düzeni</span><span class="sxs-lookup"><span data-stu-id="458a1-106">The Repository pattern</span></span>

<span data-ttu-id="458a1-107">Depoları sınıfları veya veri kaynaklarına erişmek için gerekli mantığı kapsülleyen bileşenler markalarıdır.</span><span class="sxs-lookup"><span data-stu-id="458a1-107">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="458a1-108">Bunlar daha iyi bakım sağlayarak ve altyapı ya da etki alanı modeli katmandan veritabanlarına erişmek için kullanılan teknoloji kesilmesi ortak veri erişim işlevselliği, merkezileştirme.</span><span class="sxs-lookup"><span data-stu-id="458a1-108">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="458a1-109">Entity Framework gibi bir ORM kullanırsanız, uygulanmalı kod, LINQ ve güçlü yazarak sayesinde basitleştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="458a1-109">If you use an ORM like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="458a1-110">Bu erişmelerine tesisat veri kalıcılığı mantığı yerine veri odaklanmanıza olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="458a1-110">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="458a1-111">Depo düzeni, veri kaynağı ile çalışmanın iyi belgelenmiş bir yoludur.</span><span class="sxs-lookup"><span data-stu-id="458a1-111">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="458a1-112">Kitaptaki [Kurumsal uygulama mimarisi desenleri](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler depo gibi açıklar:</span><span class="sxs-lookup"><span data-stu-id="458a1-112">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

<span data-ttu-id="458a1-113">Depo bir etki alanı nesneleri bellekte kümesi benzer bir şekilde davranan bir aracı veri eşleme ve etki alanı modeli katmanlar arasında görevleri gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="458a1-113">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="458a1-114">İstemci nesneleri bildirimli olarak sorgular oluşturmak ve bunları yanıtlar için depoları gönderir.</span><span class="sxs-lookup"><span data-stu-id="458a1-114">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="458a1-115">Kavramsal olarak, bir depo veritabanı ve saklama katmanını daha yakın olan bir yol sağlayarak bunlar üzerinde gerçekleştirilen işlemler depolanan nesneler kümesini yalıtır.</span><span class="sxs-lookup"><span data-stu-id="458a1-115">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="458a1-116">Depoları, ayrıca, iş etki alanı ve veri ayırma arasındaki bağımlılığı açıkça ve bir yönde ayırma veya eşlemesi amacını desteklemez.</span><span class="sxs-lookup"><span data-stu-id="458a1-116">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="458a1-117">Bir havuz başına toplam tanımlayın</span><span class="sxs-lookup"><span data-stu-id="458a1-117">Define one repository per aggregate</span></span>

<span data-ttu-id="458a1-118">Her toplama veya toplama kökü için bir depo sınıfına oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="458a1-118">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="458a1-119">Etki alanı Odaklı Tasarım Desenleri esas alarak bir mikro içinde veritabanını güncelleştirmek için kullanması gereken yalnızca kanal depoları olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="458a1-119">In a microservice based on domain-driven design patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="458a1-120">Bire bir ilişki toplama 's invariants ve işlemsel tutarlılık denetimleri toplama köküne sahip olan olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="458a1-120">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="458a1-121">Diğer aracılığıyla veritabanını sorgulamak uygundur kanallar (CQRS yaklaşımı yapabilirsiniz gibi), sorguları veritabanının durumu değiştirmeyin çünkü.</span><span class="sxs-lookup"><span data-stu-id="458a1-121">It is okay to query the database through other channels (as you can do following a CQRS approach), because queries do not change the state of the database.</span></span> <span data-ttu-id="458a1-122">Ancak, işlem alanı — güncelleştirmeleri — her zaman depoları ve birleşik kökleri tarafından denetlenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="458a1-122">However, the transactional area—the updates—must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="458a1-123">Temel olarak, bir depo, etki alanı varlıklar biçiminde veritabanından gelen bellekte verilerini doldurmak sağlar.</span><span class="sxs-lookup"><span data-stu-id="458a1-123">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="458a1-124">Varlıkları bellekte eklendiğinde bunlar değiştirilebilir ve işlemler üzerinden veritabanına kalıcı.</span><span class="sxs-lookup"><span data-stu-id="458a1-124">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="458a1-125">CQS/CQRS tasarım örüntüsü kullanıyorsanız, daha önce belirtildiği gibi ilk sorguları Dapper kullanarak basit SQL deyimleri tarafından gerçekleştirilen etki alanı modeli dışında yan sorgular tarafından gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="458a1-125">As noted earlier, if you are using the CQS/CQRS architectural pattern, the initial queries will be performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="458a1-126">Bu yaklaşım depoları daha esnek sorgu ve tablo birleştirme için gereken ve bu sorguların toplamalar kuralları tarafından sınırlı değildir çok daha fazladır.</span><span class="sxs-lookup"><span data-stu-id="458a1-126">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries are not restricted by rules from the aggregates.</span></span> <span data-ttu-id="458a1-127">Bu verileri, sunu katmanı veya istemci uygulamaya gider.</span><span class="sxs-lookup"><span data-stu-id="458a1-127">That data will go to the presentation layer or client app.</span></span>

<span data-ttu-id="458a1-128">Kullanıcı değişiklikler yaparsa, güncelleştirilmesi için verileri (örneğin, bir Web API hizmeti) uygulama katmanına istemci uygulaması ya da sunu katmanı gelecektir.</span><span class="sxs-lookup"><span data-stu-id="458a1-128">If the user makes changes, the data to be updated will come from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="458a1-129">Komut işleyicisinde bir komutla (veri) aldığınızda, veritabanından güncelleştirmek istediğiniz veri almak için depoları kullanın.</span><span class="sxs-lookup"><span data-stu-id="458a1-129">When you receive a command (with data) in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="458a1-130">Bellekte komutlarıyla geçirilen bilgileriyle güncelleştirmeniz ve ardından ekleyin veya bir işlem aracılığıyla veritabanındaki verileri (etki alanı varlıklar) güncelleştirin.</span><span class="sxs-lookup"><span data-stu-id="458a1-130">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="458a1-131">Bu yalnızca bir depo her toplama kökü için tanımlanmalıdır, Şekil 9-17'de gösterildiği gibi unutmayın.</span><span class="sxs-lookup"><span data-stu-id="458a1-131">Remember that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="458a1-132">Toplama içindeki tüm nesneler arasında işlemsel tutarlılık sağlamak için birleşik kök hedefe ulaşmak için hiçbir zaman veritabanında her tablo için depo oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="458a1-132">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="458a1-133">**Şekil 9-17**.</span><span class="sxs-lookup"><span data-stu-id="458a1-133">**Figure 9-17**.</span></span> <span data-ttu-id="458a1-134">Depoları, toplamları ve veritabanı tabloları arasındaki ilişki</span><span class="sxs-lookup"><span data-stu-id="458a1-134">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="458a1-135">Havuz başına bir toplama kök zorlama</span><span class="sxs-lookup"><span data-stu-id="458a1-135">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="458a1-136">Yalnızca toplama kökleri depoları olmalıdır kural zorlar deposu tasarımınızı şekilde uygulamak için yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="458a1-136">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="458a1-137">IAggregateRoot işaret arabirimi sahip olduklarından emin olmak için birlikte çalıştığı varlık türünü kısıtlayan bir genel veya temel depo türü oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="458a1-137">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the IAggregateRoot marker interface.</span></span>

<span data-ttu-id="458a1-138">Bu nedenle, altyapı katmanında uygulanan her depo sınıfına aşağıdaki kodda gösterildiği gibi kendi sözleşme veya arabirimini uygulayan:</span><span class="sxs-lookup"><span data-stu-id="458a1-138">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
```

<span data-ttu-id="458a1-139">Her özel depo arabirimi genel IRepository arabirimini uygulayan:</span><span class="sxs-lookup"><span data-stu-id="458a1-139">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="458a1-140">Ancak, kuralı zorunlu kodu daha iyi bir yolu, bir depo belirli bir toplama hedeflemek için kullandığınız açık olacak şekilde bir genel depo türü uygulamak için her deposu için tek bir toplama ilgili emin olur.</span><span class="sxs-lookup"><span data-stu-id="458a1-140">However, a better way to have the code enforce the convention that each repository should be related to a single aggregate would be to implement a generic repository type so it is explicit that you are using a repository to target a specific aggregate.</span></span> <span data-ttu-id="458a1-141">Bu, aşağıdaki kod olduğu gibi IRepository temel arabirim o genel uygulayarak kolayca gerçekleştirilebilir:</span><span class="sxs-lookup"><span data-stu-id="458a1-141">That can be easily done by implementing that generic in the IRepository base interface, as in the following code:</span></span>

```csharp
  public interface IRepository<T> where T : IAggregateRoot
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="458a1-142">Depo düzeni, uygulamanızın mantığı test kolaylaştırır</span><span class="sxs-lookup"><span data-stu-id="458a1-142">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="458a1-143">Havuz deseni kolayca uygulamanız ile birim testleri test etmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="458a1-143">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="458a1-144">Depo soyutlamalar bu hedefe ulaşmak kolaylaştırmak için birim testleri yalnızca kodu, değil altyapı, test olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="458a1-144">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="458a1-145">Bir önceki bölümünde belirtildiği gibi tanımlayın ve (örneğin, Web API mikro) uygulama katmanı altyapı katmanda doğrudan bağlı değildir şekilde deposu arabirimleri etki alanı modeli katmanında olduğu yerleştirin önerilir. Gerçek depo sınıflarını uygulanmadı.</span><span class="sxs-lookup"><span data-stu-id="458a1-145">As noted in an earlier section, it is recommended that you define and place the repository interfaces in the domain model layer so the application layer (for instance, your Web API microservice) does not depend directly on the infrastructure layer where you have implemented the actual repository classes.</span></span> <span data-ttu-id="458a1-146">Bunun yapılması ve Web API denetleyicilerinin içinde bağımlılık ekleme kullanılarak veritabanından veri yerine sahte veriler döndürmek sahte depoları uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="458a1-146">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="458a1-147">Ayrılmış bir yaklaşım oluşturmanıza olanak sağlar ve çalışma birim testleri yalnızca, uygulama mantığını veritabanı bağlantısı gerektirmeden test edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="458a1-147">That decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="458a1-148">Veritabanı bağlantıları başarısız olabilir ve daha da önemlisi, bir veritabanına karşı testleri yüzlerce çalıştıran iki nedenden dolayı bozuk.</span><span class="sxs-lookup"><span data-stu-id="458a1-148">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="458a1-149">İlk olarak, bu sayıda testleri nedeniyle çok zaman alabilir.</span><span class="sxs-lookup"><span data-stu-id="458a1-149">First, it can take a lot of time because of the large number of tests.</span></span> <span data-ttu-id="458a1-150">İkinci olarak, veritabanı kayıtlarını bir değiştirebilir ve böylece bunlar tutarlı olmayabilir, test sonuçlarını etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="458a1-150">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="458a1-151">Veritabanına karşı test bir birim testleri ancak bir tümleştirme test değil.</span><span class="sxs-lookup"><span data-stu-id="458a1-151">Testing against the database is not a unit tests but an integration test.</span></span> <span data-ttu-id="458a1-152">Hızlı çalışan birçok birim testleri olmalıdır, ancak daha az tümleştirme veritabanları karşı sınar.</span><span class="sxs-lookup"><span data-stu-id="458a1-152">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="458a1-153">Birim testleri endişelerini ayrılması açısından, etki alanı varlıkları bellekte mantığınızı çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="458a1-153">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="458a1-154">Bu depo sınıfını olanlar teslim varsayar.</span><span class="sxs-lookup"><span data-stu-id="458a1-154">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="458a1-155">Etki alanı varlıkları mantığınızı değiştirir sonra depo sınıfını bunları doğru depolayacak varsayar.</span><span class="sxs-lookup"><span data-stu-id="458a1-155">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="458a1-156">Burada önemli olan nokta, etki alanı modeli ve kendi etki alanı mantığı karşı birim testleri oluşturmaktır.</span><span class="sxs-lookup"><span data-stu-id="458a1-156">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="458a1-157">Birleşik kökleri GGG, ana tutarlılık sınırları değildir.</span><span class="sxs-lookup"><span data-stu-id="458a1-157">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="458a1-158">Depo düzeni ve eski veri erişimi sınıfı (DAL sınıfı) düzeni arasındaki fark</span><span class="sxs-lookup"><span data-stu-id="458a1-158">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="458a1-159">Veri erişim nesnesi doğrudan depolama karşı veri erişimi ve sürdürme işlemleri gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="458a1-159">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="458a1-160">İş nesnesi (EF) DbContext kullanırken olduğu gibi ancak bu güncelleştirmeler birimi bellekte gerçekleştirmek istediğiniz işlem verilerle hemen gerçekleştirilen olmayan depo işaretler.</span><span class="sxs-lookup"><span data-stu-id="458a1-160">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the DbContext), but these updates aren't performed immediately.</span></span>

<span data-ttu-id="458a1-161">Bir iş birimine birden çok Ekle içeren tek bir işlem olarak güncelleştirme veya silme işlemleri için denir.</span><span class="sxs-lookup"><span data-stu-id="458a1-161">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="458a1-162">Basitçe, belirli bir kullanıcı eylemi (örneğin, bir Web sitesinde kayıt), tüm INSERT, update ve delete işlemleri tek bir işlemde işlenme anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="458a1-162">In simple terms, it means that for a specific user action (for example, registration on a website), all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="458a1-163">Bu, birden çok veritabanı işlemleri chattier şekilde işleme değerinden daha verimli olur.</span><span class="sxs-lookup"><span data-stu-id="458a1-163">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="458a1-164">Bu uygulama katmanı kodunuzdan komutlarını çalıştırırken bu birden çok Kalıcılık işlemleri daha sonra tek bir eylemle gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="458a1-164">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="458a1-165">Asıl veritabanını depolama birimine bellek içi değişiklikleri uygulamadan hakkında karar genellikle dayanır [iş birimi düzeni](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="458a1-165">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="458a1-166">EF içinde iş birimi düzeni DBContext uygulanır.</span><span class="sxs-lookup"><span data-stu-id="458a1-166">In EF, the Unit of Work pattern is implemented as the DBContext.</span></span>

<span data-ttu-id="458a1-167">Çoğu durumda bu deseni veya depolama karşı işlemleri uygulamanın yolu uygulama performansını artırmak ve tutarsızlıklar olasılığını azaltmak.</span><span class="sxs-lookup"><span data-stu-id="458a1-167">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="458a1-168">Ayrıca, tüm hedeflenen işlemleri bir işlemin bir parçası olarak kaydedilmiş olduğundan veritabanı tablolarında engelleme işlem azaltır.</span><span class="sxs-lookup"><span data-stu-id="458a1-168">Also, it reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="458a1-169">Bu veritabanında çok sayıda yalıtılmış işlemleri yürütülürken kıyasla daha verimli olur.</span><span class="sxs-lookup"><span data-stu-id="458a1-169">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="458a1-170">Bu nedenle, seçili ORM çok sayıda küçük ve ayrı işlem yürütmeleri aksine aynı işlem içindeki birkaç güncelleştirme eylemleri gruplandırarak veritabanında yürütme iyileştirebilir.</span><span class="sxs-lookup"><span data-stu-id="458a1-170">Therefore, the selected ORM is able to optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-should-not-be-mandatory"></a><span data-ttu-id="458a1-171">Depoları zorunlu olmamalıdır</span><span class="sxs-lookup"><span data-stu-id="458a1-171">Repositories should not be mandatory</span></span>

<span data-ttu-id="458a1-172">Özel depoları daha önce bildirdi nedenlerle yararlıdır ve sıralama mikro hizmet eShopOnContainers içinde bir yaklaşım olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="458a1-172">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="458a1-173">Ancak, bir DDD tasarımı uygulamak ve hatta genel .NET geliştirme için temel bir desen değil.</span><span class="sxs-lookup"><span data-stu-id="458a1-173">However, it is not an essential pattern to implement in a DDD design or even in general development in .NET.</span></span>

<span data-ttu-id="458a1-174">Örneği için Jimmy bu kılavuz, doğrudan geribildirimi verirken Bogard aşağıda belirtilmektedir:</span><span class="sxs-lookup"><span data-stu-id="458a1-174">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

<span data-ttu-id="458a1-175">Bu büyük olasılıkla büyük bildirimimle olması.</span><span class="sxs-lookup"><span data-stu-id="458a1-175">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="458a1-176">Çoğunlukla bunlar temel kalıcılığı mekanizmasının önemli ayrıntıları gizlemek için gerçekten, depolarının fan değilim.</span><span class="sxs-lookup"><span data-stu-id="458a1-176">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="458a1-177">Buna ait neden MediatR için komutları için çok duruma.</span><span class="sxs-lookup"><span data-stu-id="458a1-177">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="458a1-178">I saklama katmanını gücünü kullanın ve bu etki alanı davranışı toplama my kökleri gönderme.</span><span class="sxs-lookup"><span data-stu-id="458a1-178">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="458a1-179">Genellikle my depoları mock istemiyorum – hala bu tümleştirmesine sahip istiyorum gerçek bir şey ile test.</span><span class="sxs-lookup"><span data-stu-id="458a1-179">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="458a1-180">CQRS giderek biz gerçekten depoları gereksinimini daha olmadığına yönelikti anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="458a1-180">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="458a1-181">Biz depoları kullanışlı ancak toplama düzeni ve zengin etki alanı modeli şekilde, DDD kritik olmadıklarını bildiremedi.</span><span class="sxs-lookup"><span data-stu-id="458a1-181">We find repositories useful, but we acknowledge that they are not critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="458a1-182">Bu nedenle, havuz deseni kullanıp, gördüğünüz gibi sığmayacak.</span><span class="sxs-lookup"><span data-stu-id="458a1-182">Therefore, use the Repository pattern or not, as you see fit.</span></span>

## <a name="the-specification-pattern"></a><span data-ttu-id="458a1-183">Belirtimi düzeni</span><span class="sxs-lookup"><span data-stu-id="458a1-183">The Specification pattern</span></span>

<span data-ttu-id="458a1-184">(Tam adını sorgu belirtimi düzeni olur) belirtimi Düzen burada bir sorgu tanımını sıralama ve mantıksal disk belleği isteğe bağlı koyabilirsiniz yer olarak tasarlanmış bir Domain-Driven tasarım deseni yöneliktir.</span><span class="sxs-lookup"><span data-stu-id="458a1-184">The Specification pattern (its full name would be Query-specification pattern) is a Domain-Driven Design pattern designed as the place where you can put the definition of a query with optional sorting and paging logic.</span></span>

<span data-ttu-id="458a1-185">Belirtimi düzeni sorguda bir nesne tanımlar.</span><span class="sxs-lookup"><span data-stu-id="458a1-185">The Specification pattern defines a query in an object.</span></span> <span data-ttu-id="458a1-186">Örneğin, bazı ürünler için arayan bir disk belleğine alınan sorgu kapsüllemek için gerekli giriş parametreleri (pageNumber, pageSize, filtre, vb.) alır PagedProduct belirtimi oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="458a1-186">For example, in order to encapsulate a paged query that searches for some products, you can create a PagedProduct specification that takes the necessary input parameters (pageNumber, pageSize, filter, etc.).</span></span> <span data-ttu-id="458a1-187">Sonra tüm depo yöntemi (genellikle bir List() aşırı) içinde bir ISpecification kabul ve o belirtimine göre beklenen sorgusunu çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="458a1-187">Then, within any Repository method (usually a List() overload) it would accept an ISpecification and run the expected query based on that specification.</span></span>

<span data-ttu-id="458a1-188">Bu yaklaşımın birkaç avantaj vardır:</span><span class="sxs-lookup"><span data-stu-id="458a1-188">There are several benefits to this approach:</span></span>

* <span data-ttu-id="458a1-189">Belirtimi hakkında tartışın bir ad (aksine, sadece bir grup LINQ ifadeleri) içeriyor.</span><span class="sxs-lookup"><span data-stu-id="458a1-189">The specification has a name (as opposed to just a bunch of LINQ expressions) that you can discuss about.</span></span>

* <span data-ttu-id="458a1-190">Belirtimi doğru olduğundan emin olmak için birim yalıtım modunda test olabilir.</span><span class="sxs-lookup"><span data-stu-id="458a1-190">The specification can be unit tested in isolation to ensure it is right.</span></span> <span data-ttu-id="458a1-191">Benzer davranış ihtiyacınız varsa onu da kolayca yeniden kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="458a1-191">It can also easily be reused if you need similar behavior.</span></span> <span data-ttu-id="458a1-192">Örneğin bir MVC görünümü eylem ve bir Web API eylemi yanı sıra çeşitli Hizmetleri'nde.</span><span class="sxs-lookup"><span data-stu-id="458a1-192">For example, on an MVC View action and a Web API action, as well as in various services.</span></span>

* <span data-ttu-id="458a1-193">Bir belirtimi döndürülecek veri şekli tanımlamak için de kullanılabilir, yalnızca verileri sorgular dönebilmek bunlar gerekli.</span><span class="sxs-lookup"><span data-stu-id="458a1-193">A specification can also be used to describe the shape of the data to be returned, so that queries can return just the data they required.</span></span> <span data-ttu-id="458a1-194">Bu web uygulamaları (Bu, genellikle iyi bir fikir değil) geç yükleme gereksinimini ortadan kaldırır ve bu ayrıntılarla kalabalık haline gelen deposu uygulamaları tutar.</span><span class="sxs-lookup"><span data-stu-id="458a1-194">This eliminates the need for lazy loading in web applications (which is usually not a good idea) and helps keep repository implementations from becoming cluttered with these details.</span></span>

<span data-ttu-id="458a1-195">Bir genel belirtimi arabirimi, aşağıdaki kod örneğidir [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb ).</span><span class="sxs-lookup"><span data-stu-id="458a1-195">An example of a generic Specification interface is the following code from [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb ).</span></span>

```csharp
// https://github.com/dotnet-architecture/eShopOnWeb 
public interface ISpecification<T>
{
    Expression<Func<T, bool>> Criteria { get; }
    List<Expression<Func<T, object>>> Includes { get; }
    List<string> IncludeStrings { get; }
}
```

<span data-ttu-id="458a1-196">Yaklaşan bölümlerde nasıl Entity Framework Çekirdek 2.0 belirtimi desenle uygulanacağını ve herhangi bir havuz sınıfın kullanma anlatılmıştır.</span><span class="sxs-lookup"><span data-stu-id="458a1-196">In the upcoming sections, it is explained how to implement the Specification pattern with Entity Framework Core 2.0 and how to use it from any Repository class.</span></span>

<span data-ttu-id="458a1-197">**Önemli Not:** belirtimi desen aşağıdaki ek kaynaklara olduğu gibi birçok farklı şekillerde uygulanabilir eski bir düzeni olduğunu.</span><span class="sxs-lookup"><span data-stu-id="458a1-197">**Important note:** The specification pattern is an old pattern that can be implemented in many different ways, as in the following additional resources.</span></span> <span data-ttu-id="458a1-198">Bir desen/fikir eski yaklaşımlar iyi biliyorum, ancak LINQ ve ifadeler gibi modern dil özelliklerinden olmuyor eski uygulamalarının kaybolacağını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="458a1-198">As a pattern/idea, older approaches are good to know, but beware of older implementations that are not taking advantage of modern language capabilities like Linq and expressions.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="458a1-199">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="458a1-199">Additional resources</span></span>

### <a name="the-repository-pattern"></a><span data-ttu-id="458a1-200">Depo düzeni</span><span class="sxs-lookup"><span data-stu-id="458a1-200">The Repository pattern</span></span>

-   <span data-ttu-id="458a1-201">**Edward Hieatt ve Ramiz bana. Depo düzeni.**
    [*https://martinfowler.com/eaaCatalog/repository.html*](https://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="458a1-201">**Edward Hieatt and Rob Mee. Repository pattern.**
[*https://martinfowler.com/eaaCatalog/repository.html*](https://martinfowler.com/eaaCatalog/repository.html)</span></span>

-   <span data-ttu-id="458a1-202">**Depo düzeni**
    [*https://msdn.microsoft.com/library/ff649690.aspx*](https://msdn.microsoft.com/library/ff649690.aspx)</span><span class="sxs-lookup"><span data-stu-id="458a1-202">**The Repository pattern**
[*https://msdn.microsoft.com/library/ff649690.aspx*](https://msdn.microsoft.com/library/ff649690.aspx)</span></span>

-   <span data-ttu-id="458a1-203">**Depo düzeni: Bir veri Kalıcılık özeti**
    [*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="458a1-203">**Repository Pattern: A data persistence abstraction**
[*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span></span>

-   <span data-ttu-id="458a1-204">**Eric Evans. Etki alanı Odaklı Tasarım: Yazılım Kalp karmaşıklığı Tackling.**</span><span class="sxs-lookup"><span data-stu-id="458a1-204">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="458a1-205">(Kitap; havuz deseni tartışması içerir) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="458a1-205">(Book; includes a discussion of the Repository pattern) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="458a1-206">Çalışma deseni birimi</span><span class="sxs-lookup"><span data-stu-id="458a1-206">Unit of Work pattern</span></span>

-   <span data-ttu-id="458a1-207">**Martin Fowler. Çalışma deseni birimidir.**
    [*https://martinfowler.com/eaaCatalog/unitOfWork.html*](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="458a1-207">**Martin Fowler. Unit of Work pattern.**
[*https://martinfowler.com/eaaCatalog/unitOfWork.html*](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

<!-- -->

-   <span data-ttu-id="458a1-208">**Bir ASP.NET MVC uygulamasındaki depo ve iş desenleri ölçü uygulama**
    [*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span><span class="sxs-lookup"><span data-stu-id="458a1-208">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>

### <a name="the-specification-pattern"></a><span data-ttu-id="458a1-209">Belirtimi düzeni</span><span class="sxs-lookup"><span data-stu-id="458a1-209">The Specification pattern</span></span>

-   <span data-ttu-id="458a1-210">**Belirtimi deseni.**
    [*http://deviq.com/specification-pattern/*](http://deviq.com/specification-pattern/)</span><span class="sxs-lookup"><span data-stu-id="458a1-210">**The Specification pattern.**
[*http://deviq.com/specification-pattern/*](http://deviq.com/specification-pattern/)</span></span>

-   <span data-ttu-id="458a1-211">**Evans, Eric (2004). Tasarım güdümlü bir etki alanı. Addison-Wesley. p. 224.**</span><span class="sxs-lookup"><span data-stu-id="458a1-211">**Evans, Eric (2004). Domain Driven Design. Addison-Wesley. p. 224.**</span></span>

-   <span data-ttu-id="458a1-212">**Belirtimleri. Martin Fowler**
    [*https://www.martinfowler.com/apsupp/spec.pdf/*](https://www.martinfowler.com/apsupp/spec.pdf)</span><span class="sxs-lookup"><span data-stu-id="458a1-212">**Specifications. Martin Fowler**
[*https://www.martinfowler.com/apsupp/spec.pdf/*](https://www.martinfowler.com/apsupp/spec.pdf)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="458a1-213">[Önceki](domain-events-design-implementation.md)
[sonraki](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="458a1-213">[Previous](domain-events-design-implementation.md)
[Next](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>

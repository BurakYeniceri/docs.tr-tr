---
title: Desen eşleştirme C# Kılavuzu
description: C# ' ifadelerin eşleşen kalıbı hakkında bilgi edinin
ms.date: 01/24/2017
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 635ab45c89a38f3dedac2d60ea1e31ebf394c9b2
ms.sourcegitcommit: 2ad7d06f4f469b5d8a5280ac0e0289a81867fc8e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/08/2018
ms.locfileid: "35231482"
---
# <a name="pattern-matching"></a><span data-ttu-id="d30e9-103">Desen Eşleştirme</span><span class="sxs-lookup"><span data-stu-id="d30e9-103">Pattern Matching</span></span> #

<span data-ttu-id="d30e9-104">Desenler test değerine belirli bir sahip *şekil*ve *ayıklamak* eşleşen şekil olduğunda değeri bilgileri.</span><span class="sxs-lookup"><span data-stu-id="d30e9-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="d30e9-105">Desen eşleştirme zaten günümüzde kullandığınız algoritmalar için daha az sözdizimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="d30e9-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="d30e9-106">Zaten varolan sözdizimini kullanarak algoritmaları eşleşen kalıbı oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="d30e9-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="d30e9-107">Yazdığınız `if` veya `switch` test değerleri deyimleri.</span><span class="sxs-lookup"><span data-stu-id="d30e9-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="d30e9-108">Ardından, bu deyimleri eşleştiğinde, ayıklayın ve bu değeri bilgileri kullanın.</span><span class="sxs-lookup"><span data-stu-id="d30e9-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="d30e9-109">Yeni söz dizimi öğeleri, zaten aşina deyimleri uzantıları: `is` ve `switch`.</span><span class="sxs-lookup"><span data-stu-id="d30e9-109">The new syntax elements are extensions to statements you are already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="d30e9-110">Bu yeni uzantılar bir değer test etme ve bu bilgileri ayıklama birleştirin.</span><span class="sxs-lookup"><span data-stu-id="d30e9-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="d30e9-111">Bu konuda, biz nasıl okunabilir, kısa kod etkinleştirir göstermek için yeni sözdizimine göreceğiz.</span><span class="sxs-lookup"><span data-stu-id="d30e9-111">In this topic, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="d30e9-112">Desen eşleştirme burada veri ve kod, burada veri ve üzerlerinde değişiklik yöntemleri sıkı şekilde bağlı nesne yönelimli tasarımları ayrılır deyimleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="d30e9-112">Pattern matching enables idioms where data and the code are separated, unlike object oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="d30e9-113">Bu yeni deyimleri göstermek için şimdi deyimleri eşleşen kalıbı kullanarak geometrik şekiller temsil eden yapılar ile çalışır.</span><span class="sxs-lookup"><span data-stu-id="d30e9-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="d30e9-114">Sınıf hiyerarşileri oluşturma ve oluşturma ile biliyor [sanal ve geçersiz kılınan yöntemleri](methods.md#inherited) nesne çalışma zamanı türüne göre nesne davranışını özelleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d30e9-114">You are probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="d30e9-115">Bu teknikler sınıf hiyerarşisinde yapılandırılmaz veri mümkün değil.</span><span class="sxs-lookup"><span data-stu-id="d30e9-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="d30e9-116">Veri ve yöntemleri farklı olduğunda, diğer araçlar gerekir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="d30e9-117">Yeni *desen eşleştirme* yapıları verileri incelemek ve bu verilerin herhangi bir koşula dayalı akış denetimi işlemek temizleyici sözdizimi etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="d30e9-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="d30e9-118">Zaten yazma `if` deyimleri ve `switch` bir değişkenin değeri sınayın.</span><span class="sxs-lookup"><span data-stu-id="d30e9-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="d30e9-119">Yazdığınız `is` bir değişken türü test deyimleri.</span><span class="sxs-lookup"><span data-stu-id="d30e9-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="d30e9-120">*Desen eşleştirme* bu deyimleri için yeni özellikleri ekler.</span><span class="sxs-lookup"><span data-stu-id="d30e9-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="d30e9-121">Bu konuda, farklı geometrik şekiller alanını hesaplar bir yöntem yapı.</span><span class="sxs-lookup"><span data-stu-id="d30e9-121">In this topic, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="d30e9-122">Ancak, nesne yönelimli teknikleri yeniden ayırma ve farklı şekiller için sınıf hiyerarşisi oluşturmak olmadan gerçekleştirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d30e9-122">But, you'll do it without resorting to object oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="d30e9-123">Kullanacağınız *desen eşleştirme* yerine.</span><span class="sxs-lookup"><span data-stu-id="d30e9-123">You'll use *pattern matching* instead.</span></span> <span data-ttu-id="d30e9-124">Devralma kullanmıyorsanız, her şekli hale getireceğiz daha fazla vurgulamak için bir `struct` yerine bir sınıf.</span><span class="sxs-lookup"><span data-stu-id="d30e9-124">To further emphasize that we're not using inheritance, you'll make each shape a `struct` instead of a class.</span></span> <span data-ttu-id="d30e9-125">Bu farklı Not `struct` türleri, ortak bir kullanıcı tanımlı temel türü, böylece devralma olası tasarım belirtemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="d30e9-125">Note that different `struct` types cannot specify a common user defined base type, so inheritance is not a possible design.</span></span>
<span data-ttu-id="d30e9-126">Bu örnek geçerken bu kodu nasıl, bir nesne hiyerarşisi yapılandırılmış olması ile karşılaştırın.</span><span class="sxs-lookup"><span data-stu-id="d30e9-126">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="d30e9-127">Desen eşleştirme işlemek ve gereken sorgu veri sınıf hiyerarşisinin olmadığı durumlarda, çok Zarif tasarımları sağlar.</span><span class="sxs-lookup"><span data-stu-id="d30e9-127">When the data you must query and manipulate is not a class hierarchy, pattern matching enables very elegant designs.</span></span>

<span data-ttu-id="d30e9-128">Bir Özet şekli tanımıyla başlatma ve farklı belirli şekil sınıfları ekleme yerine, bunun yerine basit verilerle tanımları geometrik şekillerin her biri için yalnızca başlayalım:</span><span class="sxs-lookup"><span data-stu-id="d30e9-128">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="d30e9-129">Bu yapıları, bazı şekil alanı hesaplar bir yöntem yazalım.</span><span class="sxs-lookup"><span data-stu-id="d30e9-129">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="d30e9-130">`is` Deseni ifadesi yazın</span><span class="sxs-lookup"><span data-stu-id="d30e9-130">The `is` type pattern expression</span></span>

<span data-ttu-id="d30e9-131">C# 7.0 önce her tür bir dizi test gerekir `if` ve `is` deyimleri:</span><span class="sxs-lookup"><span data-stu-id="d30e9-131">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="d30e9-132">Yukarıdaki kod klasik bir ifade olduğunu *türü düzeni*: türünü ve bu türüne göre farklı bir eylem getirmeden belirlemek için bir değişken test ettiğiniz.</span><span class="sxs-lookup"><span data-stu-id="d30e9-132">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="d30e9-133">Bu kodu daha basit hale uzantıları kullanarak `is` ifadesi bir değişken IF test atamak için başarılı olur:</span><span class="sxs-lookup"><span data-stu-id="d30e9-133">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="d30e9-134">Bu güncelleştirilmiş sürüm `is` ifade değişkeni testleri hem uygun türde yeni bir değişkene atar.</span><span class="sxs-lookup"><span data-stu-id="d30e9-134">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="d30e9-135">Ayrıca, bu sürüm içeren bildirim `Rectangle` türü olan bir `struct`.</span><span class="sxs-lookup"><span data-stu-id="d30e9-135">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="d30e9-136">Yeni `is` ifadesi başvuru türleri yanı sıra değer türleri ile çalışır.</span><span class="sxs-lookup"><span data-stu-id="d30e9-136">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="d30e9-137">Desen eşleştirme ifadeler için dil kuralları bir eşleşme ifadesi sonuçlarını kötüye önlemenize yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="d30e9-137">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="d30e9-138">Değişkenleri yukarıdaki örnekte `s`, `c`, ve `r` yalnızca kapsamındaki ve ilgili desen eşleşme ifadeleri olduğunda kesinlikle atanan `true` sonuçları.</span><span class="sxs-lookup"><span data-stu-id="d30e9-138">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="d30e9-139">Başka bir konumda ya da değişken kullanmayı denerseniz, kodunuzu derleyici hataları oluşturur.</span><span class="sxs-lookup"><span data-stu-id="d30e9-139">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="d30e9-140">Ayrıntılı kapsam ile başlayarak, bu kuralların her ikisi de inceleyelim.</span><span class="sxs-lookup"><span data-stu-id="d30e9-140">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="d30e9-141">Değişkeni `c` kapsamında olup yalnızca `else` ilk dalı `if` deyimi.</span><span class="sxs-lookup"><span data-stu-id="d30e9-141">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="d30e9-142">Değişkeni `s` yöntemi kapsamında yer `ComputeAreaModernIs`.</span><span class="sxs-lookup"><span data-stu-id="d30e9-142">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="d30e9-143">Çünkü her dalı bir `if` deyimi değişkenleri için ayrı bir kapsam oluşturur.</span><span class="sxs-lookup"><span data-stu-id="d30e9-143">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="d30e9-144">Ancak, `if` deyimi kendisini desteklemez.</span><span class="sxs-lookup"><span data-stu-id="d30e9-144">However, the `if` statement itself does not.</span></span> <span data-ttu-id="d30e9-145">İçinde bildirilen değişkenlerin anlamına `if` deyimi aynı kapsamı olan `if` deyimi (Bu durumda yöntemi.) Bu davranış desen eşleştirme için özel değildir ancak değişken kapsamlar için tanımlanmış bir davranıştır ve `if` ve `else` deyimleri.</span><span class="sxs-lookup"><span data-stu-id="d30e9-145">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior is not specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="d30e9-146">Değişkenleri `c` ve `s` ne zaman atanmış olan ilgili `if` deyimleri true nedeniyle kesinlikle atanan zaman true mekanizması.</span><span class="sxs-lookup"><span data-stu-id="d30e9-146">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="d30e9-147">Bu konudaki örnekler önerilen yapı Desen eşleştirmesi kullanın `is` ifade kesinlikle eşleşme değişkeninde atar `true` dalı `if` deyimi.</span><span class="sxs-lookup"><span data-stu-id="d30e9-147">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="d30e9-148">Mantığı tarafından bildiren tersine çevirebilir `if (!(shape is Square s))` değişkeni `s` kesinlikle yalnızca atanmış olur `false` dal.</span><span class="sxs-lookup"><span data-stu-id="d30e9-148">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="d30e9-149">Bu geçerli bir C# olmakla birlikte, mantığı izlenecek daha karmaşık olduğu için önerilmez.</span><span class="sxs-lookup"><span data-stu-id="d30e9-149">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="d30e9-150">Bu kurallar bu desene karşılanmadığı yanlışlıkla bir desen eşleştirme ifadesi sonucu erişmeye olası anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-150">These rules mean that you are unlikely to accidentally access the result of a pattern match expression when that pattern was not met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="d30e9-151">Desen eşleştirme kullanılarak `switch` deyimleri</span><span class="sxs-lookup"><span data-stu-id="d30e9-151">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="d30e9-152">Zaman gibi diğer şekil türlerini desteklemek gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-152">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="d30e9-153">Test ettiğiniz koşullar sayısı arttıkça, kullanmanın bulabilirsiniz `is` ifadeleri eşleşen kalıbı sıkıcı dönüşebilir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-153">As the number of conditions you are testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="d30e9-154">Gerektiren ek olarak `if` denetlemek istediğiniz her türündeki deyimleri `is` ifadeleri giriş tek bir türü eşleşirse test sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="d30e9-154">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="d30e9-155">Bu durumda, bulacaksınız `switch` desen eşleştirme ifadeleri daha iyi bir seçim haline gelir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-155">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="d30e9-156">Geleneksel `switch` deyimi olan bir desen ifadesini: sabit düzeni desteklenir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-156">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="d30e9-157">Kullanılan sabit bir değişkene karşılaştırmak bir `case` deyimi:</span><span class="sxs-lookup"><span data-stu-id="d30e9-157">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="d30e9-158">Tarafından desteklenen tek düzeni `switch` deyimi sabit düzeni oluştu.</span><span class="sxs-lookup"><span data-stu-id="d30e9-158">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="d30e9-159">Daha fazla sınırlı sayısal türler oluştu ve `string` türü.</span><span class="sxs-lookup"><span data-stu-id="d30e9-159">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="d30e9-160">Bu kısıtlamaları kaldırıldı ve artık yazabilirsiniz bir `switch` türü desenini kullanarak deyimi:</span><span class="sxs-lookup"><span data-stu-id="d30e9-160">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="d30e9-161">Desen eşleştirme `switch` deyimini kullanan geleneksel C tarzı kullanmış olan geliştiricilere bilinen sözdizimini `switch` deyimi.</span><span class="sxs-lookup"><span data-stu-id="d30e9-161">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="d30e9-162">Her `case` değerlendirilir ve kod giriş değişkeni eşleşen koşul altında yürütülür.</span><span class="sxs-lookup"><span data-stu-id="d30e9-162">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="d30e9-163">Kod yürütmeyi "bir servis talebi ifadesinden sonraki geçemez"; söz dizimi `case` deyimi gerektirir, her `case` sonunda bir `break`, `return`, veya `goto`.</span><span class="sxs-lookup"><span data-stu-id="d30e9-163">Code execution cannot "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="d30e9-164">`goto` Başka bir etiket için atlamak için deyimleri yalnızca sabit desenini (Klasik switch deyimi) geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-164">The `goto` statements to jump to another label are valid only for the constant pattern (the classic switch statement).</span></span>

<span data-ttu-id="d30e9-165">Yöneten önemli yeni kurallar vardır `switch` deyimi.</span><span class="sxs-lookup"><span data-stu-id="d30e9-165">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="d30e9-166">Değişken türü kısıtlamalar `switch` ifadesi kaldırıldı.</span><span class="sxs-lookup"><span data-stu-id="d30e9-166">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="d30e9-167">Gibi herhangi türdeki `object` Bu örnekte, kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-167">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="d30e9-168">Case ifadeleri artık sabit değerleri için sınırlı değildir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-168">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="d30e9-169">Bu sınırlama kaldırılması anlamına gelir, yeniden sıralama `switch` bölümler, programın davranışını değişebilir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-169">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="d30e9-170">Birden fazla sabit değerleri için sınırlı olduğunda `case` etiket değeri eşleşebilecek `switch` ifade.</span><span class="sxs-lookup"><span data-stu-id="d30e9-170">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="d30e9-171">Kuralla birleştirmek, her `switch` bölüm gerekir değil atlayabilir sonraki bölüme ve, ardından `switch` bölümleri düzenlenmeyecek herhangi bir sırada davranışı etkilemeden.</span><span class="sxs-lookup"><span data-stu-id="d30e9-171">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="d30e9-172">Şimdi, genelleştirilmiş daha fazla ile `switch` ifadeleri, her bölüm sırası önemlidir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-172">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="d30e9-173">`switch` İfadeleri metinsel sırayla değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-173">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="d30e9-174">Yürütme aktarır ilk `switch` eşleşen etiket `switch` ifade.</span><span class="sxs-lookup"><span data-stu-id="d30e9-174">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="d30e9-175">Unutmayın `default` durumda, yalnızca diğer durum etiketi eşleşiyorsa yürütülür.</span><span class="sxs-lookup"><span data-stu-id="d30e9-175">Note that the `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="d30e9-176">`default` Durumda son olarak, kendi metinsel sipariş bağımsız olarak değerlendirildi.</span><span class="sxs-lookup"><span data-stu-id="d30e9-176">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="d30e9-177">Varsa hiçbir `default` çalışması ve diğer hiçbiri `case` deyimleri eşleşmesi, deyimi aşağıdaki yürütülmeye `switch` deyimi.</span><span class="sxs-lookup"><span data-stu-id="d30e9-177">If there is no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="d30e9-178">Hiçbiri `case` etiketleri kod gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-178">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="d30e9-179">`when` yan tümcelerinde `case` ifadeleri</span><span class="sxs-lookup"><span data-stu-id="d30e9-179">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="d30e9-180">Özel durumlar kullanarak 0 alanı olan bu şekiller için yapabileceğiniz bir `when` yan tümcesi `case` etiketi.</span><span class="sxs-lookup"><span data-stu-id="d30e9-180">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="d30e9-181">Bir kare yan uzunluğu 0 ile ya da RADIUS 0 olan bir daire 0 bir alana sahip.</span><span class="sxs-lookup"><span data-stu-id="d30e9-181">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="d30e9-182">Bu koşul kullanarak belirttiğiniz bir `when` yan tümcesi `case` etiketi:</span><span class="sxs-lookup"><span data-stu-id="d30e9-182">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="d30e9-183">Bu değişiklik birkaç önemli noktaları yeni söz dizimi hakkında gösterir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-183">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="d30e9-184">İlk olarak, çoklu `case` etiketleri için uygulanabilir `switch` bölümü.</span><span class="sxs-lookup"><span data-stu-id="d30e9-184">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="d30e9-185">İfade bloğu yürütülen etiketlerin hiçbirinde olduğunda `true`.</span><span class="sxs-lookup"><span data-stu-id="d30e9-185">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="d30e9-186">Bu örnekte, `switch` ifadesi bir daire veya kare 0 alan ile yöntem sabiti 0 döndürür.</span><span class="sxs-lookup"><span data-stu-id="d30e9-186">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="d30e9-187">Bu örnek iki iki farklı değişkenleri tanıtır `case` ilk kez etiketleri `switch` bloğu.</span><span class="sxs-lookup"><span data-stu-id="d30e9-187">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="d30e9-188">Dikkat bu deyimlerinde `switch` bloğu ya da değişkenleri kullanmayın `c` (için daire) veya `s` (için kare).</span><span class="sxs-lookup"><span data-stu-id="d30e9-188">Notice that the statements in this `switch` block do not use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="d30e9-189">Bu değişkenleri hiçbiri kesinlikle bu atanan `switch` bloğu.</span><span class="sxs-lookup"><span data-stu-id="d30e9-189">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="d30e9-190">Bu durumların herhangi birini eşleşiyorsa değişkenleri açıkça birini atanmıştır.</span><span class="sxs-lookup"><span data-stu-id="d30e9-190">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="d30e9-191">Ancak, bildirmek mümkün değildir *hangi* derleme zamanında, her iki durumda çalışma zamanında eşleştiğinden atanmıştır.</span><span class="sxs-lookup"><span data-stu-id="d30e9-191">However, it is impossible to tell *which* has been assigned at compile-time, because either case could match at runtime.</span></span> <span data-ttu-id="d30e9-192">Bu nedenle, çoğu kez kullandığınızda, birden çok `case` etiketleri aynı bloğu için yeni bir değişkende tanıtmak olmaz `case` deyimi veya yalnızca kullanacağınız değişkende `when` yan tümcesi.</span><span class="sxs-lookup"><span data-stu-id="d30e9-192">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you will only use the variable in the `when` clause.</span></span>

<span data-ttu-id="d30e9-193">Bu şekiller 0 alan ile eklenir birkaç daha fazla şekil türleri ekleyelim: dikdörtgen ve bir üçgen:</span><span class="sxs-lookup"><span data-stu-id="d30e9-193">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="d30e9-194">Bu değişiklik kümesini ekler `case` bozuk durumda, etiketleri ve etiketleri ve her yeni şekiller blokları.</span><span class="sxs-lookup"><span data-stu-id="d30e9-194">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="d30e9-195">Son olarak, ekleyebileceğiniz bir `null` bağımsız değişken değil emin olmak için durum `null`:</span><span class="sxs-lookup"><span data-stu-id="d30e9-195">Finally, you can add a `null` case to ensure the argument is not `null`:</span></span>

[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="d30e9-196">İçin özel bir davranış `null` düzeni ilginç çünkü sabiti `null` desende bir türe sahip değil, ancak herhangi bir başvuru türü veya boş değer atanabilir tür dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-196">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern does not have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="d30e9-197">Yerine Dönüştür bir `null` herhangi bir türü için dili tanımlayan bir `null` değer değişkenin derleme zamanı türünden bağımsız olarak herhangi bir tür modeliyle eşleşmez.</span><span class="sxs-lookup"><span data-stu-id="d30e9-197">Rather than convert a `null` to any type, the language defines that a `null` value will not match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="d30e9-198">Bu davranış yeni yapar `switch` türü desenine ile tutarlı `is` deyimi: `is` deyimleri her zaman geri `false` denetlenen değer olduğunda `null`.</span><span class="sxs-lookup"><span data-stu-id="d30e9-198">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="d30e9-199">Ayrıca basittir: türü işaretlendiğinde, ek bir null denetimi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="d30e9-199">It's also simpler: once you have checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="d30e9-200">Hiçbir null bulunmasına yukarıdaki örnekleri servis talebi bloklarını hiçbirinde denetler görebilirsiniz: boş olmayan bir değer türü desen eşleştirme garanti beri gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-200">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they are not necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="d30e9-201">`var` bildirimlerinde `case` ifadeleri</span><span class="sxs-lookup"><span data-stu-id="d30e9-201">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="d30e9-202">Giriş `var` gibi bir eşleşme ifadeleri desen eşleştirme yeni kurallar tanıtır.</span><span class="sxs-lookup"><span data-stu-id="d30e9-202">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="d30e9-203">İlk kural olan `var` bildirimini normal türü çıkarım kuralları izler: türü anahtar ifadesi statik türünde olmasını algılanır.</span><span class="sxs-lookup"><span data-stu-id="d30e9-203">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="d30e9-204">Bu kuraldan türü her zaman eşleşir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-204">From that rule, the type always matches.</span></span>

<span data-ttu-id="d30e9-205">İkinci kuralı olan bir `var` bildirimi diğer tür düzeni ifadeler içeren null denetimi sahip değil.</span><span class="sxs-lookup"><span data-stu-id="d30e9-205">The second rule is that a `var` declaration does not have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="d30e9-206">Bu değişken null olabilir ve bu durumda null denetimi gereklidir anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-206">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="d30e9-207">Bu iki kural çoğu durumda, diğer bir deyişle bir `var` bildiriminde bir `case` ifadeyle eşleşen aynı koşullarda bir `default` ifade.</span><span class="sxs-lookup"><span data-stu-id="d30e9-207">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="d30e9-208">Herhangi bir varsayılan olmayan durumu için tercih edilen olduğundan `default` durumda `default` durumu hiçbir zaman yürütülecek.</span><span class="sxs-lookup"><span data-stu-id="d30e9-208">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="d30e9-209">Derleyici Uyarısı bu durumlarda yayma değil burada bir `default` durumda yazıldı, ancak hiçbir zaman yürütülür.</span><span class="sxs-lookup"><span data-stu-id="d30e9-209">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="d30e9-210">Bu tutarlıdır geçerli `switch` burada tüm olası durumların listelenen deyimi davranışı.</span><span class="sxs-lookup"><span data-stu-id="d30e9-210">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="d30e9-211">Üçüncü kural kullanır tanıtır burada bir `var` durumda yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="d30e9-211">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="d30e9-212">Burada, Giriş bir dize ve bilinen komut değerlerini aradığınız bir desen eşleştirmesi yaptıklarını düşünün.</span><span class="sxs-lookup"><span data-stu-id="d30e9-212">Imagine that you are doing a pattern match where the input is a string and you are searching for known command values.</span></span> <span data-ttu-id="d30e9-213">Şöyle yazabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="d30e9-213">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="d30e9-214">`var` Durumda eşleşmeleri `null`, boş dize veya yalnızca boşluk içeriyor herhangi bir dize.</span><span class="sxs-lookup"><span data-stu-id="d30e9-214">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="d30e9-215">Önceki kod kullanan bildirimi `?.` onu değil yanlışlıkla throw emin olmak için işleci bir <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="d30e9-215">Notice that the preceding code uses the `?.` operator to ensure that it does not accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="d30e9-216">`default` Durumunu işler bu komutu ayrıştırıcı tarafından anlaşılmayan herhangi bir dize değeri.</span><span class="sxs-lookup"><span data-stu-id="d30e9-216">The `default` case handles any other string values that are not understood by this command parser.</span></span>

<span data-ttu-id="d30e9-217">Bu bir yere göz önünde bulundurun isteyebilirsiniz örnektir bir `var` durumda farklıdır ifade bir `default` ifade.</span><span class="sxs-lookup"><span data-stu-id="d30e9-217">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="d30e9-218">Sonuçları</span><span class="sxs-lookup"><span data-stu-id="d30e9-218">Conclusions</span></span>

<span data-ttu-id="d30e9-219">*Desen eşleştirme yapıları* denetim akışı farklı değişkenleri ve devralma hiyerarşisi tarafından ilgili olmayan türleri arasında kolayca yönetmenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="d30e9-219">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that are not related by an inheritance hierarchy.</span></span> <span data-ttu-id="d30e9-220">Değişkeni test herhangi bir koşul kullanmak için mantığı de denetleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d30e9-220">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="d30e9-221">Desenleri ve veri ve bu verileri işlemek yöntemleri ayrı nerede daha dağıtılmış uygulamalar oluşturmak daha sık gerekir deyimleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="d30e9-221">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="d30e9-222">Bu örnekte kullanılan şekli yapılar herhangi bir yöntem içermiyor fark edeceksiniz yalnızca salt okunur özellikler.</span><span class="sxs-lookup"><span data-stu-id="d30e9-222">You'll notice that the shape structs used in this sample do not contain any methods, just read-only properties.</span></span>
<span data-ttu-id="d30e9-223">Desen eşleştirme herhangi bir veri türü ile çalışır.</span><span class="sxs-lookup"><span data-stu-id="d30e9-223">Pattern Matching works with any data type.</span></span> <span data-ttu-id="d30e9-224">Nesne inceleyin ifadeleri yazmak ve bu koşullara göre denetim akışı kararlar.</span><span class="sxs-lookup"><span data-stu-id="d30e9-224">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="d30e9-225">Bu örnek için bir Özet sınıf hiyerarşisi oluşturma izlersiniz tasarım ile koddan karşılaştırmak `Shape` ve türetilmiş özel şekiller her alanını hesaplamak için sanal bir yöntem, kendi uygulama.</span><span class="sxs-lookup"><span data-stu-id="d30e9-225">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="d30e9-226">Desen eşleştirme ifadeleri verilerle çalışmak ve veri depolama sorunları davranışı kaygılarını ayırmak istediğiniz zaman çok kullanışlı bir aracı olabilir genellikle bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d30e9-226">You'll often find that pattern matching expressions can be a very useful tool when you are working with data and want to separate the data storage concerns from the behavior concerns.</span></span>


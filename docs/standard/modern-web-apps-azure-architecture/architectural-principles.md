---
title: Mimari ilkeleri
description: "ASP.NET Core ve Azure ile modern Web uygulamaları mimari | Mimari ilkeleri"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 18abca8ce8280ff1fa2b52650be57a59d1201fab
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 12/23/2017
---
#<a name="architectural-principles"></a><span data-ttu-id="cfd0e-103">Mimari ilkeleri</span><span class="sxs-lookup"><span data-stu-id="cfd0e-103">Architectural Principles</span></span>

> <span data-ttu-id="cfd0e-104">"Oluşturucular binalar oluşturulduysa program yolu programcıları yazdı ve ardından gelen boyunca ilk woodpecker civilization yok."</span><span class="sxs-lookup"><span data-stu-id="cfd0e-104">"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization."</span></span>  
> <span data-ttu-id="cfd0e-105">_\-Gerald Weinberg_</span><span class="sxs-lookup"><span data-stu-id="cfd0e-105">_\- Gerald Weinberg_</span></span>

## <a name="summary"></a><span data-ttu-id="cfd0e-106">Özet</span><span class="sxs-lookup"><span data-stu-id="cfd0e-106">Summary</span></span>

<span data-ttu-id="cfd0e-107">Mimari ve Bakım aklınızda ile yazılım çözümleri tasarlama gerekir.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-107">You should architect and design software solutions with maintainability in mind.</span></span> <span data-ttu-id="cfd0e-108">Bu bölümde özetlendiği ilkeler, temiz, sürdürülebilir uygulamalarda sonuçlanır mimari kararlar doğru yönlendirmeye yardımcı olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-108">The principles outlined in this section can help guide you toward architectural decisions that will result in clean, maintainable applications.</span></span> <span data-ttu-id="cfd0e-109">Genellikle, bu ilkeler, uygulamanızın diğer bölümlerine sıkı şekilde bağlı değildir, ancak bunun yerine açık arabirimler aracılığıyla iletişim ayrık bileşenleri dışında uygulamaları oluşturmak veya sistemleri Mesajlaşma doğru size yol gösterecektir.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-109">Generally, these principles will guide you toward building applications out of discrete components that are not tightly coupled to other parts of your application, but rather communicate through explicit interfaces or messaging systems.</span></span>

## <a name="common-design-principles"></a><span data-ttu-id="cfd0e-110">Ortak tasarım ilkeleri</span><span class="sxs-lookup"><span data-stu-id="cfd0e-110">Common design principles</span></span>

### <a name="separation-of-concerns"></a><span data-ttu-id="cfd0e-111">Sorunları ayrılması</span><span class="sxs-lookup"><span data-stu-id="cfd0e-111">Separation of Concerns</span></span>

<span data-ttu-id="cfd0e-112">Geliştirirken yol gösterici bir ilke olan **ayrımı biri ile ilgili sorunlar**.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-112">A guiding principle when developing is **Separation of Concerns**.</span></span> <span data-ttu-id="cfd0e-113">Bu ilkeyi yazılım ayrılmalıdır gerçekleştirdiği iş türlerini göre onaylar.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-113">This principle asserts that software should be separated based on the kinds of work it performs.</span></span> <span data-ttu-id="cfd0e-114">Örneğin, kullanıcıya görüntülenecek önemli öğeleri tanımlamak için mantığı içeren ve onları daha belirgin hale getirmek için belirli bir şekilde gibi öğeler biçimlendiren bir uygulamayı göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-114">For instance, consider an application that includes logic for identifying noteworthy items to display to the user, and which formats such items in a particular way to make them more noticeable.</span></span> <span data-ttu-id="cfd0e-115">Biçimlendirmek için hangi öğe seçmek için sorumlu davranışı, bunlar yalnızca tesadüfen birbiriyle ilişkili ayrı sorunları olduğundan öğeleri biçimlendirme için sorumlu davranış ayrı tutulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-115">The behavior responsible for choosing which items to format should be kept separate from the behavior responsible for formatting the items, since these are separate concerns that are only coincidentally related to one another.</span></span>

<span data-ttu-id="cfd0e-116">Mimari, uygulamaların bu ilkeyi altyapısı ve kullanıcı arabirimi mantığı çekirdek işletme davranışına ayırarak izlemek için mantıksal olarak oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-116">Architecturally, applications can be logically built to follow this principle by separating core business behavior from infrastructure and user interface logic.</span></span> <span data-ttu-id="cfd0e-117">İdeal olarak, iş kurallarını ve mantığı uygulamadaki başka projelerde bağımlı olmamalıdır ayrı bir proje bulunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-117">Ideally, business rules and logic should reside in a separate project, which should not depend on other projects in the application.</span></span> <span data-ttu-id="cfd0e-118">Bu iş modeli kolay olduğundan emin olun yardımcı sınamak ve sıkı şekilde alt düzey uygulama ayrıntılarını bağlı olmadan geliştirin.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-118">This helps ensure that the business model is easy to test and can evolve without being tightly coupled to low-level implementation details.</span></span> <span data-ttu-id="cfd0e-119">Bir anahtar kullanımı arkasında göz önüne alarak katmanlı uygulama mimarilerindeki sorunları ayrılmasıdır.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-119">Separation of concerns is a key consideration behind the use of layers in application architectures.</span></span>

### <a name="encapsulation"></a><span data-ttu-id="cfd0e-120">Kapsülleme</span><span class="sxs-lookup"><span data-stu-id="cfd0e-120">Encapsulation</span></span>

<span data-ttu-id="cfd0e-121">Bir uygulamanın farklı bölümlerini kullanması gereken **kapsülleme** bunları uygulamanın diğer kısımlarından verenlerden için.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-121">Different parts of an application should use **encapsulation** to insulate them from other parts of the application.</span></span> <span data-ttu-id="cfd0e-122">Uygulama bileşenleri ve Katmanlar, kendi ortak dış sözleşmeleri olmayan ihlal sürece bozmadan kendi iç uygulaması ayarlayabilmeniz için olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-122">Application components and layers should be able to adjust their internal implementation without breaking their collaborators as long as external contracts are not violated.</span></span> <span data-ttu-id="cfd0e-123">Kapsülleme doğru kullanımı, nesneleri ve paketleri aynı arabirimi korunur sürece alternatif uygulamaları ile değiştirilebilir beri gevşek bağlantı ve modülerlik uygulama tasarımlarına elde yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-123">Proper use of encapsulation helps achieve loose coupling and modularity in application designs, since objects and packages can be replaced with alternative implementations so long as the same interface is maintained.</span></span>

<span data-ttu-id="cfd0e-124">Sınıfları, sınıfın iç durumu erişimi dışında sınırlayarak kapsülleme elde edilir.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-124">In classes, encapsulation is achieved by limiting outside access to the class's internal state.</span></span> <span data-ttu-id="cfd0e-125">Nesnenin durumunu denetlemek bir dış aktör istiyorsa, onu bir iyi tanımlanmış işlevi (veya özellik ayarlayıcısı aracılığıyla), nesnenin özel durumu için doğrudan erişim sahibi olmayı yerine bunu.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-125">If an outside actor wants to manipulate the state of the object, it should do so through a well-defined function (or property setter), rather than having direct access to the private state of the object.</span></span> <span data-ttu-id="cfd0e-126">Benzer şekilde, uygulama bileşenlerini ve uygulamaların kendileri kendi ortak çalışanlarla durumlarına doğrudan değiştirilmesine izin vermek yerine kullanmak için iyi tanımlanmış arabirimleri maruz bırakmamalısınız.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-126">Likewise, application components and applications themselves should expose well-defined interfaces for their collaborators to use, rather than allowing their state to be modified directly.</span></span> <span data-ttu-id="cfd0e-127">Bu uygulamanın iç tasarım ortak sözleşmeleri korunur sürece bunu yaparsanız, ortak çalışanlar, böylece kesintiye uğrar endişelenmeden zamanla gelişmesi boşaltır.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-127">This frees the application's internal design to evolve over time without worrying that doing so will break collaborators, so long as the public contracts are maintained.</span></span>

### <a name="dependency-inversion"></a><span data-ttu-id="cfd0e-128">Bağımlılık tersine çevirme</span><span class="sxs-lookup"><span data-stu-id="cfd0e-128">Dependency Inversion</span></span>

<span data-ttu-id="cfd0e-129">Uygulama içinde bağımlılık yönünü soyutlama, uygulama ayrıntılarını yönde olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-129">The direction of dependency within the application should be in the direction of abstraction, not implementation details.</span></span> <span data-ttu-id="cfd0e-130">Derleme zamanı bağımlılık çalışma zamanı yürütme yönde akar şekilde uygulamaların çoğu yazılır.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-130">Most applications are written such that compile-time dependency flows in the direction of runtime execution.</span></span> <span data-ttu-id="cfd0e-131">Bu, doğrudan bağımlılık grafiğinin oluşturur.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-131">This produces a direct dependency graph.</span></span> <span data-ttu-id="cfd0e-132">Diğer bir deyişle, bir işlev modülü C ve ardından derleme zamanı A olacaktır, çağıran modülü A çağrıları işlevi modülünde B, a C, Şekil 4-1'de gösterildiği gibi bağlı olan B bağımlı varsa.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-132">That is, if module A calls a function in module B, which calls a function in module C, then at compile time A will depend on B which will depend on C, as shown in Figure 4-1.</span></span>

![](./media/image4-1.png)

<span data-ttu-id="cfd0e-133">**Şekil 4-1.**</span><span class="sxs-lookup"><span data-stu-id="cfd0e-133">**Figure 4-1.**</span></span> <span data-ttu-id="cfd0e-134">Doğrudan bağımlılık grafiğinin.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-134">Direct dependency graph.</span></span>

<span data-ttu-id="cfd0e-135">Bağımlılık ters çevirmeyi ilkesini uygulamak için çalışma zamanında B çağrısına olası kolaylaştırarak B uygulayan bir Özet yöntemleri çağırmak bir verir ancak arabirime bağımlı b A derleme zamanında denetlenen (Bu nedenle, *ters çevirme* genel derleme zamanı bağımlılığı).</span><span class="sxs-lookup"><span data-stu-id="cfd0e-135">Applying the dependency inversion principle allows A to call methods on an abstraction that B implements, making it possible for A to call B at runtime, but for B to depend on an interface controlled by A at compile time (thus, *inverting* the typical compile-time dependency).</span></span> <span data-ttu-id="cfd0e-136">Çalışma zamanında, program yürütme akışını değişmeden kalır, ancak bu arabirimleri farklı uygulamaları kolayca takılabilen olduğunu arabirimleri giriş anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-136">At run time, the flow of program execution remains unchanged, but the introduction of interfaces means that different implementations of these interfaces can easily be plugged in.</span></span>

![](./media/image4-2.png)

<span data-ttu-id="cfd0e-137">**Şekil 4-2.**</span><span class="sxs-lookup"><span data-stu-id="cfd0e-137">**Figure 4-2.**</span></span> <span data-ttu-id="cfd0e-138">Ters bağımlılık grafiğinin.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-138">Inverted dependency graph.</span></span>

<span data-ttu-id="cfd0e-139">**Bağımlılık ters çevirmeyi** bağlıdır ve diğer yönden yerine, daha yüksek düzey soyutlamalar uygulamak için uygulama ayrıntılarını yazılabilir bu yana birbirine sıkı şekilde bağlı uygulamaları oluşturmak, önemli bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-139">**Dependency inversion** is a key part of building loosely-coupled applications, since implementation details can be written to depend on and implement higher level abstractions, rather than the other way around.</span></span> <span data-ttu-id="cfd0e-140">Sonuçta elde edilen sonuç olarak daha sınanabilir, modüler ve sürdürülebilir uygulamalardır.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-140">The resulting applications are more testable, modular, and maintainable as a result.</span></span> <span data-ttu-id="cfd0e-141">Uygulaması *bağımlılık ekleme* bağımlılık ters çevirmeyi ilkesini izleyerek mümkün hale getirilir.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-141">The practice of *dependency injection* is made possible by following the dependency inversion principle.</span></span>

### <a name="explicit-dependencies"></a><span data-ttu-id="cfd0e-142">Açık bağımlılıkları</span><span class="sxs-lookup"><span data-stu-id="cfd0e-142">Explicit Dependencies</span></span>

<span data-ttu-id="cfd0e-143">**Açıkça yöntemleri ve sınıfları düzgün çalışabilmesi için gereksinim duydukları tüm iş nesnelerini istemeniz gerekir.**</span><span class="sxs-lookup"><span data-stu-id="cfd0e-143">**Methods and classes should explicitly require any collaborating objects they need in order to function correctly.**</span></span> <span data-ttu-id="cfd0e-144">Sınıf Oluşturucular, geçerli bir durumda olması için ve düzgün çalışması için gereken noktaları tanımlamak sınıflar için bir fırsattır.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-144">Class constructors provide an opportunity for classes to identify the things they need in order to be in a valid state and to function properly.</span></span> <span data-ttu-id="cfd0e-145">Bu sınıfları, kullanılabilir oluşturulan ve çağrılır, ancak hangi yalnızca işlev görecektir düzgün belirli genel veya altyapı bileşenlerini bulunmuyorsa sınıfları tanımlarsanız Yükleniyor *yapan dürüst olmayan* istemcileri ile.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-145">If you define classes that can be constructed and called, but which will only function properly if certain global or infrastructure components are in place, these classes are being *dishonest* with their clients.</span></span> <span data-ttu-id="cfd0e-146">Oluşturucu sözleşme, yalnızca belirtilen şeyleri (büyük olasılıkla hiçbir şey sınıfı yalnızca varsayılan bir oluşturucu kullanılıyorsa), ancak sonra bir nesneyi renge çalışma zamanında gereken istemci başka bir şey gerçekten belirtiyor.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-146">The constructor contract is telling the client that it only needs the things specified (possibly nothing if the class is just using a default constructor), but then at runtime it turns out the object really did need something else.</span></span>

<span data-ttu-id="cfd0e-147">Açık bağımlılıkları ilkesini izleyerek, sınıflar ve yöntemler çalışması için istedikleri hakkında istemcileri ile dürüst yükleniyor.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-147">By following the explicit dependencies principle, your classes and methods are being honest with their clients about what they need in order to function.</span></span> <span data-ttu-id="cfd0e-148">Bu, daha çok kendinden belgeli kodunuzu sağlar ve kullanıcılar yöntemi formunda gerekli sağladıkları sürece bu güven için gelecek olduğundan, kodlama daha kullanıcı dostu sözleşmeler veya Oluşturucu parametreleri, birlikte çalıştığınız nesneleri davranacak doğru çalışma zamanında.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-148">This makes your code more self-documenting and your coding contracts more user-friendly, since users will come to trust that as long as they provide what's required in the form of method or constructor parameters, the objects they're working with will behave correctly at runtime.</span></span>

### <a name="single-responsibility"></a><span data-ttu-id="cfd0e-149">Tek sorumluluk</span><span class="sxs-lookup"><span data-stu-id="cfd0e-149">Single Responsibility</span></span>

<span data-ttu-id="cfd0e-150">Tek sorumluluk ilkesini nesne odaklı tasarım uygulanır, ancak ayrıca sorunları ayrılması için benzer bir mimari ilkesi olarak düşünülebilir.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-150">The single responsibility principle applies to object-oriented design, but can also be considered as an architectural principle similar to separation of concerns.</span></span> <span data-ttu-id="cfd0e-151">Nesneleri yalnızca bir sorumluluk olmalıdır ve değiştirmek için yalnızca bir neden olması gerektiğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-151">It states that objects should have only one responsibility and that they should have only one reason to change.</span></span> <span data-ttu-id="cfd0e-152">Özellikle, nesne değiştirmeniz gerekir tek bir sorumluluğunu gerçekleştirir şekilde güncelleştirilmesi gerekir, durumdur.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-152">Specifically, the only situation in which the object should change is if the manner in which it performs its one responsibility must be updated.</span></span> <span data-ttu-id="cfd0e-153">Bu ilke aşağıdaki daha üretmeye yardımcı gevşek bağlanmış ve modüler sistemleri, pek çok yeni davranış bu yana yeni sınıflar olarak yerine mevcut sınıflarını ek sorumluluğu ekleyerek uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-153">Following this principle helps to produce more loosely-coupled and modular systems, since many kinds of new behavior can be implemented as new classes, rather than by adding additional responsibility to existing classes.</span></span> <span data-ttu-id="cfd0e-154">Yeni sınıflar ekleyerek her zaman bu yana hiçbir kod varolan sınıfları değiştirme daha güvenlidir henüz yeni sınıflarında bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-154">Adding new classes is always safer than changing existing classes, since no code yet depends on the new classes.</span></span>

<span data-ttu-id="cfd0e-155">Tek yapılı bir uygulamada, biz uygulama katmanlar için yüksek bir düzeyde tek sorumluluk ilkesini uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-155">In a monolithic application, we can apply the single responsibility principle at a high level to the layers in the application.</span></span> <span data-ttu-id="cfd0e-156">Sunu sorumluluk UI projesinde kalacağı, veri erişirken bir altyapı projesi içinde sorumluluk tutulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-156">Presentation responsibility should remain in the UI project, while data access responsibility should be kept within an infrastructure project.</span></span> <span data-ttu-id="cfd0e-157">İş mantığı, burada kolayca sınanabilir ve bağımsız olarak diğer sorumluluklarını gelişmesi uygulama çekirdek projesinde tutulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-157">Business logic should be kept in the application core project, where it can be easily tested and can evolve independently from other responsibilities.</span></span>

<span data-ttu-id="cfd0e-158">Bu ilke uygulama mimarisi için uygulanan ve mantıksal kendi uç noktasına gerçekleştirilecek mikro alın.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-158">When this principle is applied to application architecture, and taken to its logical endpoint, you get microservices.</span></span> <span data-ttu-id="cfd0e-159">Verilen mikro hizmet tek bir sorumluluk olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-159">A given microservice should have a single responsibility.</span></span> <span data-ttu-id="cfd0e-160">Bir sistem davranışını genişletmek gerekiyorsa, ek mikro ekleyerek yerine var olan bir sorumluluğu ekleyerek yapmak genellikle daha iyidir.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-160">If you need to extend the behavior of a system, it's usually better to do it by adding additional microservices, rather than by adding responsibility to an existing one.</span></span>

[<span data-ttu-id="cfd0e-161">Mikro mimarisi hakkında daha fazla bilgi edinin</span><span class="sxs-lookup"><span data-stu-id="cfd0e-161">Learn more about microservices architecture</span></span>](http://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a><span data-ttu-id="cfd0e-162">(KURU) kendiniz yineleme</span><span class="sxs-lookup"><span data-stu-id="cfd0e-162">Don't Repeat Yourself (DRY)</span></span>

<span data-ttu-id="cfd0e-163">Uygulama, bu hata sık sık bir kaynak olarak belirli bir kavram birden çok yerde ilgili davranışını belirtme kaçınmalısınız.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-163">The application should avoid specifying behavior related to a particular concept in multiple places as this is a frequent source of errors.</span></span> <span data-ttu-id="cfd0e-164">Belirli bir noktada bu davranış ve olasılığını değiştirme gereksinimleri değişikliği gerektirecek davranışı en az bir örneğini güncelleştirilmesi başarısız olur sistemin tutarsız davranışlara neden.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-164">At some point, a change in requirements will require changing this behavior and the likelihood that at least one instance of the behavior will fail to be updated will result in inconsistent behavior of the system.</span></span>

<span data-ttu-id="cfd0e-165">Mantığı çoğaltmak yerine bir programlama yapısı kapsüller.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-165">Rather than duplicating logic, encapsulate it in a programming construct.</span></span> <span data-ttu-id="cfd0e-166">Bu davranışı üzerinde tek yetkilisi oluşturmak ve bu davranışı kullanımı yeni yapı gerektiren uygulama, herhangi bir bölümünü sahip olun.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-166">Make this construct the single authority over this behavior, and have any other part of the application that requires this behavior use the new construct.</span></span>

> [!NOTE]
> <span data-ttu-id="cfd0e-167">Yalnızca tesadüfen yinelenen davranışı birbirine bağlayan kaçının.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-167">Avoid binding together behavior that is only coincidentally repetitive.</span></span> <span data-ttu-id="cfd0e-168">Yalnızca iki farklı sabit hem de aynı değere sahip olduğundan, kavramsal olarak bunlar için farklı işlemler başvuruyorsanız Örneğin, yalnızca bir sabit olmalıdır anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-168">For example, just because two different constants both have the same value, that doesn't mean you should have only one constant, if conceptually they're referring to different things.</span></span>

### <a name="persistence-ignorance"></a><span data-ttu-id="cfd0e-169">Kalıcılık kullanmayan</span><span class="sxs-lookup"><span data-stu-id="cfd0e-169">Persistence Ignorance</span></span>

<span data-ttu-id="cfd0e-170">**Kalıcılık kullanmayan** , kalıcı gerekiyor, ancak kodu Kalıcılık teknolojisi seçim tarafından etkilenmemesini türleri için (PI) başvuruyor.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-170">**Persistence ignorance** (PI) refers to types that need to be persisted, but whose code is unaffected by the choice of persistence technology.</span></span> <span data-ttu-id="cfd0e-171">Belirli bir taban sınıftan devralın ya da belirli bir arabirim uygulamak gerekmediği için .NET böyle türlerinde bazen için düz eski CLR nesneleri (POCOs) denir.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-171">Such types in .NET are sometimes referred to as Plain Old CLR Objects (POCOs), because they do not need to inherit from a particular base class or implement a particular interface.</span></span> <span data-ttu-id="cfd0e-172">Kalıcılık kullanmayan uygulamaya ek esneklik sunan birden çok yolla kalıcı olmasını aynı iş modeli izin verdiği için faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-172">Persistence ignorance is valuable because it allows the same business model to be persisted in multiple ways, offering additional flexibility to the application.</span></span> <span data-ttu-id="cfd0e-173">Kalıcılık seçimler başka bir veritabanı teknolojisine zaman içinde değişebilir veya başka biçimlerde Kalıcılık ne olursa olsun uygulamayı kullanmaya ek olarak gerekli olabilir (örneğin, bir Redis önbelleği veya ek olarak Azure DocumentDb kullanarak bir ilişkisel veritabanı).</span><span class="sxs-lookup"><span data-stu-id="cfd0e-173">Persistence choices might change over time, from one database technology to another, or additional forms of persistence might be required in addition to whatever the application started with (for example, using a Redis cache or Azure DocumentDb in addition to a relational database).</span></span>

<span data-ttu-id="cfd0e-174">Bu ilkeyi ihlal bazı örnekleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="cfd0e-174">Some examples of violations of this principle include:</span></span>

-   <span data-ttu-id="cfd0e-175">Gerekli bir taban sınıfı</span><span class="sxs-lookup"><span data-stu-id="cfd0e-175">A required base class</span></span>

-   <span data-ttu-id="cfd0e-176">Gerekli arabirim uygulaması</span><span class="sxs-lookup"><span data-stu-id="cfd0e-176">A required interface implementation</span></span>

-   <span data-ttu-id="cfd0e-177">Kendilerini (etkin kayıt deseni gibi) kaydetmek için sorumlu sınıfları</span><span class="sxs-lookup"><span data-stu-id="cfd0e-177">Classes responsible for saving themselves (such as the Active Record pattern)</span></span>

-   <span data-ttu-id="cfd0e-178">Gerekli varsayılan oluşturucu</span><span class="sxs-lookup"><span data-stu-id="cfd0e-178">Required default constructor</span></span>

-   <span data-ttu-id="cfd0e-179">Virtual anahtar sözcüğü gerektiren özellikleri</span><span class="sxs-lookup"><span data-stu-id="cfd0e-179">Properties requiring virtual keyword</span></span>

-   <span data-ttu-id="cfd0e-180">Kalıcılık özgü gerekli öznitelikler</span><span class="sxs-lookup"><span data-stu-id="cfd0e-180">Persistence-specific required attributes</span></span>

<span data-ttu-id="cfd0e-181">Sınıfları yukarıdaki özellikleri veya davranışları hiçbirini sahip gereksinim kalıcı olmasını türleri ve yeni veri erişim stratejileri gelecekte benimsemeyi daha zor hale getirme, Kalıcılık teknolojisi seçimi arasındaki bağlantı ekler.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-181">The requirement that classes have any of the above features or behaviors adds coupling between the types to be persisted and the choice of persistence technology, making it more difficult to adopt new data access strategies in the future.</span></span>

### <a name="bounded-contexts"></a><span data-ttu-id="cfd0e-182">Sınırlanmış bağlamları</span><span class="sxs-lookup"><span data-stu-id="cfd0e-182">Bounded Contexts</span></span>

<span data-ttu-id="cfd0e-183">**Bağlamları ilişkisindeki** Domain-Driven Tasarım Merkezi desende şunlardır.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-183">**Bounded contexts** are a central pattern in Domain-Driven Design.</span></span> <span data-ttu-id="cfd0e-184">Bunlar büyük uygulamalar ve kuruluşlardaki kuruluşlarda karmaşıklık ayrı kavramsal modüllerine çiğnemekten tarafından sağlarlar.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-184">They provide a way of tackling complexity in large applications or organizations by breaking it up into separate conceptual modules.</span></span> <span data-ttu-id="cfd0e-185">Kavramsal modüllerin ardından diğer bağlamlarda ayrılmış bir bağlamı temsil eder (Bu nedenle, sınırlanmış) ve bağımsız olarak gelişmesi.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-185">Each conceptual module then represents a context which is separated from other contexts (hence, bounded), and can evolve independently.</span></span> <span data-ttu-id="cfd0e-186">Sınırlanmış her bağlam ideal kavramları içerdiği için kendi adları seçmek boş olmalıdır ve özel erişim, kendi kalıcı depolama alanına sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-186">Each bounded context should ideally be free to choose its own names for concepts within it, and should have exclusive access to its own persistence store.</span></span>

<span data-ttu-id="cfd0e-187">En azından, tek tek web uygulamaları kendi sınırlanmış bağlamla bir veritabanını başka uygulamalarla paylaşma yerine kendi iş modeli için kendi Kalıcılık deposu olması olmaya çabalar.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-187">At a minimum, individual web applications should strive to be their own bounded context, with their own persistence store for their business model, rather than sharing a database with other applications.</span></span> <span data-ttu-id="cfd0e-188">Sınırlanmış bağlamları arasındaki iletişim için iş mantığı sağlayan bir paylaşılan veritabanı yerine programlama arabirimleri aracılığıyla oluşur ve gerçekleşmesi değişikliklere yanıt almak için olayları yerleştirir.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-188">Communication between bounded contexts occurs through programmatic interfaces, rather than through a shared database, which allows for business logic and events to take place in response to changes that take place.</span></span> <span data-ttu-id="cfd0e-189">Bağlamları harita yakından, ayrıca tek tek kendi sınırlanmış bağlamları ideal olarak uygulanan mikro ilişkisindeki.</span><span class="sxs-lookup"><span data-stu-id="cfd0e-189">Bounded contexts map closely to microservices, which also are ideally implemented as their own individual bounded contexts.</span></span>

> ### <a name="references--modern-web-applications"></a><span data-ttu-id="cfd0e-190">Başvuruları – Modern Web uygulamaları</span><span class="sxs-lookup"><span data-stu-id="cfd0e-190">References – Modern Web Applications</span></span>
> - <span data-ttu-id="cfd0e-191">**Sorunları ayrılması**</span><span class="sxs-lookup"><span data-stu-id="cfd0e-191">**Separation of Concerns**</span></span>  
> <span data-ttu-id="cfd0e-192"><http://deviq.com/separation-of-concerns/></span><span class="sxs-lookup"><span data-stu-id="cfd0e-192"><http://deviq.com/separation-of-concerns/></span></span>
> - <span data-ttu-id="cfd0e-193">**Kapsülleme** <http://deviq.com/encapsulation/></span><span class="sxs-lookup"><span data-stu-id="cfd0e-193">**Encapsulation** <http://deviq.com/encapsulation/></span></span>
> - <span data-ttu-id="cfd0e-194">**Bağımlılık tersine çevirme ilkesi**</span><span class="sxs-lookup"><span data-stu-id="cfd0e-194">**Dependency Inversion Principle**</span></span>  
> <span data-ttu-id="cfd0e-195"><http://deviq.com/Dependency-inversion-Principle/></span><span class="sxs-lookup"><span data-stu-id="cfd0e-195"><http://deviq.com/dependency-inversion-principle/></span></span>
> - <span data-ttu-id="cfd0e-196">**Açık bağımlılıkları İlkesi**</span><span class="sxs-lookup"><span data-stu-id="cfd0e-196">**Explicit Dependencies Principle**</span></span>  
> <span data-ttu-id="cfd0e-197"><http://deviq.com/Explicit-Dependencies-Principle/></span><span class="sxs-lookup"><span data-stu-id="cfd0e-197"><http://deviq.com/explicit-dependencies-principle/></span></span>
> - <span data-ttu-id="cfd0e-198">**Kendiniz yineleme**</span><span class="sxs-lookup"><span data-stu-id="cfd0e-198">**Don't Repeat Yourself**</span></span>  
> <span data-ttu-id="cfd0e-199"><http://deviq.com/Don-t-REPEAT-yourself/></span><span class="sxs-lookup"><span data-stu-id="cfd0e-199"><http://deviq.com/don-t-repeat-yourself/></span></span>
> - <span data-ttu-id="cfd0e-200">**Kalıcılık kullanmayan**</span><span class="sxs-lookup"><span data-stu-id="cfd0e-200">**Persistence Ignorance**</span></span>  
> <span data-ttu-id="cfd0e-201"><http://deviq.com/persistence-ignorance/></span><span class="sxs-lookup"><span data-stu-id="cfd0e-201"><http://deviq.com/persistence-ignorance/></span></span>
> - <span data-ttu-id="cfd0e-202">**Sınırlanmış bağlamı**</span><span class="sxs-lookup"><span data-stu-id="cfd0e-202">**Bounded Context**</span></span>  
> <span data-ttu-id="cfd0e-203"><https://martinfowler.com/bliki/BoundedContext.HTML></span><span class="sxs-lookup"><span data-stu-id="cfd0e-203"><https://martinfowler.com/bliki/BoundedContext.html></span></span>

> [!div class="step-by-step"]
<span data-ttu-id="cfd0e-204">[Önceki] (choose-between-traditional-web-and-single-page-apps.md) [sonraki] (ortak-web-uygulama-architectures.md)</span><span class="sxs-lookup"><span data-stu-id="cfd0e-204">[Previous] (choose-between-traditional-web-and-single-page-apps.md) [Next] (common-web-application-architectures.md)</span></span>

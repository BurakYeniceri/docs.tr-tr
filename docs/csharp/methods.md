---
title: "Yöntemler - C# Kılavuzu"
description: "Yöntem, yöntem parametreleri ve dönüş değerleri yöntemi genel bakış"
keywords: .NET, .NET Core, C#
author: rpetrusha
ms.author: ronpet
ms.date: 10/26/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 577a8527-1081-4b36-9b9e-0685b6553c6e
ms.openlocfilehash: 48127d5168ace7733f29f78dc3f72d9c0d051e4e
ms.sourcegitcommit: 83dd5ec003e788ccb3e33f3412a7af39ae347646
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/15/2018
---
# <a name="methods"></a><span data-ttu-id="3902a-104">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="3902a-104">Methods</span></span> #

<span data-ttu-id="3902a-105">Bir dizi deyimi içeren kod bloğu bir yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="3902a-105">A method is a code block that contains a series of statements.</span></span> <span data-ttu-id="3902a-106">Bir program yöntemini çağırarak ve tüm gerekli yöntemi bağımsız değişkenleri belirtme yürütülecek deyimleri neden olur.</span><span class="sxs-lookup"><span data-stu-id="3902a-106">A program causes the statements to be executed by calling the method and specifying any required method arguments.</span></span> <span data-ttu-id="3902a-107">C# ' ta yürütülen her yönerge bir yöntem bağlamında gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="3902a-107">In C#, every executed instruction is performed in the context of a method.</span></span> <span data-ttu-id="3902a-108">`Main` Yöntemi her C# uygulaması için giriş noktasıdır ve program başlatıldığında, ortak dil çalışma zamanı tarafından (CLR) adı verilir.</span><span class="sxs-lookup"><span data-stu-id="3902a-108">The `Main` method is the entry point for every C# application and it is called by the common language runtime (CLR) when the program is started.</span></span>

> [!NOTE]
> <span data-ttu-id="3902a-109">Bu konu, adlandırılmış yöntemleri açıklar.</span><span class="sxs-lookup"><span data-stu-id="3902a-109">This topic discusses named methods.</span></span> <span data-ttu-id="3902a-110">Anonim işlevler hakkında daha fazla bilgi için bkz: [anonim işlevler](programming-guide/statements-expressions-operators/anonymous-functions.md).</span><span class="sxs-lookup"><span data-stu-id="3902a-110">For information about anonymous functions, see [Anonymous Functions](programming-guide/statements-expressions-operators/anonymous-functions.md).</span></span>

<span data-ttu-id="3902a-111">Bu konu aşağıdaki bölümleri içermektedir:</span><span class="sxs-lookup"><span data-stu-id="3902a-111">This topic contains the following sections:</span></span>

- [<span data-ttu-id="3902a-112">Yöntem imzaları</span><span class="sxs-lookup"><span data-stu-id="3902a-112">Method signatures</span></span>](#signatures)
- [<span data-ttu-id="3902a-113">Yöntem çağırma</span><span class="sxs-lookup"><span data-stu-id="3902a-113">Method invocation</span></span>](#invocation)
- [<span data-ttu-id="3902a-114">Devralınan ve geçersiz kılınan yöntemleri</span><span class="sxs-lookup"><span data-stu-id="3902a-114">Inherited and overridden methods</span></span>](#inherited)
- [<span data-ttu-id="3902a-115">Parametreleri geçirme</span><span class="sxs-lookup"><span data-stu-id="3902a-115">Passing parameters</span></span>](#passing)
  - [<span data-ttu-id="3902a-116">Parametreleri değere göre geçirme</span><span class="sxs-lookup"><span data-stu-id="3902a-116">Passing parameters by value</span></span>](#byval)
  - [<span data-ttu-id="3902a-117">Parametreleri başvuruya göre geçirme</span><span class="sxs-lookup"><span data-stu-id="3902a-117">Passing parameters by reference</span></span>](#byref)
  - [<span data-ttu-id="3902a-118">Parametre dizileri</span><span class="sxs-lookup"><span data-stu-id="3902a-118">Parameter arrays</span></span>](#paramarray)
- [<span data-ttu-id="3902a-119">İsteğe bağlı parametreler ve bağımsız değişkenler</span><span class="sxs-lookup"><span data-stu-id="3902a-119">Optional parameters and arguments</span></span>](#optional)
- [<span data-ttu-id="3902a-120">Dönüş değerleri</span><span class="sxs-lookup"><span data-stu-id="3902a-120">Return values</span></span>](#return)
- [<span data-ttu-id="3902a-121">Genişletme yöntemleri</span><span class="sxs-lookup"><span data-stu-id="3902a-121">Extension methods</span></span>](#extension)
- [<span data-ttu-id="3902a-122">Zaman uyumsuz yöntemleri</span><span class="sxs-lookup"><span data-stu-id="3902a-122">Async Methods</span></span>](#async)
- [<span data-ttu-id="3902a-123">İfade gövdeli üyeler</span><span class="sxs-lookup"><span data-stu-id="3902a-123">Expression-bodied members</span></span>](#expr)
- [<span data-ttu-id="3902a-124">Yineleyiciler</span><span class="sxs-lookup"><span data-stu-id="3902a-124">Iterators</span></span>](#iterators)

<a name="signatures"></a>
## <a name="method-signatures"></a><span data-ttu-id="3902a-125">Yöntem imzaları</span><span class="sxs-lookup"><span data-stu-id="3902a-125">Method signatures</span></span> ##

<span data-ttu-id="3902a-126">İçinde bildirilen yöntemleri bir `class` veya `struct` belirterek:</span><span class="sxs-lookup"><span data-stu-id="3902a-126">Methods are declared in a `class` or `struct` by specifying:</span></span>

- <span data-ttu-id="3902a-127">İsteğe bağlı bir erişim düzeyi, gibi `public` veya `private`.</span><span class="sxs-lookup"><span data-stu-id="3902a-127">An optional access level, such as `public` or `private`.</span></span> <span data-ttu-id="3902a-128">Varsayılan, `private` değeridir.</span><span class="sxs-lookup"><span data-stu-id="3902a-128">The default is `private`.</span></span>
- <span data-ttu-id="3902a-129">İsteğe bağlı değiştiricileri gibi `abstract` veya `sealed`.</span><span class="sxs-lookup"><span data-stu-id="3902a-129">Optional modifiers such as `abstract` or `sealed`.</span></span>
- <span data-ttu-id="3902a-130">Dönüş değeri veya `void` yöntemi hiçbiri varsa.</span><span class="sxs-lookup"><span data-stu-id="3902a-130">The return value, or `void` if the method has none.</span></span>
- <span data-ttu-id="3902a-131">Yöntem adı.</span><span class="sxs-lookup"><span data-stu-id="3902a-131">The method name.</span></span>
- <span data-ttu-id="3902a-132">Herhangi bir yöntem parametreleri.</span><span class="sxs-lookup"><span data-stu-id="3902a-132">Any method parameters.</span></span> <span data-ttu-id="3902a-133">Yöntem parametreleri parantez içine alınmış ve virgülle ayrılır.</span><span class="sxs-lookup"><span data-stu-id="3902a-133">Method parameters are enclosed in parentheses and are separated by commas.</span></span> <span data-ttu-id="3902a-134">Boş parantez yöntemi hiçbir parametre gerektirmiyor gösterir.</span><span class="sxs-lookup"><span data-stu-id="3902a-134">Empty parentheses indicate that the method requires no parameters.</span></span>

<span data-ttu-id="3902a-135">Bu bölümleri birlikte yöntem imzası oluştururlar.</span><span class="sxs-lookup"><span data-stu-id="3902a-135">These parts together form the method signature.</span></span>

> [!NOTE]
> <span data-ttu-id="3902a-136">Bir yöntemin dönüş türü yöntemi için yöntem aşırı yükleme amacıyla imza parçası değil.</span><span class="sxs-lookup"><span data-stu-id="3902a-136">A return type of a method is not part of the signature of the method for the purposes of method overloading.</span></span> <span data-ttu-id="3902a-137">Ancak, bir temsilci ve işaret yöntemi uyumluluğu belirlerken yöntemi imzası parçası olan.</span><span class="sxs-lookup"><span data-stu-id="3902a-137">However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.</span></span>

<span data-ttu-id="3902a-138">Aşağıdaki örnek adlı bir sınıf tanımlar `Motorcycle` beş yöntemleri içerir:</span><span class="sxs-lookup"><span data-stu-id="3902a-138">The following example defines a class named `Motorcycle` that contains five methods:</span></span>

[!code-csharp[csSnippets.Methods#40](../../samples/snippets/csharp/concepts/methods/methods40.cs#40)]

<span data-ttu-id="3902a-139">Unutmayın `Motorcycle` sınıfı içeren bir aşırı yüklenmiş yöntemin `Drive`.</span><span class="sxs-lookup"><span data-stu-id="3902a-139">Note that the `Motorcycle` class includes an overloaded method, `Drive`.</span></span> <span data-ttu-id="3902a-140">İki yöntem aynı ada sahip, ancak bunların parametre türleri tarafından ayrıştırılan gerekir.</span><span class="sxs-lookup"><span data-stu-id="3902a-140">Two methods have the same name, but must be differentiated by their parameter types.</span></span>

<a name="invocation"></a>
## <a name="method-invocation"></a><span data-ttu-id="3902a-141">Yöntem çağırma</span><span class="sxs-lookup"><span data-stu-id="3902a-141">Method invocation</span></span> ##

<span data-ttu-id="3902a-142">Yöntemleri olabilir ya da *örneği* veya *statik*.</span><span class="sxs-lookup"><span data-stu-id="3902a-142">Methods can be either *instance* or *static*.</span></span> <span data-ttu-id="3902a-143">Bir örnek yöntemi çağrılırken bir nesne örneği ve bu nesnede metodunu çağırın gerektirir; Bu örnek ve verileri üzerinde örnek yöntemi çalışır.</span><span class="sxs-lookup"><span data-stu-id="3902a-143">Invoking an instance method requires that you instantiate an object and call the method on that object; an instance method operates on that instance and its data.</span></span> <span data-ttu-id="3902a-144">Yöntemin ait olduğu türünün adı başvurarak bir statik yöntem çağırma; statik yöntemler çalışan örnek veriler üzerinde çalıştırmayın.</span><span class="sxs-lookup"><span data-stu-id="3902a-144">You invoke a static method by referencing the name of the type to which the method belongs; static methods operate do not operate on instance data.</span></span> <span data-ttu-id="3902a-145">Bir nesne örneği aracılığıyla statik bir yöntem çağrısı çalışılıyor derleyici hatası oluşturur.</span><span class="sxs-lookup"><span data-stu-id="3902a-145">Attempting to call a static method through an object instance generates a compiler error.</span></span>

<span data-ttu-id="3902a-146">Bir yöntemi çağırmak için bir alan erişim gibi olur.</span><span class="sxs-lookup"><span data-stu-id="3902a-146">Calling a method is like accessing a field.</span></span> <span data-ttu-id="3902a-147">Nesne adı (örnek yöntemi arıyorsanız,) veya tür adı sonra (aradığınız varsa bir `static` yöntemi), nokta, yöntemi ve parantez adını ekleyin.</span><span class="sxs-lookup"><span data-stu-id="3902a-147">After the object name (if you are calling an instance method) or the type name (if you are calling a `static` method), add a period, the name of the method, and parentheses.</span></span> <span data-ttu-id="3902a-148">Bağımsız değişkenler ayraç içinde listelenmiştir ve virgülle ayrılır.</span><span class="sxs-lookup"><span data-stu-id="3902a-148">Arguments are listed within the parentheses, and are separated by commas.</span></span>

<span data-ttu-id="3902a-149">Yöntem tanımı adlarını ve gerekli olan herhangi bir parametre türlerini belirtir.</span><span class="sxs-lookup"><span data-stu-id="3902a-149">The method definition specifies the names and types of any parameters that are required.</span></span> <span data-ttu-id="3902a-150">Çağıran yöntemi çağırır her parametre için bağımsız değişken olarak adlandırılan somut değerleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="3902a-150">When a caller invokes the method, it provides concrete values, called arguments, for each parameter.</span></span> <span data-ttu-id="3902a-151">Bağımsız değişken parametre türü ile uyumlu olması gerekir, ancak bir arama kodda kullandıysanız bağımsız değişken adını, aynı adlı parametre yönteminde tanımlanmış olması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="3902a-151">The arguments must be compatible with the parameter type, but the argument name, if one is used in the calling code, does not have to be the same as the parameter named defined in the method.</span></span> <span data-ttu-id="3902a-152">Aşağıdaki örnekte, `Square` yöntemi içeren tek bir parametre türü `int` adlı *ı*.</span><span class="sxs-lookup"><span data-stu-id="3902a-152">In the following example, the `Square` method includes a single parameter of type `int` named *i*.</span></span> <span data-ttu-id="3902a-153">İlk yöntem çağrısı geçişleri `Square` yöntemi bir değişkeni türü `int` adlı *num*; saniye, sabit bir sayısal değer; ve üçüncü, bir ifade.</span><span class="sxs-lookup"><span data-stu-id="3902a-153">The first method call passes the `Square` method a variable of type `int` named *num*; the second, a numeric constant; and the third, an expression.</span></span>

[!code-csharp[csSnippets.Methods#74](../../samples/snippets/csharp/concepts/methods/params74.cs#74)]

<span data-ttu-id="3902a-154">En yaygın formun yöntemi çağırma konumsal bağımsız değişkenleri kullanılır. Yöntem parametreleri aynı sırada değişkenlerinde sağlar.</span><span class="sxs-lookup"><span data-stu-id="3902a-154">The most common form of method invocation used positional arguments; it supplies arguments in the same order as method parameters.</span></span> <span data-ttu-id="3902a-155">Yöntemlerinin `Motorcycle` sınıfı bu nedenle aşağıdaki örnekteki çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="3902a-155">The methods of the `Motorcycle` class can therefore be called as in the following example.</span></span> <span data-ttu-id="3902a-156">Çağrı `Drive` yöntemi, örneğin, iki parametre yöntemin sözdiziminde karşılık gelen iki bağımsız değişken içerir.</span><span class="sxs-lookup"><span data-stu-id="3902a-156">The call to the `Drive` method, for example, includes two arguments that correspond to the two parameters in the method's syntax.</span></span> <span data-ttu-id="3902a-157">İlk değeri olur `miles` parametresi, ikinci değerini `speed` parametresi.</span><span class="sxs-lookup"><span data-stu-id="3902a-157">The first becomes the value of the `miles` parameter, the second the value of the `speed` parameter.</span></span>

[!code-csharp[csSnippets.Methods#41](../../samples/snippets/csharp/concepts/methods/methods40.cs#41)]

<span data-ttu-id="3902a-158">Ayrıca kullanabilir *bağımsız değişkenleri adlı* yerine bir yöntem çağrılırken, konuma göre bağımsız değişken.</span><span class="sxs-lookup"><span data-stu-id="3902a-158">You can also used *named arguments* instead of positional arguments when invoking a method.</span></span> <span data-ttu-id="3902a-159">Adlandırılmış bağımsız değişkenler kullanma, belirttiğiniz üste parametre adı (":") ve bağımsız değişkeni.</span><span class="sxs-lookup"><span data-stu-id="3902a-159">When using named arguments, you specify the parameter name followed by a colon (":") and the argument.</span></span> <span data-ttu-id="3902a-160">Yöntemin bağımsız değişkenler, tüm gerekli bağımsız mevcut olduğu sürece herhangi bir sırada yer alabilir.</span><span class="sxs-lookup"><span data-stu-id="3902a-160">Arguments to the method can appear in any order, as long as all required arguments are present.</span></span> <span data-ttu-id="3902a-161">Aşağıdaki örnek, çağrılacak adlandırılmış bağımsız değişkenler kullanır `TestMotorcycle.Drive` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="3902a-161">The following example uses named arguments to invoke the `TestMotorcycle.Drive` method.</span></span> <span data-ttu-id="3902a-162">Bu örnekte, adlandırılmış bağımsız değişkenler yöntemin parametre listesinden ters sırada geçirildi.</span><span class="sxs-lookup"><span data-stu-id="3902a-162">In this example, the named arguments are passed in the opposite order from the method's parameter list.</span></span>

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/named1.cs#45)]

<span data-ttu-id="3902a-163">Konumsal iki bağımsız değişken'ı kullanarak bir yöntem çağırabileceği ve adlandırılmış bağımsız değişkenler.</span><span class="sxs-lookup"><span data-stu-id="3902a-163">You can invoke a method using both positional arguments and named arguments.</span></span> <span data-ttu-id="3902a-164">Ancak, bir konumsal bağımsız değişkeni bir adlandırılmış bağımsız değişkeni izlenemiyor.</span><span class="sxs-lookup"><span data-stu-id="3902a-164">However, a positional argument cannot follow a named argument.</span></span> <span data-ttu-id="3902a-165">Aşağıdaki örnek çağırır `TestMotorcycle.Drive` bir konumsal bağımsız değişkeni ve bir adlandırılmış bağımsız değişkeni kullanarak önceki örnekten yöntemi.</span><span class="sxs-lookup"><span data-stu-id="3902a-165">The following example invokes the `TestMotorcycle.Drive` method from the previous example using one positional argument and one named argument.</span></span>

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/named2.cs#46)]

 <a name="inherited"></a>
 ##<a name="inherited-and-overridden-methods"></a><span data-ttu-id="3902a-166">Devralınan ve geçersiz kılınan yöntemleri</span><span class="sxs-lookup"><span data-stu-id="3902a-166">Inherited and overridden methods</span></span> ##

<span data-ttu-id="3902a-167">Açıkça bir türde tanımlanan üyeleri ek olarak, bir türü, taban sınıflarından tanımlanan üyeleri devralır.</span><span class="sxs-lookup"><span data-stu-id="3902a-167">In addition to the members that are explicitly defined in a type, a type inherits members defined in its base classes.</span></span> <span data-ttu-id="3902a-168">Yönetilen tür sistemi içindeki tüm türler doğrudan veya dolaylı olarak devralınmalıdır beri <xref:System.Object> sınıfı, tüm türleri devral, bu grubun üyeleri gibi <xref:System.Object.Equals(System.Object)>, <xref:System.Object.GetType>, ve <xref:System.Object.ToString>.</span><span class="sxs-lookup"><span data-stu-id="3902a-168">Since all types in the managed type system inherit directly or indirectly from the <xref:System.Object> class, all types inherit its members, such as <xref:System.Object.Equals(System.Object)>, <xref:System.Object.GetType>, and <xref:System.Object.ToString>.</span></span> <span data-ttu-id="3902a-169">Aşağıdaki örnek tanımlayan bir `Person` sınıfı, iki başlatır `Person` nesneleri ve çağırır `Person.Equals` iki nesnenin eşit olup olmadığını belirlemek için yöntemi.</span><span class="sxs-lookup"><span data-stu-id="3902a-169">The following example defines a `Person` class, instantiates two `Person` objects, and calls the `Person.Equals` method to determine whether the two objects are equal.</span></span> <span data-ttu-id="3902a-170">`Equals` Yöntemi, ancak tanımlı değil de `Person` sınıf; kaynağından devralındı <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="3902a-170">The `Equals` method, however, is not defined in the `Person` class; it is inherited from <xref:System.Object>.</span></span>

[!code-csharp[csSnippets.Methods#104](../../samples/snippets/csharp/concepts/methods/inherited1.cs#104)]

<span data-ttu-id="3902a-171">Türlerini kullanarak devralınan üyeleri kılabilirsiniz `override` anahtar sözcüğü ve geçersiz kılınan yöntemi için bir uygulama sağlama.</span><span class="sxs-lookup"><span data-stu-id="3902a-171">Types can override inherited members by using the `override` keyword and providing an implementation for the overridden method.</span></span> <span data-ttu-id="3902a-172">Yöntem imzası geçersiz kılınan yöntemi olarak aynı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="3902a-172">The method signature must be the same as that of the overridden method.</span></span> <span data-ttu-id="3902a-173">Bu geçersiz kılmaları aşağıdaki örnek önceki bir gibi olmasıdır <xref:System.Object.Equals(System.Object)> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="3902a-173">The following example is like the previous one, except that it overrides the <xref:System.Object.Equals(System.Object)> method.</span></span> <span data-ttu-id="3902a-174">(Ayrıca geçersiz kılar <xref:System.Object.GetHashCode> tutarlı sonuçlar sağlamak için iki yöntem amaçlandığından yöntemi.)</span><span class="sxs-lookup"><span data-stu-id="3902a-174">(It also overrides the <xref:System.Object.GetHashCode> method, since the two methods are intended to provide consistent results.)</span></span>

[!code-csharp[csSnippets.Methods#105](../../samples/snippets/csharp/concepts/methods/overridden1.cs#105)]

<a name="passing"></a>
## <a name="passing-parameters"></a><span data-ttu-id="3902a-175">Parametreleri geçirme</span><span class="sxs-lookup"><span data-stu-id="3902a-175">Passing parameters</span></span> ##

<span data-ttu-id="3902a-176">C# türleridir ya da *değer türleri* veya *başvuru türleri*.</span><span class="sxs-lookup"><span data-stu-id="3902a-176">Types in C# are either *value types* or *reference types*.</span></span> <span data-ttu-id="3902a-177">Yerleşik değer türlerinin listesi için bkz: [türleri ve değişkenleri](./tour-of-csharp/types-and-variables.md).</span><span class="sxs-lookup"><span data-stu-id="3902a-177">For a list of built-in value types, see [Types and variables](./tour-of-csharp/types-and-variables.md).</span></span> <span data-ttu-id="3902a-178">Varsayılan olarak, değer türleri ve başvuru türleri bir yönteme değeriyle geçirilir.</span><span class="sxs-lookup"><span data-stu-id="3902a-178">By default, both value types and reference types are passed to a method by value.</span></span>

<a name="byval"></a>
### <a name="passing-parameters-by-value"></a><span data-ttu-id="3902a-179">Parametreleri değere göre geçirme</span><span class="sxs-lookup"><span data-stu-id="3902a-179">Passing parameters by value</span></span> ###

<span data-ttu-id="3902a-180">Değer türü değere göre bir yönteme geçirildiğinde nesnenin nesne yerine bir kopyasını yönteme geçirilir.</span><span class="sxs-lookup"><span data-stu-id="3902a-180">When a value type is passed to a method by value, a copy of the object instead of the object itself is passed to the method.</span></span> <span data-ttu-id="3902a-181">Bu nedenle, Denetim çağırana döndürüldüğünde çağrılan yöntemin Nesne değişiklikleri özgün nesne üzerinde etkisi yoktur.</span><span class="sxs-lookup"><span data-stu-id="3902a-181">Therefore, changes to the object in the called method have no effect on the original object when control returns to the caller.</span></span>

<span data-ttu-id="3902a-182">Aşağıdaki örnek bir değer türü için bir yöntem tarafından değeri geçirir ve değer türünün değerini değiştirmek çağrılan yöntemin çalışır.</span><span class="sxs-lookup"><span data-stu-id="3902a-182">The following example passes a value type to a method by value, and the called method attempts to change the value type's value.</span></span> <span data-ttu-id="3902a-183">Türünde bir değişken tanımlar `int`, bir değer türü, 20 değerine başlatır ve adlı bir yönteme geçirir `ModifyValue` 30 değişkenin değeri değişir.</span><span class="sxs-lookup"><span data-stu-id="3902a-183">It defines a variable of type `int`, which is a value type, initializes its value to 20, and passes it to a method named `ModifyValue` that changes the variable's value to 30.</span></span> <span data-ttu-id="3902a-184">Ancak, yöntem döndüğünde, değişkenin değeri değişmeden kalır.</span><span class="sxs-lookup"><span data-stu-id="3902a-184">When the method returns, however, the variable's value remains unchanged.</span></span>

[!code-csharp[csSnippets.Methods#10](../../samples/snippets/csharp/concepts/methods/byvalue10.cs#10)]

<span data-ttu-id="3902a-185">Başvuru türünde bir nesne değeri tarafından bir yönteme geçirildiğinde nesneye bir başvurusu tarafından geçirildi.</span><span class="sxs-lookup"><span data-stu-id="3902a-185">When an object of a reference type is passed to a method by value, a reference to the object is passed by value.</span></span> <span data-ttu-id="3902a-186">Diğer bir deyişle, nesnenin kendisini değil ancak nesnenin konumunu belirten bir bağımsız değişken yöntemi alır.</span><span class="sxs-lookup"><span data-stu-id="3902a-186">That is, the method receives not the object itself, but an argument that indicates the location of the object.</span></span> <span data-ttu-id="3902a-187">Bu başvuru kullanarak nesne üyesi değiştirirseniz, değişiklik denetimi için arama yöntem döndüğünde nesnesinde yansıtılır.</span><span class="sxs-lookup"><span data-stu-id="3902a-187">If you change a member of the object by using this reference, the change is reflected in the object when control returns to the calling method.</span></span> <span data-ttu-id="3902a-188">Denetim çağırana döndürdüğünde ancak, yönteme geçirilen nesneyi değiştirme özgün nesne üzerinde etkisi yoktur.</span><span class="sxs-lookup"><span data-stu-id="3902a-188">However, replacing the object passed to the method has no effect on the original object when control returns to the caller.</span></span>

<span data-ttu-id="3902a-189">Aşağıdaki örnek adında (bir başvuru türü olan) bir sınıfı tanımlar `SampleRefType`.</span><span class="sxs-lookup"><span data-stu-id="3902a-189">The following example defines a class (which is a reference type) named `SampleRefType`.</span></span> <span data-ttu-id="3902a-190">Bunu başlatır bir `SampleRefType` nesne, 44 için atar kendi `value` alan ve nesnesine geçirir `ModifyObject` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="3902a-190">It instantiates a `SampleRefType` object, assigns 44 to its `value` field, and passes the object to the `ModifyObject` method.</span></span> <span data-ttu-id="3902a-191">Bu örnek önceki örnekteki gibi temelde aynı şeyi yapar--bu bağımsız değişken değeri tarafından bir yönteme geçirir.</span><span class="sxs-lookup"><span data-stu-id="3902a-191">This example does essentially the same thing as the previous example -- it passes an argument by value to a method.</span></span> <span data-ttu-id="3902a-192">Ancak bir başvuru türü kullanıldığından, sonuç farklıdır.</span><span class="sxs-lookup"><span data-stu-id="3902a-192">But because a reference type is used, the result is different.</span></span> <span data-ttu-id="3902a-193">İçinde yapılan değişiklik `ModifyObject` için `obj.value` alan de değişiklikleri `value` bağımsız değişken alan `rt`, `Main` 33, bir yönteme örnek gösterir çıktısı olarak.</span><span class="sxs-lookup"><span data-stu-id="3902a-193">The modification that is made in `ModifyObject` to the `obj.value` field also changes the `value` field of the argument, `rt`, in the `Main` method to 33, as the output from the example shows.</span></span>

[!code-csharp[csSnippets.Methods#42](../../samples/snippets/csharp/concepts/methods/byvalue42.cs#42)]

<a name="byref"></a>
### <a name="passing-parameters-by-reference"></a><span data-ttu-id="3902a-194">Parametreleri başvuruya göre geçirme</span><span class="sxs-lookup"><span data-stu-id="3902a-194">Passing parameters by reference</span></span> ###

<span data-ttu-id="3902a-195">Bir yöntem bir bağımsız değişken değerini değiştirin ve bu değişiklik denetimi için arama yöntem döndüğünde refect istediğiniz istediğinizde başvuruya göre bir parametre geçirin.</span><span class="sxs-lookup"><span data-stu-id="3902a-195">You pass a parameter by reference when you want to change the value of an argument in a method and want to refect that change when control returns to the calling method.</span></span> <span data-ttu-id="3902a-196">Başvuruya göre bir parametre geçirmek için kullandığınız [ `ref` ](language-reference/keywords/ref.md) veya [ `out` ](language-reference/keywords/out-parameter-modifier.md) anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="3902a-196">To pass a parameter by reference, you use the [`ref`](language-reference/keywords/ref.md) or [`out`](language-reference/keywords/out-parameter-modifier.md) keyword.</span></span> <span data-ttu-id="3902a-197">Başvuruya göre kopyalama kaçının ancak hala kullanarak değişiklikleri önlemek için de bir değer geçirebilirsiniz [ `in` ](language-reference/keywords/in-parameter-modifier.md) anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="3902a-197">You can also pass a value by reference to avoid copying but still prevent modifications using the [`in`](language-reference/keywords/in-parameter-modifier.md) keyword.</span></span>

<span data-ttu-id="3902a-198">Başvuru tarafından geçirilen değer dışında aşağıdaki örnekte önceki birine aynıdır `ModifyValue` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="3902a-198">The following example is identical to the previous one, except the value is passed by reference to the `ModifyValue` method.</span></span> <span data-ttu-id="3902a-199">Parametresinin değeri değiştirildiği içinde `ModifyValue` yöntemi, değerindeki değişikliği denetim çağırana döndürdüğünde yansıtılır.</span><span class="sxs-lookup"><span data-stu-id="3902a-199">When the value of the parameter is modified in the `ModifyValue` method, the change in value is reflected when control returns to the caller.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/byref106.cs#106)]

<span data-ttu-id="3902a-200">Ref parametreleri kullanan genel bir desen değişkenlerin değerleri değiştirmeyi içerir.</span><span class="sxs-lookup"><span data-stu-id="3902a-200">A common pattern that uses by ref parameters involves swapping the values of variables.</span></span> <span data-ttu-id="3902a-201">İki değişkenleri başvuruya göre bir yönteme geçirin ve içeriklerini yöntemi değiştirir.</span><span class="sxs-lookup"><span data-stu-id="3902a-201">You pass two variables to a method by reference, and the method swaps their contents.</span></span> <span data-ttu-id="3902a-202">Aşağıdaki örnek tamsayı değerleri değiştirir.</span><span class="sxs-lookup"><span data-stu-id="3902a-202">The following example swaps integer values.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/swap107.cs#107)]

<span data-ttu-id="3902a-203">Bir başvuru türü parametre geçirme ayrı ayrı öğeler veya alanlar değeri yerine başvuru değeri değiştirmenize izin verir.</span><span class="sxs-lookup"><span data-stu-id="3902a-203">Passing a reference-type parameter allows you to change the value of the reference itself, rather than the value of its individual elements or fields.</span></span>

<a name="paramarray"></a>
### <a name="parameter-arrays"></a><span data-ttu-id="3902a-204">Parametre dizileri</span><span class="sxs-lookup"><span data-stu-id="3902a-204">Parameter arrays</span></span> ###

<span data-ttu-id="3902a-205">Bazı durumlarda, tam sayıda bağımsız değişken yönteminize belirtin kısıtlayıcı gereksinimdir.</span><span class="sxs-lookup"><span data-stu-id="3902a-205">Sometimes, the requirement that you specify the exact number of arguments to your method is restrictive.</span></span> <span data-ttu-id="3902a-206">Kullanarak `params` parametre dizisine bir parametredir, değişken sayıda bağımsız değişken çağrılacak yönteminizi izin göstermek için anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="3902a-206">By using the `params` keyword to indicate that a parameter is a parameter array, you allow your method to be called with a variable number of arguments.</span></span> <span data-ttu-id="3902a-207">Parametresi ile etiketlenmiş `params` anahtar sözcüğü bir dizi türünde olması gerekir ve bu yöntemin parametre listesindeki son parametre olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="3902a-207">The parameter tagged with the `params` keyword must must be an array type, and it must be the last parameter in the method's parameter list.</span></span>

<span data-ttu-id="3902a-208">Çağıran, ardından üç yolla yöntemi çağırabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="3902a-208">A caller can then invoke the method in either of three ways:</span></span>

- <span data-ttu-id="3902a-209">Uygun türde bir dizi geçirerek öğeleri istenen sayısını içerir.</span><span class="sxs-lookup"><span data-stu-id="3902a-209">By passing an array of the appropriate type that contains the desired number of elements.</span></span>
- <span data-ttu-id="3902a-210">Uygun bir tür bağımsız değişkenleri, virgülle ayrılmış listesini yönteme geçirerek.</span><span class="sxs-lookup"><span data-stu-id="3902a-210">By passing a comma-separated list of individual arguments of the appropriate type to the method.</span></span>
- <span data-ttu-id="3902a-211">Bir bağımsız değişken parametre dizisine sağlayarak değil.</span><span class="sxs-lookup"><span data-stu-id="3902a-211">By not providing an argument to the parameter array.</span></span>

<span data-ttu-id="3902a-212">Aşağıdaki örnek, adlandırılmış bir yöntem tanımlar `DoStringOperation` ilk parametresiyle belirtilen dize işlemi gerçekleştiren bir `StringOperation` numaralandırma üyesi.</span><span class="sxs-lookup"><span data-stu-id="3902a-212">The following example defines a method named `DoStringOperation` that performs the string operation specified by its first parameter, a `StringOperation` enumeration member.</span></span> <span data-ttu-id="3902a-213">Sonra işlemi gerçekleştirmek için olduğu dizeleri bir parametre dizisi tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="3902a-213">The strings upon which it is to perform the operation are defined by a parameter array.</span></span> <span data-ttu-id="3902a-214">`Main` Yöntemi yöntemi çağırma tüm üç yolu gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="3902a-214">The `Main` method illustrates all three ways of invoking the method.</span></span> <span data-ttu-id="3902a-215">Yöntem ile etiketlenmiş Not `params` anahtar sözcüğü hazırlanmış, böylece değerini bağımsız değişken parametre dizisi için sağlanmaktadır durumu işlemek için `null`.</span><span class="sxs-lookup"><span data-stu-id="3902a-215">Note that the method tagged with the `params` keyword must be prepared to handle the case in which no argument is supplied for the parameter array, so that its value is `null`.</span></span>

[!code-csharp[csSnippets.Methods#106](../../samples/snippets/csharp/concepts/methods/byref108.cs#108)]

<a name="optional"></a>
## <a name="optional-parameters-and-arguments"></a><span data-ttu-id="3902a-216">İsteğe bağlı parametreler ve bağımsız değişkenler</span><span class="sxs-lookup"><span data-stu-id="3902a-216">Optional parameters and arguments</span></span> ##

<span data-ttu-id="3902a-217">Bir yöntemin tanımı parametrelerini gerekli veya isteğe bağlı oldukları belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3902a-217">A method definition can specify that its parameters are required or that they are optional.</span></span> <span data-ttu-id="3902a-218">Varsayılan olarak, parametreler gereklidir.</span><span class="sxs-lookup"><span data-stu-id="3902a-218">By default, parameters are required.</span></span> <span data-ttu-id="3902a-219">İsteğe bağlı parametreler yöntemi tanımı'nda parametrenin varsayılan değeri dahil olmak üzere belirtildi.</span><span class="sxs-lookup"><span data-stu-id="3902a-219">Optional parameters are specified by including the parameter's default value in the method definition.</span></span> <span data-ttu-id="3902a-220">Yöntem çağrıldığında, bağımsız değişken için isteğe bağlı parametresi belirtilirse, varsayılan değer yerine kullanılır.</span><span class="sxs-lookup"><span data-stu-id="3902a-220">When the method is called, if no argument is supplied for an optional parameter, the default value is used instead.</span></span>

<span data-ttu-id="3902a-221">Parametrenin varsayılan değeri ifadeleri şu tür biri tarafından atanmış gerekir:</span><span class="sxs-lookup"><span data-stu-id="3902a-221">The parameter's default value must be assigned by one of the following kinds of expressions:</span></span>

- <span data-ttu-id="3902a-222">Değişmez değer dize veya sayı gibi bir sabiti.</span><span class="sxs-lookup"><span data-stu-id="3902a-222">A constant, such as a literal string or number.</span></span>
- <span data-ttu-id="3902a-223">Bir ifade formun `new ValType`, burada `ValType` değer türü değil.</span><span class="sxs-lookup"><span data-stu-id="3902a-223">An expression of the form `new ValType`, where `ValType` is a value type.</span></span> <span data-ttu-id="3902a-224">Bu tür gerçek bir üyesi değil değer türünün örtük varsayılan oluşturucu çağırır unutmayın.</span><span class="sxs-lookup"><span data-stu-id="3902a-224">Note that this invokes the value type's implicit default constructor, which is not an actual member of the type.</span></span>
- <span data-ttu-id="3902a-225">Bir ifade formun `default(ValType)`, burada `ValType` değer türü değil.</span><span class="sxs-lookup"><span data-stu-id="3902a-225">An expression of the form `default(ValType)`, where `ValType` is a value type.</span></span>

<span data-ttu-id="3902a-226">Bir yöntem gerekli ve isteğe bağlı parametreleri içeriyorsa, isteğe bağlı parametreler parametre listesi, tüm gerekli parametreleri sonunda tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="3902a-226">If a method includes both required and optional parameters, optional parameters are defined at the end of the parameter list, after all required parameters.</span></span>

<span data-ttu-id="3902a-227">Aşağıdaki örnek, bir yöntem tanımlar `ExampleMethod`, bir gerekli ve isteğe bağlı parametrelerden sahiptir.</span><span class="sxs-lookup"><span data-stu-id="3902a-227">The following example defines a method, `ExampleMethod`, that has one required and two optional parameters.</span></span>

[!code-csharp[csSnippets.Methods#21](../../samples/snippets/csharp/concepts/methods/optional1.cs#21)]

<span data-ttu-id="3902a-228">Birden çok isteğe bağlı bağımsız değişkenlere sahip bir yöntem kullanarak konumsal bağımsız değişkenlerine çağrılırsa, çağıran bir bağımsız değişken sağlanan sonuncu birinciye tüm isteğe bağlı parametreler için bağımsız değişken girmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="3902a-228">If a method with multiple optional arguments is invoked using positional arguments, the caller must supply an argument for all optional parameters from the first one to the last one for which an argument is supplied.</span></span> <span data-ttu-id="3902a-229">Durumunda `ExampleMethod` yöntemi, örneğin, çağıran bir bağımsız değişken sağlarsa `description` parametresi, onu gerekir ayrıca sağlamak için bir tane `optionalInt` parametresi.</span><span class="sxs-lookup"><span data-stu-id="3902a-229">In the case of the  `ExampleMethod` method, for example, if the caller supplies an argument for the `description` parameter, it must also supply one for the `optionalInt` parameter.</span></span> <span data-ttu-id="3902a-230">`opt.ExampleMethod(2, 2, "Addition of 2 and 2");` Geçerli yöntem çağırma olduğu; `opt.ExampleMethod(2, , "Addition of 2 and 0);` bir "bağımsız değişkeni eksik" oluşturur derleyici hatası.</span><span class="sxs-lookup"><span data-stu-id="3902a-230">`opt.ExampleMethod(2, 2, "Addition of 2 and 2");` is a valid method call; `opt.ExampleMethod(2, , "Addition of 2 and 0);` generates an "Argument missing" compiler error.</span></span>

<span data-ttu-id="3902a-231">Adlandırılmış bağımsız değişkenler veya konumsal ve adlandırılmış bağımsız değişkenler bir birleşimini kullanarak bir yöntem çağrılırsa, çağıran yöntem çağrısı son konumsal değişkeninde izleyin herhangi bir bağımsız değişken atlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3902a-231">If a method is called using named arguments or a combination of positional and named arguments, the caller can omit any arguments that follow the last positional argument in the method call.</span></span>

<span data-ttu-id="3902a-232">Aşağıdaki örnek çağrıları `ExampleMethod` yöntemi üç kez.</span><span class="sxs-lookup"><span data-stu-id="3902a-232">The following example calls the `ExampleMethod` method three times.</span></span>  <span data-ttu-id="3902a-233">İlk iki yöntem çağrılarını konumsal bağımsız değişkenlerini kullanın.</span><span class="sxs-lookup"><span data-stu-id="3902a-233">The first two method calls use positional arguments.</span></span> <span data-ttu-id="3902a-234">Son bağımsız değişken ikinci atlar sırada ilk iki isteğe bağlı bağımsız değişkenler atlar.</span><span class="sxs-lookup"><span data-stu-id="3902a-234">The first omits both optional arguments, while the second omits the last argument.</span></span> <span data-ttu-id="3902a-235">Üçüncü yöntem çağrısı gerekli parametre için konumsal bir bağımsız değişken sağlar, ancak adlandırılmış bağımsız değişkeni için bir değer sağlamak için kullanır `description` atlama sırasında parametre `optionalInt` bağımsız değişkeni.</span><span class="sxs-lookup"><span data-stu-id="3902a-235">The third method call supplies a positional argument for the required parameter, but uses a named argument to supply a value to the `description` parameter while omitting the `optionalInt` argument.</span></span>

[!code-csharp[csSnippets.Methods#22](../../samples/snippets/csharp/concepts/methods/optional1.cs#22)]

<span data-ttu-id="3902a-236">İsteğe bağlı parametreler kullanımını etkiler *aşırı yükleme çözümü*, veya C# Derleyici belirler belirli hangi aşırı yüklemenin bir yöntem çağrısı tarafından gibi çağrılması gereken şekilde:</span><span class="sxs-lookup"><span data-stu-id="3902a-236">The use of optional parameters affects *overload resolution*, or the way in which the C# compiler determines which particular overload should be invoked by a method call, as follows:</span></span>

- <span data-ttu-id="3902a-237">Yöntemi, dizin oluşturucu veya oluşturucusu yürütme aday, tüm parametrelerinin isteğe bağlı olduğu veya karşılık gelen, adıyla veya konuma arama deyiminde tek bir bağımsız değişken ve bağımsız değişken parametre türüne dönüştürülebilir ise.</span><span class="sxs-lookup"><span data-stu-id="3902a-237">A method, indexer, or constructor is a candidate for execution if each of its parameters either is optional or corresponds, by name or by position, to a single argument in the calling statement, and that argument can be converted to the type of the parameter.</span></span>
- <span data-ttu-id="3902a-238">Birden fazla aday bulunursa, tercih edilen dönüştürmeleri için aşırı çözümleme kurallarını açıkça belirtilen bağımsız değişkenler için uygulanır.</span><span class="sxs-lookup"><span data-stu-id="3902a-238">If more than one candidate is found, overload resolution rules for preferred conversions are applied to the arguments that are explicitly specified.</span></span> <span data-ttu-id="3902a-239">İsteğe bağlı parametreleri belirtilmemişse bağımsız değişkenleri göz ardı edilir.</span><span class="sxs-lookup"><span data-stu-id="3902a-239">Omitted arguments for optional parameters are ignored.</span></span>
- <span data-ttu-id="3902a-240">İki aday eşit iyi olmasını nitelendirilmiştir, tercih değişkenleri çağrısında atlanmış isteğe bağlı parametreler yok bir aday gider.</span><span class="sxs-lookup"><span data-stu-id="3902a-240">If two candidates are judged to be equally good, preference goes to a candidate that does not have optional parameters for which arguments were omitted in the call.</span></span> <span data-ttu-id="3902a-241">Daha az parametrelere sahip bir aday aşırı çözünürlük genel bir tercih sonucu budur.</span><span class="sxs-lookup"><span data-stu-id="3902a-241">This is a consequence of a general preference in overload resolution for candidates that have fewer parameters.</span></span>

 <a name="return"></a>
 ## <a name="return-values"></a><span data-ttu-id="3902a-242">Döndürülen değerler</span><span class="sxs-lookup"><span data-stu-id="3902a-242">Return values</span></span> ##

<span data-ttu-id="3902a-243">Yöntemleri bir değer çağırana geri dönebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3902a-243">Methods can return a value to the caller.</span></span> <span data-ttu-id="3902a-244">Dönüş türü (önce yöntem adını listelenen) değilse, `void`, yöntem kullanarak değeri döndürebilir `return` anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="3902a-244">If the return type (the type listed before the method name) is not `void`, the method can return the value by using the `return` keyword.</span></span> <span data-ttu-id="3902a-245">With deyimi `return` değişken, sabit veya dönüş türüyle eşleşen ifadesi tarafından anahtar sözcüğünü yöntemi çağırana bu değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="3902a-245">A statement with the `return` keyword followed by a variable, constant, or expression that matches the return type will return that value to the method caller.</span></span> <span data-ttu-id="3902a-246">Void olmayan yöntemleriyle dönüş türü kullanmak için gerekli `return` bir değer döndürmek üzere anahtar sözcük.</span><span class="sxs-lookup"><span data-stu-id="3902a-246">Methods with a non-void return type are required to use the `return` keyword to return a value.</span></span> <span data-ttu-id="3902a-247">`return` Anahtar sözcüğü yönteminin yürütülmesi de durdurulur.</span><span class="sxs-lookup"><span data-stu-id="3902a-247">The `return` keyword also stops the execution of the method.</span></span>

<span data-ttu-id="3902a-248">Dönüş türü ise `void`, `return` deyimi bir değer olmadan yönteminin yürütülmesi durdurmak hala faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="3902a-248">If the return type is `void`, a `return` statement without a value is still useful to stop the execution of the method.</span></span> <span data-ttu-id="3902a-249">Olmadan `return` anahtar sözcüğü yöntemi durduracak kod bloğunu sonuna ulaştığında yürütülüyor.</span><span class="sxs-lookup"><span data-stu-id="3902a-249">Without the `return` keyword, the method will stop executing when it reaches the end of the code block.</span></span>

<span data-ttu-id="3902a-250">Örneğin, bu iki yöntem kullanmak `return` tamsayılar döndürmek için anahtar sözcüğü:</span><span class="sxs-lookup"><span data-stu-id="3902a-250">For example, these two methods use the `return` keyword to return integers:</span></span>

[!code-csharp[csSnippets.Methods#44](../../samples/snippets/csharp/concepts/methods/return44.cs#44)]

<span data-ttu-id="3902a-251">Bir yönteminden döndürülen bir değer kullanmak için arama yöntemi aynı türde bir değer yeterli olacaktır yöntem çağrısının kendisini her yerde kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3902a-251">To use a value returned from a method, the calling method can use the method call itself anywhere a value of the same type would be sufficient.</span></span> <span data-ttu-id="3902a-252">Dönüş değeri bir değişkene de atayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3902a-252">You can also assign the return value to a variable.</span></span> <span data-ttu-id="3902a-253">Örneğin, aşağıdaki iki kod örnekleri aynı hedefe gerçekleştirirsiniz:</span><span class="sxs-lookup"><span data-stu-id="3902a-253">For example, the following two code examples accomplish the same goal:</span></span>

[!code-csharp[csSnippets.Methods#45](../../samples/snippets/csharp/concepts/methods/return44.cs#45)]

[!code-csharp[csSnippets.Methods#46](../../samples/snippets/csharp/concepts/methods/return44.cs#46)]

<span data-ttu-id="3902a-254">Yerel bir değişken, bu durumda, kullanarak `result`depolamak için bir değer isteğe bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="3902a-254">Using a local variable, in this case, `result`, to store a value is optional.</span></span> <span data-ttu-id="3902a-255">Tüm kapsamını yöntemi için bağımsız değişken özgün değeri depolamak gerekiyorsa gerekli olabilir veya kod okunabilirliğini yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="3902a-255">It may help the readability of the code, or it may be necessary if you need to store the original value of the argument for the entire scope of the method.</span></span>

<span data-ttu-id="3902a-256">Bazen, tek bir değer birden fazla döndürülecek yönteminizi istersiniz.</span><span class="sxs-lookup"><span data-stu-id="3902a-256">Sometimes, you want your method to return more than a single value.</span></span> <span data-ttu-id="3902a-257">C# 7. 0'dan başlayarak, kolayca kullanarak bunu yapabilirsiniz *kayıt türlerinin* ve *dizi değişmez değerleri*.</span><span class="sxs-lookup"><span data-stu-id="3902a-257">Starting with C# 7.0, you can do this easily by using *tuple types* and *tuple literals*.</span></span> <span data-ttu-id="3902a-258">Kayıt türü demete ait öğeleri veri türlerini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="3902a-258">The tuple type defines the data types of the tuple's elements.</span></span> <span data-ttu-id="3902a-259">Dizi değişmez değerleri döndürülen kayıt gerçek değerler sağlayın.</span><span class="sxs-lookup"><span data-stu-id="3902a-259">Tuple literals provide the actual values of the returned tuple.</span></span> <span data-ttu-id="3902a-260">Aşağıdaki örnekte, `(string, string, string, int)` tarafından döndürülen dizi türünü tanımlayan `GetPersonalInfo` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="3902a-260">In the following example, `(string, string, string, int)` defines the tuple type that is returned by the `GetPersonalInfo` method.</span></span> <span data-ttu-id="3902a-261">İfade `(per.FirstName, per.MiddleName, per.LastName, per.Age)` tanımlama yöntemi döndürür, Orta, adı ve Soyadı, geçerlilik süresi ile birlikte değişmez değer; olan bir `PersonInfo` nesnesi.</span><span class="sxs-lookup"><span data-stu-id="3902a-261">The expression `(per.FirstName, per.MiddleName, per.LastName, per.Age)` is the tuple literal; the method returns the first, middle, and last name, along with the age, of a `PersonInfo` object.</span></span>

```csharp
public (string, string, string, int) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    if (per != null)
       return (per.FirstName, per.MiddleName, per.LastName, per.Age);
    else
       return null;
}
```

<span data-ttu-id="3902a-262">Çağıran, ardından aşağıdaki gibi kod ile döndürülen tanımlama grubu kullanmasını sağlayabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="3902a-262">The caller can then consume the returned tuple with code like the following:</span></span>

```csharp
var person = GetPersonalInfo("111111111")
if (person != null)
   Console.WriteLine("{person.Item1} {person.Item3}: age = {person.Item4}");
```

<span data-ttu-id="3902a-263">Adları tanımlama grubu türü tanımında başlığın öğeleri yeniden atanabilir.</span><span class="sxs-lookup"><span data-stu-id="3902a-263">Names can also be assigned to the tuple elements in the tuple type definition.</span></span> <span data-ttu-id="3902a-264">Aşağıdaki örnek, farklı bir sürümünü gösterir `GetPersonalInfo` kullanan yöntemi adlı öğeleri:</span><span class="sxs-lookup"><span data-stu-id="3902a-264">The following example shows an alternate version of the `GetPersonalInfo` method that uses named elements:</span></span>

```csharp
public (string FName, string MName, string LName, int Age) GetPersonalInfo(string id)
{
    PersonInfo per = PersonInfo.RetrieveInfoById(id);
    if (per != null)
       return (per.FirstName, per.MiddleName, per.LastName, per.Age);
    else
       return null;
}
```

<span data-ttu-id="3902a-265">Önceki çağrısı `GetPersonInfo` yöntemi sonra değiştirilebilir gibi:</span><span class="sxs-lookup"><span data-stu-id="3902a-265">The previous call to the `GetPersonInfo` method can then be modified as follows:</span></span>

```csharp
var person = GetPersonalInfo("111111111");
if (person != null)
   Console.WriteLine("{person.FName} {person.LName}: age = {person.Age}");
```

<span data-ttu-id="3902a-266">Bir yöntem bağımsız değişken olarak bir dizi geçirilir ve ayrı ayrı öğeler değerini değiştirir, iyi stili veya değerlerin işlevsel akış için bunu seçebilirsiniz ancak bu yöntem dizi döndürecek şekilde gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="3902a-266">If a method is passed an array as an argument and modifies the value of individual elements, it is not necessary for the method to return the array, although you may choose to do so for good style or functional flow of values.</span></span>  <span data-ttu-id="3902a-267">C# değerine göre tüm başvuru türleri geçer ve bir dizi başvurusu dizi yönelik işaretçinin değeri nedeni budur.</span><span class="sxs-lookup"><span data-stu-id="3902a-267">This is because C# passes all reference types by value, and the value of an array reference is the pointer to the array.</span></span> <span data-ttu-id="3902a-268">Aşağıdaki örnekte, içeriğini değiştirir `values` içinde yapılan dizi `DoubleValues` observable dizi başvuruyor herhangi bir kod tarafından bir yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="3902a-268">In the following example, changes to the contents of the `values` array that are made in the `DoubleValues` method are observable by any code that has a reference to the array.</span></span>

[!code-csharp[csSnippets.Methods#101](../../samples/snippets/csharp/concepts/methods/returnarray1.cs#101)]

 <a name="exten"></a>
 ## <a name="extension-methods"></a><span data-ttu-id="3902a-269">Genişletme yöntemleri</span><span class="sxs-lookup"><span data-stu-id="3902a-269">Extension methods</span></span> ##

<span data-ttu-id="3902a-270">Normalde, mevcut bir türle bir yöntem eklemek için iki yolu vardır:</span><span class="sxs-lookup"><span data-stu-id="3902a-270">Ordinarily, there are two ways to add a method to an existing type:</span></span>

- <span data-ttu-id="3902a-271">Bu tür için kaynak kodunu değiştirin.</span><span class="sxs-lookup"><span data-stu-id="3902a-271">Modify the source code for that type.</span></span> <span data-ttu-id="3902a-272">Elbette, tür kaynak kodu kendisine değil, bunu yapamaz.</span><span class="sxs-lookup"><span data-stu-id="3902a-272">You cannot do this, of course, if you do not own the type's source code.</span></span> <span data-ttu-id="3902a-273">Ve ayrıca yöntemini desteklemek için tüm özel veri alanları eklerseniz, bu önemli bir değişiklik olur.</span><span class="sxs-lookup"><span data-stu-id="3902a-273">And this becomes a breaking change if you also add any private data fields to support the method.</span></span>
- <span data-ttu-id="3902a-274">Türetilen bir sınıfta yeni yöntemi tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="3902a-274">Define the new method in a derived class.</span></span> <span data-ttu-id="3902a-275">Bir yöntemi, yapılar ve numaralandırmalar gibi diğer türleri için devralma kullanarak bu şekilde eklenemez.</span><span class="sxs-lookup"><span data-stu-id="3902a-275">A method cannot be added in this way using inheritance for other types, such as structures and enumerations.</span></span> <span data-ttu-id="3902a-276">Veya "korumalı bir sınıf için bir yöntem eklemek için" kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="3902a-276">Nor can it be used to "add" a method to a sealed class.</span></span>

<span data-ttu-id="3902a-277">"Bir yöntem için mevcut bir türle türü değiştirme veya devralınan bir türünün yeni yöntemi uygulama olmadan Ekle" genişletme yöntemleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="3902a-277">Extension methods let you "add" a method to an existing type without modifying the type itself or implementing the new method in an inherited type.</span></span> <span data-ttu-id="3902a-278">Genişletme yöntemi, onu genişletir türü ile aynı bütünleştirilmiş kodda bulunmasını da yok.</span><span class="sxs-lookup"><span data-stu-id="3902a-278">The extension method also does not have to reside in the same assembly as the type it extends.</span></span> <span data-ttu-id="3902a-279">Tanımlanan bir tür üyesi değilmiş gibi bir genişletme yöntemi çağırın.</span><span class="sxs-lookup"><span data-stu-id="3902a-279">You call an extension method as if it were a defined member of a type.</span></span>

<span data-ttu-id="3902a-280">Daha fazla bilgi için bkz: [genişletme yöntemleri](programming-guide/classes-and-structs/extension-methods.md).</span><span class="sxs-lookup"><span data-stu-id="3902a-280">For more information, see [Extension Methods](programming-guide/classes-and-structs/extension-methods.md).</span></span>

<a name="async"></a>
## <a name="async-methods"></a><span data-ttu-id="3902a-281">Zaman uyumsuz yöntemleri</span><span class="sxs-lookup"><span data-stu-id="3902a-281">Async Methods</span></span> ##

<span data-ttu-id="3902a-282">Async özelliği kullanarak, açık geri aramalar kullanarak veya birden çok yöntem veya lambda ifadeleri kodunuzu el ile bölme olmadan zaman uyumsuz yöntemleri çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3902a-282">By using the async feature, you can invoke asynchronous methods without using explicit callbacks or manually splitting your code across multiple methods or lambda expressions.</span></span>

<span data-ttu-id="3902a-283">Bir yöntem ile işaretlerseniz [zaman uyumsuz](language-reference/keywords/async.md) kullanabileceğiniz değiştiricisi, [await](language-reference/keywords/await.md) yönteminde işleci.</span><span class="sxs-lookup"><span data-stu-id="3902a-283">If you mark a method with the [async](language-reference/keywords/async.md) modifier, you can use the [await](language-reference/keywords/await.md) operator in the method.</span></span> <span data-ttu-id="3902a-284">Ulaştığında denetlemek bir `await` async yöntemi ifadesinde, Denetim döndürür awaited görev tamamlanmadı, çağıran ve yöntemiyle ediyor `await` awaited görevi tamamlanana kadar anahtar sözcüğü askıya alındı.</span><span class="sxs-lookup"><span data-stu-id="3902a-284">When control reaches an `await` expression in the async method, control returns to the caller if the awaited task is not completed, and progress in the method with the `await` keyword is suspended until the awaited task completes.</span></span> <span data-ttu-id="3902a-285">Görev tamamlandığında, yürütme yönteminde devam edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3902a-285">When the task is complete, execution can resume in the method.</span></span>

> [!NOTE]
> <span data-ttu-id="3902a-286">Bir zaman uyumsuz yöntem henüz tamamlanmadı ilk awaited nesne bulduğu veya zaman uyumsuz yönteminin sonuna alır çağırana döndürür hangisi önce gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="3902a-286">An async method returns to the caller when either it encounters the first awaited object that’s not yet complete or it gets to the end of the async method, whichever occurs first.</span></span>

<span data-ttu-id="3902a-287">Zaman uyumsuz yöntem dönüş türüne sahip olabilir <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, veya `void`.</span><span class="sxs-lookup"><span data-stu-id="3902a-287">An async method can have a return type of <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.Task>, or `void`.</span></span> <span data-ttu-id="3902a-288">`void` Türü öncelikle olay işleyicileri tanımlamak için kullanılan dönüş burada bir `void` dönüş türü gerekli.</span><span class="sxs-lookup"><span data-stu-id="3902a-288">The `void` return type is used primarily to define event handlers, where a `void` return type is required.</span></span> <span data-ttu-id="3902a-289">Döndüren bir zaman uyumsuz yöntem `void` beklemenin olamaz, ve void döndüren bir yöntem arayan yöntemi atar özel durumlarını yakalama olamaz.</span><span class="sxs-lookup"><span data-stu-id="3902a-289">An async method that returns `void` can't be awaited, and the caller of a void-returning method can't catch exceptions that the method throws.</span></span> <span data-ttu-id="3902a-290">C# yayımlandığında, 7, bir zaman uyumsuz yöntem izin vermek için bu kısıtlama kolaylaştırır [herhangi bir görev benzeri türü döndürülecek](https://github.com/ljw1004/roslyn/blob/features/async-return/docs/specs/feature%20-%20arbitrary%20async%20returns.md).</span><span class="sxs-lookup"><span data-stu-id="3902a-290">C# 7, when it is released, will ease this restriction to allow an async method [to return any task-like type](https://github.com/ljw1004/roslyn/blob/features/async-return/docs/specs/feature%20-%20arbitrary%20async%20returns.md).</span></span>

<span data-ttu-id="3902a-291">Aşağıdaki örnekte, `DelayAsync` bir tamsayı döndürür bir dönüş ifadesi olan bir zaman uyumsuz bir yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="3902a-291">In the following example, `DelayAsync` is an async method that has a return statement that returns an integer.</span></span> <span data-ttu-id="3902a-292">Bir zaman uyumsuz yöntem olduğu için yöntemi bildiriminden dönüş türüne sahip olmalıdır `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="3902a-292">Because it is an async method, its method declaration must have a return type of `Task<int>`.</span></span> <span data-ttu-id="3902a-293">Dönüş türü olduğundan `Task<int>`, değerlendirmesi `await` ifadesinde `DoSomethingAsync` aşağıdaki gibi bir tamsayı üreten `int result = await delayTask` deyimini gösterir.</span><span class="sxs-lookup"><span data-stu-id="3902a-293">Because the return type is `Task<int>`, the evaluation of the `await` expression in `DoSomethingAsync` produces an integer, as the following `int result = await delayTask` statement demonstrates.</span></span>

[!code-csharp[csSnippets.Methods#102](../../samples/snippets/csharp/concepts/methods/async1.cs#102)]

<span data-ttu-id="3902a-294">Herhangi bir zaman uyumsuz yöntem bildiremezsiniz [içinde](language-reference/keywords/in-parameter-modifier.md), [ref](language-reference/keywords/ref.md), veya [çıkışı](language-reference/keywords/out-parameter-modifier.md) parametreleri, ancak bu tür parametrelerine sahip yöntemleri çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3902a-294">An async method can't declare any [in](language-reference/keywords/in-parameter-modifier.md), [ref](language-reference/keywords/ref.md), or [out](language-reference/keywords/out-parameter-modifier.md) parameters, but it can call methods that have such parameters.</span></span>

 <span data-ttu-id="3902a-295">Zaman uyumsuz yöntemleri hakkında daha fazla bilgi için bkz: [uyumsuz ve bekleme ile zaman uyumsuz programlama](async.md), [akış denetimi zaman uyumsuz programlarda](programming-guide/concepts/async/control-flow-in-async-programs.md), ve [zaman uyumsuz dönüş türleri](programming-guide/concepts/async/async-return-types.md).</span><span class="sxs-lookup"><span data-stu-id="3902a-295">For more information about async methods, see [Asynchronous Programming with Async and Await](async.md), [Control Flow in Async Programs](programming-guide/concepts/async/control-flow-in-async-programs.md), and [Async Return Types](programming-guide/concepts/async/async-return-types.md).</span></span>

<a name="expr"></a>
## <a name="expression-bodied-members"></a><span data-ttu-id="3902a-296">İfade bodied üyeleri</span><span class="sxs-lookup"><span data-stu-id="3902a-296">Expression-bodied members</span></span> ##

<span data-ttu-id="3902a-297">Yalnızca hemen ifade ile sonuç ya da tek bir deyimde yönteminin gövdesi olarak sahip yöntemi tanımı yaygındır.</span><span class="sxs-lookup"><span data-stu-id="3902a-297">It is common to have method definitions that simply return immediately with the result of an expression, or that have a single statement as the body of the method.</span></span>  <span data-ttu-id="3902a-298">Bu tür yöntemlerini kullanarak tanımlamak için bir söz dizimi kısayol yoktur `=>`:</span><span class="sxs-lookup"><span data-stu-id="3902a-298">There is a syntax shortcut for defining such methods using `=>`:</span></span>

```csharp
public Point Move(int dx, int dy) => new Point(x + dx, y + dy);
public void Print() => Console.WriteLine(First + " " + Last);
// Works with operators, properties, and indexers too.
public static Complex operator +(Complex a, Complex b) => a.Add(b);
public string Name => First + " " + Last;
public Customer this[long id] => store.LookupCustomer(id);
```

<span data-ttu-id="3902a-299">Yöntem döndürüyorsa `void` veya bir zaman uyumsuz yöntem yönteminin gövdesi bir deyim ifadesi (aynı Lambda'lar gibi) olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="3902a-299">If the method returns `void` or is an async method, the body of the method must be a statement expression (same as with lambdas).</span></span>  <span data-ttu-id="3902a-300">Özellikler ve dizin oluşturucular için salt okunur olmaları gerekir ve kullanmaz `get` erişimci anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="3902a-300">For properties and indexers, they must be read-only, and you do not use the `get` accessor keyword.</span></span>

<a name="iterators"></a>
## <a name="iterators"></a><span data-ttu-id="3902a-301">Yineleyiciler</span><span class="sxs-lookup"><span data-stu-id="3902a-301">Iterators</span></span> ##

<span data-ttu-id="3902a-302">Yineleyici özel bir yineleme listesini veya bir dizi gibi bir koleksiyon üzerinden gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="3902a-302">An iterator performs a custom iteration over a collection, such as a list or an array.</span></span> <span data-ttu-id="3902a-303">Yineleyici kullanan [verim return](language-reference/keywords/yield.md) her öğeye aynı anda geri dönmek için deyimi.</span><span class="sxs-lookup"><span data-stu-id="3902a-303">An iterator uses the [yield return](language-reference/keywords/yield.md) statement to return each element one at a time.</span></span> <span data-ttu-id="3902a-304">Zaman bir `yield return` arayan dizisi sonraki öğe istemesini deyimi ulaşıldığında, geçerli konumu hatırlanır.</span><span class="sxs-lookup"><span data-stu-id="3902a-304">When a `yield return` statement is reached, the current location is remembered so that the caller can request the next element in the sequence.</span></span>

<span data-ttu-id="3902a-305">Yineleyici dönüş türü olabilir <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator>, veya <xref:System.Collections.Generic.IEnumerator%601>.</span><span class="sxs-lookup"><span data-stu-id="3902a-305">The return type of an iterator can be <xref:System.Collections.IEnumerable>, <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.IEnumerator>, or <xref:System.Collections.Generic.IEnumerator%601>.</span></span>

<span data-ttu-id="3902a-306">Daha fazla bilgi için bkz: [yineleyiciler](programming-guide/concepts/iterators.md).</span><span class="sxs-lookup"><span data-stu-id="3902a-306">For more information, see [Iterators](programming-guide/concepts/iterators.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="3902a-307">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="3902a-307">See also</span></span> ##

<span data-ttu-id="3902a-308">[Erişim değiştiricileri](language-reference/keywords/access-modifiers.md) </span><span class="sxs-lookup"><span data-stu-id="3902a-308">[Access Modifiers](language-reference/keywords/access-modifiers.md) </span></span>  
<span data-ttu-id="3902a-309">[Statik sınıflar ve statik sınıf üyeleri](programming-guide/classes-and-structs/static-classes-and-static-class-members.md) </span><span class="sxs-lookup"><span data-stu-id="3902a-309">[Static Classes and Static Class Members](programming-guide/classes-and-structs/static-classes-and-static-class-members.md) </span></span>  
<span data-ttu-id="3902a-310">[Devralma](programming-guide/classes-and-structs/inheritance.md) </span><span class="sxs-lookup"><span data-stu-id="3902a-310">[Inheritance](programming-guide/classes-and-structs/inheritance.md) </span></span>  
<span data-ttu-id="3902a-311">[Soyut ve korumalı sınıflar ve sınıf üyeleri](programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md) </span><span class="sxs-lookup"><span data-stu-id="3902a-311">[Abstract and Sealed Classes and Class Members](programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md) </span></span>  
<span data-ttu-id="3902a-312">[Parametreleri](language-reference/keywords/params.md) </span><span class="sxs-lookup"><span data-stu-id="3902a-312">[params](language-reference/keywords/params.md) </span></span>  
<span data-ttu-id="3902a-313">[Çıkışı](language-reference/keywords/out-parameter-modifier.md) </span><span class="sxs-lookup"><span data-stu-id="3902a-313">[out](language-reference/keywords/out-parameter-modifier.md) </span></span>  
<span data-ttu-id="3902a-314">[Ref](language-reference/keywords/ref.md) </span><span class="sxs-lookup"><span data-stu-id="3902a-314">[ref](language-reference/keywords/ref.md) </span></span>  
<span data-ttu-id="3902a-315">[İçinde](language-reference/keywords/in-parameter-modifier.md) </span><span class="sxs-lookup"><span data-stu-id="3902a-315">[in](language-reference/keywords/in-parameter-modifier.md) </span></span>  
[<span data-ttu-id="3902a-316">Parametreleri Geçirme</span><span class="sxs-lookup"><span data-stu-id="3902a-316">Passing Parameters</span></span>](programming-guide/classes-and-structs/passing-parameters.md)

---
title: "Anlam Analizi ile çalışmaya başlama"
description: "Bu öğreticide, .NET derleme SDK'sını kullanarak anlamsal Analizi ile çalışma genel bir bakış sağlar."
author: billwagner
ms.author: wiwagn
ms.date: 02/06/2018
ms.topic: conceptual
ms.prod: .net
ms.devlang: devlang-csharp
ms.custom: mvc
ms.openlocfilehash: 04bd57dfd32a51bf5d7e3a573e34140b0feec90f
ms.sourcegitcommit: 3a96c706e4dbb4667bf3bf37edac9e1666646f93
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/27/2018
---
# <a name="get-started-with-semantic-analysis"></a><span data-ttu-id="f7c36-103">Anlam Analizi ile çalışmaya başlama</span><span class="sxs-lookup"><span data-stu-id="f7c36-103">Get started with semantic analysis</span></span>

<span data-ttu-id="f7c36-104">Bu öğretici sözdizimi API ile tanıdık varsayar.</span><span class="sxs-lookup"><span data-stu-id="f7c36-104">This tutorial assumes you're familiar with the Syntax API.</span></span> <span data-ttu-id="f7c36-105">[Sözdizimi Analizi ile çalışmaya başlama](syntax-analysis.md) makale yeterli giriş sağlar.</span><span class="sxs-lookup"><span data-stu-id="f7c36-105">The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction.</span></span>

<span data-ttu-id="f7c36-106">Bu öğreticide, keşfedin **simgesi** ve **bağlama API'leri**.</span><span class="sxs-lookup"><span data-stu-id="f7c36-106">In this tutorial, you explore the **Symbol** and **Binding APIs**.</span></span> <span data-ttu-id="f7c36-107">Bu API'ları hakkında bilgi sağlamak _anlamsal anlamı_ bir programın.</span><span class="sxs-lookup"><span data-stu-id="f7c36-107">These APIs provide information about the _semantic meaning_ of a program.</span></span> <span data-ttu-id="f7c36-108">İsteyin ve programınızdaki herhangi bir simge ile temsil edilen türleri hakkında sorularını olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="f7c36-108">They enable you to ask and answer questions about the types represented by any symbol in your program.</span></span>

## <a name="understanding-compilations-and-symbols"></a><span data-ttu-id="f7c36-109">Anlama derlemeleri ve simgeler</span><span class="sxs-lookup"><span data-stu-id="f7c36-109">Understanding Compilations and Symbols</span></span>

<span data-ttu-id="f7c36-110">Daha fazla .NET derleyici SDK ile çalışırken, sözdizimi API ve anlam API arasındaki farklılıklar öğrenmeniz.</span><span class="sxs-lookup"><span data-stu-id="f7c36-110">As you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API.</span></span> <span data-ttu-id="f7c36-111">**Sözdizimi API** bakmak sayesinde _yapısı_ bir programın.</span><span class="sxs-lookup"><span data-stu-id="f7c36-111">The **Syntax API** allows you to look at the _structure_ of a program.</span></span> <span data-ttu-id="f7c36-112">Ancak, genellikle daha zengin bilgi semantiğini hakkında istediğiniz veya _anlamı_ bir programın.</span><span class="sxs-lookup"><span data-stu-id="f7c36-112">However, often you want richer information about the semantics or _meaning_ of a program.</span></span> <span data-ttu-id="f7c36-113">Gevşek kod dosyası ya da VB veya C# kod parçacığını yalıtım modunda sözdizimsel olarak çözümlenebilir olsa da, "Bu değişken türünü bir boşlukta nedir" gibi sorular sormak için anlamlı değil.</span><span class="sxs-lookup"><span data-stu-id="f7c36-113">While a loose code file or snippet of VB or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as "what's the type of this variable" in a vacuum.</span></span> <span data-ttu-id="f7c36-114">Tür adı anlamını derleme başvurularını, ad alanı içe aktarımlarını veya diğer kod dosyaları bağımlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="f7c36-114">The meaning of a type name may be dependent on assembly references, namespace imports, or other code files.</span></span> <span data-ttu-id="f7c36-115">Kullanarak bu soruları yanıtlanır **anlamsal API**, özellikle <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="f7c36-115">Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class.</span></span>

<span data-ttu-id="f7c36-116">Örneği <xref:Microsoft.CodeAnalysis.Compilation> derleyici tarafından görülen tek bir projeye paraleldir ve Visual Basic veya C# programı derlemek için gereken her şeyi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="f7c36-116">An instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program.</span></span> <span data-ttu-id="f7c36-117">**Derleme** derlenecek kaynak dosyaları, derleme başvurusu, derleyici seçenekleri kümesi içerir.</span><span class="sxs-lookup"><span data-stu-id="f7c36-117">The **compilation** includes the set of source files to be compiled, assembly references, compiler options.</span></span> <span data-ttu-id="f7c36-118">Diğer tüm bilgiler bu bağlamda kullanarak kod anlamı hakkında neden.</span><span class="sxs-lookup"><span data-stu-id="f7c36-118">You can reason about the meaning of the code using all the other information in this context.</span></span> <span data-ttu-id="f7c36-119">A <xref:Microsoft.CodeAnalysis.Compilation> bulabilirsiniz **simgeleri** -türleri, ad alanları, üyeleri ve adları ve diğer ifadeleri başvuran değişkenler gibi varlıklar.</span><span class="sxs-lookup"><span data-stu-id="f7c36-119">A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to.</span></span> <span data-ttu-id="f7c36-120">Adları ve ifadeler ile ilişkilendirme işlemi **simgeleri** çağrılır **bağlama**.</span><span class="sxs-lookup"><span data-stu-id="f7c36-120">The process of associating names and expressions with **Symbols** is called **Binding**.</span></span>

<span data-ttu-id="f7c36-121">Gibi <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> dile özgü türevleri ile bir Özet sınıf.</span><span class="sxs-lookup"><span data-stu-id="f7c36-121">Like <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives.</span></span> <span data-ttu-id="f7c36-122">Derleme örneği oluştururken, üzerinde bir Üreteç yöntemi çağırmanız gerekir <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (veya <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) sınıfı.</span><span class="sxs-lookup"><span data-stu-id="f7c36-122">When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class.</span></span>

## <a name="querying-symbols"></a><span data-ttu-id="f7c36-123">Simgeler sorgulama</span><span class="sxs-lookup"><span data-stu-id="f7c36-123">Querying symbols</span></span>

<span data-ttu-id="f7c36-124">Bu öğreticide, "Hello World" programı yeniden bakın.</span><span class="sxs-lookup"><span data-stu-id="f7c36-124">In this tutorial, you look at the "Hello World" program again.</span></span> <span data-ttu-id="f7c36-125">Bu süre, programın ne bu simgeleri göstermek türlerini anlamak için sembolleri sorgu.</span><span class="sxs-lookup"><span data-stu-id="f7c36-125">This time, you query the symbols in the program to understand what types those symbols represent.</span></span> <span data-ttu-id="f7c36-126">Bir ad alanındaki türler için sorgular ve bir türünde kullanılabilen yöntemler bulmayı öğrenin.</span><span class="sxs-lookup"><span data-stu-id="f7c36-126">You query for the types in a namespace, and learn to find the methods available on a type.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f7c36-127">Aşağıdaki örnekler gerektiren **.NET derleyici SDK** Visual Studio 2017 bir parçası olarak yüklenir.</span><span class="sxs-lookup"><span data-stu-id="f7c36-127">The following samples require the **.NET Compiler SDK** installed as part of Visual Studio 2017.</span></span> <span data-ttu-id="f7c36-128">Altında listelenen son isteğe bağlı bileşen olarak .NET derleyici SDK bulabilirsiniz **Visual Studio uzantısı geliştirme** iş yükü.</span><span class="sxs-lookup"><span data-stu-id="f7c36-128">You can find the .NET Compiler SDK as the last optional component listed under the **Visual Studio extension development** workload.</span></span> <span data-ttu-id="f7c36-129">Şablonlar bu bileşeni yüklü değil.</span><span class="sxs-lookup"><span data-stu-id="f7c36-129">The templates aren't installed without this component.</span></span>

<span data-ttu-id="f7c36-130">Bu örnek için tamamlanmış kod görebilirsiniz [GitHub örnekleri depomuzda](https://github.com/dotnet/samples/csharp/roslyn-sdk/SemanticQuickStart).</span><span class="sxs-lookup"><span data-stu-id="f7c36-130">You can see the finished code for this sample in [our GitHub samples repository](https://github.com/dotnet/samples/csharp/roslyn-sdk/SemanticQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="f7c36-131">Sözdizimi ağacı türleri devralma programı farklı konumlarda geçerli farklı söz dizimi öğeleri tanımlamak için kullanın.</span><span class="sxs-lookup"><span data-stu-id="f7c36-131">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="f7c36-132">Genellikle bu API'leri kullanarak atama özellikleri veya belirli türetilmiş türler için koleksiyon üyeleri anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f7c36-132">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="f7c36-133">Aşağıdaki örneklerde, atama ve atamalar açıkça yazılan değişkenler kullanılarak ayrı deyim ' dir.</span><span class="sxs-lookup"><span data-stu-id="f7c36-133">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="f7c36-134">Dönüş türleri API ve çalışma zamanı türü, döndürülen nesnelerin görmek için kodu okuyabilir.</span><span class="sxs-lookup"><span data-stu-id="f7c36-134">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="f7c36-135">Uygulamada, incelenmesi nesnelerin türünü tanımlamak için API adları kullanır ve örtük olarak yazılan değişkenler kullanmak için daha yaygın bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="f7c36-135">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="f7c36-136">Yeni C# oluşturma **tek başına kod analizi aracı** proje:</span><span class="sxs-lookup"><span data-stu-id="f7c36-136">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="f7c36-137">Visual Studio'da, **dosya** > **yeni** > **proje** yeni proje iletişim kutusu görüntülemek için.</span><span class="sxs-lookup"><span data-stu-id="f7c36-137">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="f7c36-138">Altında **Visual C#** > **genişletilebilirlik**, seçin **tek başına kod analizi aracı**.</span><span class="sxs-lookup"><span data-stu-id="f7c36-138">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="f7c36-139">Projenizin adı "**SemanticQuickStart**" ve Tamam'ı tıklatın.</span><span class="sxs-lookup"><span data-stu-id="f7c36-139">Name your project "**SemanticQuickStart**" and click OK.</span></span>

<span data-ttu-id="f7c36-140">Temel "Hello World!" analiz etmeyi deneyeceğimiz</span><span class="sxs-lookup"><span data-stu-id="f7c36-140">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="f7c36-141">daha önce gösterilen programı.</span><span class="sxs-lookup"><span data-stu-id="f7c36-141">program shown earlier.</span></span>
<span data-ttu-id="f7c36-142">Bir sabit olarak Hello World program için metni ekleyin, `Program` sınıfı:</span><span class="sxs-lookup"><span data-stu-id="f7c36-142">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program test](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="f7c36-143">Ardından, kod metinde sözdizimi ağacı oluşturmak için aşağıdaki kodu ekleyin `programText` sabit.</span><span class="sxs-lookup"><span data-stu-id="f7c36-143">Next, add the following code to build the syntax tree for the code text in the `programText` constant.</span></span>  <span data-ttu-id="f7c36-144">Aşağıdaki satırı ekleyin, `Main` yöntemi:</span><span class="sxs-lookup"><span data-stu-id="f7c36-144">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="f7c36-145">Ardından, yapı bir <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> ağacından zaten oluşturulmuş.</span><span class="sxs-lookup"><span data-stu-id="f7c36-145">Next, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created.</span></span> <span data-ttu-id="f7c36-146">"Hello World" örnek dayanan <xref:System.String> ve <xref:System.Console> türleri.</span><span class="sxs-lookup"><span data-stu-id="f7c36-146">The "Hello World" sample relies on the <xref:System.String> and <xref:System.Console> types.</span></span> <span data-ttu-id="f7c36-147">Bu iki derlemeniz türlerinde bildirir derleme başvurmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="f7c36-147">You need to reference the assembly that declares those two types in your compilation.</span></span> <span data-ttu-id="f7c36-148">Aşağıdaki satırı ekleyin, `Main` yöntemi uygun derlemesine başvuru dahil olmak üzere, sözdizimi ağacı derlenmesini oluşturmak için:</span><span class="sxs-lookup"><span data-stu-id="f7c36-148">Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:</span></span>

[!code-csharp[Create the compilation](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#3 "Create the compilation for the semantic model")]

<span data-ttu-id="f7c36-149"><xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> Yöntemi derleme başvurularını ekler.</span><span class="sxs-lookup"><span data-stu-id="f7c36-149">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation.</span></span> <span data-ttu-id="f7c36-150"><xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)> Yöntemi bir başvuru olarak bir derleme yükler.</span><span class="sxs-lookup"><span data-stu-id="f7c36-150">The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)> method loads an assembly as a reference.</span></span> 

## <a name="querying-the-semantic-model"></a><span data-ttu-id="f7c36-151">Anlam modeli sorgulama</span><span class="sxs-lookup"><span data-stu-id="f7c36-151">Querying the semantic model</span></span>

<span data-ttu-id="f7c36-152">Bulduktan sonra bir <xref:Microsoft.CodeAnalysis.Compilation> için sorabileceğiniz bir <xref:Microsoft.CodeAnalysis.SemanticModel> herhangi <xref:Microsoft.CodeAnalysis.SyntaxTree> uygulamasında bulunan <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="f7c36-152">Once you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="f7c36-153">Tüm bilgileri kaynağı normalde IntelliSense elde edebileceğiniz olarak anlam modeli düşünebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f7c36-153">You can think of the semantic model as the source for all the information would normally get from intellisense.</span></span> <span data-ttu-id="f7c36-154">A <xref:Microsoft.CodeAnalysis.SemanticModel> yanıt "Adları bu konumda kapsamdaki nelerdir?" gibi soruları</span><span class="sxs-lookup"><span data-stu-id="f7c36-154">A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like "What names are in scope at this location?"</span></span> <span data-ttu-id="f7c36-155">"Hangi üyelerinin bu yönteminden erişilebilir?"</span><span class="sxs-lookup"><span data-stu-id="f7c36-155">"What members are accessible from this method?"</span></span> <span data-ttu-id="f7c36-156">"Ne değişkenler bu metin bloğunda kullanılır?"</span><span class="sxs-lookup"><span data-stu-id="f7c36-156">"What variables are used in this block of text?"</span></span> <span data-ttu-id="f7c36-157">"ne bu ad/ifade başvurun?"</span><span class="sxs-lookup"><span data-stu-id="f7c36-157">and "What does this name/expression refer to?"</span></span> <span data-ttu-id="f7c36-158">Anlam modeli oluşturmak için bu deyim ekleyin:</span><span class="sxs-lookup"><span data-stu-id="f7c36-158">Add this statement to create the semantic model:</span></span>

[!code-csharp[Create the semantic model](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#4 "Create the semantic model")]

## <a name="binding-a-name"></a><span data-ttu-id="f7c36-159">Bir ad bağlama</span><span class="sxs-lookup"><span data-stu-id="f7c36-159">Binding a name</span></span>

<span data-ttu-id="f7c36-160"><xref:Microsoft.CodeAnalysis.Compilation> Oluşturur <xref:Microsoft.CodeAnalysis.SemanticModel> gelen <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span><span class="sxs-lookup"><span data-stu-id="f7c36-160">The <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="f7c36-161">Model oluşturduktan sonra ilk bulmak için sorgulayabilirsiniz `using` yönerge ve sembol bilgilerini almak `System` ad alanı.</span><span class="sxs-lookup"><span data-stu-id="f7c36-161">After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace.</span></span> <span data-ttu-id="f7c36-162">Bu iki satır ekleyin, `Main` anlam modeli oluşturmak ve ilk simgesini almak için yöntemi deyimi kullanarak:</span><span class="sxs-lookup"><span data-stu-id="f7c36-162">Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:</span></span>

[!code-csharp[Find the namespace symbol for the first using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#5 "Find the namespace symbol for the first using")]

<span data-ttu-id="f7c36-163">Önceki kod edinmeyi gösteren bir <xref:Microsoft.CodeAnalysis.SemanticModel> nesnesi, HelloWorld için <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span><span class="sxs-lookup"><span data-stu-id="f7c36-163">The preceding code shows how to obtain a <xref:Microsoft.CodeAnalysis.SemanticModel> object for your HelloWorld <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="f7c36-164">Model elde edilir sonra ad ilk `using` yönergesi almak için bağlı bir <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> için `System` ad alanı.</span><span class="sxs-lookup"><span data-stu-id="f7c36-164">Once the model is obtained, the name in the first `using` directive is bound to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace.</span></span> <span data-ttu-id="f7c36-165">Önceki kod Ayrıca, kullandığınız gösterilmektedir **sözdizimi modeli** ; kod yapısını bulmak için kullandığınız **anlam modeli** anlamlarını anlamak için.</span><span class="sxs-lookup"><span data-stu-id="f7c36-165">The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning.</span></span> <span data-ttu-id="f7c36-166">**Sözdizimi modeli** dizeyi bulur `System` kullanarak deyimi.</span><span class="sxs-lookup"><span data-stu-id="f7c36-166">The **syntax model** finds the string `System` in the using statement.</span></span> <span data-ttu-id="f7c36-167">**Anlam modeli** tanımlanan türleri hakkında tüm bilgiler `System` ad alanı.</span><span class="sxs-lookup"><span data-stu-id="f7c36-167">The **semantic model** has all the information about the types defined in the `System` namespace.</span></span>

<span data-ttu-id="f7c36-168">Gelen <xref:Microsoft.CodeAnalysis.SymbolInfo> edinebilirsiniz nesne <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> kullanarak <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> özelliği.</span><span class="sxs-lookup"><span data-stu-id="f7c36-168">From the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="f7c36-169">Bu özellik bu ifade başvurduğu simgesini döndürür.</span><span class="sxs-lookup"><span data-stu-id="f7c36-169">This property returns the symbol this expression refers to.</span></span> <span data-ttu-id="f7c36-170">Herhangi bir şeye (örneğin, sayısal değişmez değerleri) Bu özellik başvuran yok ifadeleri olduğu `null`.</span><span class="sxs-lookup"><span data-stu-id="f7c36-170">For expressions that don't refer to anything (such as numeric literals) this property is `null`.</span></span> <span data-ttu-id="f7c36-171">Zaman <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> null değil <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> simgenin türünü gösterir.</span><span class="sxs-lookup"><span data-stu-id="f7c36-171">When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol.</span></span> <span data-ttu-id="f7c36-172">Bu örnekte, <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> özelliği bir <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f7c36-172">In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f7c36-173">Aşağıdaki kodu ekleyin, `Main` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="f7c36-173">Add the following code to your `Main` method.</span></span> <span data-ttu-id="f7c36-174">Simge için alır `System` ad alanı ve görüntüler tüm alt ad alanlarını içinde bildirilen `System` ad alanı:</span><span class="sxs-lookup"><span data-stu-id="f7c36-174">It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:</span></span>

[!code-csharp[Display all the child namespaces](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#6 "Display all the child namespaces from this compilation")]

<span data-ttu-id="f7c36-175">Programını çalıştırın ve aşağıdaki çıktı görmeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="f7c36-175">Run the program and you should see the following output:</span></span>

```
Collections
Configuration
Deployment
Diagnostics
Globalization
IO
Reflection
Resources
Runtime
Security
StubHelpers
Text
Threading
Press any key to continue . . .
```

> [!NOTE]
> <span data-ttu-id="f7c36-176">Çıkış alt ad alanı, her ad alanı içermeyen `System` ad alanı.</span><span class="sxs-lookup"><span data-stu-id="f7c36-176">The output does not include every namespace that is a child namespace of the `System` namespace.</span></span> <span data-ttu-id="f7c36-177">Yalnızca bütünleştirilmiş koduna başvuruyor bu derlemede varsa her ad alanı görüntüler nerede `System.String` bildirilmedi.</span><span class="sxs-lookup"><span data-stu-id="f7c36-177">It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared.</span></span> <span data-ttu-id="f7c36-178">Bu derleme diğer derlemelerde bildirilen ad bilinmiyor</span><span class="sxs-lookup"><span data-stu-id="f7c36-178">Any namespaces declared in other assemblies are not known to this compilation</span></span>

### <a name="binding-an-expression"></a><span data-ttu-id="f7c36-179">Bir ifade bağlama</span><span class="sxs-lookup"><span data-stu-id="f7c36-179">Binding an expression</span></span>

<span data-ttu-id="f7c36-180">Önceki kod, bir ad bağlayarak bir sembol bulmak gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="f7c36-180">The preceding code shows how to find a symbol by binding to a name.</span></span> <span data-ttu-id="f7c36-181">Adları olmayan diğer ifadeler bağlanabilen bir C# programında vardır.</span><span class="sxs-lookup"><span data-stu-id="f7c36-181">There are other expressions in a C# program that can be bound that aren't names.</span></span> <span data-ttu-id="f7c36-182">Bu özellik göstermek için şimdi basit bir dize sabit değeri bağlamayı erişin.</span><span class="sxs-lookup"><span data-stu-id="f7c36-182">To demonstrate this capability, let's access the binding to a simple string literal.</span></span>

<span data-ttu-id="f7c36-183">"Hello World" programı içeren bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, "Hello, World!"</span><span class="sxs-lookup"><span data-stu-id="f7c36-183">The "Hello World" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the "Hello, World!"</span></span> <span data-ttu-id="f7c36-184">konsolda görüntülenen dize.</span><span class="sxs-lookup"><span data-stu-id="f7c36-184">string displayed to the console.</span></span>

<span data-ttu-id="f7c36-185">"Hello, World!" Bul</span><span class="sxs-lookup"><span data-stu-id="f7c36-185">You find the "Hello, World!"</span></span> <span data-ttu-id="f7c36-186">tek bir dize programa değişmez değer bulma tarafından dizesi.</span><span class="sxs-lookup"><span data-stu-id="f7c36-186">string by locating the single string literal in the program.</span></span> <span data-ttu-id="f7c36-187">Ardından, sözdizimi düğümü bulunan sonra tür bilgi bu düğüm için anlam modeli alın.</span><span class="sxs-lookup"><span data-stu-id="f7c36-187">Then, once you've located the syntax node, get the type info for that node from the semantic model.</span></span> <span data-ttu-id="f7c36-188">Aşağıdaki kodu ekleyin, `Main` yöntemi:</span><span class="sxs-lookup"><span data-stu-id="f7c36-188">Add the following code to your `Main` method:</span></span>

[!code-csharp[Find the namespace symbol for the only using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#7 "Find the namespace symbol for the only using")]

<span data-ttu-id="f7c36-189"><xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> Yapı içeren bir <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> özelliği sabit türü anlamsal bilgilerine erişim sağlar.</span><span class="sxs-lookup"><span data-stu-id="f7c36-189">The <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal.</span></span> <span data-ttu-id="f7c36-190">Bu örnekte, o `string` türü.</span><span class="sxs-lookup"><span data-stu-id="f7c36-190">In this example, that's the `string` type.</span></span> <span data-ttu-id="f7c36-191">Bu özellik yerel bir değişkene atar bir bildirimi ekleyin:</span><span class="sxs-lookup"><span data-stu-id="f7c36-191">Add a declaration that assigns this property to a local variable:</span></span>

[!code-csharp[Find the semantic information about the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#8 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="f7c36-192">Bu öğreticiyi tamamlamak için şimdi tüm genel yöntemler bildirilen bir dizi oluşturan bir LINQ sorgusu yapı `string` , dönüş türü bir `string`.</span><span class="sxs-lookup"><span data-stu-id="f7c36-192">To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`.</span></span> <span data-ttu-id="f7c36-193">Bu sorgu karmaşık sağlandığından, yapı satır alır, tek bir sorgu yeniden yapılandırma.</span><span class="sxs-lookup"><span data-stu-id="f7c36-193">This query gets complex, so let's build it line by line, then reconstruct it as a single query.</span></span> <span data-ttu-id="f7c36-194">Bu sorgu için kaynak üzerinde bildirilen tüm üyeleri dizisidir `string` türü:</span><span class="sxs-lookup"><span data-stu-id="f7c36-194">The source for this query is the sequence of all members declared on the `string` type:</span></span>

[!code-csharp[Access the sequence of members on the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#9 "Access the sequence of members on the string type.")]

<span data-ttu-id="f7c36-195">Bu kaynak sırası karakterlerine özellikleri ve alanları da dahil olmak üzere tüm üyeleri bu nedenle kullanarak filtre <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> yöntemi Bul öğesine <xref:Microsoft.CodeAnalysis.IMethodSymbol?diplayProperty=nameWithType> nesneler:</span><span class="sxs-lookup"><span data-stu-id="f7c36-195">That source sequence conatins all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?diplayProperty=nameWithType> objects:</span></span>

[!code-csharp[Filter the sequence to only methods](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#10 "Find the subset of the collection that is the methods.")]

<span data-ttu-id="f7c36-196">Ardından, yalnızca genel ve dönüş yöntemlerini döndürmek için başka bir filtre Ekle bir `string`:</span><span class="sxs-lookup"><span data-stu-id="f7c36-196">Next, add another filter to return only those methods that are public and return a `string`:</span></span>

[!code-csharp[Filter on return type and accessibility](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#11 "Find only the public methods that return a string.")]

<span data-ttu-id="f7c36-197">Yalnızca ad özelliği ve yalnızca DISTINCT adlarını herhangi aşırı kaldırarak seçin:</span><span class="sxs-lookup"><span data-stu-id="f7c36-197">Select only the name property, and only distinct names by removing any overloads:</span></span>

[!code-csharp[find the distinct names.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#12 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="f7c36-198">Ayrıca LINQ sorgu sözdizimini kullanarak tam sorgusu oluşturun ve sonra konsolda tüm yöntemi adlarını görüntülemek:</span><span class="sxs-lookup"><span data-stu-id="f7c36-198">You can also build the full query using the LINQ query syntax, and then display all the method names in  the console:</span></span>

[!code-csharp[build and display the results of this query.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#12 "Build and display the results of the query.")]

<span data-ttu-id="f7c36-199">Derleme ve programı çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="f7c36-199">Build and run the program.</span></span> <span data-ttu-id="f7c36-200">Şu çıktı görmeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="f7c36-200">You should see the following output:</span></span>

```
Join
Substring
Trim
TrimStart
TrimEnd
Normalize
PadLeft
PadRight
ToLower
ToLowerInvariant
ToUpper
ToUpperInvariant
ToString
Insert
Replace
Remove
Format
Copy
Concat
Intern
IsInterned
Press any key to continue . . .
```
<span data-ttu-id="f7c36-201">Anlam API bulmak ve bu programın parçası olan simgeler hakkında bilgi görüntülemek için kullandığınız.</span><span class="sxs-lookup"><span data-stu-id="f7c36-201">You've used the Semantic API to find and display information about the symbols that are part of this program.</span></span>

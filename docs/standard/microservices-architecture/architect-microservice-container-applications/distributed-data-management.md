---
title: Dağıtılmış veri yönetimi için sorunlar ve çözümler
description: Kapsayıcılı .NET uygulamaları için .NET mikro hizmet mimarisi | Dağıtılmış veri yönetimi için sorunlar ve çözümler
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.openlocfilehash: 7574a28fc3e8eb3288a81fa5a7ad26f34f1a3eb9
ms.sourcegitcommit: 6eac9a01ff5d70c6d18460324c016a3612c5e268
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/15/2018
ms.locfileid: "45646226"
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="368f7-103">Dağıtılmış veri yönetimi için sorunlar ve çözümler</span><span class="sxs-lookup"><span data-stu-id="368f7-103">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="368f7-104">Sınama \#1: her mikro hizmet sınırlarını tanımlama</span><span class="sxs-lookup"><span data-stu-id="368f7-104">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="368f7-105">Mikro hizmet sınırlarını tanımlama herkes karşılaştığında ilk testten olabilir.</span><span class="sxs-lookup"><span data-stu-id="368f7-105">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="368f7-106">Her mikro hizmet, uygulamanızın bir parçası olması gerekir ve her bir mikro hizmetin tüm avantajları ve onu ilettiği zorlukları ile otonom olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="368f7-106">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="368f7-107">Ancak, bu sınırları nasıl saptadınız mı?</span><span class="sxs-lookup"><span data-stu-id="368f7-107">But how do you identify those boundaries?</span></span>

<span data-ttu-id="368f7-108">İlk olarak, uygulamanın mantıksal etki alanı modelleri ve ilgili verileri gerekir.</span><span class="sxs-lookup"><span data-stu-id="368f7-108">First, you need to focus on the application’s logical domain models and related data.</span></span> <span data-ttu-id="368f7-109">Veri ve aynı uygulama içinde farklı bağlamlardaki ayrılmış Adaları belirlemeye çalışın gerekir.</span><span class="sxs-lookup"><span data-stu-id="368f7-109">You must try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="368f7-110">Her bağlamı, farklı iş dili (farklı iş terimlerini) olabilir.</span><span class="sxs-lookup"><span data-stu-id="368f7-110">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="368f7-111">Bağlamları tanımlanabilir ve bağımsız olarak yönetilebilir.</span><span class="sxs-lookup"><span data-stu-id="368f7-111">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="368f7-112">Hüküm ve bu farklı bağlamlardaki kullanılabilir varlıklar benzer görünebilir, ancak başka bir bağlamda farklı bir amaç için bir iş kavramını belirli bir bağlamda kullanılan keşfedin ve hatta farklı bir ad olabilir.</span><span class="sxs-lookup"><span data-stu-id="368f7-112">The terms and entities used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="368f7-113">Örneğin, bir kullanıcının kullanıcı kimliği veya üyelik bağlamı olarak olarak CRM bağlamda, bir müşteri bir sipariş bağlamında bir alıcı olarak adlandırılabilir ve VS.</span><span class="sxs-lookup"><span data-stu-id="368f7-113">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="368f7-114">Her bağlamı tam olarak her iş mikro hizmet ve onun ilişkili için sınırları nasıl tanımlamak için farklı bir etki alanı ile birden çok uygulama içerikleri arasındaki sınırları tanımlamak şekilde etki alanı modeli ve veri.</span><span class="sxs-lookup"><span data-stu-id="368f7-114">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="368f7-115">Her zaman bu mikro hizmetler arasında eşleştirmeye en aza indirmek çalışır.</span><span class="sxs-lookup"><span data-stu-id="368f7-115">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="368f7-116">Bu kılavuzda bu bölümdeki tanımlama ve etki alanı modeli tasarımı hakkında daha fazla ayrıntıya gider [her mikro hizmet için etki alanı modeli sınırlarını tanımlama](identify-microservice-domain-model-boundaries.md) daha sonra.</span><span class="sxs-lookup"><span data-stu-id="368f7-116">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="368f7-117">Sınama \#2: veri birden fazla mikro hizmetler sorgu oluşturma</span><span class="sxs-lookup"><span data-stu-id="368f7-117">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="368f7-118">İkinci sık iletişim için mikro Hizmetleri kaçınarak uzak istemci uygulamalardan birden fazla mikro hizmetler, veri alan sorguları uygulanması zordur.</span><span class="sxs-lookup"><span data-stu-id="368f7-118">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="368f7-119">Sepet, katalog ve kullanıcı kimlik mikro hizmetler tarafından ait kullanıcı bilgilerini göstermek için gereken bir mobil uygulama tek bir ekrandan bir örnek olabilir.</span><span class="sxs-lookup"><span data-stu-id="368f7-119">An example could be a single screen from a mobile app that needs to show user information that is owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="368f7-120">Başka bir örnek, birden fazla mikro Hizmetleri bulunan birçok tabloları içeren karmaşık bir rapor olabilir.</span><span class="sxs-lookup"><span data-stu-id="368f7-120">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="368f7-121">Doğru çözüm, sorgu karmaşıklığına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="368f7-121">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="368f7-122">Ancak herhangi bir durumda, iletişimin sistemin verimliliğini artırmak istiyorsanız, toplam bilgileri için bir yol gerekir.</span><span class="sxs-lookup"><span data-stu-id="368f7-122">But in any case, you will need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="368f7-123">En popüler çözümler aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="368f7-123">The most popular solutions are the following.</span></span>

<span data-ttu-id="368f7-124">**API ağ geçidi**.</span><span class="sxs-lookup"><span data-stu-id="368f7-124">**API Gateway**.</span></span> <span data-ttu-id="368f7-125">Farklı veritabanlarına ait birden fazla mikro hizmetin gelen Basit veri toplama için önerilen yaklaşım bir API ağ geçidi başvurulan bir toplama mikro hizmetidir.</span><span class="sxs-lookup"><span data-stu-id="368f7-125">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="368f7-126">Ancak, sisteminizdeki bir sıkıştırma noktası olabilir ve mikro hizmet bağımsız çalışma sınırı ilkesini ihlal edebilir çünkü bu düzen uygulama hakkında dikkatli olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="368f7-126">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="368f7-127">Bu olasılığını azaltmak için her bir dikey "dilim" ya da sistemin iş alanı odaklanarak birden çok fined şirketlerinde API ağ geçitleri olabilir.</span><span class="sxs-lookup"><span data-stu-id="368f7-127">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical “slice” or business area of the system.</span></span> <span data-ttu-id="368f7-128">API ağ geçidi desenini kullanarak bölümünde daha ayrıntılı açıklanmıştır daha sonra bir API ağ geçidi.</span><span class="sxs-lookup"><span data-stu-id="368f7-128">The API Gateway pattern is explained in more detail in the section in the Using an API Gateway later.</span></span>

<span data-ttu-id="368f7-129">**Sorgu/okuma tablolarla CQRS**.</span><span class="sxs-lookup"><span data-stu-id="368f7-129">**CQRS with query/reads tables**.</span></span> <span data-ttu-id="368f7-130">Birden fazla mikro hizmetin veri toplama için başka bir çözüm [gerçekleştirilmiş görünüm düzeni](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span><span class="sxs-lookup"><span data-stu-id="368f7-130">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="368f7-131">Bu yaklaşımda, önceden oluşturduğunuz (hazırlama normalleştirilmişlikten çıkarılmış veriler gerçek sorguları meydana gelmeden), birden fazla mikro hizmetin ait verilerle bir salt okunur tablo.</span><span class="sxs-lookup"><span data-stu-id="368f7-131">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that is owned by multiple microservices.</span></span> <span data-ttu-id="368f7-132">Tablo, istemci uygulamanın ihtiyaçlarına uygun bir biçimde.</span><span class="sxs-lookup"><span data-stu-id="368f7-132">The table has a format suited to the client app’s needs.</span></span>

<span data-ttu-id="368f7-133">Mobil uygulama ekran gibi göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="368f7-133">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="368f7-134">Tek bir veritabanı varsa, verileri birden çok tablo karmaşık birleşim gerçekleştiren bir SQL sorgusu kullanarak bu ekran için birlikte çekeceği.</span><span class="sxs-lookup"><span data-stu-id="368f7-134">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="368f7-135">Ancak, birden çok veritabanına sahip ve her veritabanı farklı bir mikro hizmet tarafından sahip olunan, bu veritabanlarını sorgulama ve SQL birleştirme oluşturma olamaz.</span><span class="sxs-lookup"><span data-stu-id="368f7-135">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="368f7-136">Bir challenge, karmaşık bir sorgu olur.</span><span class="sxs-lookup"><span data-stu-id="368f7-136">Your complex query becomes a challenge.</span></span> <span data-ttu-id="368f7-137">CQRS yaklaşımı kullanarak bir gereksinimi ele almanız — normalleştirilmişlikten çıkarılmış bir tablo sorguları için kullanılan farklı bir veritabanı oluşturun.</span><span class="sxs-lookup"><span data-stu-id="368f7-137">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that is used just for queries.</span></span> <span data-ttu-id="368f7-138">Tablo, özellikle uygulamanızın ekran ve sorgu tablodaki sütunlar için gerekli alanlar arasında bire bir ilişki ile karmaşık bir sorgu için ihtiyacınız olan verileri için tasarlanmış olması.</span><span class="sxs-lookup"><span data-stu-id="368f7-138">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application’s screen and the columns in the query table.</span></span> <span data-ttu-id="368f7-139">Ayrıca raporlama amacıyla hizmet.</span><span class="sxs-lookup"><span data-stu-id="368f7-139">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="368f7-140">Bu yaklaşım yalnızca özgün (sorgu ve mikro hizmetler arasında birleştirme için nasıl); sorunu çözer zaten sahip olduğunuz sorgu tabloda uygulamanız için gereken veriler için oldukça karmaşık bir birleşim ile karşılaştırıldığında performansı da artırır.</span><span class="sxs-lookup"><span data-stu-id="368f7-140">This approach not only solves the original problem (how to query and join across microservices); it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="368f7-141">Elbette, komut ve sorgu sorumluluğu ayrımı (CQRS) içeren sorgu/okuma tablolar'ı kullanarak ek geliştirme iş anlamına gelir ve nihai tutarlılık yaklaşımını benimseyin gerekecektir.</span><span class="sxs-lookup"><span data-stu-id="368f7-141">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you will need to embrace eventual consistency.</span></span> <span data-ttu-id="368f7-142">Öte yandan, performans ve yüksek ölçeklenebilirlik gereksinimlerine [işbirliği senaryoları](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (veya bağlı açısından rekabetçi senaryoları) olan birden çok veritabanıyla CQRS burada uygulamalıdır.</span><span class="sxs-lookup"><span data-stu-id="368f7-142">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) is where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="368f7-143">**"Soğuk verileri" merkezi veritabanlarındaki**.</span><span class="sxs-lookup"><span data-stu-id="368f7-143">**“Cold data” in central databases**.</span></span> <span data-ttu-id="368f7-144">Karmaşık raporlar ve gerçek zamanlı veri gerektirmeyebilecek sorgular için "veri"Sık erişimli dışarı aktarmak için yaygın bir yaklaşım olan (mikro hizmetler işlemsel verileri) olarak "soğuk veri" yalnızca raporlama için kullanılan büyük veritabanları.</span><span class="sxs-lookup"><span data-stu-id="368f7-144">For complex reports and queries that might not require real-time data, a common approach is to export your “hot data” (transactional data from the microservices) as “cold data” into large databases that are used only for reporting.</span></span> <span data-ttu-id="368f7-145">Hadoop, bir Azure SQL veri ambarı veya raporlar için kullanılan (boyut bir sorun olmayacaktır) bile tek bir SQL veritabanı gibi bir veri ambarı gibi büyük veri tabanlı bir sistem, merkezi bir veritabanı sistemi olabilir.</span><span class="sxs-lookup"><span data-stu-id="368f7-145">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database used just for reports (if size will not be an issue).</span></span>

<span data-ttu-id="368f7-146">Bu merkezi bir veritabanında yalnızca sorgular ve gerçek zamanlı veri gerekmeyen raporlar için kullanılacak aklınızda bulundurun.</span><span class="sxs-lookup"><span data-stu-id="368f7-146">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="368f7-147">Özgün güncelleştirmeleri ve işlemleri, kaynağınız getirilir, mikro hizmetler verilerinizi olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="368f7-147">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="368f7-148">Olay temelli iletişim (sonraki bölümde ele) kullanarak ya da diğer veritabanı altyapısı içeri/dışarı aktarma araçları kullanarak verileri eşitlemek şekilde olacaktır.</span><span class="sxs-lookup"><span data-stu-id="368f7-148">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="368f7-149">Olay temelli iletişim kullanırsanız, bu tümleştirme işlemi benzer şekilde CQRS sorgu tablolar için daha önce açıklandığı gibi veri yaymak olacaktır.</span><span class="sxs-lookup"><span data-stu-id="368f7-149">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="368f7-150">Ancak, uygulama tasarımınızı sürekli karmaşık sorgular için birden fazla mikro hizmetin bilgileri toplayarak içeriyorsa, hatalı bir tasarım belirtisi olabilir — bir mikro hizmet diğer mikro hizmetler mümkün olarak yalıtılmış olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="368f7-150">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design—a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="368f7-151">(Her zaman soğuk veri merkezi veritabanlarını kullanması gereken raporları/analizleri dışlar.) Bu sorun genellikle mikro hizmetler birleştirmek için bir neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="368f7-151">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="368f7-152">Gelişimi, özerkliği ve güçlü bağımlılıkları uyumda ve veri toplama ile her bir mikro Hizmet dağıtımının dengelemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="368f7-152">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="368f7-153">Sınama \#3: birden çok mikro hizmetler arasında tutarlılığı elde etme</span><span class="sxs-lookup"><span data-stu-id="368f7-153">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="368f7-154">Daha önce belirtildiği gibi her bir mikro hizmet tarafından sahip olunan veri, mikro hizmet için özeldir ve yalnızca kendi mikro hizmet API'si kullanılarak erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="368f7-154">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="368f7-155">Bu nedenle, sunulan birden fazla mikro hizmetler arasında tutarlılık sağlarken uçtan uca iş süreçlerini uygulanması zordur.</span><span class="sxs-lookup"><span data-stu-id="368f7-155">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="368f7-156">Bu sorunu çözümlemek için bir örnekten göz atalım [hizmetine başvuru uygulaması](https://aka.ms/eshoponcontainers).</span><span class="sxs-lookup"><span data-stu-id="368f7-156">To analyze this problem, let’s look at an example from the [eShopOnContainers reference application](https://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="368f7-157">Katalog mikro hizmet stok düzeylerini dahil olmak üzere tüm ürünlerle ilgili bilgileri tutar.</span><span class="sxs-lookup"><span data-stu-id="368f7-157">The Catalog microservice maintains information about all the products, including their stock level.</span></span> <span data-ttu-id="368f7-158">Sıralama mikro hizmet, siparişler yönetir ve yeni bir sipariş kullanılabilir Kataloğu ürün stok saklama aşmamasını doğrulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="368f7-158">The Ordering microservice manages orders and must verify that a new order does not exceed the available catalog product stock.</span></span> <span data-ttu-id="368f7-159">(Veya senaryo backordered ürünleri işleme mantığı gerektirebilir.) Bir kuramsal tek parça sürümünde bu uygulama, sıralama alt sistemi yalnızca bir ACID işlemi kullanılabilir hisse senedi denetleyin, Siparişler tablosunda sırasını oluşturmak ve kullanılabilir Ürünler tablosu stokta güncelleştirmek için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="368f7-159">(Or the scenario might involve logic that handles backordered products.) In a hypothetical monolithic version of this application, the ordering subsystem could simply use an ACID transaction to check the available stock, create the order in the Orders table, and update the available stock in the Products table.</span></span>

<span data-ttu-id="368f7-160">Ancak, bir mikro hizmet tabanlı uygulama sipariş ve ürün tablolarını ilgili kendi mikro hizmetin sahibi olur.</span><span class="sxs-lookup"><span data-stu-id="368f7-160">However, in a microservices-based application, the Order and Product tables are owned by their respective microservices.</span></span> <span data-ttu-id="368f7-161">Şekil 4-9'da gösterildiği gibi hiçbir mikro hizmet kendi işlem ya da sorguları, başka bir mikro hizmet tarafından sahip olunan veritabanları hiç olmadığı kadar içermelidir.</span><span class="sxs-lookup"><span data-stu-id="368f7-161">No microservice should ever include databases owned by another microservice in its own transactions or queries, as shown in Figure 4-9.</span></span>

![](./media/image9.PNG)

<span data-ttu-id="368f7-162">**Şekil 4-9**.</span><span class="sxs-lookup"><span data-stu-id="368f7-162">**Figure 4-9**.</span></span> <span data-ttu-id="368f7-163">Bir mikro hizmet, bir tablodaki başka bir mikro hizmet doğrudan erişemez</span><span class="sxs-lookup"><span data-stu-id="368f7-163">A microservice cannot directly access a table in another microservice</span></span>

<span data-ttu-id="368f7-164">Ürünler tablosu Kataloğu mikro hizmet tarafından sahiplenildiğinden sıralama mikro hizmet Ürünler tablosu doğrudan güncelleştirmelidir değil.</span><span class="sxs-lookup"><span data-stu-id="368f7-164">The Ordering microservice should not update the Products table directly, because the Products table is owned by the Catalog microservice.</span></span> <span data-ttu-id="368f7-165">Katalog mikro hizmet için bir güncelleştirme yapmak için sıralama mikro hizmet yalnızca sürekli tümleştirme olayları (ileti ve olay tabanlı iletişim) gibi zaman uyumsuz iletişim kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="368f7-165">To make an update to the Catalog microservice, the Ordering microservice should only ever use asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="368f7-166">Bu, nasıl [hizmetine](https://aka.ms/eshoponcontainers) başvuru uygulaması, bu tür bir güncelleştirme gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="368f7-166">This is how the [eShopOnContainers](https://aka.ms/eshoponcontainers) reference application performs this type of update.</span></span>

<span data-ttu-id="368f7-167">Tarafından belirtildiği gibi [CAP Teoremi](https://en.wikipedia.org/wiki/CAP_theorem), ACID güçlü tutarlılık ve kullanılabilirlik arasında seçim yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="368f7-167">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="368f7-168">Mikro hizmet tabanlı çoğu senaryoda, kullanılabilirlik ve güçlü tutarlılık aksine yüksek ölçeklenebilirlik talep.</span><span class="sxs-lookup"><span data-stu-id="368f7-168">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="368f7-169">Görev açısından kritik uygulamalar kalması gereken ve çalışan ve geliştiricilerin güçlü tutarlılık zayıf veya nihai tutarlılık ile çalışmaya yönelik teknikleri kullanarak çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="368f7-169">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="368f7-170">Çoğu mikro hizmet tabanlı mimari tarafından uygulanan yaklaşıma budur.</span><span class="sxs-lookup"><span data-stu-id="368f7-170">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="368f7-171">Ayrıca, ACID stili veya iki aşamalı tamamlama işlemleri yalnızca mikro hizmetler ilkelerine karşı değildir; Çoğu NoSQL veritabanları (örneğin, Azure Cosmos DB, MongoDB, vb.) iki aşamalı tamamlama işlemleri desteklemez.</span><span class="sxs-lookup"><span data-stu-id="368f7-171">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions.</span></span> <span data-ttu-id="368f7-172">Ancak, veri koruma hizmetleri ve veritabanları arasında tutarlılığı gereklidir.</span><span class="sxs-lookup"><span data-stu-id="368f7-172">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="368f7-173">Bu zorluğu da yedekli olacak şekilde bazı verilere ihtiyaç duyduğunda, birden fazla mikro hizmetler arasında değişiklikleri yaymak nasıl soruyu ilgili — Örneğin, ne zaman ürün adına veya açıklamasına Kataloğu mikro hizmet ve sepet olması gerekir mikro hizmet.</span><span class="sxs-lookup"><span data-stu-id="368f7-173">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product’s name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="368f7-174">Bu sorun için iyi bir çözümdür, olay tabanlı iletişim ve bir Yayımla ve abone ol sistemi geliştirilmiştir mikro hizmetler arasındaki son tutarlılık kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="368f7-174">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="368f7-175">Bu konulara bölümünde ele alınmıştır [zaman uyumsuz olay temelli iletişim](asynchronous-message-based-communication.md#asynchronous-event-driven-communication) bu kılavuzun sonraki.</span><span class="sxs-lookup"><span data-stu-id="368f7-175">These topics are covered in the section [Asynchronous event-driven communication](asynchronous-message-based-communication.md#asynchronous-event-driven-communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="368f7-176">Sınama \#4: nasıl mikro hizmet sınırları arasında iletişim</span><span class="sxs-lookup"><span data-stu-id="368f7-176">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="368f7-177">Mikro hizmet arasında iletişim kuran sınırları gerçek zor olur.</span><span class="sxs-lookup"><span data-stu-id="368f7-177">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="368f7-178">Bu bağlamda iletişim başvurmuyor, protokol (HTTP ve REST, AMQP, Mesajlaşma vb.) kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="368f7-178">In this context, communication does not refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="368f7-179">Bunun yerine, kullanmanız gereken hangi iletişim stili ve özellikle bu nasıl bağlı mikro hizmetlerin olmalıdır yöneliktir.</span><span class="sxs-lookup"><span data-stu-id="368f7-179">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="368f7-180">Hata oluştuğunda bağlantısından düzeyine bağlı olarak, bu hata, sistem üzerindeki etkisini önemli ölçüde farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="368f7-180">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="368f7-181">Bir mikro hizmet tabanlı uygulama, çok sayıda yapıtları gezinmek ve birçok sunucuları veya konaklar arasında dağıtılmış hizmetlerle gibi dağıtılmış bir sistemde bileşenleri sonunda başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="368f7-181">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="368f7-182">Böylece bunlar hesaba riskleri Dağıtılmış Sistem bu tür genel katılarak üzerinde mikro hizmetlerin ve iletişimi tasarım gerek kısmi hata ve daha da büyük kesintiler oluşacaktır.</span><span class="sxs-lookup"><span data-stu-id="368f7-182">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them taking into account the risks common in this type of distributed system.</span></span>

<span data-ttu-id="368f7-183">HTTP REST tabanlı mikro hizmetler, kendi kolaylık olması nedeniyle uygulamak yaygın bir yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="368f7-183">A popular approach is to implement HTTP (REST)-based microservices, due to their simplicity.</span></span> <span data-ttu-id="368f7-184">HTTP tabanlı yaklaşım edilebilir, sorun burada kullandığınız nasıl ilişkilidir.</span><span class="sxs-lookup"><span data-stu-id="368f7-184">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="368f7-185">Yalnızca istemci uygulamaları veya API ağ geçitleri, mikro hizmetler ile etkileşim kurmak için HTTP isteklerini ve yanıtlarını kullanırsanız, uygundur.</span><span class="sxs-lookup"><span data-stu-id="368f7-185">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that is fine.</span></span> <span data-ttu-id="368f7-186">Ancak mikro hizmetler arasında zaman uyumlu HTTP çağrıları için uzun zincirleri oluşturursanız, mikro hizmetler tek parça bir uygulamayı nesneleri değilmiş gibi kendi sınırları arasında iletişim kurma, uygulamanızın sonunda sorunlarla karşılaşırsanız çalışır.</span><span class="sxs-lookup"><span data-stu-id="368f7-186">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="368f7-187">Örneğin, istemci uygulamanız sıralama mikro hizmet gibi tek bir mikro hizmet için bir HTTP API çağrısı yapar düşünün.</span><span class="sxs-lookup"><span data-stu-id="368f7-187">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="368f7-188">Sıralama mikro hizmet sırayla ek çağırırsa döngüsü içinde aynı istek/yanıt HTTP kullanarak mikro hizmetler, HTTP çağrıları zinciri oluşturuyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="368f7-188">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you are creating a chain of HTTP calls.</span></span> <span data-ttu-id="368f7-189">Başlangıçta makul görünebilir.</span><span class="sxs-lookup"><span data-stu-id="368f7-189">It might sound reasonable initially.</span></span> <span data-ttu-id="368f7-190">Ancak, bu yolunda giderken dikkat edilmesi gereken önemli noktalar vardır:</span><span class="sxs-lookup"><span data-stu-id="368f7-190">However, there are important points to consider when going down this path:</span></span>

-   <span data-ttu-id="368f7-191">Engelleme ve düşük performans.</span><span class="sxs-lookup"><span data-stu-id="368f7-191">Blocking and low performance.</span></span> <span data-ttu-id="368f7-192">HTTP zaman uyumlu yapısı nedeniyle, iç HTTP çağrıları bitene kadar özgün istek yanıt almazsınız.</span><span class="sxs-lookup"><span data-stu-id="368f7-192">Due to the synchronous nature of HTTP, the original request will not get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="368f7-193">Bu çağrı sayısı önemli ölçüde artırır ve aynı zamanda bir mikro hizmet için bir ara HTTP çağrıları engellenir hayal edin.</span><span class="sxs-lookup"><span data-stu-id="368f7-193">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="368f7-194">Performansı etkilenir ve genel ölçeklenebilirlik katlanarak ek HTTP istekleri artış etkilenecek sonucudur.</span><span class="sxs-lookup"><span data-stu-id="368f7-194">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

-   <span data-ttu-id="368f7-195">HTTP ile eşleştirmeye mikro hizmetler.</span><span class="sxs-lookup"><span data-stu-id="368f7-195">Coupling microservices with HTTP.</span></span> <span data-ttu-id="368f7-196">İş mikro hizmetler ile diğer iş mikro hizmetler bağlanmış olmalıdır değil.</span><span class="sxs-lookup"><span data-stu-id="368f7-196">Business microservices should not be coupled with other business microservices.</span></span> <span data-ttu-id="368f7-197">İdeal olarak, bunlar "varlığını diğer mikro hizmetler hakkında bilmeniz gerekenler değil".</span><span class="sxs-lookup"><span data-stu-id="368f7-197">Ideally, they should not “know” about the existence of other microservices.</span></span> <span data-ttu-id="368f7-198">Uygulamanız mikro hizmetler örnekte olduğu gibi eşlenmesiyle dayanıyorsa, mikro hizmet başına otonomi elde neredeyse imkansız olur.</span><span class="sxs-lookup"><span data-stu-id="368f7-198">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

-   <span data-ttu-id="368f7-199">Herhangi bir mikro hizmet hatası.</span><span class="sxs-lookup"><span data-stu-id="368f7-199">Failure in any one microservice.</span></span> <span data-ttu-id="368f7-200">Herhangi bir mikro hizmet başarısız olursa (ve sonunda başarısız olur olduğunda) ve tüm zincir mikro HTTP çağrıları ile bağlantılı bir mikro hizmet zinciri uygulanması durumunda başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="368f7-200">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="368f7-201">Mikro hizmet tabanlı bir sistem yanı sıra mümkün kısmi hataları sırasında çalışmaya devam etmek için tasarlanmış olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="368f7-201">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="368f7-202">Yeniden deneme üstel geri alma ya da devre kesicinin mekanizmaları kullanan istemci mantığı uygulamasına olsa bile, daha fazla karmaşık HTTP çağrısı zincirleri olan HTTP tabanlı bir hata stratejisi uygulamak olan daha karmaşık.</span><span class="sxs-lookup"><span data-stu-id="368f7-202">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="368f7-203">İç, mikro hizmetler, HTTP isteklerini zincirleri açıklandığı oluşturarak kurarken aslında bu intraprocess iletişim mekanizmaları yerine işlemleri arasındaki HTTP tabanlı ancak tek parça bir uygulamayı sahip tartışılabilir.</span><span class="sxs-lookup"><span data-stu-id="368f7-203">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intraprocess communication mechanisms.</span></span>

<span data-ttu-id="368f7-204">Bu nedenle, mikro hizmet otonomi zorlamak ve daha iyi bir dayanıklılık olması için istek/yanıt iletişim zincirleri kullanımını mikro hizmetler arasında en aza indirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="368f7-204">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="368f7-205">Yalnızca zaman uyumsuz etkileşim inter-mikro hizmet iletişimi için zaman uyumsuz ileti ve olay-tabanlı iletişim veya özgün HTTP istek/yanıt döngüsü bağımsız olarak HTTP yoklama kullanarak kullanmanız önerilir.</span><span class="sxs-lookup"><span data-stu-id="368f7-205">It is recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="368f7-206">Zaman uyumsuz iletişim kullanımı ile ek ayrıntılar sonraki bölümlerde bu kılavuzda açıklanan [zaman uyumsuz bir mikro hizmet tümleştirmesi zorlar mikro hizmet'ın bağımsız çalışma sınırı](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) ve [zaman uyumsuz ileti tabanlı iletişim](asynchronous-message-based-communication.md).</span><span class="sxs-lookup"><span data-stu-id="368f7-206">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice’s autonomy](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) and [Asynchronous message-based communication](asynchronous-message-based-communication.md).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="368f7-207">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="368f7-207">Additional resources</span></span>

-   <span data-ttu-id="368f7-208">**CAP Teoremi**
    [*https://en.wikipedia.org/wiki/CAP\_theorem*](https://en.wikipedia.org/wiki/CAP_theorem)</span><span class="sxs-lookup"><span data-stu-id="368f7-208">**CAP theorem**
[*https://en.wikipedia.org/wiki/CAP\_theorem*](https://en.wikipedia.org/wiki/CAP_theorem)</span></span>

-   <span data-ttu-id="368f7-209">**Son tutarlılık**
    [*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span><span class="sxs-lookup"><span data-stu-id="368f7-209">**Eventual consistency**
[*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span></span>

-   <span data-ttu-id="368f7-210">**Veri tutarlılığı temel bilgileri**
    [*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span><span class="sxs-lookup"><span data-stu-id="368f7-210">**Data Consistency Primer**
[*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span></span>

-   <span data-ttu-id="368f7-211">**Martin Fowler. CQRS (komut ve sorgu sorumluluğu ayrımı)**
    [*https://martinfowler.com/bliki/CQRS.html*](https://martinfowler.com/bliki/CQRS.html)</span><span class="sxs-lookup"><span data-stu-id="368f7-211">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)**
[*https://martinfowler.com/bliki/CQRS.html*](https://martinfowler.com/bliki/CQRS.html)</span></span>

-   <span data-ttu-id="368f7-212">**Gerçekleştirilmiş Görünüm**
    [*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span><span class="sxs-lookup"><span data-stu-id="368f7-212">**Materialized View**
[*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span></span>

-   <span data-ttu-id="368f7-213">**Charles satır. ACID vs. TABANI: Veritabanı işlem işleme Shifting pH**
    [*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span><span class="sxs-lookup"><span data-stu-id="368f7-213">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing**
[*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span></span>

-   <span data-ttu-id="368f7-214">**Telafi işlemi**
    [*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span><span class="sxs-lookup"><span data-stu-id="368f7-214">**Compensating Transaction**
[*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span></span>

-   <span data-ttu-id="368f7-215">**UDI Dahan. Hizmet yönelimli oluşturma**
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span><span class="sxs-lookup"><span data-stu-id="368f7-215">**Udi Dahan. Service Oriented Composition**
[*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="368f7-216">[Önceki](logical-versus-physical-architecture.md)
[İleri](identify-microservice-domain-model-boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="368f7-216">[Previous](logical-versus-physical-architecture.md)
[Next](identify-microservice-domain-model-boundaries.md)</span></span>

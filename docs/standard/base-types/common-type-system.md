---
title: Ortak Tür Sistemi
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- type system
- common type system
- assemblies [.NET Framework], types
- reference types
- value types
- cross-language interoperability
- namespaces [.NET Framework], types
- types, about types
ms.assetid: 53c57c96-83e1-4ee3-9543-9ac832671a89
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 5d21a3a315b7dc63a84f7b5d43d55c06eb2d5188
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33579593"
---
# <a name="common-type-system"></a><span data-ttu-id="fd2e1-102">Ortak Tür Sistemi</span><span class="sxs-lookup"><span data-stu-id="fd2e1-102">Common Type System</span></span>
<span data-ttu-id="fd2e1-103">Ortak tür sistemi nasıl türleri bildirilen kullanılan ve ortak dil çalışma zamanı'nda yönetilen tanımlar ve ayrıca diller arası Integration zamanının desteği önemli bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-103">The common type system defines how types are declared, used, and managed in the common language runtime, and is also an important part of the runtime's support for cross-language integration.</span></span> <span data-ttu-id="fd2e1-104">Ortak tür sistemi aşağıdaki işlevleri gerçekleştirir:</span><span class="sxs-lookup"><span data-stu-id="fd2e1-104">The common type system performs the following functions:</span></span>  
  
-   <span data-ttu-id="fd2e1-105">Etkinleştirme diller arası tümleştirme, tür güvenliği ve yüksek performanslı kodu yürütme yardımcı olan bir çerçeve oluşturur.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-105">Establishes a framework that helps enable cross-language integration, type safety, and high-performance code execution.</span></span>  
  
-   <span data-ttu-id="fd2e1-106">Tam pek çok programlama dilleri destekliyor nesne yönelimli bir modeli sağlar.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-106">Provides an object-oriented model that supports the complete implementation of many programming languages.</span></span>  
  
-   <span data-ttu-id="fd2e1-107">Farklı dillerde yazılmış nesneleri birbiriyle etkileşim kurabilen yardımcı olun dilleri izlemelidir, kuralları tanımlar.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-107">Defines rules that languages must follow, which helps ensure that objects written in different languages can interact with each other.</span></span>  
  
-   <span data-ttu-id="fd2e1-108">Temel veri türlerini içeren bir kitaplık sağlar (gibi <xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.Int32>, ve <xref:System.UInt64>) uygulama geliştirme kullanılır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-108">Provides a library that contains the primitive data types (such as <xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.Int32>, and <xref:System.UInt64>) used in application development.</span></span>  
  
 <span data-ttu-id="fd2e1-109">Bu konu aşağıdaki bölümleri içermektedir:</span><span class="sxs-lookup"><span data-stu-id="fd2e1-109">This topic contains the following sections:</span></span>  
  
-   [<span data-ttu-id="fd2e1-110">.NET türleri</span><span class="sxs-lookup"><span data-stu-id="fd2e1-110">Types in .NET</span></span>](#types_in_the_net_framework)  
  
-   [<span data-ttu-id="fd2e1-111">Tür Tanımları</span><span class="sxs-lookup"><span data-stu-id="fd2e1-111">Type Definitions</span></span>](#type_definitions)  
  
-   [<span data-ttu-id="fd2e1-112">Tür Üyeleri</span><span class="sxs-lookup"><span data-stu-id="fd2e1-112">Type Members</span></span>](#type_members)  
  
-   [<span data-ttu-id="fd2e1-113">Tür üyeleri özellikleri</span><span class="sxs-lookup"><span data-stu-id="fd2e1-113">Characteristics of Type Members</span></span>](#characteristics_of_type_members)  
  
<a name="types_in_the_net_framework"></a>   
## <a name="types-in-net"></a><span data-ttu-id="fd2e1-114">.NET türleri</span><span class="sxs-lookup"><span data-stu-id="fd2e1-114">Types in .NET</span></span>  
 <span data-ttu-id="fd2e1-115">.NET içindeki tüm türler olan değer türleri veya başvuru türleri.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-115">All types in .NET are either value types or reference types.</span></span>  
  
 <span data-ttu-id="fd2e1-116">Değer türleri olan nesneleri nesnenin gerçek değeri tarafından temsil edilen veri türleridir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-116">Value types are data types whose objects are represented by the object's actual value.</span></span> <span data-ttu-id="fd2e1-117">Bir değişkene bir değer türü örneği atanırsa, bu değişkenin değerini yeni bir kopyasını verilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-117">If an instance of a value type is assigned to a variable, that variable is given a fresh copy of the value.</span></span>  
  
 <span data-ttu-id="fd2e1-118">Başvuru türleri olan nesneleri başvuru (bir işaretçi benzer) nesnenin gerçek değeri olarak temsil edilir veri türleridir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-118">Reference types are data types whose objects are represented by a reference (similar to a pointer) to the object's actual value.</span></span> <span data-ttu-id="fd2e1-119">Bir başvuru türü bir değişkene atanırsa, bu değişken (nokta) başvuran özgün değeri.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-119">If a reference type is assigned to a variable, that variable references (points to) the original value.</span></span> <span data-ttu-id="fd2e1-120">Hiçbir kopyalama yapılır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-120">No copy is made.</span></span>  
  
 <span data-ttu-id="fd2e1-121">.NET içinde ortak tür sistemi türleri aşağıdaki beş kategorilerini destekler:</span><span class="sxs-lookup"><span data-stu-id="fd2e1-121">The common type system in .NET supports the following five categories of types:</span></span>  
  
-   [<span data-ttu-id="fd2e1-122">Sınıflar</span><span class="sxs-lookup"><span data-stu-id="fd2e1-122">Classes</span></span>](#Classes)  
  
-   [<span data-ttu-id="fd2e1-123">Yapılar</span><span class="sxs-lookup"><span data-stu-id="fd2e1-123">Structures</span></span>](#Structures)  
  
-   [<span data-ttu-id="fd2e1-124">Sabit Listeleri</span><span class="sxs-lookup"><span data-stu-id="fd2e1-124">Enumerations</span></span>](#Enumerations)  
  
-   [<span data-ttu-id="fd2e1-125">Arabirimler</span><span class="sxs-lookup"><span data-stu-id="fd2e1-125">Interfaces</span></span>](#Interfaces)  
  
-   [<span data-ttu-id="fd2e1-126">Temsilciler</span><span class="sxs-lookup"><span data-stu-id="fd2e1-126">Delegates</span></span>](#Delegates)  
  
<a name="Classes"></a>   
### <a name="classes"></a><span data-ttu-id="fd2e1-127">Sınıflar</span><span class="sxs-lookup"><span data-stu-id="fd2e1-127">Classes</span></span>  
 <span data-ttu-id="fd2e1-128">Bir sınıf, türetilmiş doğrudan başka bir sınıftan ve, türetilen dolaylı bir başvuru türüdür <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-128">A class is a reference type that can be derived directly from another class and that is derived implicitly from <xref:System.Object?displayProperty=nameWithType>.</span></span> <span data-ttu-id="fd2e1-129">Sınıf (sınıfının bir örneği olan) bir nesne (yöntem, olayları ya da Özellikler) gerçekleştirebileceğiniz işlemler tanımlar ve veri nesnesi (alanları) içerir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-129">The class defines the operations that an object (which is an instance of the class) can perform (methods, events, or properties) and the data that the object contains (fields).</span></span> <span data-ttu-id="fd2e1-130">Bir sınıf tanımı ve (aksine, yalnızca uygulama olmadan tanımını içeren arabirimler, örneğin,), uygulama genellikle içerse uygulaması olan bir veya daha fazla üye sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-130">Although a class generally includes both definition and implementation (unlike interfaces, for example, which contain only definition without implementation), it can have one or more members that have no implementation.</span></span>  
  
 <span data-ttu-id="fd2e1-131">Aşağıdaki tabloda bir sınıf olabilir özellikleri bazıları açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-131">The following table describes some of the characteristics that a class may have.</span></span> <span data-ttu-id="fd2e1-132">Çalışma zamanı destekleyen her bir dilin bir sınıf belirtmek için bir yol sağlar veya sınıf üyesi bir veya daha fazla şu özelliklere sahiptir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-132">Each language that supports the runtime provides a way to indicate that a class or class member has one or more of these characteristics.</span></span> <span data-ttu-id="fd2e1-133">Ancak, tek tek programlama dilleri hedefleyen .NET şu özelliklere kullanımına değil.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-133">However, individual programming languages that target .NET may not make all these characteristics available.</span></span>  
  
|<span data-ttu-id="fd2e1-134">Özelliği</span><span class="sxs-lookup"><span data-stu-id="fd2e1-134">Characteristic</span></span>|<span data-ttu-id="fd2e1-135">Açıklama</span><span class="sxs-lookup"><span data-stu-id="fd2e1-135">Description</span></span>|  
|--------------------|-----------------|  
|<span data-ttu-id="fd2e1-136">korumalı</span><span class="sxs-lookup"><span data-stu-id="fd2e1-136">sealed</span></span>|<span data-ttu-id="fd2e1-137">Başka bir sınıf bu türden türetilmiş belirtir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-137">Specifies that another class cannot be derived from this type.</span></span>|  
|<span data-ttu-id="fd2e1-138">uygulamalar</span><span class="sxs-lookup"><span data-stu-id="fd2e1-138">implements</span></span>|<span data-ttu-id="fd2e1-139">Arabirim üyeleri uygulamaları sağlayarak sınıfı bir veya daha fazla arabirimin kullandığını gösterir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-139">Indicates that the class uses one or more interfaces by providing implementations of interface members.</span></span>|  
|<span data-ttu-id="fd2e1-140">abstract</span><span class="sxs-lookup"><span data-stu-id="fd2e1-140">abstract</span></span>|<span data-ttu-id="fd2e1-141">Sınıf örneği gösterir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-141">Indicates that the class cannot be instantiated.</span></span> <span data-ttu-id="fd2e1-142">Kullanmak için başka bir sınıf ondan türetilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-142">To use it, you must derive another class from it.</span></span>|  
|<span data-ttu-id="fd2e1-143">devralır</span><span class="sxs-lookup"><span data-stu-id="fd2e1-143">inherits</span></span>|<span data-ttu-id="fd2e1-144">Sınıfın örnekleri, temel sınıfın belirtilen herhangi bir yere kullanılabileceğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-144">Indicates that instances of the class can be used anywhere the base class is specified.</span></span> <span data-ttu-id="fd2e1-145">Taban sınıfından devralıyor türetilmiş bir sınıf temel sınıfı tarafından sağlanan herhangi bir ortak üye uyarlamasını kullanabilir veya türetilmiş bir sınıf kendi uygulama Genel üyeler uygulamasıyla geçersiz kılabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-145">A derived class that inherits from a base class can use the implementation of any public members provided by the base class, or the derived class can override the implementation of the public members with its own implementation.</span></span>|  
|<span data-ttu-id="fd2e1-146">dışa aktarılan ya da dışa aktarılamaz</span><span class="sxs-lookup"><span data-stu-id="fd2e1-146">exported or not exported</span></span>|<span data-ttu-id="fd2e1-147">Bir sınıf içinde tanımlandığı derleme dışında görünür olup olmadığını gösterir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-147">Indicates whether a class is visible outside the assembly in which it is defined.</span></span> <span data-ttu-id="fd2e1-148">Bu özellik yalnızca üst düzey sınıflar ve iç içe geçmiş sınıflar için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-148">This characteristic applies only to top-level classes and not to nested classes.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="fd2e1-149">Bir sınıfı ayrıca bir üst sınıf veya yapı iç içe.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-149">A class can also be nested in a parent class or structure.</span></span> <span data-ttu-id="fd2e1-150">İç içe geçmiş sınıflar da üye özelliklere sahiptir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-150">Nested classes also have member characteristics.</span></span> <span data-ttu-id="fd2e1-151">Daha fazla bilgi için bkz: [iç içe geçmiş türler](#NestedTypes).</span><span class="sxs-lookup"><span data-stu-id="fd2e1-151">For more information, see [Nested Types](#NestedTypes).</span></span>  
  
 <span data-ttu-id="fd2e1-152">Hiç uygulamanız sınıf üyeleri soyut üyeleridir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-152">Class members that have no implementation are abstract members.</span></span> <span data-ttu-id="fd2e1-153">Bir veya daha fazla soyut üye olan bir sınıfı kendisi değildir soyut; yeni örneklerini oluşturulamıyor.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-153">A class that has one or more abstract members is itself abstract; new instances of it cannot be created.</span></span> <span data-ttu-id="fd2e1-154">Çalışma zamanı hedef bazı dillerde, üyelerine hiçbiri soyut olsa bile, bir sınıf soyut olarak işaretlemek olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-154">Some languages that target the runtime let you mark a class as abstract even if none of its members are abstract.</span></span> <span data-ttu-id="fd2e1-155">Temel bir kapsülleyen istediğinizde bir Özet sınıf kullanabilirsiniz türetilmiş sınıfları işlev kümesi devralır veya uygun olduğunda geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-155">You can use an abstract class when you want to encapsulate a basic set of functionality that derived classes can inherit or override when appropriate.</span></span> <span data-ttu-id="fd2e1-156">Özet olmayan sınıflar somut sınıflar adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-156">Classes that are not abstract are referred to as concrete classes.</span></span>  
  
 <span data-ttu-id="fd2e1-157">Bir sınıf herhangi bir sayıda arabirim uygulayabilirsiniz, ancak ek olarak yalnızca bir taban sınıftan devralabilirsiniz <xref:System.Object?displayProperty=nameWithType>, hangi tüm sınıflar örtük olarak devral gelen.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-157">A class can implement any number of interfaces, but it can inherit from only one base class in addition to <xref:System.Object?displayProperty=nameWithType>, from which all classes inherit implicitly.</span></span> <span data-ttu-id="fd2e1-158">Tüm sınıflar, yeni sınıfın örneği başlatır en az bir oluşturucuya sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-158">All classes must have at least one constructor, which initializes new instances of the class.</span></span> <span data-ttu-id="fd2e1-159">Bir oluşturucu açıkça tanımlamıyorsa, çoğu derleyicileri otomatik olarak varsayılan (parametresiz) Oluşturucusu sağlar.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-159">If you do not explicitly define a constructor, most compilers will automatically provide a default (parameterless) constructor.</span></span>  
  
<a name="Structures"></a>   
### <a name="structures"></a><span data-ttu-id="fd2e1-160">Yapılar</span><span class="sxs-lookup"><span data-stu-id="fd2e1-160">Structures</span></span>  
 <span data-ttu-id="fd2e1-161">Örtük olarak türeyen bir değer türü yapısıdır <xref:System.ValueType?displayProperty=nameWithType>, sırayla türetilen <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-161">A structure is a value type that derives implicitly from <xref:System.ValueType?displayProperty=nameWithType>, which in turn is derived from <xref:System.Object?displayProperty=nameWithType>.</span></span> <span data-ttu-id="fd2e1-162">Bir yapı, bellek gereksinimleri küçük değerlerini temsil eden ve değerleri parametreleri kesin türü belirtilmiş yöntemleri değeri olarak parametre olarak geçirme çok yararlı olacaktır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-162">A structure is very useful for representing values whose memory requirements are small, and for passing values as by-value parameters to methods that have strongly typed parameters.</span></span> <span data-ttu-id="fd2e1-163">. NET'te, tüm temel veri türleri (<xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.DateTime>, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.Single>, <xref:System.UInt16>, <xref:System.UInt32>, ve <xref:System.UInt64>) yapıları olarak tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-163">In .NET, all primitive data types (<xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.DateTime>, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.Single>, <xref:System.UInt16>, <xref:System.UInt32>, and <xref:System.UInt64>) are defined as structures.</span></span>  
  
 <span data-ttu-id="fd2e1-164">Sınıflar gibi yapıları verileri (yapısı alanları) ve bu verileri (yapısı yöntemleri) gerçekleştirilen işlemleri tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-164">Like classes, structures define both data (the fields of the structure) and the operations that can be performed on that data (the methods of the structure).</span></span> <span data-ttu-id="fd2e1-165">Yapıları tanımlanan sanal yöntemleri de dahil olmak üzere üzerinde yöntemleri çağırabilirsiniz yani <xref:System.Object?displayProperty=nameWithType> ve <xref:System.ValueType?displayProperty=nameWithType> sınıfları ve değer türü kendisini tanımlanmış herhangi bir yöntem.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-165">This means that you can call methods on structures, including the virtual methods defined on the <xref:System.Object?displayProperty=nameWithType> and <xref:System.ValueType?displayProperty=nameWithType> classes, and any methods defined on the value type itself.</span></span> <span data-ttu-id="fd2e1-166">Diğer bir deyişle, yapıları alanları, özellikleri ve olayları yanı sıra statik ve statik olmayan yöntemleri olabilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-166">In other words, structures can have fields, properties, and events, as well as static and nonstatic methods.</span></span> <span data-ttu-id="fd2e1-167">Yapıları örneklerini oluşturmak, parametre olarak geçirmek, yerel değişkenleri olarak depolamak veya başka bir değer türü bir alana depolamaya veya türü başvuru.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-167">You can create instances of structures, pass them as parameters, store them as local variables, or store them in a field of another value type or reference type.</span></span> <span data-ttu-id="fd2e1-168">Yapıları arabirimleri de uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-168">Structures can also implement interfaces.</span></span>  
  
 <span data-ttu-id="fd2e1-169">Değer türleri birçok bakımdan sınıfları ayrıca farklıdır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-169">Value types also differ from classes in several respects.</span></span> <span data-ttu-id="fd2e1-170">İlk olarak, bunlar örtük olarak devralınmalıdır rağmen <xref:System.ValueType?displayProperty=nameWithType>, herhangi bir türünden doğrudan devral olamaz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-170">First, although they implicitly inherit from <xref:System.ValueType?displayProperty=nameWithType>, they cannot directly inherit from any type.</span></span> <span data-ttu-id="fd2e1-171">Benzer şekilde, başka bir türü onlardan türetilebilir, yani tüm değer türleri korumalıdır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-171">Similarly, all value types are sealed, which means that no other type can be derived from them.</span></span> <span data-ttu-id="fd2e1-172">Bunlar ayrıca oluşturucular gerek yoktur.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-172">They also do not require constructors.</span></span>  
  
 <span data-ttu-id="fd2e1-173">Her değer türü için ortak dil çalışma zamanı aynı durumu ve değer türü davranışlara sahiptir sınıftır karşılık gelen bir Kutulu türü sağlar.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-173">For each value type, the common language runtime supplies a corresponding boxed type, which is a class that has the same state and behavior as the value type.</span></span> <span data-ttu-id="fd2e1-174">Değer türü örneği türünde bir parametre kabul eden bir yönteme geçirildiğinde Kutulu <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-174">An instance of a value type is boxed when it is passed to a method that accepts a parameter of type <xref:System.Object?displayProperty=nameWithType>.</span></span> <span data-ttu-id="fd2e1-175">Sarmalanmamış (diğer bir deyişle, bir sınıfın bir örnekten bir değer türü örneğine geri dönüştürülmüş) denetim döndüğünde yöntemi çağrısından değer türü başvurusu tarafından parametre olarak kabul eder.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-175">It is unboxed (that is, converted from an instance of a class back to an instance of a value type) when control returns from a method call that accepts a value type as a by-reference parameter.</span></span> <span data-ttu-id="fd2e1-176">Bazı diller Kutulu türü gerekli olduğunda özel bir sözdizimi kullanmanızı gerektirir; gerektiğinde başkalarının otomatik olarak paketlenmiş türünü kullanın.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-176">Some languages require that you use special syntax when the boxed type is required; others automatically use the boxed type when it is needed.</span></span> <span data-ttu-id="fd2e1-177">Değer türü tanımladığınızda, paketlenmiş hem sarmalanmamış türü tanımlama.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-177">When you define a value type, you are defining both the boxed and the unboxed type.</span></span>  
  
<a name="Enumerations"></a>   
### <a name="enumerations"></a><span data-ttu-id="fd2e1-178">Numaralandırmalar</span><span class="sxs-lookup"><span data-stu-id="fd2e1-178">Enumerations</span></span>  
 <span data-ttu-id="fd2e1-179">Doğrudan öğesinden devralınan bir değer türü numaralandırma (numaralandırma) olduğunda <xref:System.Enum?displayProperty=nameWithType> ve kaynakları adları temel alınan bir ilkel türü değerleri için alternatif.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-179">An enumeration (enum) is a value type that inherits directly from <xref:System.Enum?displayProperty=nameWithType> and that supplies alternate names for the values of an underlying primitive type.</span></span> <span data-ttu-id="fd2e1-180">Bir numaralandırma türü yerleşik işaretli veya işaretsiz tamsayı türlerden biri olmalıdır bir temel alınan türü olan bir ada sahip (gibi <xref:System.Byte>, <xref:System.Int32>, veya <xref:System.UInt64>) ve alanları kümesi.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-180">An enumeration type has a name, an underlying type that must be one of the built-in signed or unsigned integer types (such as <xref:System.Byte>, <xref:System.Int32>, or <xref:System.UInt64>), and a set of fields.</span></span> <span data-ttu-id="fd2e1-181">Her biri bir sabiti temsil eden statik değişmez değer alanları alanlardır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-181">The fields are static literal fields, each of which represents a constant.</span></span> <span data-ttu-id="fd2e1-182">Aynı değeri için birden çok alan atanabilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-182">The same value can be assigned to multiple fields.</span></span> <span data-ttu-id="fd2e1-183">Bu durumda, değerlerden biri yansıma ve dize dönüştürme için birincil numaralandırma değeri olarak işaretlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-183">When this occurs, you must mark one of the values as the primary enumeration value for reflection and string conversion.</span></span>  
  
 <span data-ttu-id="fd2e1-184">Türünde bir değer (tür atama yok çalışma zamanı tarafından gerekli değildir) temel bir numaralandırma ve tersi yönde atayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-184">You can assign a value of the underlying type to an enumeration and vice versa (no cast is required by the runtime).</span></span> <span data-ttu-id="fd2e1-185">Numaralandırma örneği oluşturun ve yöntemlerini çağırın <xref:System.Enum?displayProperty=nameWithType>, numaralandırmanın temel türünde tanımlanan olarak herhangi bir yöntem yanı sıra.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-185">You can create an instance of an enumeration and call the methods of <xref:System.Enum?displayProperty=nameWithType>, as well as any methods defined on the enumeration's underlying type.</span></span> <span data-ttu-id="fd2e1-186">Ancak, bazı dillerde, temel alınan türünün bir örneği gerekli olduğunda bir numaralandırma parametre olarak geçirmek sağlayabilir değil (veya tersi).</span><span class="sxs-lookup"><span data-stu-id="fd2e1-186">However, some languages might not let you pass an enumeration as a parameter when an instance of the underlying type is required (or vice versa).</span></span>  
  
 <span data-ttu-id="fd2e1-187">Numaralandırmalar için aşağıdaki ek kısıtlamalar geçerlidir:</span><span class="sxs-lookup"><span data-stu-id="fd2e1-187">The following additional restrictions apply to enumerations:</span></span>  
  
-   <span data-ttu-id="fd2e1-188">Bunlar kendi yöntemleri tanımlayamazsınız.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-188">They cannot define their own methods.</span></span>  
  
-   <span data-ttu-id="fd2e1-189">Bunlar arabirimleri uygulayamaz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-189">They cannot implement interfaces.</span></span>  
  
-   <span data-ttu-id="fd2e1-190">Bunlar, özellikleri veya olayları tanımlayamazsınız.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-190">They cannot define properties or events.</span></span>  
  
-   <span data-ttu-id="fd2e1-191">Genel bir tür içinde yalnızca içe çünkü genel edilmedikleri sürece genel, olamaz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-191">They cannot be generic, unless they are generic only because they are nested within a generic type.</span></span> <span data-ttu-id="fd2e1-192">Diğer bir deyişle, bir numaralandırma türü parametrelerinin kendi sahip olamaz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-192">That is, an enumeration cannot have type parameters of its own.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="fd2e1-193">Visual Basic, C# ve C++ ile oluşturulan iç içe geçmiş türler (numaralandırmalar dahil) tüm kapsayan genel türleri tür parametrelerini içerir ve kendi tür parametreleri olmasa bile, bu nedenle genel.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-193">Nested types (including enumerations) created with Visual Basic, C#, and C++ include the type parameters of all enclosing generic types, and are therefore generic even if they do not have type parameters of their own.</span></span> <span data-ttu-id="fd2e1-194">Daha fazla bilgi için bkz: "Türleri iç içe geçmiş" <xref:System.Type.MakeGenericType%2A?displayProperty=nameWithType> başvuru konusu.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-194">For more information, see "Nested Types" in the <xref:System.Type.MakeGenericType%2A?displayProperty=nameWithType> reference topic.</span></span>  
  
 <span data-ttu-id="fd2e1-195"><xref:System.FlagsAttribute> Öznitelik bir bit alanı adlı numaralandırması özel bir tür gösterir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-195">The <xref:System.FlagsAttribute> attribute denotes a special kind of enumeration called a bit field.</span></span> <span data-ttu-id="fd2e1-196">Çalışma zamanı kendisini geleneksel numaralandırmalar ve bit alanları arasında ayrım yapmaz ancak dilinizi bunu.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-196">The runtime itself does not distinguish between traditional enumerations and bit fields, but your language might do so.</span></span> <span data-ttu-id="fd2e1-197">Bu ayrım yapıldığında, bit düzeyinde işleçler bit alanları, ancak numaralandırmalar, adlandırılmamış değerlerini oluşturmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-197">When this distinction is made, bitwise operators can be used on bit fields, but not on enumerations, to generate unnamed values.</span></span> <span data-ttu-id="fd2e1-198">Numaralandırmalar genellikle gün hafta, ülke veya bölge adları gibi benzersiz öğelerin listesi için kullanılır ve benzeri.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-198">Enumerations are generally used for lists of unique elements, such as days of the week, country or region names, and so on.</span></span> <span data-ttu-id="fd2e1-199">Bit alanları genellikle nitelikleri veya birlikte gibi oluşabilecek miktarları listesi için kullanılan `Red And Big And Fast`.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-199">Bit fields are generally used for lists of qualities or quantities that might occur in combination, such as `Red And Big And Fast`.</span></span>  
  
 <span data-ttu-id="fd2e1-200">Aşağıdaki örnek bit alanları ve geleneksel numaralandırmalar nasıl kullanılacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-200">The following example shows how to use both bit fields and traditional enumerations.</span></span>  
  
 [!code-csharp[Conceptual.Types.Enum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.enum/cs/example.cs#1)]
 [!code-vb[Conceptual.Types.Enum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.enum/vb/example.vb#1)]  
  
<a name="Interfaces"></a>   
### <a name="interfaces"></a><span data-ttu-id="fd2e1-201">Arabirimler</span><span class="sxs-lookup"><span data-stu-id="fd2e1-201">Interfaces</span></span>  
 <span data-ttu-id="fd2e1-202">Bir "yapabilirsiniz" ilişkiyi belirten bir sözleşme bir arabirim tanımlar veya "sahip bir" ilişki.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-202">An interface defines a contract that specifies a "can do" relationship or a "has a" relationship.</span></span> <span data-ttu-id="fd2e1-203">Arabirimleri genellikle karşılaştırma ve sıralama gibi işlevlerini uygulamak için kullanılır ( <xref:System.IComparable> ve <xref:System.IComparable%601> arabirimleri), eşitlik için test ( <xref:System.IEquatable%601> arabirimi), veya bir koleksiyondaki öğelerin numaralandırma ( <xref:System.Collections.IEnumerable> ve <xref:System.Collections.Generic.IEnumerable%601> arabirimleri).</span><span class="sxs-lookup"><span data-stu-id="fd2e1-203">Interfaces are often used to implement functionality, such as comparing and sorting (the <xref:System.IComparable> and <xref:System.IComparable%601> interfaces), testing for equality (the <xref:System.IEquatable%601> interface), or enumerating items in a collection (the <xref:System.Collections.IEnumerable> and <xref:System.Collections.Generic.IEnumerable%601> interfaces).</span></span> <span data-ttu-id="fd2e1-204">Arabirim özellikleri, yöntemleri ve olaylar, soyut üyelerini tümü olabilir; üyeleri ve bunların imza arabirimi tanımlar, diğer bir deyişle, bu, her arabirim üyesini işlevselliğini tanımlamak için arabirimini uygulayan türü bırakır, ancak.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-204">Interfaces can have properties, methods, and events, all of which are abstract members; that is, although the interface defines the members and their signatures, it leaves it to the type that implements the interface to define the functionality of each interface member.</span></span> <span data-ttu-id="fd2e1-205">Başka bir deyişle, herhangi bir sınıf veya bir arabirimini uygulayan yapısı arabirimde bildirilen soyut üyelerini tanımlarında sağlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-205">This means that any class or structure that implements an interface must supply definitions for the abstract members declared in the interface.</span></span> <span data-ttu-id="fd2e1-206">Bir arabirim herhangi uygulayan sınıf veya yapı de bir veya daha fazla diğer arabirimleri uygulamak için gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-206">An interface can require any implementing class or structure to also implement one or more other interfaces.</span></span>  
  
 <span data-ttu-id="fd2e1-207">Arabirimleri aşağıdaki kısıtlamalar geçerlidir:</span><span class="sxs-lookup"><span data-stu-id="fd2e1-207">The following restrictions apply to interfaces:</span></span>  
  
-   <span data-ttu-id="fd2e1-208">Bir arabirim ile tüm erişilebilirlik bildirilebilir ancak arabirim üyeleri tüm ortak erişilebilirlik olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-208">An interface can be declared with any accessibility, but interface members must all have public accessibility.</span></span>  
  
-   <span data-ttu-id="fd2e1-209">Arabirimleri oluşturucular tanımlayamazsınız.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-209">Interfaces cannot define constructors.</span></span>  
  
-   <span data-ttu-id="fd2e1-210">Arabirimleri alanları tanımlayamazsınız.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-210">Interfaces cannot define fields.</span></span>  
  
-   <span data-ttu-id="fd2e1-211">Arabirimleri yalnızca örnek üyelerin tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-211">Interfaces can define only instance members.</span></span> <span data-ttu-id="fd2e1-212">Bunlar statik üyeler tanımlanamaz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-212">They cannot define static members.</span></span>  
  
 <span data-ttu-id="fd2e1-213">Birden fazla arabirimi aynı imzaya sahip bir üye bildirebilir olduğundan, bir uygulama üye gerektiren arabirimine eşlemek için her bir dilin kuralları sağlamanız gerekir ve bu üyeleri ayrı uygulamaları olabilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-213">Each language must provide rules for mapping an implementation to the interface that requires the member, because more than one interface can declare a member with the same signature, and these members can have separate implementations.</span></span>  
  
<a name="Delegates"></a>   
### <a name="delegates"></a><span data-ttu-id="fd2e1-214">Temsilciler</span><span class="sxs-lookup"><span data-stu-id="fd2e1-214">Delegates</span></span>  
 <span data-ttu-id="fd2e1-215">Temsilciler c++'ta, işlev işaretçileri benzeyen bir amaca hizmet başvuru türleridir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-215">Delegates are reference types that serve a purpose similar to that of function pointers in C++.</span></span> <span data-ttu-id="fd2e1-216">Olay işleyicileri ve .NET geri çağırma işlevleri için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-216">They are used for event handlers and callback functions in .NET.</span></span> <span data-ttu-id="fd2e1-217">İşlev işaretçileri aksine temsilciler güvenli, doğrulanabilir ve güvenli yazın.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-217">Unlike function pointers, delegates are secure, verifiable, and type safe.</span></span> <span data-ttu-id="fd2e1-218">Bir temsilci türü herhangi bir örnek yöntemi veya uyumlu bir imzaya sahip statik yöntemi temsil edebilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-218">A delegate type can represent any instance method or static method that has a compatible signature.</span></span>  
  
 <span data-ttu-id="fd2e1-219">Bu temsilci atamak için geçirilen bağımsız değişken için güvenli bir şekilde geçirilebilir güvence altına alır çünkü temsilci parametresinin türü yöntemi parametresinin türü kısıtlayıcı ise temsilcisi bir parametre karşılık gelen bir yöntem parametresi ile uyumlu. yöntem.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-219">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="fd2e1-220">Bu dönüş türü yönteminin dönüş değeri güvenle çevirebilirsiniz güvence altına alır çünkü yöntemin dönüş türünü temsilci dönüş türünden daha kısıtlayıcı ise benzer şekilde, bir temsilci dönüş türü bir yöntemi, dönüş türü ile uyumlu. Temsilci e.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-220">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="fd2e1-221">Örneğin, türünde bir parametreye sahip bir temsilci <xref:System.Collections.IEnumerable> ve dönüş türü <xref:System.Object> türünde bir parametre içeren bir yöntem gösterebilir <xref:System.Object> ve bir dönüş değeri <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-221">For example, a delegate that has a parameter of type <xref:System.Collections.IEnumerable> and a return type of <xref:System.Object> can represent a method that has a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.IEnumerable>.</span></span> <span data-ttu-id="fd2e1-222">Daha fazla bilgi ve örnek kod için bkz: <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-222">For more information and example code, see <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="fd2e1-223">Bir temsilci temsil ettiği yönteme bağlı olmayı kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-223">A delegate is said to be bound to the method it represents.</span></span> <span data-ttu-id="fd2e1-224">Yöntemine bağlanan ek olarak bir temsilci nesneye bağlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-224">In addition to being bound to the method, a delegate can be bound to an object.</span></span> <span data-ttu-id="fd2e1-225">Nesne yönteminin ilk parametresini temsil eder ve temsilci çağrılır her zaman yönteme geçirilen.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-225">The object represents the first parameter of the method, and is passed to the method every time the delegate is invoked.</span></span> <span data-ttu-id="fd2e1-226">Yöntem örnek yöntemi ise, ilişkili nesne örtük geçirilen `this` parametre (`Me` Visual Basic'te); yöntemi statik nesne yöntemi resmi ilk parametre olarak geçirilir ve temsilci imza eşleşmelidir Kalan parametreleri.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-226">If the method is an instance method, the bound object is passed as the implicit `this` parameter (`Me` in Visual Basic); if the method is static, the object is passed as the first formal parameter of the method, and the delegate signature must match the remaining parameters.</span></span> <span data-ttu-id="fd2e1-227">Daha fazla bilgi ve örnek kod için bkz: <xref:System.Delegate?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-227">For more information and example code, see <xref:System.Delegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="fd2e1-228">Tüm temsilcileri devralınmalıdır <xref:System.MulticastDelegate?displayProperty=nameWithType>, devralan <xref:System.Delegate?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-228">All delegates inherit from <xref:System.MulticastDelegate?displayProperty=nameWithType>, which inherits from <xref:System.Delegate?displayProperty=nameWithType>.</span></span> <span data-ttu-id="fd2e1-229">C#, Visual Basic ve C++ dilleri devralma bu türlerinden izin vermez.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-229">The C#, Visual Basic, and C++ languages do not allow inheritance from these types.</span></span> <span data-ttu-id="fd2e1-230">Bunun yerine, temsilciler bildirmek için anahtar sözcükleri girin.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-230">Instead, they provide keywords for declaring delegates.</span></span>  
  
 <span data-ttu-id="fd2e1-231">Temsilciler öğesinden devraldığı <xref:System.MulticastDelegate>, bir temsilci temsilciyi temsil eder ve temsilci çağrıldığında yürütülme yöntemlerin listesi bir çağrı listesi vardır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-231">Because delegates inherit from <xref:System.MulticastDelegate>, a delegate has an invocation list, which is a list of methods that the delegate represents and that are executed when the delegate is invoked.</span></span> <span data-ttu-id="fd2e1-232">Listedeki tüm yöntemleri temsilci çağrıldığında sağlanan bağımsız değişkenler alırsınız.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-232">All methods in the list receive the arguments supplied when the delegate is invoked.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fd2e1-233">Temsilci bir dönüş türüne sahip olsa bile dönüş değeri kendi çağırma listesinde birden fazla yöntemi olan bir temsilci için tanımlı değil.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-233">The return value is not defined for a delegate that has more than one method in its invocation list, even if the delegate has a return type.</span></span>  
  
 <span data-ttu-id="fd2e1-234">Çoğu durumda, gibi geri arama yöntemleri ile temsil eden bir temsilci yalnızca bir yöntem ve yapmanız gereken tek Eylemler temsilci oluşturma ve onu çağırma.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-234">In many cases, such as with callback methods, a delegate represents only one method, and the only actions you have to take are creating the delegate and invoking it.</span></span>  
  
 <span data-ttu-id="fd2e1-235">Birden fazla yöntemi temsil eden temsilciler .NET yöntemlerinin sağlar <xref:System.Delegate> ve <xref:System.MulticastDelegate> temsilci yöntem bir temsilcinin çağırma listesine ekleme gibi işlemleri desteklemek için sınıflar ( <xref:System.Delegate.Combine%2A?displayProperty=nameWithType> yöntemi), bir yöntem ( kaldırma<xref:System.Delegate.Remove%2A?displayProperty=nameWithType> yöntemi) ve çağırma listesi alınıyor ( <xref:System.Delegate.GetInvocationList%2A?displayProperty=nameWithType> yöntemi).</span><span class="sxs-lookup"><span data-stu-id="fd2e1-235">For delegates that represent multiple methods, .NET provides methods of the <xref:System.Delegate> and <xref:System.MulticastDelegate> delegate classes to support operations such as adding a method to a delegate's invocation list (the <xref:System.Delegate.Combine%2A?displayProperty=nameWithType> method), removing a method (the <xref:System.Delegate.Remove%2A?displayProperty=nameWithType> method), and getting the invocation list (the <xref:System.Delegate.GetInvocationList%2A?displayProperty=nameWithType> method).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fd2e1-236">Bu diller için ekleme ve kaldırma olay işleyicileri sözdizimi sağladığından bu yöntemleri için C#, C++ ve Visual Basic, olay işleyici temsilcileri kullanmak gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-236">It is not necessary to use these methods for event-handler delegates in C#, C++, and Visual Basic, because these languages provide syntax for adding and removing event handlers.</span></span>  
  
 
  
<a name="type_definitions"></a>   
## <a name="type-definitions"></a><span data-ttu-id="fd2e1-237">Tür tanımları</span><span class="sxs-lookup"><span data-stu-id="fd2e1-237">Type Definitions</span></span>  
 <span data-ttu-id="fd2e1-238">Bir tür tanımı aşağıdakileri içerir:</span><span class="sxs-lookup"><span data-stu-id="fd2e1-238">A type definition includes the following:</span></span>  
  
-   <span data-ttu-id="fd2e1-239">Türünde tanımlanmış tüm öznitelikler.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-239">Any attributes defined on the type.</span></span>  
  
-   <span data-ttu-id="fd2e1-240">Tür erişilebilirlik (görünürlük).</span><span class="sxs-lookup"><span data-stu-id="fd2e1-240">The type's accessibility (visibility).</span></span>  
  
-   <span data-ttu-id="fd2e1-241">Tür adı.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-241">The type's name.</span></span>  
  
-   <span data-ttu-id="fd2e1-242">Tür temel türü.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-242">The type's base type.</span></span>  
  
-   <span data-ttu-id="fd2e1-243">Türü tarafından uygulanan tüm arabirimler.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-243">Any interfaces implemented by the type.</span></span>  
  
-   <span data-ttu-id="fd2e1-244">Her tür üyeleri tanımlar.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-244">Definitions for each of the type's members.</span></span>  
  
### <a name="attributes"></a><span data-ttu-id="fd2e1-245">Öznitelikler</span><span class="sxs-lookup"><span data-stu-id="fd2e1-245">Attributes</span></span>  
 <span data-ttu-id="fd2e1-246">Öznitelikler ek kullanıcı tanımlı meta veri sağlar.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-246">Attributes provide additional user-defined metadata.</span></span> <span data-ttu-id="fd2e1-247">En yaygın olarak, bunlar kendi bütünleştirilmiş kodunda bir türü hakkında ek bilgi depolamak için ya da Tasarım zamanı ya da çalışma zamanı ortamı türü üyesi ya da davranışını değiştirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-247">Most commonly, they are used to store additional information about a type in its assembly, or to modify the behavior of a type member in either the design-time or run-time environment.</span></span>  
  
 <span data-ttu-id="fd2e1-248">Öznitelikleri sınıflardır kendilerini devralınan <xref:System.Attribute?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-248">Attributes are themselves classes that inherit from <xref:System.Attribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="fd2e1-249">Özniteliklerin her destek dilleri öznitelikleri bir dil öğesine uygulama için kendi sözdizimine sahip.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-249">Languages that support the use of attributes each have their own syntax for applying attributes to a language element.</span></span> <span data-ttu-id="fd2e1-250">Öznitelikler, neredeyse her dil öğesine uygulanabilir; için bir öznitelik uygulanabilir belirli öğeleri tarafından tanımlanan <xref:System.AttributeUsageAttribute> bu öznitelik sınıfı uygulanır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-250">Attributes can be applied to almost any language element; the specific elements to which an attribute can be applied are defined by the <xref:System.AttributeUsageAttribute> that is applied to that attribute class.</span></span>  
  
### <a name="type-accessibility"></a><span data-ttu-id="fd2e1-251">Türü erişilebilirlik</span><span class="sxs-lookup"><span data-stu-id="fd2e1-251">Type Accessibility</span></span>  
 <span data-ttu-id="fd2e1-252">Tüm türleri kendi erişilebilirlik diğer türlerinden yöneten bir değiştirici sahip.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-252">All types have a modifier that governs their accessibility from other types.</span></span> <span data-ttu-id="fd2e1-253">Aşağıdaki tabloda çalışma zamanı tarafından desteklenen tür eriþebilirlik açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-253">The following table describes the type accessibilities supported by the runtime.</span></span>  
  
|<span data-ttu-id="fd2e1-254">Erişilebilirlik</span><span class="sxs-lookup"><span data-stu-id="fd2e1-254">Accessibility</span></span>|<span data-ttu-id="fd2e1-255">Açıklama</span><span class="sxs-lookup"><span data-stu-id="fd2e1-255">Description</span></span>|  
|-------------------|-----------------|  
|<span data-ttu-id="fd2e1-256">public</span><span class="sxs-lookup"><span data-stu-id="fd2e1-256">public</span></span>|<span data-ttu-id="fd2e1-257">Türü tarafından tüm derlemelerde erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-257">The type is accessible by all assemblies.</span></span>|  
|<span data-ttu-id="fd2e1-258">derleme</span><span class="sxs-lookup"><span data-stu-id="fd2e1-258">assembly</span></span>|<span data-ttu-id="fd2e1-259">Türü, derleme içinde yalnızca erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-259">The type is accessible only from within its assembly.</span></span>|  
  
 <span data-ttu-id="fd2e1-260">İç içe geçmiş tür erişilebilirliğini üyesinin bildirilen erişilebilirlik ve hemen kapsayan tür erişilebilirlik etki alanı tarafından belirlenir kendi erişilebilirlik etki bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-260">The accessibility of a nested type depends on its accessibility domain, which is determined by both the declared accessibility of the member and the accessibility domain of the immediately containing type.</span></span> <span data-ttu-id="fd2e1-261">Ancak, iç içe geçmiş tür erişilebilirlik etki alanı, kapsayan tür aşamaz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-261">However, the accessibility domain of a nested type cannot exceed that of the containing type.</span></span>  
  
 <span data-ttu-id="fd2e1-262">Erişilebilirlik etki alanı iç içe üyesi `M` bir türü bildirilmiş `T` bir programdan `P` şu şekilde tanımlanır (Bu belirtmeye `M` kendisini bir türü olabilir):</span><span class="sxs-lookup"><span data-stu-id="fd2e1-262">The accessibility domain of a nested member `M` declared in a type `T` within a program `P` is defined as follows (noting that `M` might itself be a type):</span></span>  
  
-   <span data-ttu-id="fd2e1-263">Varsa bildirilen erişilebilirliğini `M` olan `public`, Erişilebilirlik etki alanı `M` erişilebilirlik etki alanıdır `T`.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-263">If the declared accessibility of `M` is `public`, the accessibility domain of `M` is the accessibility domain of `T`.</span></span>  
  
-   <span data-ttu-id="fd2e1-264">Varsa bildirilen erişilebilirliğini `M` olan `protected internal`, Erişilebilirlik etki alanı `M` kesişimi erişilebilirlik etki alanının olduğu `T` program metnini ile `P` ve türetilmiş herhangi bir türde program metin `T` dışında bildirilen `P`.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-264">If the declared accessibility of `M` is `protected internal`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `P` and the program text of any type derived from `T` declared outside `P`.</span></span>  
  
-   <span data-ttu-id="fd2e1-265">Varsa bildirilen erişilebilirliğini `M` olan `protected`, Erişilebilirlik etki alanı `M` kesişimi erişilebilirlik etki alanının olduğu `T` program metnini ile `T` ve türetilmişherhangibirtür`T`.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-265">If the declared accessibility of `M` is `protected`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `T` and any type derived from `T`.</span></span>  
  
-   <span data-ttu-id="fd2e1-266">Varsa bildirilen erişilebilirliğini `M` olan `internal`, Erişilebilirlik etki alanı `M` kesişimi erişilebilirlik etki alanının olduğu `T` program metnini ile `P`.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-266">If the declared accessibility of `M` is `internal`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `P`.</span></span>  
  
-   <span data-ttu-id="fd2e1-267">Varsa bildirilen erişilebilirliğini `M` olan `private`, Erişilebilirlik etki alanı `M` program metni olur `T`.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-267">If the declared accessibility of `M` is `private`, the accessibility domain of `M` is the program text of `T`.</span></span>  
  
### <a name="type-names"></a><span data-ttu-id="fd2e1-268">Tür Adları</span><span class="sxs-lookup"><span data-stu-id="fd2e1-268">Type Names</span></span>  
 <span data-ttu-id="fd2e1-269">Ortak tür sistemi adları yalnızca iki kısıtlamaları getirir:</span><span class="sxs-lookup"><span data-stu-id="fd2e1-269">The common type system imposes only two restrictions on names:</span></span>  
  
-   <span data-ttu-id="fd2e1-270">Tüm adlar Unicode (16-bit) karakter dizeleri olarak kodlanır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-270">All names are encoded as strings of Unicode (16-bit) characters.</span></span>  
  
-   <span data-ttu-id="fd2e1-271">Adları bir katıştırılmış 0x0000 (16-bit) değerine sahip olacak şekilde izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-271">Names are not permitted to have an embedded (16-bit) value of 0x0000.</span></span>  
  
 <span data-ttu-id="fd2e1-272">Bununla birlikte, çoğu dil tür adları ek kısıtlamaları zorunlu tuttukları.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-272">However, most languages impose additional restrictions on type names.</span></span> <span data-ttu-id="fd2e1-273">Tüm karşılaştırmaları bir bayt bayt temelinde gerçekleştirilir ve bu nedenle büyük küçük harfe duyarlı ve yerel ayar bağımsız.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-273">All comparisons are done on a byte-by-byte basis, and are therefore case-sensitive and locale-independent.</span></span>  
  
 <span data-ttu-id="fd2e1-274">Bir tür türleri diğer modüller ve derlemeler başvurabilir karşın, bir .NET modülünde bir türü tam olarak tanımlanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-274">Although a type might reference types from other modules and assemblies, a type must be fully defined within one .NET module.</span></span> <span data-ttu-id="fd2e1-275">(Derleyici desteği bağlı olarak, ancak bu birden çok kaynak kodu dosyasına ayrılabilir.) Tür adları yalnızca ad alanı içinde benzersiz olması.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-275">(Depending on compiler support, however, it can be divided into multiple source code files.) Type names need be unique only within a namespace.</span></span> <span data-ttu-id="fd2e1-276">Tam olarak bir türünü tanımlamak için tür adı, türü uyarlamasını içeren ad tarafından nitelenmiş olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-276">To fully identify a type, the type name must be qualified by the namespace that contains the implementation of the type.</span></span>  
  
### <a name="base-types-and-interfaces"></a><span data-ttu-id="fd2e1-277">Taban türleri ve arabirimleri</span><span class="sxs-lookup"><span data-stu-id="fd2e1-277">Base Types and Interfaces</span></span>  
 <span data-ttu-id="fd2e1-278">Bir tür değerleri ve davranışları başka bir türden devralabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-278">A type can inherit values and behaviors from another type.</span></span> <span data-ttu-id="fd2e1-279">Ortak tür sistemi türleri birden çok taban türünden devralan izin vermiyor.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-279">The common type system does not allow types to inherit from more than one base type.</span></span>  
  
 <span data-ttu-id="fd2e1-280">Bir türü herhangi bir sayıda arabirim uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-280">A type can implement any number of interfaces.</span></span> <span data-ttu-id="fd2e1-281">Bir arabirim için bir tür tüm sanal üyeleri bu arabirimi uygulamalıdır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-281">To implement an interface, a type must implement all the virtual members of that interface.</span></span> <span data-ttu-id="fd2e1-282">Sanal bir yöntem tarafından türetilmiş bir tür uygulanabilir ve statik veya dinamik olarak çağrılır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-282">A virtual method can be implemented by a derived type and can be invoked either statically or dynamically.</span></span>  
  
  
  
<a name="type_members"></a>   
## <a name="type-members"></a><span data-ttu-id="fd2e1-283">Tür üyeleri</span><span class="sxs-lookup"><span data-stu-id="fd2e1-283">Type Members</span></span>  
 <span data-ttu-id="fd2e1-284">Çalışma zamanı davranışı ve bir türünün durumunu belirtir, türün üyeleri tanımlamanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-284">The runtime enables you to define members of your type, which specifies the behavior and state of a type.</span></span> <span data-ttu-id="fd2e1-285">Tür üyeleri şunları içerir:</span><span class="sxs-lookup"><span data-stu-id="fd2e1-285">Type members include the following:</span></span>  
  
-   [<span data-ttu-id="fd2e1-286">Alanlar</span><span class="sxs-lookup"><span data-stu-id="fd2e1-286">Fields</span></span>](#Fields)  
  
-   [<span data-ttu-id="fd2e1-287">Özellikler</span><span class="sxs-lookup"><span data-stu-id="fd2e1-287">Properties</span></span>](#Properties)  
  
-   [<span data-ttu-id="fd2e1-288">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="fd2e1-288">Methods</span></span>](#Methods)  
  
-   [<span data-ttu-id="fd2e1-289">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="fd2e1-289">Constructors</span></span>](#Constructors)  
  
-   [<span data-ttu-id="fd2e1-290">Olaylar</span><span class="sxs-lookup"><span data-stu-id="fd2e1-290">Events</span></span>](#Events)  
  
-   [<span data-ttu-id="fd2e1-291">İç içe geçmiş türler</span><span class="sxs-lookup"><span data-stu-id="fd2e1-291">Nested types</span></span>](#NestedTypes)  
  
<a name="Fields"></a>   
### <a name="fields"></a><span data-ttu-id="fd2e1-292">Alanlar</span><span class="sxs-lookup"><span data-stu-id="fd2e1-292">Fields</span></span>  
 <span data-ttu-id="fd2e1-293">Bir alan açıklar ve tür durumu bölümünü içerir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-293">A field describes and contains part of the type's state.</span></span> <span data-ttu-id="fd2e1-294">Alanlar, çalışma zamanı tarafından desteklenen herhangi bir türde olabilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-294">Fields can be of any type supported by the runtime.</span></span> <span data-ttu-id="fd2e1-295">En yaygın olarak, ya da alanlardır `private` veya `protected`, böylece erişilebilir yalnızca sınıf içinde veya türetilmiş bir sınıf.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-295">Most commonly, fields are either `private` or `protected`, so that they are accessible only from within the class or from a derived class.</span></span> <span data-ttu-id="fd2e1-296">Bir alanın değerini türünü dışında değiştirilebilir, bir özellik set erişimcisi genellikle kullanılır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-296">If the value of a field can be modified from outside its type, a property set accessor is typically used.</span></span> <span data-ttu-id="fd2e1-297">Genel olarak sunulan alanlar genellikle salt okunurdur ve iki türde olabilir:</span><span class="sxs-lookup"><span data-stu-id="fd2e1-297">Publicly exposed fields are usually read-only and can be of two types:</span></span>  
  
-   <span data-ttu-id="fd2e1-298">Sabitler, tasarım zamanında değeri atanır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-298">Constants, whose value is assigned at design time.</span></span> <span data-ttu-id="fd2e1-299">Bu, bir sınıfın statik üyeleri bunlar kullanarak tanımlanmayan ancak `static` (`Shared` Visual Basic'te) anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-299">These are static members of a class, although they are not defined using the `static` (`Shared` in Visual Basic) keyword.</span></span>  
  
-   <span data-ttu-id="fd2e1-300">Değerleri bir sınıf oluşturucu atanabilir salt okunur değişkenler.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-300">Read-only variables, whose values can be assigned in the class constructor.</span></span>  
  
 <span data-ttu-id="fd2e1-301">Aşağıdaki örnek, salt okunur alanlarının iki bu kullanımları gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-301">The following example illustrates these two usages of read-only fields.</span></span>  
  
 [!code-csharp[Conceptual.Types.Members.Fields#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.members.fields/cs/example.cs#1)]
 [!code-vb[Conceptual.Types.Members.Fields#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.members.fields/vb/example.vb#1)]  
  
<a name="Properties"></a>   
### <a name="properties"></a><span data-ttu-id="fd2e1-302">Özellikler</span><span class="sxs-lookup"><span data-stu-id="fd2e1-302">Properties</span></span>  
 <span data-ttu-id="fd2e1-303">Bir özellik adları bir değer veya türünün durumunu ve alma veya özelliğin değeri ayarlamak için yöntemleri tanımlar.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-303">A property names a value or state of the type and defines methods for getting or setting the property's value.</span></span> <span data-ttu-id="fd2e1-304">İlkel türler, basit türler, kullanıcı tanımlı türler veya kullanıcı tanımlı türler koleksiyonlarının özelliklerini olabilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-304">Properties can be primitive types, collections of primitive types, user-defined types, or collections of user-defined types.</span></span> <span data-ttu-id="fd2e1-305">Özellikleri genellikle bir türde ortak arabirimi tür gerçek gösteriminden bağımsız tutmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-305">Properties are often used to keep the public interface of a type independent from the type's actual representation.</span></span> <span data-ttu-id="fd2e1-306">Bu, doğrudan (örneğin, bir özelliğin hesaplanan değeri döndürdüğünde) sınıfında depolanmaz değerleri yansıtacak şekilde veya değerleri için özel alanlar atandığını önce doğrulama gerçekleştirmek için özellikleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-306">This enables properties to reflect values that are not directly stored in the class (for example, when a property returns a computed value) or to perform validation before values are assigned to private fields.</span></span> <span data-ttu-id="fd2e1-307">Aşağıdaki örnek, ikinci düzeni gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-307">The following example illustrates the latter pattern.</span></span>  
  
 [!code-csharp[Conceptual.Types.Members.Properties#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.members.properties/cs/example.cs#1)]
 [!code-vb[Conceptual.Types.Members.Properties#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.members.properties/vb/example.vb#1)]  
  
 <span data-ttu-id="fd2e1-308">Özellik dahil ek olarak, okunabilir bir özellik içeren bir türü için Microsoft Ara dili (MSIL) içeren bir `get_` *propertyname* yöntemi ve bir yazılabilir içeren bir türü için MSIL özelliği içeren bir `set_` *propertyname* yöntemi.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-308">In addition to including the property itself, the Microsoft intermediate language (MSIL) for a type that contains a readable property includes a `get_`*propertyname* method, and the MSIL for a type that contains a writable property includes a `set_`*propertyname* method.</span></span>  
  
<a name="Methods"></a>   
### <a name="methods"></a><span data-ttu-id="fd2e1-309">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="fd2e1-309">Methods</span></span>  
 <span data-ttu-id="fd2e1-310">Yöntemi türüne göre kullanılabilen işlemleri açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-310">A method describes operations that are available on the type.</span></span> <span data-ttu-id="fd2e1-311">Bir yöntemin imzası izin verilen türleri tüm parametreler ve dönüş değerini belirtir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-311">A method's signature specifies the allowable types of all its parameters and of its return value.</span></span>  
  
 <span data-ttu-id="fd2e1-312">Yöntem çağrıları için gerekli parametreleri kesin sayısı çoğu yöntemlerini tanımlama rağmen bazı yöntemler parametreleri değişken sayıda destekler.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-312">Although most methods define the precise number of parameters required for method calls, some methods support a variable number of parameters.</span></span> <span data-ttu-id="fd2e1-313">Bu yöntemlerin parametresi ile işaretlenmiş son bildirilen <xref:System.ParamArrayAttribute> özniteliği.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-313">The final declared parameter of these methods is marked with the <xref:System.ParamArrayAttribute> attribute.</span></span> <span data-ttu-id="fd2e1-314">Dil derleyicileri genellikle sağlayan bir anahtar sözcük gibi `params` C# ve `ParamArray` Visual Basic'te açık kullanımını yapıyorsa <xref:System.ParamArrayAttribute> gereksiz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-314">Language compilers typically provide a keyword, such as `params` in C# and `ParamArray` in Visual Basic, that makes explicit use of <xref:System.ParamArrayAttribute> unnecessary.</span></span>  
  
<a name="Constructors"></a>   
### <a name="constructors"></a><span data-ttu-id="fd2e1-315">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="fd2e1-315">Constructors</span></span>  
 <span data-ttu-id="fd2e1-316">Bir oluşturucusu bir özel bir sınıf veya yapı yeni örneklerini oluşturur yöntemi türüdür.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-316">A constructor is a special kind of method that creates new instances of a class or structure.</span></span> <span data-ttu-id="fd2e1-317">Diğer herhangi bir yöntem gibi bir Oluşturucu parametreleri içerebilir; Ancak, Oluşturucular bir dönüş değerine sahip (diğer bir deyişle, döndürmeleri `void`).</span><span class="sxs-lookup"><span data-stu-id="fd2e1-317">Like any other method, a constructor can include parameters; however, constructors have no return value (that is, they return `void`).</span></span>  
  
 <span data-ttu-id="fd2e1-318">Kaynak kodu bir sınıf için bir oluşturucu açıkça tanımlamıyorsa derleyici varsayılan (parametresiz) Oluşturucusu içerir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-318">If the source code for a class does not explicitly define a constructor, the compiler includes a default (parameterless) constructor.</span></span> <span data-ttu-id="fd2e1-319">Ancak, bir sınıf için kaynak kodunu yalnızca parametreli oluşturucular tanımlıyorsa, Visual Basic ve C# Derleyicileri parametresiz bir kurucusu oluşturmaz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-319">However, if the source code for a class defines only parameterized constructors, the Visual Basic and C# compilers do not generate a parameterless constructor.</span></span>  
  
 <span data-ttu-id="fd2e1-320">Bir yapı için kaynak kodunu oluşturucular tanımlıyorsa, bunlar parametreli gerekir; Varsayılan (parametresiz) Oluşturucusu bir yapı tanımlayamazsınız ve derleyicileri yapıları veya diğer değer türleri için parametresiz oluşturucular oluşturmaz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-320">If the source code for a structure defines constructors, they must be parameterized; a structure cannot define a default (parameterless) constructor, and compilers do not generate parameterless constructors for structures or other value types.</span></span> <span data-ttu-id="fd2e1-321">Tüm değer türleri bir örtük varsayılan oluşturucusu olmalı.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-321">All value types do have an implicit default constructor.</span></span> <span data-ttu-id="fd2e1-322">Bu oluşturucu ortak dil çalışma zamanı tarafından uygulanır ve tüm alanları varsayılan değerlerine yapısının başlatır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-322">This constructor is implemented by the common language runtime and initializes all fields of the structure to their default values.</span></span>  
  
<a name="Events"></a>   
### <a name="events"></a><span data-ttu-id="fd2e1-323">Olaylar</span><span class="sxs-lookup"><span data-stu-id="fd2e1-323">Events</span></span>  
 <span data-ttu-id="fd2e1-324">Bir olay için yanıt bir olay tanımlar ve olayı tetiklenmeden abone olma ve aboneliği sonlandırma için yöntemleri tanımlar.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-324">An event defines an incident that can be responded to, and defines methods for subscribing to, unsubscribing from, and raising the event.</span></span> <span data-ttu-id="fd2e1-325">Olaylar, genellikle diğer türleri durum değişiklikleri bildirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-325">Events are often used to inform other types of state changes.</span></span> <span data-ttu-id="fd2e1-326">Daha fazla bilgi için bkz: [olayları](../../../docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="fd2e1-326">For more information, see [Events](../../../docs/standard/events/index.md).</span></span>  
  
<a name="NestedTypes"></a>   
### <a name="nested-types"></a><span data-ttu-id="fd2e1-327">İç içe Geçmiş Türler</span><span class="sxs-lookup"><span data-stu-id="fd2e1-327">Nested Types</span></span>  
 <span data-ttu-id="fd2e1-328">Diğer bir türünün bir üyesi olan bir türü bir iç içe geçmiş türüdür.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-328">A nested type is a type that is a member of some other type.</span></span> <span data-ttu-id="fd2e1-329">İç içe geçmiş türler içeren tipine sıkı şekilde bağlı ve genel amaçlı bir tür olarak yararlı olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-329">Nested types should be tightly coupled to their containing type and must not be useful as a general-purpose type.</span></span> <span data-ttu-id="fd2e1-330">İç içe geçmiş türler bildiri türü kullanır ve iç içe geçmiş tür örneklerini oluşturur ve iç içe geçmiş tür kullanımı genel üyeler gösterilmeyen olduğunda yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-330">Nested types are useful when the declaring type uses and creates instances of the nested type, and use of the nested type is not exposed in public members.</span></span>  
  
 <span data-ttu-id="fd2e1-331">İç içe geçmiş türler için bazı geliştiriciler karmaşıktır ve görünürlük ilgi çekici bir nedeni olmadıkça herkese görünür olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-331">Nested types are confusing to some developers and should not be publicly visible unless there is a compelling reason for visibility.</span></span> <span data-ttu-id="fd2e1-332">İyi tasarlanmış bir kitaplıkta geliştiriciler nadiren nesneleri örneği veya değişkenleri bildirmek için iç içe geçmiş türler kullanmaya olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-332">In a well-designed library, developers should rarely have to use nested types to instantiate objects or declare variables.</span></span>  
  
  
  
<a name="characteristics_of_type_members"></a>   
## <a name="characteristics-of-type-members"></a><span data-ttu-id="fd2e1-333">Tür üyeleri özellikleri</span><span class="sxs-lookup"><span data-stu-id="fd2e1-333">Characteristics of Type Members</span></span>  
 <span data-ttu-id="fd2e1-334">Ortak tür sistemi türü üyelerinin çeşitli özelliklere sahip olanak tanır; Ancak, bu özellikleri desteklemek için dilleri gerekmez.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-334">The common type system allows type members to have a variety of characteristics; however, languages are not required to support all these characteristics.</span></span> <span data-ttu-id="fd2e1-335">Aşağıdaki tabloda üye özelliklerini açıklar.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-335">The following table describes member characteristics.</span></span>  
  
|<span data-ttu-id="fd2e1-336">Özelliği</span><span class="sxs-lookup"><span data-stu-id="fd2e1-336">Characteristic</span></span>|<span data-ttu-id="fd2e1-337">İçin geçerli olabilir</span><span class="sxs-lookup"><span data-stu-id="fd2e1-337">Can apply to</span></span>|<span data-ttu-id="fd2e1-338">Açıklama</span><span class="sxs-lookup"><span data-stu-id="fd2e1-338">Description</span></span>|  
|--------------------|------------------|-----------------|  
|<span data-ttu-id="fd2e1-339">abstract</span><span class="sxs-lookup"><span data-stu-id="fd2e1-339">abstract</span></span>|<span data-ttu-id="fd2e1-340">Yöntemler, özellikler ve olaylar</span><span class="sxs-lookup"><span data-stu-id="fd2e1-340">Methods, properties, and events</span></span>|<span data-ttu-id="fd2e1-341">Türü yöntemin uygulaması sağlamaz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-341">The type does not supply the method's implementation.</span></span> <span data-ttu-id="fd2e1-342">Devralmalı ya da soyut yöntemler uygulama türlerini yöntemi için uygulama sağlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-342">Types that inherit or implement abstract methods must supply an implementation for the method.</span></span> <span data-ttu-id="fd2e1-343">Türetilmiş bir tür kendisini soyut bir tür olduğunda tek özel durumdur.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-343">The only exception is when the derived type is itself an abstract type.</span></span> <span data-ttu-id="fd2e1-344">Tüm soyut yöntemler sanal.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-344">All abstract methods are virtual.</span></span>|  
|<span data-ttu-id="fd2e1-345">özel, aile, derleme, ailesi ve derleme, Aile veya derleme ya da ortak</span><span class="sxs-lookup"><span data-stu-id="fd2e1-345">private, family, assembly, family and assembly, family or assembly, or public</span></span>|<span data-ttu-id="fd2e1-346">Tümü</span><span class="sxs-lookup"><span data-stu-id="fd2e1-346">All</span></span>|<span data-ttu-id="fd2e1-347">Üye erişilebilirliğini tanımlar:</span><span class="sxs-lookup"><span data-stu-id="fd2e1-347">Defines the accessibility of the member:</span></span><br /><br /> <span data-ttu-id="fd2e1-348">private</span><span class="sxs-lookup"><span data-stu-id="fd2e1-348">private</span></span><br /> <span data-ttu-id="fd2e1-349">Erişilebilir yalnızca iç içe geçmiş tür veya üye aynı türde içinde.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-349">Accessible only from within the same type as the member, or within a nested type.</span></span><br /><br /> <span data-ttu-id="fd2e1-350">Ailesi</span><span class="sxs-lookup"><span data-stu-id="fd2e1-350">family</span></span><br /> <span data-ttu-id="fd2e1-351">İçinden erişilebilir aynı üye olarak ve ondan devralır türetilen türlerin yazın.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-351">Accessible from within the same type as the member, and from derived types that inherit from it.</span></span><br /><br /> <span data-ttu-id="fd2e1-352">derleme</span><span class="sxs-lookup"><span data-stu-id="fd2e1-352">assembly</span></span><br /> <span data-ttu-id="fd2e1-353">Yalnızca türünün tanımlandığı derleme erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-353">Accessible only in the assembly in which the type is defined.</span></span><br /><br /> <span data-ttu-id="fd2e1-354">Aile ve derleme</span><span class="sxs-lookup"><span data-stu-id="fd2e1-354">family and assembly</span></span><br /> <span data-ttu-id="fd2e1-355">Uygun türlerinden erişilebilir ailesi ve derleme erişim.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-355">Accessible only from types that qualify for both family and assembly access.</span></span><br /><br /> <span data-ttu-id="fd2e1-356">Aile veya derleme</span><span class="sxs-lookup"><span data-stu-id="fd2e1-356">family or assembly</span></span><br /> <span data-ttu-id="fd2e1-357">Uygun türlerinden erişilebilir ailesi veya derleme erişim.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-357">Accessible only from types that qualify for either family or assembly access.</span></span><br /><br /> <span data-ttu-id="fd2e1-358">public</span><span class="sxs-lookup"><span data-stu-id="fd2e1-358">public</span></span><br /> <span data-ttu-id="fd2e1-359">Her tür erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-359">Accessible from any type.</span></span>|  
|<span data-ttu-id="fd2e1-360">son</span><span class="sxs-lookup"><span data-stu-id="fd2e1-360">final</span></span>|<span data-ttu-id="fd2e1-361">Yöntemler, özellikler ve olaylar</span><span class="sxs-lookup"><span data-stu-id="fd2e1-361">Methods, properties, and events</span></span>|<span data-ttu-id="fd2e1-362">Sanal bir yöntem, türetilen türde de değiştirilemiyor.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-362">The virtual method cannot be overridden in a derived type.</span></span>|  
|<span data-ttu-id="fd2e1-363">yalnızca başlatma</span><span class="sxs-lookup"><span data-stu-id="fd2e1-363">initialize-only</span></span>|<span data-ttu-id="fd2e1-364">Alanlar</span><span class="sxs-lookup"><span data-stu-id="fd2e1-364">Fields</span></span>|<span data-ttu-id="fd2e1-365">Değer yalnızca başlatılabilir ve sonra başlatma yazılamaz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-365">The value can only be initialized, and cannot be written after initialization.</span></span>|  
|<span data-ttu-id="fd2e1-366">örnek</span><span class="sxs-lookup"><span data-stu-id="fd2e1-366">instance</span></span>|<span data-ttu-id="fd2e1-367">Alanlar, yöntemleri, özellikleri ve olayları</span><span class="sxs-lookup"><span data-stu-id="fd2e1-367">Fields, methods, properties, and events</span></span>|<span data-ttu-id="fd2e1-368">Bir üye olarak işaretlenmemiş olması `static` (C# ve C++) `Shared` (Visual Basic) `virtual` (C# ve C++) veya `Overridable` (Visual Basic) (örnek anahtar sözcük yoktur) örnek üyesine değil.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-368">If a member is not marked as `static` (C# and C++), `Shared` (Visual Basic), `virtual` (C# and C++), or `Overridable` (Visual Basic), it is an instance member (there is no instance keyword).</span></span> <span data-ttu-id="fd2e1-369">Bu tür üyeler bellekte kullanmak nesneleri olarak kadar kopyasını olacaktır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-369">There will be as many copies of such members in memory as there are objects that use it.</span></span>|  
|<span data-ttu-id="fd2e1-370">değişmez değer</span><span class="sxs-lookup"><span data-stu-id="fd2e1-370">literal</span></span>|<span data-ttu-id="fd2e1-371">Alanlar</span><span class="sxs-lookup"><span data-stu-id="fd2e1-371">Fields</span></span>|<span data-ttu-id="fd2e1-372">Alanına atanan değer yerleşik değer türü derleme zamanında bilinen sabit bir değerdir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-372">The value assigned to the field is a fixed value, known at compile time, of a built-in value type.</span></span> <span data-ttu-id="fd2e1-373">Değişmez değer alanları sabitleri da adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-373">Literal fields are sometimes referred to as constants.</span></span>|  
|<span data-ttu-id="fd2e1-374">NewSlot veya geçersiz kılma</span><span class="sxs-lookup"><span data-stu-id="fd2e1-374">newslot or override</span></span>|<span data-ttu-id="fd2e1-375">Tümü</span><span class="sxs-lookup"><span data-stu-id="fd2e1-375">All</span></span>|<span data-ttu-id="fd2e1-376">Üye aynı imzaya sahip devralınan üyeleri ile nasıl etkileşim kurduğu tanımlar:</span><span class="sxs-lookup"><span data-stu-id="fd2e1-376">Defines how the member interacts with inherited members that have the same signature:</span></span><br /><br /> <span data-ttu-id="fd2e1-377">NewSlot</span><span class="sxs-lookup"><span data-stu-id="fd2e1-377">newslot</span></span><br /> <span data-ttu-id="fd2e1-378">Devralınan aynı imzaya sahip üyeleri gizler.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-378">Hides inherited members that have the same signature.</span></span><br /><br /> <span data-ttu-id="fd2e1-379">override</span><span class="sxs-lookup"><span data-stu-id="fd2e1-379">override</span></span><br /> <span data-ttu-id="fd2e1-380">Devralınan sanal bir yöntem tanımının yerini alır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-380">Replaces the definition of an inherited virtual method.</span></span><br /><br /> <span data-ttu-id="fd2e1-381">Newslot varsayılandır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-381">The default is newslot.</span></span>|  
|<span data-ttu-id="fd2e1-382">static</span><span class="sxs-lookup"><span data-stu-id="fd2e1-382">static</span></span>|<span data-ttu-id="fd2e1-383">Alanlar, yöntemleri, özellikleri ve olayları</span><span class="sxs-lookup"><span data-stu-id="fd2e1-383">Fields, methods, properties, and events</span></span>|<span data-ttu-id="fd2e1-384">Üye türünde değil belirli bir örneği için tanımlandıktan türüne ait; üye türünün bir örneği oluşturulmaz ve türünün tüm örneklerini arasında paylaşılan olsa bile bulunmaktadır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-384">The member belongs to the type it is defined on, not to a particular instance of the type; the member exists even if an instance of the type is not created, and it is shared among all instances of the type.</span></span>|  
|<span data-ttu-id="fd2e1-385">virtual</span><span class="sxs-lookup"><span data-stu-id="fd2e1-385">virtual</span></span>|<span data-ttu-id="fd2e1-386">Yöntemler, özellikler ve olaylar</span><span class="sxs-lookup"><span data-stu-id="fd2e1-386">Methods, properties, and events</span></span>|<span data-ttu-id="fd2e1-387">Bu yöntem tarafından türetilmiş bir tür uygulanabilir ve statik veya dinamik olarak çağrılır.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-387">The method can be implemented by a derived type and can be invoked either statically or dynamically.</span></span> <span data-ttu-id="fd2e1-388">Dinamik çağırma kullanılırsa, hangi yöntemin kullanımı adlı çalışma zamanında çağrı yapar örneğin türünü (derleme zamanında bilinen türü yerine) belirler.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-388">If dynamic invocation is used, the type of the instance that makes the call at run time (rather than the type known at compile time) determines which implementation of the method is called.</span></span> <span data-ttu-id="fd2e1-389">Sanal bir yöntem statik olarak çağırmak için değişkenin yöntemi istenen sürümünü kullanan bir türe gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-389">To invoke a virtual method statically, the variable might have to be cast to a type that uses the desired version of the method.</span></span>|  
  
### <a name="overloading"></a><span data-ttu-id="fd2e1-390">Aşırı Yükleme</span><span class="sxs-lookup"><span data-stu-id="fd2e1-390">Overloading</span></span>  
 <span data-ttu-id="fd2e1-391">Her tür üyesi benzersiz bir imza içeriyor.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-391">Each type member has a unique signature.</span></span> <span data-ttu-id="fd2e1-392">Yöntem imzaları yöntem adı ve parametre listesi (sırası ve yöntemin bağımsız değişken türleri) oluşur.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-392">Method signatures consist of the method name and a parameter list (the order and types of the method's arguments).</span></span> <span data-ttu-id="fd2e1-393">Kendi imzaları farklı olduğu sürece, aynı ada sahip birden çok yöntem içinde bir tür tanımlanabilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-393">Multiple methods with the same name can be defined within a type as long as their signatures differ.</span></span> <span data-ttu-id="fd2e1-394">Aynı ada sahip iki veya daha fazla yöntem tanımlandığında, yöntemi aşırı yüklenmiş kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-394">When two or more methods with the same name are defined, the method is said to be overloaded.</span></span> <span data-ttu-id="fd2e1-395">Örneğin, <xref:System.Char?displayProperty=nameWithType>, <xref:System.Char.IsDigit%2A> yöntemi aşırı yüklü.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-395">For example, in <xref:System.Char?displayProperty=nameWithType>, the <xref:System.Char.IsDigit%2A> method is overloaded.</span></span> <span data-ttu-id="fd2e1-396">Bir yöntemi alır bir <xref:System.Char>.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-396">One method takes a <xref:System.Char>.</span></span> <span data-ttu-id="fd2e1-397">Başka bir yöntem geçen bir <xref:System.String> ve bir <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-397">The other method takes a <xref:System.String> and an <xref:System.Int32>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="fd2e1-398">Dönüş türü bir yöntemin imzası parçası dikkate alınmaz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-398">The return type is not considered part of a method's signature.</span></span> <span data-ttu-id="fd2e1-399">Diğer bir deyişle, bunlar yalnızca dönüş türüne göre farklıysa yöntemlerini aşırı yüklenemez.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-399">That is, methods cannot be overloaded if they differ only by return type.</span></span>  
  
### <a name="inheriting-overriding-and-hiding-members"></a><span data-ttu-id="fd2e1-400">Devralma özelliği, geçersiz kılma ve üyeleri gizleme</span><span class="sxs-lookup"><span data-stu-id="fd2e1-400">Inheriting, Overriding, and Hiding Members</span></span>  
 <span data-ttu-id="fd2e1-401">Türetilmiş bir tür, temel türdeki tüm üyelerin devralır; diğer bir deyişle, bu üyeler üzerinde tanımlı ve türetilmiş bir tür için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-401">A derived type inherits all members of its base type; that is, these members are defined on, and available to, the derived type.</span></span> <span data-ttu-id="fd2e1-402">Devralınan üyeleri niteliklerini ve davranış iki yolla değiştirilebilir:</span><span class="sxs-lookup"><span data-stu-id="fd2e1-402">The behavior or qualities of inherited members can be modified in two ways:</span></span>  
  
-   <span data-ttu-id="fd2e1-403">Türetilmiş bir tür aynı imzaya sahip yeni bir üye tanımlayarak devralınmış bir üyeyi gizleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-403">A derived type can hide an inherited member by defining a new member with the same signature.</span></span> <span data-ttu-id="fd2e1-404">Bu önceden ortak üyesi özel yapmak veya olarak işaretlenmiş bir devralınan yöntemi yeni davranışını tanımlamak için yapılabilir `final`.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-404">This might be done to make a previously public member private or to define new behavior for an inherited method that is marked as `final`.</span></span>  
  
-   <span data-ttu-id="fd2e1-405">Türetilmiş bir tür devralınan sanal bir yöntem geçersiz kılabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-405">A derived type can override an inherited virtual method.</span></span> <span data-ttu-id="fd2e1-406">Geçersiz kılma yöntemi yeni bir derleme zamanında bilinen değişkeninin türü yerine çalışma zamanında değer türüne göre çağrılacak yöntem tanımını sağlar.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-406">The overriding method provides a new definition of the method that will be invoked based on the type of the value at run time rather than the type of the variable known at compile time.</span></span> <span data-ttu-id="fd2e1-407">Yalnızca sanal yöntemi olarak işaretlenmişse bir yöntem sanal bir yöntem kılabilirsiniz `final` ve yeni yöntemi en az sanal yöntemi olarak erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-407">A method can override a virtual method only if the virtual method is not marked as `final` and the new method is at least as accessible as the virtual method.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="fd2e1-408">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="fd2e1-408">See Also</span></span>  
 [<span data-ttu-id="fd2e1-409">.NET API tarayıcı</span><span class="sxs-lookup"><span data-stu-id="fd2e1-409">.NET API Browser</span></span>](/dotnet/api)  
 [<span data-ttu-id="fd2e1-410">Ortak dil çalışma zamanı</span><span class="sxs-lookup"><span data-stu-id="fd2e1-410">Common Language Runtime</span></span>](../../../docs/standard/clr.md)  
 [<span data-ttu-id="fd2e1-411">.NET içinde Tür Dönüştürme</span><span class="sxs-lookup"><span data-stu-id="fd2e1-411">Type Conversion in .NET</span></span>](../../../docs/standard/base-types/type-conversion.md)

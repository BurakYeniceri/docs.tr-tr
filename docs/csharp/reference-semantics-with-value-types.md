---
title: "Başvuru semantiği ile değer türleri"
description: "Kopyalama yapıları güvenle en aza dil özellikleri anlama"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 0c6e44a3e1a1458f4211b66b6d1ef5b4b30cd7c1
ms.sourcegitcommit: 5177d6ae2e9baf026f07ee0631556700a5a193f7
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/28/2017
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="27d46-103">Başvuru semantiği ile değer türleri</span><span class="sxs-lookup"><span data-stu-id="27d46-103">Reference semantics with value types</span></span>

<span data-ttu-id="27d46-104">Değer türleri kullanmanın bir avantajı, bunlar genellikle yığın ayırmaları kaçının ' dir.</span><span class="sxs-lookup"><span data-stu-id="27d46-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="27d46-105">Karşılık gelen dezavantajı, değeriyle kopyalanırlar ' dir.</span><span class="sxs-lookup"><span data-stu-id="27d46-105">The corresponding disadvantage is that they are copied by value.</span></span> <span data-ttu-id="27d46-106">Bu kolaylığını büyük miktarlarda verinin çalışması algoritmaları iyileştirmek daha zor hale getirir.</span><span class="sxs-lookup"><span data-stu-id="27d46-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="27d46-107">C# 7.2 içindeki yeni dil özellikleri pass-by-reference semantiği değer türleri ile etkinleştirmek mekanizmaları sağlar.</span><span class="sxs-lookup"><span data-stu-id="27d46-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="27d46-108">Bu özellikler akıllıca kullanırsanız, her iki ayırma en aza indirmek ve işlemleri kopyalayın.</span><span class="sxs-lookup"><span data-stu-id="27d46-108">If you use these features wisely you can minimize both allocations and copy operations.</span></span> <span data-ttu-id="27d46-109">Bu makalede, bu yeni özellikleri açıklar.</span><span class="sxs-lookup"><span data-stu-id="27d46-109">This article explores those new features.</span></span>

<span data-ttu-id="27d46-110">Bu makaledeki örnek kod çoğunu C# 7.2 eklenen özellikler gösterir.</span><span class="sxs-lookup"><span data-stu-id="27d46-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="27d46-111">Bu özellikleri kullanmak için projenizin C# 7,2 veya üzeri projenizde kullanacak şekilde yapılandırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="27d46-111">In order to use those features, you have to configure your project to use C# 7.2 or later in your project.</span></span> <span data-ttu-id="27d46-112">Visual Studio seçmek için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="27d46-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="27d46-113">Her proje için seçin **proje** menüsünde, ardından **özellikleri**.</span><span class="sxs-lookup"><span data-stu-id="27d46-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="27d46-114">Seçin **yapı** sekmesinde **Gelişmiş**.</span><span class="sxs-lookup"><span data-stu-id="27d46-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="27d46-115">Buradan, dil sürümü yapılandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="27d46-115">From there, you can configure the language version.</span></span> <span data-ttu-id="27d46-116">"7.2" veya "en son" seçin.</span><span class="sxs-lookup"><span data-stu-id="27d46-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="27d46-117">Veya düzenleyebilirsiniz *csproj* dosya ve aşağıdaki düğüm ekleyin:</span><span class="sxs-lookup"><span data-stu-id="27d46-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="27d46-118">"7,2" veya "en son" değerini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="27d46-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="specifying-in-parameters"></a><span data-ttu-id="27d46-119">Belirtme `in` parametreleri</span><span class="sxs-lookup"><span data-stu-id="27d46-119">Specifying `in` parameters</span></span>

<span data-ttu-id="27d46-120">C# 7.2 ekler `in` varolan tamamlamak üzere anahtar sözcük `ref` ve `out` bağımsız değişkenleri başvuruya göre geçirir bir yöntem yazdığınızda anahtar sözcükler.</span><span class="sxs-lookup"><span data-stu-id="27d46-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords when you write a method that passes arguments by reference.</span></span> <span data-ttu-id="27d46-121">`in` Anahtar sözcüğü parametresi başvuruya göre geçirme ve çağrılan yöntem kendisine geçirilen değer değiştirmez belirtir.</span><span class="sxs-lookup"><span data-stu-id="27d46-121">The `in` keyword specifies that you are passing the parameter by reference and the called method does not modify the value passed to it.</span></span> 

<span data-ttu-id="27d46-122">Bu ek tasarım hedefi ifade etmek için tam bir sözlüğünü sağlar.</span><span class="sxs-lookup"><span data-stu-id="27d46-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="27d46-123">Değer türleri aşağıdaki değiştiricileri hiçbirini belirtmeyin olduğunda çağrılan yönteme geçirildiğinde kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="27d46-123">Value types are copied when passed to a called method when you do not specify any of the following modifiers.</span></span> <span data-ttu-id="27d46-124">Bu değiştiricileri her bir değer türü başvurusu tarafından kopya önleme geçirilen belirtin.</span><span class="sxs-lookup"><span data-stu-id="27d46-124">Each of these modifiers specify that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="27d46-125">Her değiştiricisi farklı bir hedefi ifade eder:</span><span class="sxs-lookup"><span data-stu-id="27d46-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="27d46-126">`out`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkeninin değerini ayarlar.</span><span class="sxs-lookup"><span data-stu-id="27d46-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="27d46-127">`ref`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkeninin değeri ayarlayabilir.</span><span class="sxs-lookup"><span data-stu-id="27d46-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="27d46-128">`in`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkeninin değeri değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="27d46-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="27d46-129">Eklediğinizde `in` değiştiricisi başvuruya göre bağımsız değişken geçirmek için tasarım hedefi olan gereksiz kopyalama önlemek için başvuruya göre bağımsız değişken geçirmek için bildirin.</span><span class="sxs-lookup"><span data-stu-id="27d46-129">When you add the `in` modifier to pass an argument by reference, you declare your design intent is to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="27d46-130">Bu bağımsız değişken olarak kullanılan nesne değiştirmek istiyorsanız değil.</span><span class="sxs-lookup"><span data-stu-id="27d46-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="27d46-131">Aşağıdaki kod örneği 3B uzaydaki iki nokta arasındaki uzaklığı hesaplar bir yöntemin gösterir.</span><span class="sxs-lookup"><span data-stu-id="27d46-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="27d46-132">Her üç çiftleri içeren iki yapıları bağımsız değişkenler.</span><span class="sxs-lookup"><span data-stu-id="27d46-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="27d46-133">Bir çift 8 bayt olduğundan, her bir bağımsız değişkeni 24 bayttır.</span><span class="sxs-lookup"><span data-stu-id="27d46-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="27d46-134">Belirterek `in` değiştiricisi, geçirdiğiniz bu bağımsız değişkenlerden 4-bayt veya 8-bayt başvuru makine mimarisi bağlı olarak.</span><span class="sxs-lookup"><span data-stu-id="27d46-134">By specifying the `in` modifier, you pass 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="27d46-135">Boyutu fark küçüktür, ancak uygulamanız bu yöntem birçok farklı değerleri kullanarak sıkı bir döngüde çağırdığında, hızlı bir şekilde ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="27d46-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="27d46-136">`in` Değiştiricisi hazırlandı `out` ve `ref` başka yöntemler de.</span><span class="sxs-lookup"><span data-stu-id="27d46-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="27d46-137">Yalnızca içinde varken, farklı bir yöntem aşırı oluşturulamıyor `in`, `out` veya `ref`.</span><span class="sxs-lookup"><span data-stu-id="27d46-137">You cannot create overloads of a method that differ only in the presence of `in`, `out` or `ref`.</span></span> <span data-ttu-id="27d46-138">Bu yeni kurallar her zaman için tanımlanmış aynı davranışı genişletmek `out` ve `ref` parametreleri.</span><span class="sxs-lookup"><span data-stu-id="27d46-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="27d46-139">`in` Değiştiricisi parametreler isteyen herhangi bir üyesi için uygulanan: yöntemler, temsilciler, Lambda'lar, yerel İşlevler, dizin oluşturucular, işleçler.</span><span class="sxs-lookup"><span data-stu-id="27d46-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="27d46-140">Farklı `ref` ve `out` bağımsız değişken kullandığınız değişmez değerler veya sabitleri bağımsız değişkeni için bir `in` parametresi.</span><span class="sxs-lookup"><span data-stu-id="27d46-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="27d46-141">Ayrıca, farklı bir `ref` veya `out` parametre, geçerli gerekmeyen `in` çağrısı sitede değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="27d46-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="27d46-142">Aşağıdaki kod iki örnek çağırma gösterir `CalculateDistance` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="27d46-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="27d46-143">İlk iki yerel değişkenleri başvuruya göre geçirilen kullanır.</span><span class="sxs-lookup"><span data-stu-id="27d46-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="27d46-144">İkinci yöntem çağrısının bir parçası olarak oluşturulan geçici bir değişken içerir.</span><span class="sxs-lookup"><span data-stu-id="27d46-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="27d46-145">İçinde derleyici sağlar, salt okunur yapısına birkaç yolu vardır bir `in` bağımsız değişkeni zorlanır.</span><span class="sxs-lookup"><span data-stu-id="27d46-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="27d46-146">Öncelikle, çağrılan yöntemin doğrudan atayamazsınız bir `in` parametresi.</span><span class="sxs-lookup"><span data-stu-id="27d46-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="27d46-147">Herhangi bir alan için doğrudan atayamazsınız bir `in` parametresi.</span><span class="sxs-lookup"><span data-stu-id="27d46-147">It can't directly assign to any field of an `in` parameter.</span></span> <span data-ttu-id="27d46-148">Ayrıca, geçiremezsiniz bir `in` yöntemi yoğun parametresini `ref` veya `out` değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="27d46-148">In addition, you cannot pass an `in` parameter to any method demanding the `ref` or `out` modifier.</span></span>
<span data-ttu-id="27d46-149">Derleyici zorlar `in` olmayan bir salt okunur değişken bağımsız değişken.</span><span class="sxs-lookup"><span data-stu-id="27d46-149">The compiler enforces that the `in` argument is a readonly variable.</span></span> <span data-ttu-id="27d46-150">Geçişi değerli semantiği kullanan herhangi bir örnek yöntemini çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="27d46-150">You can call any instance method that uses pass-by-value semantics.</span></span> <span data-ttu-id="27d46-151">Bu durumlarda, bir kopyasını `in` parametresi oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="27d46-151">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="27d46-152">Derleyici herhangi için geçici bir değişken oluşturmak için `in` parametresi, ayrıca varsayılan değerleri için belirtebilirsiniz `in` parametresi.</span><span class="sxs-lookup"><span data-stu-id="27d46-152">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="27d46-153">İzleme kodu, ikinci noktası için varsayılan değer olarak kaynak (noktası 0,0) belirlemek için kullanır:</span><span class="sxs-lookup"><span data-stu-id="27d46-153">The follow code uses that to specify the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="27d46-154">`in` Parametresi atamasını Ayrıca başvuru türleriyle kullanılan veya sayısal değerleri oluşturulmuş.</span><span class="sxs-lookup"><span data-stu-id="27d46-154">The `in` parameter designation can also be used with reference types or built in numeric values.</span></span> <span data-ttu-id="27d46-155">Bununla birlikte, her iki durumda da avantajları en az, varsa.</span><span class="sxs-lookup"><span data-stu-id="27d46-155">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="27d46-156">`ref readonly`döndürür</span><span class="sxs-lookup"><span data-stu-id="27d46-156">`ref readonly` returns</span></span>

<span data-ttu-id="27d46-157">Başvuruya göre dönüş değeri türü, ancak bu değeri değiştirmeden gelen arayan engellemek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="27d46-157">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="27d46-158">Kullanım `ref readonly` bu tasarım hedefi express değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="27d46-158">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="27d46-159">Okuyucular, var olan verilere bir başvuru döndürüyor, ancak değişiklik sağlanmıyor olduğunu bildirir.</span><span class="sxs-lookup"><span data-stu-id="27d46-159">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="27d46-160">Derleyici çağıran başvurusu değiştirilemez zorlar.</span><span class="sxs-lookup"><span data-stu-id="27d46-160">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="27d46-161">Deneme değerine doğrudan atamak için bir derleme zamanı hatası oluşturur.</span><span class="sxs-lookup"><span data-stu-id="27d46-161">Attempts to assign to the value directly generate a compile-time error.</span></span> <span data-ttu-id="27d46-162">Ancak, derleyici herhangi bir üye yöntemini yapısı durumunu değiştirir olmadığını bilemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="27d46-162">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="27d46-163">Nesne değiştirilmeyen emin olmak için derleyici bir kopyasını oluşturur ve bu kopyayı kullanarak başvurular üye çağırır.</span><span class="sxs-lookup"><span data-stu-id="27d46-163">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="27d46-164">Herhangi bir değişiklik savunma bu kopyaya ' dir.</span><span class="sxs-lookup"><span data-stu-id="27d46-164">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="27d46-165">Büyük olasılıkla, kitaplığını kullanarak `Point3D` genellikle kaynak kod genelindeki kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="27d46-165">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="27d46-166">Her örneği yığında yeni bir nesne oluşturur.</span><span class="sxs-lookup"><span data-stu-id="27d46-166">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="27d46-167">Bir sabit oluşturup başvuruya göre dönmek için yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="27d46-167">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="27d46-168">Ancak, iç depolama başvuru döndürürse, çağıran başvurulan depolama değiştirilemiyor zorlamak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="27d46-168">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="27d46-169">Aşağıdaki kod döndüren bir salt okunur özelliği tanımlayan bir `readonly ref` için bir `Point3D` kaynağını belirtir.</span><span class="sxs-lookup"><span data-stu-id="27d46-169">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="27d46-170">Ref salt okunur bir kopyasını dönüş oluşturmak kolaydır: yalnızca ile bildirilmemiş bir değişkene atayın `ref readonly` değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="27d46-170">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="27d46-171">Derleyici nesneyi atama bir parçası olarak kopyalamak için kod oluşturur.</span><span class="sxs-lookup"><span data-stu-id="27d46-171">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="27d46-172">Bir değişkene atadığınızda bir `ref readonly return`, ya da belirtebilirsiniz bir `ref readonly` değişkeni veya salt okunur başvuru değeri tarafından kopyasını:</span><span class="sxs-lookup"><span data-stu-id="27d46-172">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the readonly reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="27d46-173">İlk atama önceki kodda bir kopyasını oluşturur `Origin` sabiti ve kopyalama atar.</span><span class="sxs-lookup"><span data-stu-id="27d46-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="27d46-174">İkinci bir başvuru atar.</span><span class="sxs-lookup"><span data-stu-id="27d46-174">The second assigns a reference.</span></span> <span data-ttu-id="27d46-175">Dikkat `readonly` değiştiricisi değişken bildirimi parçası olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="27d46-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="27d46-176">Başvurduğu başvurusu değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="27d46-176">The reference to which it refers cannot be modified.</span></span> <span data-ttu-id="27d46-177">Bunu yapmak için deneme, bir derleme zamanı hatasına neden.</span><span class="sxs-lookup"><span data-stu-id="27d46-177">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="27d46-178">`readonly struct`türü</span><span class="sxs-lookup"><span data-stu-id="27d46-178">`readonly struct` type</span></span>

<span data-ttu-id="27d46-179">Uygulama `ref readonly` yapı yüksek trafik kullanımlar için yeterli olabilir.</span><span class="sxs-lookup"><span data-stu-id="27d46-179">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="27d46-180">Diğer durumlarda, sabit bir yapı oluşturmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="27d46-180">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="27d46-181">Ardından readonly başvuruya göre geçirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="27d46-181">Then you can always pass by readonly reference.</span></span> <span data-ttu-id="27d46-182">Alıştırma savunma kaldırır meydana yöntemleri olarak kullanılan bir yapı eriştiğinizde kopyalar bir `in` parametresi.</span><span class="sxs-lookup"><span data-stu-id="27d46-182">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="27d46-183">Bunu oluşturarak yapabilirsiniz bir `readonly struct` türü.</span><span class="sxs-lookup"><span data-stu-id="27d46-183">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="27d46-184">Ekleyebileceğiniz `readonly` yapısı bildirimine değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="27d46-184">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="27d46-185">Tüm örnek yapı üyesi olmalarını derleyici zorlar `readonly`; `struct` sabit olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="27d46-185">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="27d46-186">Diğer en iyi duruma getirme vardır bir `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="27d46-186">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="27d46-187">Kullanabileceğiniz `in` her konumda değiştiricisi burada bir `readonly struct` bir bağımsız değişken.</span><span class="sxs-lookup"><span data-stu-id="27d46-187">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="27d46-188">Ayrıca, döndürebilir bir `readonly struct` olarak bir `ref return` zaman iade nesneyi, yaşam süresi genişletir nesnesi döndüren yöntemi kapsamı dışındadır.</span><span class="sxs-lookup"><span data-stu-id="27d46-188">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="27d46-189">Son olarak, üyeleri çağırdığınızda derleyici daha verimli kodunu oluşturur bir `readonly struct`: `this` alıcı kopyasını yerine başvurusunun olduğundan her zaman bir `in` parametresine geçirilen üye yöntemi başvuru.</span><span class="sxs-lookup"><span data-stu-id="27d46-189">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="27d46-190">Bu iyileştirme kullanırken daha fazla kopyalama kaydeder bir `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="27d46-190">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="27d46-191">`Point3D` Bu değişikliği mükemmel bir adaydır.</span><span class="sxs-lookup"><span data-stu-id="27d46-191">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="27d46-192">Aşağıdaki kod güncelleştirilmiş gösterir `ReadonlyPoint3D` yapısı:</span><span class="sxs-lookup"><span data-stu-id="27d46-192">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="27d46-193">`ref struct`türü</span><span class="sxs-lookup"><span data-stu-id="27d46-193">`ref struct` type</span></span>

<span data-ttu-id="27d46-194">Başka bir ilgili dil yığını ayrılmış olması gereken değer türünü bildirmesine olanağı özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="27d46-194">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="27d46-195">Diğer bir deyişle, bu tür hiçbir zaman öbek üzerinde başka bir sınıf üyesi olarak oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="27d46-195">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="27d46-196">Bu özellik için birincil motivasyon oluştu <xref:System.Span%601> ve ilgili yapıları.</span><span class="sxs-lookup"><span data-stu-id="27d46-196">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="27d46-197"><xref:System.Span%601>yönetilen bir işaretçi bir grubun üyeleri ve diğeri aralık uzunluğu olan içerebilir.</span><span class="sxs-lookup"><span data-stu-id="27d46-197"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="27d46-198">C# güvenli olmayan bir bağlam dışında yönetilen bellek işaretçiler desteklemediğinden, aslında biraz farklı uygulanır.</span><span class="sxs-lookup"><span data-stu-id="27d46-198">It's actually implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="27d46-199">İşaretçinin ve uzunluk değişiklikleri yazma atomik değil.</span><span class="sxs-lookup"><span data-stu-id="27d46-199">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="27d46-200">Yani bir <xref:System.Span%601> aralığı hataları dışında tabi olacaktır veya diğer tür güvenlik ihlallerini onu değil kısıtlı bir tek yığın çerçevesi olan.</span><span class="sxs-lookup"><span data-stu-id="27d46-200">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="27d46-201">Ayrıca, yönetilen bir işaretçi GC yığınında genellikle koyma JIT zamanında çöküyor.</span><span class="sxs-lookup"><span data-stu-id="27d46-201">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="27d46-202">Kullanılarak oluşturulan bellekle çalışma benzer gereksinimleri olabilir [ `stackalloc` ](language-reference/keywords/stackalloc.md) veya birlikte çalışma API'leri bellekten kullanılırken.</span><span class="sxs-lookup"><span data-stu-id="27d46-202">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="27d46-203">Kendi tanımlayabilirsiniz `ref struct` türleri bu ihtiyaçları için.</span><span class="sxs-lookup"><span data-stu-id="27d46-203">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="27d46-204">Bu makalede, gördüğünüz kullanan örnekler `Span<T>` basitleştirmek için.</span><span class="sxs-lookup"><span data-stu-id="27d46-204">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="27d46-205">`ref struct` Bildirimi bildirir bu tür bir yapı yığında olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="27d46-205">The `ref struct` declaration declares that a struct of this type must be on the stack.</span></span> <span data-ttu-id="27d46-206">Dil kuralları bu türlerinin güvenli kullanımını emin olun.</span><span class="sxs-lookup"><span data-stu-id="27d46-206">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="27d46-207">Diğer türleri olarak bildirilen `ref struct` dahil <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="27d46-207">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="27d46-208">Tutma amacı bir `ref struct` yazın yığın ayırma değişkeni derleyici tüm zorlar çeşitli kurallar tanıtır gibi `ref struct` türleri.</span><span class="sxs-lookup"><span data-stu-id="27d46-208">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="27d46-209">Kutu olamaz bir `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="27d46-209">You can't box a `ref struct`.</span></span> <span data-ttu-id="27d46-210">Nesnesine atanamaz bir `ref struct` türünde bir değişkene `object`, `dynamic`, veya herhangi bir arabirim türü.</span><span class="sxs-lookup"><span data-stu-id="27d46-210">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="27d46-211">Bildiremezsiniz bir `ref struct` bir sınıf veya normal yapı üyesi olarak.</span><span class="sxs-lookup"><span data-stu-id="27d46-211">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="27d46-212">Yerel değişkenler bildiremezsiniz `ref struct` zaman uyumsuz yöntemleri türlerinde.</span><span class="sxs-lookup"><span data-stu-id="27d46-212">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="27d46-213">Döndüren zaman uyumlu yöntemleri bildirebilir `Task`, `Task<T>` veya görev-like türleri.</span><span class="sxs-lookup"><span data-stu-id="27d46-213">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="27d46-214">Bildiremezsiniz `ref struct` yineleyiciler yerel değişkenler.</span><span class="sxs-lookup"><span data-stu-id="27d46-214">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="27d46-215">Yakalama yapılamaz `ref struct` lambda ifadeleri veya yerel işlevler değişkenlerinin.</span><span class="sxs-lookup"><span data-stu-id="27d46-215">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="27d46-216">Bu kısıtlamalar değil yanlışlıkla kullandığınızdan emin olun bir `ref struct` Yönetilen yığın Yükselt bir şekilde.</span><span class="sxs-lookup"><span data-stu-id="27d46-216">These restrictions ensure that you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="conclusions"></a><span data-ttu-id="27d46-217">Sonuçları</span><span class="sxs-lookup"><span data-stu-id="27d46-217">Conclusions</span></span>

<span data-ttu-id="27d46-218">C# dili Bu geliştirmeler, burada bellek ayırmaları gerekli performansını elde için kritik olabilir performans kritik algoritmaları için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="27d46-218">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="27d46-219">Yazdığınız kodu bu özellikleri sık kullanmadığınız bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="27d46-219">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="27d46-220">Ancak, bu geliştirmeler, .NET Framework'teki birçok konumdaki uyarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="27d46-220">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="27d46-221">Daha da fazla API'leri yaparken bu özellikleri kullanan, kendi uygulamaların performansını artırmak görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="27d46-221">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>

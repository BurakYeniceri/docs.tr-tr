---
title: ASP.NET Core MVC uygulamaları sınama
description: ASP.NET Core ve Azure ile modern Web uygulamaları mimari | ASP.NET Core MVC uygulamaları sınama
author: ardalis
ms.author: wiwagn
ms.date: 10/08/2017
ms.openlocfilehash: b22e0e109144b4abd04cd4199cfdec244d8fa7af
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/29/2018
ms.locfileid: "37106508"
---
# <a name="test-aspnet-core-mvc-apps"></a><span data-ttu-id="efcee-103">ASP.NET Core MVC uygulamaları sınama</span><span class="sxs-lookup"><span data-stu-id="efcee-103">Test ASP.NET Core MVC Apps</span></span>

> <span data-ttu-id="efcee-104">_"Birim testi ürününüzü hoşlanmıyorsanız, büyük olasılıkla müşterilerinizin, ya da test etmek gibi olmaz." _ 
>  _- Anonim -_</span><span class="sxs-lookup"><span data-stu-id="efcee-104">_"If you don't like unit testing your product, most likely your customers won't like to test it, either."_
 _- Anonymous-_</span></span>

## <a name="summary"></a><span data-ttu-id="efcee-105">Özet</span><span class="sxs-lookup"><span data-stu-id="efcee-105">Summary</span></span>

<span data-ttu-id="efcee-106">Yazılım herhangi karmaşıklık değişikliklere yanıt beklenmeyen şekilde başarısız olabilir.</span><span class="sxs-lookup"><span data-stu-id="efcee-106">Software of any complexity can fail in unexpected ways in response to changes.</span></span> <span data-ttu-id="efcee-107">Bu nedenle, değişiklikleri yaptıktan sonra test en Önemsiz (veya en az önemli) uygulamalar dışındaki tüm için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="efcee-107">Thus, testing after making changes is required for all but the most trivial (or least critical) applications.</span></span> <span data-ttu-id="efcee-108">Manuel test yavaş, az güvenilir, en pahalı şekilde yazılım test etmektir.</span><span class="sxs-lookup"><span data-stu-id="efcee-108">Manual testing is the slowest, least reliable, most expensive way to test software.</span></span> <span data-ttu-id="efcee-109">Ne yazık ki, uygulamaları sınanabilir olacak şekilde tasarlanmıştır değil, yalnızca anlamına gelir kullanılabilir olabilir.</span><span class="sxs-lookup"><span data-stu-id="efcee-109">Unfortunately, if applications are not designed to be testable, it can be the only means available.</span></span> <span data-ttu-id="efcee-110">Mimari ilkelerini düzenlendiği aşağıdaki bölümde X yazılmış uygulamalar için birim test edilebilir olmalıdır ve ASP.NET Core uygulamaları otomatik tümleştirme ve işlevsel testleri de destekler.</span><span class="sxs-lookup"><span data-stu-id="efcee-110">Applications written following the architectural principles laid out in chapter X should be unit testable, and ASP.NET Core applications support automated integration and functional testing as well.</span></span>

## <a name="kinds-of-automated-tests"></a><span data-ttu-id="efcee-111">Otomatikleştirilmiş test türleri</span><span class="sxs-lookup"><span data-stu-id="efcee-111">Kinds of Automated Tests</span></span>

<span data-ttu-id="efcee-112">Yazılım uygulamaları için otomatikleştirilmiş testleri birçok çeşit vardır.</span><span class="sxs-lookup"><span data-stu-id="efcee-112">There are many kinds of automated tests for software applications.</span></span> <span data-ttu-id="efcee-113">Basit, en düşük düzey test birim testi olur.</span><span class="sxs-lookup"><span data-stu-id="efcee-113">The simplest, lowest level test is the unit test.</span></span> <span data-ttu-id="efcee-114">Biraz daha yüksek bir düzeyde tümleştirme testleri ve işlevsel testleri vardır.</span><span class="sxs-lookup"><span data-stu-id="efcee-114">At a slightly higher level there are integration tests and functional tests.</span></span> <span data-ttu-id="efcee-115">Diğer UI testleri, yük testleri, stres testleri ve Duman testleri gibi testler bu belgenin kapsamı dışındadır türleridir.</span><span class="sxs-lookup"><span data-stu-id="efcee-115">Other kinds of tests, like UI tests, load tests, stress tests, and smoke tests, are beyond the scope of this document.</span></span>

### <a name="unit-tests"></a><span data-ttu-id="efcee-116">Birim testleri</span><span class="sxs-lookup"><span data-stu-id="efcee-116">Unit Tests</span></span>

<span data-ttu-id="efcee-117">Birim testi uygulama mantığının tek bir parçası sınar.</span><span class="sxs-lookup"><span data-stu-id="efcee-117">A unit test tests a single part of your application's logic.</span></span> <span data-ttu-id="efcee-118">Bir başka onu öyle şeylerden bazıları listeleyerek açıklayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="efcee-118">One can further describe it by listing some of the things that it isn't.</span></span> <span data-ttu-id="efcee-119">Birim testi kodu çalışır bağımlılıklar veya hangi tümleştirme testleri altyapıyı – içindir nasıl test değil.</span><span class="sxs-lookup"><span data-stu-id="efcee-119">A unit test doesn't test how your code works with dependencies or infrastructure – that's what integration tests are for.</span></span> <span data-ttu-id="efcee-120">Birim testi test kodunuzu üzerine yazılır çerçevesi değil – çalışır veya, bulursanız değil, dosyalama ve geçici bir çözüm kod varsayın.</span><span class="sxs-lookup"><span data-stu-id="efcee-120">A unit test doesn't test the framework your code is written on – you should assume it works or, if you find it doesn't, file a bug and code a workaround.</span></span> <span data-ttu-id="efcee-121">Birim testi tamamen bellek ve işleminde çalışır.</span><span class="sxs-lookup"><span data-stu-id="efcee-121">A unit test runs completely in memory and in process.</span></span> <span data-ttu-id="efcee-122">Dosya sistemi, ağ veya bir veritabanı ile iletişim kuran değil.</span><span class="sxs-lookup"><span data-stu-id="efcee-122">It doesn't communicate with the file system, the network, or a database.</span></span> <span data-ttu-id="efcee-123">Birim testleri yalnızca kodunuzu test etmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="efcee-123">Unit tests should only test your code.</span></span>

<span data-ttu-id="efcee-124">Yalnızca tek bir birim, dış bağımlılıklar ile kodunuzu test olgu, birim testleri son derece hızlı bir şekilde çalıştırılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="efcee-124">Unit tests, by virtue of the fact that they test only a single unit of your code, with no external dependencies, should execute extremely quickly.</span></span> <span data-ttu-id="efcee-125">Bu nedenle, test paketlerini, birim testleri yüzlerce çalıştırabilir ve birkaç saniye içinde olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="efcee-125">Thus, you should be able to run test suites of hundreds of unit tests in a few seconds.</span></span> <span data-ttu-id="efcee-126">Bunları sık, ideal olarak her itme paylaşılan kaynak denetim deponuza ve her otomatik derleme ile kesinlikle önce derleme sunucunuzda çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="efcee-126">Run them frequently, ideally before every push to a shared source control repository, and certainly with every automated build on your build server.</span></span>

### <a name="integration-tests"></a><span data-ttu-id="efcee-127">Tümleştirme testleri</span><span class="sxs-lookup"><span data-stu-id="efcee-127">Integration Tests</span></span>

<span data-ttu-id="efcee-128">Bu altyapı veritabanları ve dosya sistemleri gibi etkileşimde kodunuzu kapsüllemek için iyi bir fikir olsa da, bazı kodun hala olacaktır ve muhtemelen test istersiniz.</span><span class="sxs-lookup"><span data-stu-id="efcee-128">Although it's a good idea to encapsulate your code that interacts with infrastructure like databases and file systems, you will still have some of that code, and you will probably want to test it.</span></span> <span data-ttu-id="efcee-129">Ayrıca, uygulamanızın bağımlılıkları tam olarak çözümlenmiş olduğunda beklediğiniz gibi kodun katman etkileşim doğrulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="efcee-129">Additionally, you should verify that your code's layers interact as you expect when your application's dependencies are fully resolved.</span></span> <span data-ttu-id="efcee-130">Tümleştirme testleri sorumluluğundadır.</span><span class="sxs-lookup"><span data-stu-id="efcee-130">This is the responsibility of integration tests.</span></span> <span data-ttu-id="efcee-131">Tümleştirme testleri genellikle dış bağımlılıkları ve altyapı üzerinde bağımlı olduğundan daha yavaştır ve birim testleri ayarlamak daha zor olma eğilimindedir.</span><span class="sxs-lookup"><span data-stu-id="efcee-131">Integration tests tend to be slower and more difficult to set up than unit tests, because they often depend on external dependencies and infrastructure.</span></span> <span data-ttu-id="efcee-132">Bu nedenle, tümleştirme testlerinde birim testleri testleriyle olabilir şeyler sınama kaçınmalısınız.</span><span class="sxs-lookup"><span data-stu-id="efcee-132">Thus, you should avoid testing things that could be tests with unit tests in integration tests.</span></span> <span data-ttu-id="efcee-133">Birim testi ile belirli bir senaryo test edebilirsiniz, birim testi ile test etmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="efcee-133">If you can test a given scenario with a unit test, you should test it with a unit test.</span></span> <span data-ttu-id="efcee-134">Şunları yapamazsınız, ardından bir tümleştirme test kullanmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="efcee-134">If you can't, then consider using an integration test.</span></span>

<span data-ttu-id="efcee-135">Tümleştirme testleri genellikle daha karmaşık kurulum ve birim testleri daha erdirme yordamları sahip olur.</span><span class="sxs-lookup"><span data-stu-id="efcee-135">Integration tests will often have more complex setup and teardown procedures than unit tests.</span></span> <span data-ttu-id="efcee-136">Örneğin, gerçek bir veritabanına karşı giden bir tümleştirme test veritabanı her test çalışması önce bilinen bir duruma döndürmek için bir yol gerekir.</span><span class="sxs-lookup"><span data-stu-id="efcee-136">For example, an integration test that goes against an actual database will need a way to return the database to a known state before each test run.</span></span> <span data-ttu-id="efcee-137">Yeni testleri eklenir ve üretim veritabanı şeması dönüşmesi, komut dosyaları eğilimindedir boyutu ve karmaşıklığı büyümeye bu test.</span><span class="sxs-lookup"><span data-stu-id="efcee-137">As new tests are added and the production database schema evolves, these test scripts will tend to grow in size and complexity.</span></span> <span data-ttu-id="efcee-138">Birçok büyük sisteminde değişiklik paylaşılan kaynak denetimine iade önce Geliştirici istasyonlarında tümleştirme testlerinin tam paketlerini çalıştırmaya zordur.</span><span class="sxs-lookup"><span data-stu-id="efcee-138">In many large systems, it is impractical to run full suites of integration tests on developer workstations before checking in changes to shared source control.</span></span> <span data-ttu-id="efcee-139">Bu durumlarda, tümleştirme testleri bir yapı sunucuda çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="efcee-139">In these cases, integration tests may be run on a build server.</span></span>

<span data-ttu-id="efcee-140">LocalFileImageService uygulama sınıfı getirme ve bir görüntü dosyası bayt kimliği verilen belirli bir klasörden döndürmek için mantığını uygular:</span><span class="sxs-lookup"><span data-stu-id="efcee-140">The LocalFileImageService implementation class implements the logic for fetching and returning the bytes of an image file from a particular folder given an id:</span></span>

```csharp
public class LocalFileImageService : IImageService
{
    private readonly IHostingEnvironment _env;
    public LocalFileImageService(IHostingEnvironment env)
    {
        _env = env;
    }
    public byte[] GetImageBytesById(int id)
    {
        try
        {
            var contentRoot = _env.ContentRootPath + "//Pics";
            var path = Path.Combine(contentRoot, id + ".png");
            return File.ReadAllBytes(path);
        }
        catch (FileNotFoundException ex)
        {
            throw new CatalogImageMissingException(ex);
        }
    }
}
```

### <a name="functional-tests"></a><span data-ttu-id="efcee-141">İşlevsel testleri</span><span class="sxs-lookup"><span data-stu-id="efcee-141">Functional Tests</span></span>

<span data-ttu-id="efcee-142">Tümleştirme testleri sistem bazı bileşenleri düzgün bir şekilde birlikte çalışmasını doğrulamak için geliştirici perspektifinden yazılır.</span><span class="sxs-lookup"><span data-stu-id="efcee-142">Integration tests are written from the perspective of the developer, to verify that some components of the system work correctly together.</span></span> <span data-ttu-id="efcee-143">İşlevsel testleri kullanıcı perspektifinden yazılır ve kendi gereksinimlerine göre sistem doğruluğundan emin olun.</span><span class="sxs-lookup"><span data-stu-id="efcee-143">Functional tests are written from the perspective of the user, and verify the correctness of the system based on its requirements.</span></span> <span data-ttu-id="efcee-144">Aşağıdaki alıntı nasıl için birim testleri karşılaştırılması işlevsel testleri hakkında düşünmek için yararlı bir benzerleme sunar:</span><span class="sxs-lookup"><span data-stu-id="efcee-144">The following excerpt offers a useful analogy for how to think about functional tests, compared to unit tests:</span></span>

> <span data-ttu-id="efcee-145">"Birçok kez geliştirme sisteminin bir ev oluşturulmasını likened.</span><span class="sxs-lookup"><span data-stu-id="efcee-145">"Many times the development of a system is likened to the building of a house.</span></span> <span data-ttu-id="efcee-146">Bu benzerleme oldukça doğru olmasa da, biz birim ve işlevsel testleri arasındaki farkı anlamak amacıyla genişletebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="efcee-146">While this analogy isn't quite correct, we can extend it for the purposes of understanding the difference between unit and functional tests.</span></span> <span data-ttu-id="efcee-147">Birim testi house'nın yapım sitesinden bir yapı denetçisi benzerdir.</span><span class="sxs-lookup"><span data-stu-id="efcee-147">Unit testing is analogous to a building inspector visiting a house's construction site.</span></span> <span data-ttu-id="efcee-148">Müşterinizle çerçeveleme, elektrik, Sıhhi tesisat ve vb. foundation house çeşitli iç sistemlerde odaklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="efcee-148">He is focused on the various internal systems of the house, the foundation, framing, electrical, plumbing, and so on.</span></span> <span data-ttu-id="efcee-149">Kendisine (ev bölümlerini düzgün çalışması ve güvenli bir şekilde, diğer bir deyişle, yapı kod karşılayan testleri) sağlar.</span><span class="sxs-lookup"><span data-stu-id="efcee-149">He ensures (tests) that the parts of the house will work correctly and safely, that is, meet the building code.</span></span> <span data-ttu-id="efcee-150">Bu senaryoda işlevsel testleri, bu aynı yapım siteyi ziyaret konut benzer.</span><span class="sxs-lookup"><span data-stu-id="efcee-150">Functional tests in this scenario are analogous to the homeowner visiting this same construction site.</span></span> <span data-ttu-id="efcee-151">Müşterinizle iç sistemlerinin uygun şekilde davranır, yapı denetçisi kendi görev çalıştığını varsayar.</span><span class="sxs-lookup"><span data-stu-id="efcee-151">He assumes that the internal systems will behave appropriately, that the building inspector is performing his task.</span></span> <span data-ttu-id="efcee-152">Konut ne bu gibi bu house Canlı olacaktır üzerinde odaklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="efcee-152">The homeowner is focused on what it will be like to live in this house.</span></span> <span data-ttu-id="efcee-153">Kendisine evin nasıl göründüğünü ile ilgilidir, çeşitli rooms rahat boyutu, ev ailesinin gereksinimlerinize uygun olmadığından, sabah sun yakalamak için iyi bir nokta olarak Windows.</span><span class="sxs-lookup"><span data-stu-id="efcee-153">He is concerned with how the house looks, are the various rooms a comfortable size, does the house fit the family's needs, are the windows in a good spot to catch the morning sun.</span></span> <span data-ttu-id="efcee-154">Konut işlevsel testleri evi gerçekleştiriyor.</span><span class="sxs-lookup"><span data-stu-id="efcee-154">The homeowner is performing functional tests on the house.</span></span> <span data-ttu-id="efcee-155">Kullanıcı açısından sahip.</span><span class="sxs-lookup"><span data-stu-id="efcee-155">He has the user's perspective.</span></span> <span data-ttu-id="efcee-156">Yapı denetçisi birim testleri evi gerçekleştiriyor.</span><span class="sxs-lookup"><span data-stu-id="efcee-156">The building inspector is performing unit tests on the house.</span></span> <span data-ttu-id="efcee-157">Oluşturucunun perspektif sahip."</span><span class="sxs-lookup"><span data-stu-id="efcee-157">He has the builder's perspective."</span></span>

<span data-ttu-id="efcee-158">Kaynak: [birim testi işlevsel testleri](http://www.softwaretestingtricks.com/2007/01/unit-testing-versus-functional-tests.html)</span><span class="sxs-lookup"><span data-stu-id="efcee-158">Source: [Unit Testing versus Functional Tests](http://www.softwaretestingtricks.com/2007/01/unit-testing-versus-functional-tests.html)</span></span>

<span data-ttu-id="efcee-159">Bildiren, Acıyı ben "geliştiriciler şu iki yolla başarısız: biz yanlış şey oluşturmak veya biz yanlış şeyi yapı."</span><span class="sxs-lookup"><span data-stu-id="efcee-159">I'm fond of saying "As developers, we fail in two ways: we build the thing wrong, or we build the wrong thing."</span></span> <span data-ttu-id="efcee-160">Birim testleri şey sağ oluşturmakta olduğunuz emin olun; işlevsel testleri doğru şeyi oluşturmakta olduğunuz emin olun.</span><span class="sxs-lookup"><span data-stu-id="efcee-160">Unit tests ensure you are building the thing right; functional tests ensure you are building the right thing.</span></span>

<span data-ttu-id="efcee-161">İşlevsel testleri sistem düzeyinde çalışır olduğundan, bunlar dereceye UI Otomasyon gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="efcee-161">Since functional tests operate at the system level, they may require some degree of UI automation.</span></span> <span data-ttu-id="efcee-162">Tümleştirme testleri gibi genellikle test altyapısını bazı tür çalışırlar.</span><span class="sxs-lookup"><span data-stu-id="efcee-162">Like integration tests, they usually work with some kind of test infrastructure as well.</span></span> <span data-ttu-id="efcee-163">Bu onları daha yavaştır ve birim ve tümleştirme testleri daha kırılır hale getirir.</span><span class="sxs-lookup"><span data-stu-id="efcee-163">This makes them slower and more brittle than unit and integration tests.</span></span> <span data-ttu-id="efcee-164">Yalnızca olması kullanıcılar beklendiği gibi sistem davranmakta emin olmanız gerekir sayıda işlevsel testleri.</span><span class="sxs-lookup"><span data-stu-id="efcee-164">You should have only as many functional tests as you need to be confident the system is behaving as users expect.</span></span>

### <a name="testing-pyramid"></a><span data-ttu-id="efcee-165">Piramit test etme</span><span class="sxs-lookup"><span data-stu-id="efcee-165">Testing Pyramid</span></span>

<span data-ttu-id="efcee-166">Bir örneği, Şekil 9-1'de gösterilen test Piramit hakkında Martin Fowler yazıldı.</span><span class="sxs-lookup"><span data-stu-id="efcee-166">Martin Fowler wrote about the testing pyramid, an example of which is shown in Figure 9-1.</span></span>

![](./media/image9-1.png)

<span data-ttu-id="efcee-167">Şekil 9-1 Piramit test etme</span><span class="sxs-lookup"><span data-stu-id="efcee-167">Figure 9-1 Testing Pyramid</span></span>

<span data-ttu-id="efcee-168">Piramit ve göreli boyutlarının farklı katmanları farklı türdeki testleri ve uygulamanız için yazmalısınız kaç temsil eder.</span><span class="sxs-lookup"><span data-stu-id="efcee-168">The different layers of the pyramid, and their relative sizes, represent different kinds of tests and how many you should write for your application.</span></span> <span data-ttu-id="efcee-169">Gördüğünüz gibi daha küçük bir tümleştirme testleri katmanında işlevsel testleri bile daha küçük bir katmanı ile desteklenen birim testleri, büyük bir taban olması önerilir.</span><span class="sxs-lookup"><span data-stu-id="efcee-169">As you can see, the recommendation is to have a large base of unit tests, supported by a smaller layer of integration tests, with an even smaller layer of functional tests.</span></span> <span data-ttu-id="efcee-170">Her katman, alt katman yeterli gerçekleştirilemiyor, ideal olarak testleri yalnızca olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="efcee-170">Each layer should ideally only have tests in it that cannot be performed adequately at a lower layer.</span></span> <span data-ttu-id="efcee-171">Belirli bir senaryo için gereken test hangi tür karar vermeye çalışırken test Piramit göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="efcee-171">Keep the testing pyramid in mind when you are trying to decide which kind of test you need for a particular scenario.</span></span>

### <a name="what-to-test"></a><span data-ttu-id="efcee-172">Test gerekenler</span><span class="sxs-lookup"><span data-stu-id="efcee-172">What to Test</span></span>

<span data-ttu-id="efcee-173">Otomatikleştirilmiş testleri yazma ile deneyimsiz geliştiriciler için ortak bir sorun ile test etmek yakında.</span><span class="sxs-lookup"><span data-stu-id="efcee-173">A common problem for developers who are inexperienced with writing automated tests is coming up with what to test.</span></span> <span data-ttu-id="efcee-174">İyi bir başlangıç noktası koşullu mantık test etmektir.</span><span class="sxs-lookup"><span data-stu-id="efcee-174">A good starting point is to test conditional logic.</span></span> <span data-ttu-id="efcee-175">Değişiklikleri koşullu bir ifadesine dayalı olarak davranışına sahip bir yöntem sahip herhangi bir yerde (if-else, geçiş, vb.), en az birkaç belirli koşulların doğru davranışını Onayla testleri gelmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="efcee-175">Anywhere you have a method with behavior that changes based on a conditional statement (if-else, switch, etc.), you should be able to come up at least a couple of tests that confirm the correct behavior for certain conditions.</span></span> <span data-ttu-id="efcee-176">Kodunuzu hata koşulları varsa, "mutluluk yolu için" kod aracılığıyla en az bir test (hatasız) ve "üzücü yolu" için en az bir test uygulamanızın hatalarını karşısında beklendiği gibi davranır onaylamak için (hataları veya alışılmadık sonuçları) yazmak iyidir.</span><span class="sxs-lookup"><span data-stu-id="efcee-176">If your code has error conditions, it's good to write at least one test for the "happy path" through the code (with no errors), and at least one test for the "sad path" (with errors or atypical results) to confirm your application behaves as expected in the face of errors.</span></span> <span data-ttu-id="efcee-177">Kod kapsamı gibi ölçümleri odaklanan yerine yük devredebilir şeyler sınama odaklanmak son olarak, deneyin.</span><span class="sxs-lookup"><span data-stu-id="efcee-177">Finally, try to focus on testing things that can fail, rather than focusing on metrics like code coverage.</span></span> <span data-ttu-id="efcee-178">Daha fazla kod kapsamı genellikle daha az daha iyi olur.</span><span class="sxs-lookup"><span data-stu-id="efcee-178">More code coverage is better than less, generally.</span></span> <span data-ttu-id="efcee-179">Ancak, çok karmaşık ve iş açısından kritik yönteminin birkaç daha fazla testleri yazma genellikle testleri yalnızca test kod kapsamı ölçümleri geliştirmek otomatik-özellikleri için yazma değerinden bir daha iyi zaman kullanılır.</span><span class="sxs-lookup"><span data-stu-id="efcee-179">However, writing a few more tests of a very complex and business-critical method is usually a better use of time than writing tests for auto-properties just to improve test code coverage metrics.</span></span>

## <a name="organizing-test-projects"></a><span data-ttu-id="efcee-180">Test projeleri düzenleme</span><span class="sxs-lookup"><span data-stu-id="efcee-180">Organizing Test Projects</span></span>

<span data-ttu-id="efcee-181">Ancak, Works sizin için en iyi test projeleri düzenlenebilir.</span><span class="sxs-lookup"><span data-stu-id="efcee-181">Test projects can be organized however works best for you.</span></span> <span data-ttu-id="efcee-182">Testleri türünü (birim testi, tümleştirme test) ve hangi (projeye göre ad alanı) test ettikleri göre ayırmak için iyi bir fikirdir.</span><span class="sxs-lookup"><span data-stu-id="efcee-182">It's a good idea to separate tests by type (unit test, integration test) and by what they are testing (by project, by namespace).</span></span> <span data-ttu-id="efcee-183">Bu ayrım tek test projesi ya da birden çok test projeleri, klasörlere oluşur olup olmadığını tasarım bir karardır.</span><span class="sxs-lookup"><span data-stu-id="efcee-183">Whether this separation consists of folders within a single test project, or multiple test projects, is a design decision.</span></span> <span data-ttu-id="efcee-184">Bir proje en kolayıdır ancak birçok testleriyle ya da daha kolay farklı testleri kümesi çalıştırmak için büyük projeler için birkaç farklı test projeleri sahip olmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="efcee-184">One project is simplest, but for large projects with many tests, or in order to more easily run different sets of tests, you might want to have several different test projects.</span></span> <span data-ttu-id="efcee-185">Birçok ekip test projeleri özellikle, hala bu tür testleri her projede nelerdir göre ayırırsanız birkaç projeleri olan uygulamalar için çok sayıda test projeleri sonuçlanabilir sınıyorsanız, proje göre düzenler.</span><span class="sxs-lookup"><span data-stu-id="efcee-185">Many teams organize test projects based on the project they are testing, which for applications with more than a few projects can result in a large number of test projects, especially if you still break these down according to what kind of tests are in each project.</span></span> <span data-ttu-id="efcee-186">Bir tehlikeye yaklaşım sınanan proje (ve sınıf) belirtmek için test projeleri klasörlerde ile uygulama başına test tür başına tek bir proje olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="efcee-186">A compromise approach is to have one project per kind of test, per application, with folders inside the test projects to indicate the project (and class) being tested.</span></span>

<span data-ttu-id="efcee-187">'Src' klasörü altında uygulama projeleri ve paralel 'test' klasörü altında uygulamanın test projeleri düzenlemek ortak bir yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="efcee-187">A common approach is to organize the application projects under a ‘src' folder, and the application's test projects under a parallel ‘tests' folder.</span></span> <span data-ttu-id="efcee-188">Bu kuruluş yararlı bulursanız, Visual Studio'da eşleşen çözüm klasörler oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="efcee-188">You can create matching solution folders in Visual Studio, if you find this organization useful.</span></span>

![](./media/image9-2.png)

<span data-ttu-id="efcee-189">Şekil 9-2 Test kuruluş çözümünüzdeki</span><span class="sxs-lookup"><span data-stu-id="efcee-189">Figure 9-2 Test organization in your solution</span></span>

<span data-ttu-id="efcee-190">Tercih ettiğiniz çerçeveye test kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="efcee-190">You can use whichever test framework you prefer.</span></span> <span data-ttu-id="efcee-191">XUnit framework iyi çalışır ve nedir tüm ASP.NET Core ve EF çekirdek testleri yazılır.</span><span class="sxs-lookup"><span data-stu-id="efcee-191">The xUnit framework works well and is what all of the ASP.NET Core and EF Core tests are written in.</span></span> <span data-ttu-id="efcee-192">Visual Studio'da Şekil 9-3'te veya dotnet yeni xunit kullanarak clı'dan gösterilen şablonu kullanarak bir xUnit test projesi ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="efcee-192">You can add an xUnit test project in Visual Studio using the template shown in Figure 9-3, or from the CLI using dotnet new xunit.</span></span>

![](./media/image9-3.png)

<span data-ttu-id="efcee-193">Şekil 9-3 Ekle xUnit Visual Studio'da Test projesi</span><span class="sxs-lookup"><span data-stu-id="efcee-193">Figure 9-3 Add an xUnit Test Project in Visual Studio</span></span>

### <a name="test-naming"></a><span data-ttu-id="efcee-194">Test adlandırma</span><span class="sxs-lookup"><span data-stu-id="efcee-194">Test Naming</span></span>

<span data-ttu-id="efcee-195">Her sınama ne yaptığını gösteren adlarla testlerinizi tutarlı bir şekilde adlandırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="efcee-195">You should name your tests in a consistent fashion, with names that indicate what each test does.</span></span> <span data-ttu-id="efcee-196">Harika başarı ile sahip bir sınıf ve test ettiğiniz yöntemi göre ad test sınıflarını yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="efcee-196">One approach I've had great success with is to name test classes according to the class and method they are testing.</span></span> <span data-ttu-id="efcee-197">Bu çok sayıda küçük test sınıflarda olur, ancak son derece her test sorumlu nedir temizleyin sağlar.</span><span class="sxs-lookup"><span data-stu-id="efcee-197">This results in many small test classes, but it makes it extremely clear what each test is responsible for.</span></span> <span data-ttu-id="efcee-198">Test yöntemi adı sınıfı ve sınanacak yöntemi tanımlamak için ayarladığınız test sınıf adı ile test edilen davranışını belirtmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="efcee-198">With the test class name set up to identify the class and method to be tested, the test method name can be used to specify the behavior being tested.</span></span> <span data-ttu-id="efcee-199">Bu beklenen bir davranış ve girişleri veya bu davranış verim varsayımlar içermelidir.</span><span class="sxs-lookup"><span data-stu-id="efcee-199">This should include the expected behavior and any inputs or assumptions that should yield this behavior.</span></span> <span data-ttu-id="efcee-200">Bazı örnek test adları:</span><span class="sxs-lookup"><span data-stu-id="efcee-200">Some example test names:</span></span>

- <span data-ttu-id="efcee-201">CatalogControllerGetImage.CallsImageServiceWithId</span><span class="sxs-lookup"><span data-stu-id="efcee-201">CatalogControllerGetImage.CallsImageServiceWithId</span></span>

- <span data-ttu-id="efcee-202">CatalogControllerGetImage.LogsWarningGivenImageMissingException</span><span class="sxs-lookup"><span data-stu-id="efcee-202">CatalogControllerGetImage.LogsWarningGivenImageMissingException</span></span>

- <span data-ttu-id="efcee-203">CatalogControllerGetImage.ReturnsFileResultWithBytesGivenSuccess</span><span class="sxs-lookup"><span data-stu-id="efcee-203">CatalogControllerGetImage.ReturnsFileResultWithBytesGivenSuccess</span></span>

- <span data-ttu-id="efcee-204">CatalogControllerGetImage.ReturnsNotFoundResultGivenImageMissingException</span><span class="sxs-lookup"><span data-stu-id="efcee-204">CatalogControllerGetImage.ReturnsNotFoundResultGivenImageMissingException</span></span>

<span data-ttu-id="efcee-205">Bu yaklaşımın bir değişim her test sınıfı adı "Gerekir" ile biten ve zamanın biraz değiştirir:</span><span class="sxs-lookup"><span data-stu-id="efcee-205">A variation of this approach ends each test class name with "Should" and modifies the tense slightly:</span></span>

- <span data-ttu-id="efcee-206">CatalogControllerGetImage**gereken**. **Çağrı**ImageServiceWithId</span><span class="sxs-lookup"><span data-stu-id="efcee-206">CatalogControllerGetImage**Should**.**Call**ImageServiceWithId</span></span>

- <span data-ttu-id="efcee-207">CatalogControllerGetImage**gereken**. **Günlük**WarningGivenImageMissingException</span><span class="sxs-lookup"><span data-stu-id="efcee-207">CatalogControllerGetImage**Should**.**Log**WarningGivenImageMissingException</span></span>

<span data-ttu-id="efcee-208">NET, ikinci adlandırma yaklaşımını bazı ekipler bulmak ancak biraz daha ayrıntılı.</span><span class="sxs-lookup"><span data-stu-id="efcee-208">Some teams find the second naming approach clearer, though slightly more verbose.</span></span> <span data-ttu-id="efcee-209">Herhangi bir durumda, böylece bir veya birkaç sınama başarısız olduğunda hangi durumlarda başarısız olmuş kendi adlarından belirgin test davranışı hakkında bilgi sağlayan bir adlandırma kuralı kullanmayı deneyin.</span><span class="sxs-lookup"><span data-stu-id="efcee-209">In any case, try to use a naming convention that provides insight into test behavior, so that when one or more tests fail, it's obvious from their names what cases have failed.</span></span> <span data-ttu-id="efcee-210">Test sonuçlarında görüntülendiğinde bu herhangi bir değer sunar gibi testleri ControllerTests.Test1 gibi vaguely, adlandırma kaçının.</span><span class="sxs-lookup"><span data-stu-id="efcee-210">Avoid naming you tests vaguely, such as ControllerTests.Test1, as these offer no value when you see them in test results.</span></span>

<span data-ttu-id="efcee-211">Çok sayıda küçük test sınıfları, yukarıdakine üreten gibi bir adlandırma kuralı izlerseniz, daha fazla klasörleri ve ad alanlarını kullanarak testlerinizi düzenlemek için bir fikirdir.</span><span class="sxs-lookup"><span data-stu-id="efcee-211">If you follow a naming convention like the one above that produces many small test classes, it's a good idea to further organize your tests using folders and namespaces.</span></span> <span data-ttu-id="efcee-212">Şekil 9-4 birkaç test projeleri klasördeki tarafından testlerin düzenlenmesi için bir yaklaşım gösterir.</span><span class="sxs-lookup"><span data-stu-id="efcee-212">Figure 9-4 shows one approach to organizing tests by folder within several test projects.</span></span>

![](./media/image9-4.png)

<span data-ttu-id="efcee-213">**Şekil 9-4.**</span><span class="sxs-lookup"><span data-stu-id="efcee-213">**Figure 9-4.**</span></span> <span data-ttu-id="efcee-214">Test sınıfları tarafından test edilen sınıfına göre klasör düzenleme.</span><span class="sxs-lookup"><span data-stu-id="efcee-214">Organizing test classes by folder based on class being tested.</span></span>

<span data-ttu-id="efcee-215">Elbette, belirli uygulama sınıfı sınanan birçok yöntemleri vardır (ve böylece çoğu sınıfları test varsa), bu uygulama sınıfına karşılık gelen bir klasöre yerleştirin mantıklı olabilir.</span><span class="sxs-lookup"><span data-stu-id="efcee-215">Of course, if a particular application class has many methods being tested (and thus many test classes), it may make sense to place these in a folder corresponding to the application class.</span></span> <span data-ttu-id="efcee-216">Bu kuruluş nasıl, dosyaları başka bir yerde klasörler halinde düzenleyebileceğini farklı değildir.</span><span class="sxs-lookup"><span data-stu-id="efcee-216">This organization is no different than how you might organize files into folders elsewhere.</span></span> <span data-ttu-id="efcee-217">En fazla üç varsa veya dört ilgili diğer birçok dosyalarını içeren bir klasördeki dosyaları, genellikle kendi alt klasöre taşımak yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="efcee-217">If you have more than three or four related files in a folder containing many other files, it's often helpful to move them into their own subfolder.</span></span>

## <a name="unit-testing-aspnet-core-apps"></a><span data-ttu-id="efcee-218">Birim testi ASP.NET Core uygulamaları</span><span class="sxs-lookup"><span data-stu-id="efcee-218">Unit Testing ASP.NET Core Apps</span></span>

<span data-ttu-id="efcee-219">İyi tasarlanmış bir ASP.NET Core uygulama karmaşıklığını ve iş mantığı çoğu iş varlıkları ve çeşitli hizmetlere kapsüllenmiş.</span><span class="sxs-lookup"><span data-stu-id="efcee-219">In a well-designed ASP.NET Core application, most of the complexity and business logic will be encapsulated in business entities and a variety of services.</span></span> <span data-ttu-id="efcee-220">ASP.NET Core MVC uygulamayla kendisini denetleyicileri, filtreleri, viewmodels ve görünümler, çok az birim testleri istemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="efcee-220">The ASP.NET Core MVC app itself, with its controllers, filters, viewmodels, and views, should require very few unit tests.</span></span> <span data-ttu-id="efcee-221">Belirli bir eylemi işlevlerinin çoğunu eylem yönteminin kendisi dışında arasındadır.</span><span class="sxs-lookup"><span data-stu-id="efcee-221">Much of the functionality of a given action lies outside the action method itself.</span></span> <span data-ttu-id="efcee-222">Etkin yönlendirme düzgün çalıştığını olup olmadığını test etme ya da genel hata işleme ile birim testi yapılamaz.</span><span class="sxs-lookup"><span data-stu-id="efcee-222">Testing whether routing works correctly, or global error handling, cannot be done effectively with a unit test.</span></span> <span data-ttu-id="efcee-223">Benzer şekilde, herhangi bir model doğrulama ve kimlik doğrulaması gibi filtreler ve yetkilendirme filtreleri olamaz test birim.</span><span class="sxs-lookup"><span data-stu-id="efcee-223">Likewise, any filters, including model validation and authentication and authorization filters, cannot be unit tested.</span></span> <span data-ttu-id="efcee-224">Bu davranış kaynakları, çoğu eylem yöntemleri bunları kullanan denetleyicisinin bağımsız sınanabilir Hizmetleri iş toplu temsilci trivially küçük olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="efcee-224">Without these sources of behavior, most action methods should be trivially small, delegating the bulk of their work to services that can be tested independent of the controller that uses them.</span></span>

<span data-ttu-id="efcee-225">Bazen birim testi kodunuzda sipariş düzenleme gerekir.</span><span class="sxs-lookup"><span data-stu-id="efcee-225">Sometimes you'll need to refactor your code in order to unit test it.</span></span> <span data-ttu-id="efcee-226">Sık bu soyutlama tanımlama ve test etmek istediğiniz kod soyutlama erişmek için bağımlılık ekleme kullanılarak yerine doğrudan altyapı karşı kodlama içerir.</span><span class="sxs-lookup"><span data-stu-id="efcee-226">Frequently this involves identifying abstractions and using dependency injection to access the abstraction in the code you'd like to test, rather than coding directly against infrastructure.</span></span> <span data-ttu-id="efcee-227">Örneğin, görüntüleri görüntüleme için bu basit eylem yöntemine göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="efcee-227">For example, consider this simple action method for displaying images:</span></span>

```csharp
[HttpGet("[controller]/pic/{id}")]
public IActionResult GetImage(int id)
{
    var contentRoot = _env.ContentRootPath + "//Pics";
    var path = Path.Combine(contentRoot, id + ".png");
    Byte[] b = System.IO.File.ReadAllBytes(path);
    return File(b, "image/png");
}
```

<span data-ttu-id="efcee-228">Birim testi bu yöntem, dosya sisteminden okumak için kullandığı System.IO.File doğrudan bağımlı tarafından zor olarak yapılır.</span><span class="sxs-lookup"><span data-stu-id="efcee-228">Unit testing this method is made difficult by its direct dependency on System.IO.File, which it uses to read from the file system.</span></span> <span data-ttu-id="efcee-229">Bu davranış beklendiği gibi çalışır, ancak gerçek dosyalarıyla böylece tümleştirme test olduğundan emin olmak için test edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="efcee-229">You can test this behavior to ensure it works as expected, but doing so with real files is an integration test.</span></span> <span data-ttu-id="efcee-230">Bu yöntemin rota test edilemez – bu işlev bir test ile kısa süre içinde nasıl yapılacağı görürsünüz dikkate değerdir.</span><span class="sxs-lookup"><span data-stu-id="efcee-230">It's worth noting you can't test this method's route – you'll see how to do this with a functional test shortly.</span></span>

<span data-ttu-id="efcee-231">Birim testi dosya sistemi davranışını doğrudan yükleyemezsiniz ve rota test edilemez, var. test etmek için nedir?</span><span class="sxs-lookup"><span data-stu-id="efcee-231">If you can't unit test the file system behavior directly, and you can't test the route, what is there to test?</span></span> <span data-ttu-id="efcee-232">İyi, birim testi mümkün kılmak için yeniden düzenleme sonra bazı test durumları ve hata işleme gibi eksik davranışı fark edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="efcee-232">Well, after refactoring to make unit testing possible, you may discover some test cases and missing behavior, such as error handling.</span></span> <span data-ttu-id="efcee-233">Bir dosya bulunamadığında zaman yöntemi ne yapar?</span><span class="sxs-lookup"><span data-stu-id="efcee-233">What does the method do when a file isn't found?</span></span> <span data-ttu-id="efcee-234">Neler?</span><span class="sxs-lookup"><span data-stu-id="efcee-234">What should it do?</span></span> <span data-ttu-id="efcee-235">Bu örnekte, işlenmiş yöntemi şöyle görünür:</span><span class="sxs-lookup"><span data-stu-id="efcee-235">In this example, the refactored method looks like this:</span></span>

```csharp
[HttpGet("[controller]/pic/{id}")\]
public IActionResult GetImage(int id)
{
    byte[] imageBytes;
    try
    {
        imageBytes = _imageService.GetImageBytesById(id);
    }
    catch (CatalogImageMissingException ex)
    {
        _logger.LogWarning($"No image found for id: {id}");
        return NotFound();
    }
    return File(imageBytes, "image/png");
}
```

<span data-ttu-id="efcee-236">\_Günlükçü ve \_Imageservice her ikisi de eklenmiş bağımlılıkları.</span><span class="sxs-lookup"><span data-stu-id="efcee-236">The \_logger and \_imageService are both injected as dependencies.</span></span> <span data-ttu-id="efcee-237">Eylem yöntemine geçirilen aynı kimliği geçirilecek test artık \_Imageservice, ve sonuçta elde edilen bayt FileResult bir parçası olarak döndürülür.</span><span class="sxs-lookup"><span data-stu-id="efcee-237">Now you can test that the same id that is passed to the action method is passed to the \_imageService, and that the resulting bytes are returned as part of the FileResult.</span></span> <span data-ttu-id="efcee-238">Ayrıca hata günlüğünü beklendiği gibi gerçekleşmekte olduğunu ve görüntünün eksikse NotFound sonuç döndürülür bu önemli uygulama davranışına (diğer bir deyişle, yalnızca geçici kodu bir sorunu tanılamak için eklenen Geliştirici) olduğunu varsayarak test edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="efcee-238">You can also test that error logging is happening as expected, and that a NotFound result is returned if the image is missing, assuming this is important application behavior (that is, not just temporary code the developer added to diagnose an issue).</span></span> <span data-ttu-id="efcee-239">Gerçek dosya mantığı ayrı uygulama hizmetine taşınmıştır ve bir uygulamaya özgü özel durum dosyası eksik çalışması için döndürmek için genişletilebilir.</span><span class="sxs-lookup"><span data-stu-id="efcee-239">The actual file logic has moved into a separate implementation service, and has been augmented to return an application-specific exception for the case of a missing file.</span></span> <span data-ttu-id="efcee-240">Bir tümleştirme test kullanarak bu uygulama bağımsız olarak, test edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="efcee-240">You can test this implementation independently, using an integration test.</span></span>

## <a name="integration-testing-aspnet-core-apps"></a><span data-ttu-id="efcee-241">Tümleştirme ASP.NET Core uygulamaları test etme</span><span class="sxs-lookup"><span data-stu-id="efcee-241">Integration Testing ASP.NET Core Apps</span></span>

<span data-ttu-id="efcee-242">Bu hizmet, yalnızca ayrı bir hizmet yeniden düzenlenmeden önce kodu vermedi CatalogController olarak IHostingEnvironment kullanır.</span><span class="sxs-lookup"><span data-stu-id="efcee-242">This service uses the IHostingEnvironment, just as the CatalogController code did before it was refactored into a separate service.</span></span> <span data-ttu-id="efcee-243">Bu IHostingEnvironment kullanılan denetleyici yalnızca kod olduğundan, bu bağımlılık CatalogController'ın oluşturucudan kaldırıldı.</span><span class="sxs-lookup"><span data-stu-id="efcee-243">Since this was the only code in the controller that used IHostingEnvironment, that dependency was removed from CatalogController's constructor.</span></span>

<span data-ttu-id="efcee-244">Bu hizmet düzgün çalıştığını test etmek için bilinen test görüntü dosyası oluşturmak ve hizmet, belirli bir giriş verilen döndürür doğrulamak gerekir.</span><span class="sxs-lookup"><span data-stu-id="efcee-244">To test that this service works correctly, you need to create a known test image file and verify that the service returns it given a specific input.</span></span> <span data-ttu-id="efcee-245">Sahte nesneler gerçekte (dosya sisteminden okuma bu durumda,) test etmek istediğiniz davranışı üzerinde kullanmayacak şekilde halletmeniz.</span><span class="sxs-lookup"><span data-stu-id="efcee-245">You should take care not to use mock objects on the behavior you actually want to test (in this case, reading from the file system).</span></span> <span data-ttu-id="efcee-246">Ancak, sahte nesneler hala tümleştirme testleri oluşturma yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="efcee-246">However, mock objects may still be useful to set up integration tests.</span></span> <span data-ttu-id="efcee-247">Bu durumda, böylece kendi ContentRootPath test görüntüsü için kullanacaksanız klasörü işaret IHostingEnvironment mock.</span><span class="sxs-lookup"><span data-stu-id="efcee-247">In this case, you can mock IHostingEnvironment so that its ContentRootPath points to the folder you're going to use for your test image.</span></span> <span data-ttu-id="efcee-248">Tüm çalışma tümleştirme test sınıf burada gösterilir:</span><span class="sxs-lookup"><span data-stu-id="efcee-248">The complete working integration test class is shown here:</span></span>

```csharp
public class LocalFileImageServiceGetImageBytesById
{
    private byte[] _testBytes = new byte[] { 0x01, 0x02, 0x03 };
    private readonly Mock<IHostingEnvironment> _mockEnvironment = new Mock<IHostingEnvironment>();
    private int _testImageId = 123;
    private string _testFileName = "123.png";
    public LocalFileImageServiceGetImageBytesById()
    {
        // create folder if necessary
        Directory.CreateDirectory(Path.Combine(GetFileDirectory(), "Pics"));
        string filePath = GetFilePath(_testFileName);
        System.IO.File.WriteAllBytes(filePath, _testBytes);
        _mockEnvironment.SetupGet<string>(m => m.ContentRootPath).Returns(GetFileDirectory());
    }
    private string GetFilePath(string fileName)
    {
        return Path.Combine(GetFileDirectory(), "Pics", fileName);
        }
            private string GetFileDirectory()
        {
            var location = System.Reflection.Assembly.GetEntryAssembly().Location;
            return Path.GetDirectoryName(location);
        }

        [Fact]
        public void ReturnsFileContentResultGivenValidId()
        {
            var fileService = new LocalFileImageService(_mockEnvironment.Object);
            var result = fileService.GetImageBytesById(_testImageId);
            Assert.Equal(_testBytes, result);
        }
    }
```

> [!NOTE]
> <span data-ttu-id="efcee-249">test çok basit – kod toplu sistem yapılandırmak ve test altyapısında (diskten okumak için bu durumda, asıl dosyası) oluşturmak gerekli olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="efcee-249">that the test itself is very simple – the bulk of the code is necessary to configure the system and create the testing infrastructure (in this case, an actual file to be read from disk).</span></span> <span data-ttu-id="efcee-250">Birim testleri'den daha karmaşık kurulum çalışması genellikle gerektiren tümleştirme testleri için bu normaldir.</span><span class="sxs-lookup"><span data-stu-id="efcee-250">This is typical for integration tests, which often require more complex setup work than unit tests.</span></span>

## <a name="functional-testing-aspnet-core-apps"></a><span data-ttu-id="efcee-251">İşlevsel bir ASP.NET Core uygulamalarını test etme</span><span class="sxs-lookup"><span data-stu-id="efcee-251">Functional Testing ASP.NET Core Apps</span></span>

<span data-ttu-id="efcee-252">ASP.NET Core uygulamaları TestServer sınıfı işlevsel testleri yazmak oldukça kolay hale getirir.</span><span class="sxs-lookup"><span data-stu-id="efcee-252">For ASP.NET Core applications, the TestServer class makes functional tests fairly easy to write.</span></span> <span data-ttu-id="efcee-253">Normalde, uygulamanız için yaptığınız gibi bir WebHostBuilder kullanarak bir TestServer yapılandırın.</span><span class="sxs-lookup"><span data-stu-id="efcee-253">You configure a TestServer using a WebHostBuilder, just as you normally do for your application.</span></span> <span data-ttu-id="efcee-254">Bu WebHostBuilder yalnızca uygulamanızın gerçek ana bilgisayar gibi yapılandırılması gerekir, ancak test işlemini kolaylaştıran tüm yönleriyle değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="efcee-254">This WebHostBuilder should be configured just like your application's real host, but you can modify any aspects of it that make testing easier.</span></span> <span data-ttu-id="efcee-255">Çoğu zaman, yeniden kullanılabilir bir yöntem (belki de bir taban sınıf) kapsülleyen şekilde birçok test çalışmaları için aynı TestServer yeniden:</span><span class="sxs-lookup"><span data-stu-id="efcee-255">Most of the time, you'll reuse the same TestServer for many test cases, so you can encapsulate it in a reusable method (perhaps in a base class):</span></span>

```csharp
public abstract class BaseWebTest
{
    protected readonly HttpClient _client;
    protected string _contentRoot;

    public BaseWebTest()
    {
        _client = GetClient();
    }

    protected HttpClient GetClient()
    {
        var startupAssembly = typeof(Startup).GetTypeInfo().Assembly;
        _contentRoot = GetProjectPath("src", startupAssembly);
        var builder = new WebHostBuilder()
        .UseContentRoot(_contentRoot)
        .UseStartup<Startup>();
        var server = new TestServer(builder);
        var client = server.CreateClient();
        return client;
    }
}
```

<span data-ttu-id="efcee-256">GetProjectPath yöntemi yalnızca web projesine (indirme örnek çözümü) fiziksel yolu döndürür.</span><span class="sxs-lookup"><span data-stu-id="efcee-256">The GetProjectPath method simply returns the physical path to the web project (download sample solution).</span></span> <span data-ttu-id="efcee-257">WebHostBuilder bu durumda yalnızca burada web uygulaması için içerik kök ve gerçek web uygulamasını kullanan aynı başlangıç sınıfı başvuran belirtir.</span><span class="sxs-lookup"><span data-stu-id="efcee-257">The WebHostBuilder in this case simply specifies where the content root for the web application is, and references the same Startup class the real web application uses.</span></span> <span data-ttu-id="efcee-258">TestServer ile çalışmak için istekleri yapmak için standart System.Net.HttpClient türü kullanın.</span><span class="sxs-lookup"><span data-stu-id="efcee-258">To work with the TestServer, you use the standard System.Net.HttpClient type to make requests to it.</span></span> <span data-ttu-id="efcee-259">TestServer TestServer üzerinde çalışan uygulama isteklerini yapmaya hazır önceden yapılandırılmış bir istemci sağlayan yararlı bir CreateClient yöntemi gösterir.</span><span class="sxs-lookup"><span data-stu-id="efcee-259">TestServer exposes a helpful CreateClient method that provides a pre-configured client that is ready to make requests to the application running on the TestServer.</span></span> <span data-ttu-id="efcee-260">Bu İstemcisi'ni kullanın (korunan ayarlamak \_yukarıdaki temel test istemci üyesinde) işlevsel testleri ASP.NET Core uygulamanız için yazarken:</span><span class="sxs-lookup"><span data-stu-id="efcee-260">You use this client (set to the protected \_client member on the base test above) when writing functional tests for your ASP.NET Core application:</span></span>

```csharp
public class CatalogControllerGetImage : BaseWebTest
{
    [Fact]
    public async Task ReturnsFileContentResultGivenValidId()
    {
        var testFilePath = Path.Combine(_contentRoot, "pics//1.png");
        var expectedFileBytes = File.ReadAllBytes(testFilePath);
        var response = await _client.GetAsync("/catalog/pic/1");
        response.EnsureSuccessStatusCode();
        var streamResponse = await response.Content.ReadAsStreamAsync();
        byte[] byteResult;
        using (var ms = new MemoryStream())
        {
            streamResponse.CopyTo(ms);
            byteResult = ms.ToArray();
        }
        Assert.Equal(expectedFileBytes, byteResult);
    }
}
```

<span data-ttu-id="efcee-261">Bu işlev sınama tüm ara yazılım, filtreleri, bağlayıcıları, yerinde olabilir vb. de dahil olmak üzere tam ASP.NET Core MVC uygulama yığınını uygular.</span><span class="sxs-lookup"><span data-stu-id="efcee-261">This functional test exercises the full ASP.NET Core MVC application stack, including all middleware, filters, binders, etc. that may be in place.</span></span> <span data-ttu-id="efcee-262">Olduğunu doğrular bir rota verilen ("/ PIC/katalog/1") bilinen bir konumda bir dosya için beklenen bayt dizisi döndürür.</span><span class="sxs-lookup"><span data-stu-id="efcee-262">It verifies that a given route ("/catalog/pic/1") returns the expected byte array for a file in a known location.</span></span> <span data-ttu-id="efcee-263">Bunu gerçek web sunucunuzu kurmak ayarlamadan yapar ve bu nedenle, gerçek web kullanarak test etmek için sunucu (örneğin, güvenlik duvarı ayarlarını sorunları) yaşayabilirsiniz brittleness çoğunu önler.</span><span class="sxs-lookup"><span data-stu-id="efcee-263">It does so without setting up a real web server, and so avoids much of the brittleness that using a real web server for testing can experience (for example, problems with firewall settings).</span></span> <span data-ttu-id="efcee-264">TestServer karşı çalıştırmak işlevsel testleri tümleştirme ve birim testleri genellikle yavaştır, ancak ağ üzerinden bir test web sunucusunda çalışır testleri hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="efcee-264">Functional tests that run against TestServer are usually slower than integration and unit tests, but are much faster than tests that would run over the network to a test web server.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="efcee-265">[Önceki](work-with-data-in-asp-net-core-apps.md)
[sonraki](development-process-for-azure.md)</span><span class="sxs-lookup"><span data-stu-id="efcee-265">[Previous](work-with-data-in-asp-net-core-apps.md)
[Next](development-process-for-azure.md)</span></span>

---
title: "Büyük Veriler ve Akış Yapma"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: ab2851f5-966b-4549-80ab-c94c5c0502d2
caps.latest.revision: 
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: e9551fcf4f302be899dcee8737b3bcfad15f1210
ms.sourcegitcommit: cf22b29db780e532e1090c6e755aa52d28273fa6
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/01/2018
---
# <a name="large-data-and-streaming"></a><span data-ttu-id="ea360-102">Büyük Veriler ve Akış Yapma</span><span class="sxs-lookup"><span data-stu-id="ea360-102">Large Data and Streaming</span></span>
[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] <span data-ttu-id="ea360-103">bir XML tabanlı iletişim altyapısıdır.</span><span class="sxs-lookup"><span data-stu-id="ea360-103">is an XML-based communications infrastructure.</span></span> <span data-ttu-id="ea360-104">XML verilerini yaygın olarak tanımlanan standart metin biçiminde kodlanmış çünkü [XML 1.0 belirtimi](http://go.microsoft.com/fwlink/?LinkId=94838), bağlı sistemler geliştiricileri ve mimarlar genellikle açısından gönderilen iletiler kablo ayak izini (veya boyut) hakkında arasında Ağ ve metin tabanlı XML kodlaması, ikili veri verimli aktarımı için özel zorluklar doğurur.</span><span class="sxs-lookup"><span data-stu-id="ea360-104">Because XML data is commonly encoded in the standard text format defined in the [XML 1.0 specification](http://go.microsoft.com/fwlink/?LinkId=94838), connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</span></span>  
  
## <a name="basic-considerations"></a><span data-ttu-id="ea360-105">Temel konuları</span><span class="sxs-lookup"><span data-stu-id="ea360-105">Basic Considerations</span></span>  
 <span data-ttu-id="ea360-106">İçin aşağıdaki bilgileri hakkında bilgiler sağlamak için [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], bu bölümde bazı genel sorunları ve Kodlamalar, ikili veri değerlendirmeleri vurgular ve, genellikle akış bağlı sistemler altyapıları için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="ea360-106">To provide background information about the following information for [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</span></span>  
  
### <a name="encoding-data-text-vs-binary"></a><span data-ttu-id="ea360-107">Kodlama verileri: Metin vs. İkili</span><span class="sxs-lookup"><span data-stu-id="ea360-107">Encoding Data: Text vs. Binary</span></span>  
 <span data-ttu-id="ea360-108">XML kodlama sayısal değerleri önemli ölçüde daha büyük olarak değerlendirilir, yinelenen niteliği başlangıç etiketleri ve bitiş etiketleri nedeniyle ikili biçimlerine kıyasla önemli yüke sahiptir algısına yaygın olarak ifade edilen Geliştirici sorunları içerir metin değerleri ifade edilir ve bir metin biçiminde katıştırmak için özel kodlanmalı çünkü bu ikili verileri verimli bir şekilde açıklanamayan çünkü.</span><span class="sxs-lookup"><span data-stu-id="ea360-108">Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</span></span>  
  
 <span data-ttu-id="ea360-109">Çoğu bu ve benzer ilgiliyse sırasında geçerli olan, bir XML Web Hizmetleri ortamında kodlanmış XML metin iletileri ve eski uzak yordam çağrısı (RPC) ikili olarak kodlanmış iletilerinde gerçek birbirinden genellikle daha az önemli ortamıdır ilk göz önünde bulundurarak önerebilir.</span><span class="sxs-lookup"><span data-stu-id="ea360-109">While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</span></span>  
  
 <span data-ttu-id="ea360-110">XML metin kodlanmış iletileri saydam ve "okunabilir", ikili iletiler genellikle oldukça karşılaştırmaya belirsiz ve Araçlar olmadan çözecek zordur.</span><span class="sxs-lookup"><span data-stu-id="ea360-110">While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</span></span> <span data-ttu-id="ea360-111">Bu fark okunabilirliği ikili iletileri de genellikle satır içi meta veri XML metin iletileri gibi olduğu yükü ekler yükünde taşımak, overlook birine yol açar.</span><span class="sxs-lookup"><span data-stu-id="ea360-111">This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</span></span> <span data-ttu-id="ea360-112">İkili dosya biçimleri için bu özellikle doğrudur kaybetmiş bağ ve dinamik çağırma özellikleri sağlamak üzere hedeflenir.</span><span class="sxs-lookup"><span data-stu-id="ea360-112">This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</span></span>  
  
 <span data-ttu-id="ea360-113">Ancak, ikili biçimler genellikle gibi açıklayıcı meta veri bilgileri "de aşağıdaki veri kayıtları için veri düzeni bildiren bir üst bilgisinde," taşır.</span><span class="sxs-lookup"><span data-stu-id="ea360-113">However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</span></span> <span data-ttu-id="ea360-114">Yükü, ardından bu ortak meta veri bloğu bildirim az ek yük ile izler.</span><span class="sxs-lookup"><span data-stu-id="ea360-114">The payload then follows this common metadata block declaration with minimal further overhead.</span></span> <span data-ttu-id="ea360-115">Buna karşılık, böylece kapsayan meta verileri her bir seri hale getirilmiş yükü nesne için art arda gelen XML her bir veri öğesi bir öğe veya öznitelik barındırır.</span><span class="sxs-lookup"><span data-stu-id="ea360-115">In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</span></span> <span data-ttu-id="ea360-116">Sonuç olarak, tek serileştirilmiş yük nesnenin boyutu her paylaşılan meta verileri açıklamasından ikili biçimi avantajları ancak her ikisi için bazı açıklayıcı meta verileri ifade edilmesi gerekir gibi ikili Beyanları metne karşılaştırılırken benzer ek daha az genel yükü nedeniyle aktarılan yükü nesnesi.</span><span class="sxs-lookup"><span data-stu-id="ea360-116">As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</span></span>  
  
 <span data-ttu-id="ea360-117">Yine de, belirli veri türleri, numaraları gibi bir dezavantajı, sabit boyutlu, ikili sayısal Beyanları kullanmanın olabilir, birkaç bayt daha küçük bir 128-bit decimal türü gibi düz metin yerine, düz metin olarak gösterimi olabilir.</span><span class="sxs-lookup"><span data-stu-id="ea360-117">Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</span></span> <span data-ttu-id="ea360-118">Metin verileri ayrıca bazı ikili biçimleri .NET ikili XML biçimine uygulanmaz, 16 bit veya 32 bit bile Unicode varsayılan ancak seçimleri, kodlama genellikle daha esnek XML metinden boyutu yararları olabilir.</span><span class="sxs-lookup"><span data-stu-id="ea360-118">Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</span></span>  
  
 <span data-ttu-id="ea360-119">Sonuç olarak, metin veya ikili arasında karar ikili iletileri her zaman XML metin iletileri küçük olduğunu varsayarak olarak oldukça olarak kolay değildir.</span><span class="sxs-lookup"><span data-stu-id="ea360-119">As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</span></span>  
  
 <span data-ttu-id="ea360-120">XML metin iletileri Temizle avantajlarından standartlara dayalı ve birlikte çalışabilirlik seçeneklerini ve platform desteği İlkler seçimi teklif ' dir.</span><span class="sxs-lookup"><span data-stu-id="ea360-120">A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="ea360-121">Bu konunun devamındaki "Kodlamalar" bölümü.</span><span class="sxs-lookup"><span data-stu-id="ea360-121"> the "Encodings" section later in this topic.</span></span>  
  
### <a name="binary-content"></a><span data-ttu-id="ea360-122">İkili içerik</span><span class="sxs-lookup"><span data-stu-id="ea360-122">Binary Content</span></span>  
 <span data-ttu-id="ea360-123">Bir alan ikili kodlamaları nerede metin tabanlı Kodlamalar elde edilen ileti boyutu açısından üstün olan resim, video, ses klipleri veya başka bir form hizmetleri arasında alınıp opak, ikili veri gibi büyük ikili veri öğeleri ve bunların Tüketiciler.</span><span class="sxs-lookup"><span data-stu-id="ea360-123">One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</span></span> <span data-ttu-id="ea360-124">Bu veri türlerini XML metni sığması için ortak Base64 kodlaması kullanarak bunları kodlanacak yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="ea360-124">To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</span></span>  
  
 <span data-ttu-id="ea360-125">Base64 ile kodlanmış bir dize, 6-kural tarafından yaygın olarak eklenen ek biçimlendirme karakterlerini (satır başı/satır besleme) saymaz 4:3 kodlama yükünü oranı Base64 için sonuçlanır özgün 8 bit veri bitleri her bir karakteri temsil eder.</span><span class="sxs-lookup"><span data-stu-id="ea360-125">In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</span></span> <span data-ttu-id="ea360-126">Birden fazla 33 500 MB yükü iletirken % boyutu kazanç XML ve ikili kodlamaları arasındaki farklar önemini genellikle senaryoya bağlıdır, ancak genellikle kabul edilebilir değil.</span><span class="sxs-lookup"><span data-stu-id="ea360-126">While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</span></span>  
  
 <span data-ttu-id="ea360-127">Bu ek yükü, ileti iletim en iyi duruma getirme mekanizmasını (MTOM) kodlama önlemek için standart bir iletideki büyük veri öğeleri harici hale getirerek ve bunları iletiyle herhangi özel kodlamadan ikili veri olarak gerçekleştirmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="ea360-127">To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</span></span> <span data-ttu-id="ea360-128">MTOM ile Basit Posta Aktarım Protokolü (SMTP) e-posta iletilerini ekler veya katıştırılmış içerik (Resimler ve diğer katıştırılmış içerik); ile benzer bir şekilde arasında alınıp verilen iletileri MTOM iletileri gerçek SOAP iletisi olan kök bölümüyle multipart/related MIME sıraları olarak paketlenir.</span><span class="sxs-lookup"><span data-stu-id="ea360-128">With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</span></span>  
  
 <span data-ttu-id="ea360-129">Böylece ilgili MIME bölümlerine bakın özel öğesi etiketleri ikili veri içerdiği ileti özgün öğeleri gerçekleşmesi MTOM SOAP iletisi beklemediğiniz kodlanmış sürümünden değiştirilir.</span><span class="sxs-lookup"><span data-stu-id="ea360-129">An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</span></span> <span data-ttu-id="ea360-130">Sonuç olarak, SOAP iletisi ile gönderilen MIME bölümleri göstererek ikili içerik başvuruyor, ancak Aksi durumda yalnızca XML metin veri taşır.</span><span class="sxs-lookup"><span data-stu-id="ea360-130">As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</span></span> <span data-ttu-id="ea360-131">Bu model yakından tanınmış SMTP modeliyle hizalanır çünkü yoktur araç kodlamak ve son derece birlikte çalışabilir bir seçim hangi kolaylaştırır MTOM iletileri birçok platformda kod çözme için desteği geniş.</span><span class="sxs-lookup"><span data-stu-id="ea360-131">Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</span></span>  
  
 <span data-ttu-id="ea360-132">Böylece MTOM kullanmanın yararları, yalnızca bir ikili veri öğesi boyutu yaklaşık 1 KB aştığında görülür yine de, Base64 olarak MTOM ayrıca MIME biçimi için gereken bazı ek ile birlikte gönderilir.</span><span class="sxs-lookup"><span data-stu-id="ea360-132">Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</span></span> <span data-ttu-id="ea360-133">Ek yükü nedeniyle, iletileri MTOM kodlu ikili yükü bu eşiğin altında kalırsa ikili veriler için Base64 kodlaması kullanan iletileri daha büyük olabilir.</span><span class="sxs-lookup"><span data-stu-id="ea360-133">Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="ea360-134">Bu konunun devamındaki "Kodlamalar" bölümü.</span><span class="sxs-lookup"><span data-stu-id="ea360-134"> the "Encodings" section later in this topic.</span></span>  
  
### <a name="large-data-content"></a><span data-ttu-id="ea360-135">Büyük veri içeriği</span><span class="sxs-lookup"><span data-stu-id="ea360-135">Large Data Content</span></span>  
 <span data-ttu-id="ea360-136">Kablo Ayak izi kenara, yukarıda açıklanan 500 MB yükü konumundaki bir harika yerel zorluk hizmet ve istemci için de oluşturur.</span><span class="sxs-lookup"><span data-stu-id="ea360-136">Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</span></span> <span data-ttu-id="ea360-137">Varsayılan olarak, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] iletileri işleyen *arabellekli modu*.</span><span class="sxs-lookup"><span data-stu-id="ea360-137">By default, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] processes messages in *buffered mode*.</span></span> <span data-ttu-id="ea360-138">Bu, bir iletinin tüm içeriği bellekte mevcut gönderilmeden önce veya alındıktan sonra olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="ea360-138">This means that the entire content of a message is present in memory before it is sent or after it is received.</span></span> <span data-ttu-id="ea360-139">Çoğu senaryo için iyi bir stratejisi ve dijital imzalar ve güvenilir teslim gibi Mesajlaşma özellikleri için gerekli olmakla birlikte, büyük iletileri bir sistem kaynaklarının tüketebileceği.</span><span class="sxs-lookup"><span data-stu-id="ea360-139">While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</span></span>  
  
 <span data-ttu-id="ea360-140">Büyük yükleri ile mücadele etmek için stratejisi akış.</span><span class="sxs-lookup"><span data-stu-id="ea360-140">The strategy to deal with large payloads is streaming.</span></span> <span data-ttu-id="ea360-141">Hata iletileri, özellikle XML'de, ifade yaygın olarak zorlayıcı nispeten küçük veri paketleri olacak şekilde, bir ileti birden çok gigabayta olmalı ve bir veri paketi birden çok sürekli veri akışı benzer.</span><span class="sxs-lookup"><span data-stu-id="ea360-141">While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</span></span> <span data-ttu-id="ea360-142">Veri akış modunda arabellekli modu yerine aktarıldığında, gönderenin ileti gövdesi içeriğini bir akış şeklinde alıcıya kullanılabilmesini sağlar ve bu duruma ileti altyapısı sürekli veri gönderenden alıcıya iletir kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="ea360-142">When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</span></span>  
  
 <span data-ttu-id="ea360-143">En yaygın senaryo aktarımları ortaya tür büyük veri içeriği ikili veri aktarımlarını olan nesneler:</span><span class="sxs-lookup"><span data-stu-id="ea360-143">The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</span></span>  
  
-   <span data-ttu-id="ea360-144">Kolayca bir ileti dizisi bölünemez.</span><span class="sxs-lookup"><span data-stu-id="ea360-144">Cannot be easily broken up into a message sequence.</span></span>  
  
-   <span data-ttu-id="ea360-145">Zamanında teslim edilmelidir.</span><span class="sxs-lookup"><span data-stu-id="ea360-145">Must be delivered in a timely manner.</span></span>  
  
-   <span data-ttu-id="ea360-146">Aktarım başlatıldığında tamamen içinde kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="ea360-146">Are not available in their entirety when the transfer is initiated.</span></span>  
  
 <span data-ttu-id="ea360-147">Bu kısıtlamaların yok verileri için daha büyük bir ileti bir oturumun kapsamı içinde iletilerinin dizileri göndermek genellikle daha iyi olur.</span><span class="sxs-lookup"><span data-stu-id="ea360-147">For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="ea360-148">Bu konunun devamındaki "Veri akışı" bölümü.</span><span class="sxs-lookup"><span data-stu-id="ea360-148"> the "Streaming Data" section later in this topic.</span></span>  
  
 <span data-ttu-id="ea360-149">Büyük miktarlarda verinin gönderirken ayarlamanız gerekir `maxAllowedContentLength` IIS ayarını (daha fazla bilgi için bkz: [yapılandırma IIS istek sınırları](http://go.microsoft.com/fwlink/?LinkId=253165)) ve `maxReceivedMessageSize` ayarı bağlama (örneğin [ System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) veya <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span><span class="sxs-lookup"><span data-stu-id="ea360-149">When sending large amounts of data you will need to set the `maxAllowedContentLength` IIS setting (for more information see [Configuring IIS Request Limits](http://go.microsoft.com/fwlink/?LinkId=253165)) and the `maxReceivedMessageSize` binding setting (for example [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) or <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span></span> <span data-ttu-id="ea360-150">`maxAllowedContentLength` 28.6 M özelliği varsayılanlara ve `maxReceivedMessageSize` özellik varsayılanlarını 64 KB.</span><span class="sxs-lookup"><span data-stu-id="ea360-150">The `maxAllowedContentLength` property defaults to 28.6 M and the `maxReceivedMessageSize` property defaults to 64KB.</span></span>  
  
## <a name="encodings"></a><span data-ttu-id="ea360-151">Encodings</span><span class="sxs-lookup"><span data-stu-id="ea360-151">Encodings</span></span>  
 <span data-ttu-id="ea360-152">Bir *kodlama* kablo iletileri sunmak nasıl hakkında kurallar kümesini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="ea360-152">An *encoding* defines a set of rules about how to present messages on the wire.</span></span> <span data-ttu-id="ea360-153">Bir *Kodlayıcı* böyle bir kodlama uygulayan ve dönüş için Gönderen tarafında sorumlu olduğu bir <xref:System.ServiceModel.Channels.Message> bellek içi iletisine bayt akışı veya ağ üzerinden gönderilen bayt arabellek.</span><span class="sxs-lookup"><span data-stu-id="ea360-153">An *encoder* implements such an encoding and is responsible, on the sender side, for turning a <xref:System.ServiceModel.Channels.Message> in-memory message into a byte stream or byte buffer that can be sent across the network.</span></span> <span data-ttu-id="ea360-154">Alıcı tarafında bir bayt dizisi bir bellek içi iletisine Kodlayıcı etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="ea360-154">On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</span></span>  
  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] <span data-ttu-id="ea360-155">üç kodlayıcılar içerir ve gerekirse, yazma ve kendi kodlayıcılara takın olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="ea360-155">includes three encoders and allows you to write and plug in your own encoders, if necessary.</span></span>  
  
 <span data-ttu-id="ea360-156">Her standart bağlamaları yapabildiği Net \* önek bağlamalarla kullanmak ikili kodlama önceden yapılandırılmış bir kodlayıcı içerir (ekleyerek <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> sınıfı) sırada <xref:System.ServiceModel.BasicHttpBinding> ve <xref:System.ServiceModel.WSHttpBinding> sınıflarını kullanın (tarafından metin ileti kodlayıcı <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> sınıfı) varsayılan olarak.</span><span class="sxs-lookup"><span data-stu-id="ea360-156">Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net\* prefix use the binary encoder (by including the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> class) while the <xref:System.ServiceModel.BasicHttpBinding> and <xref:System.ServiceModel.WSHttpBinding> classes use the text message encoder (by means of the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> class) by default.</span></span>  
  
|<span data-ttu-id="ea360-157">Kodlayıcı bağlama öğesi</span><span class="sxs-lookup"><span data-stu-id="ea360-157">Encoder binding element</span></span>|<span data-ttu-id="ea360-158">Açıklama</span><span class="sxs-lookup"><span data-stu-id="ea360-158">Description</span></span>|  
|-----------------------------|-----------------|  
|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>|<span data-ttu-id="ea360-159">Metin ileti Kodlayıcı tüm HTTP tabanlı bağlamaları için varsayılan kodlayıcı ve tüm özel bağlamaları için uygun seçim birlikte çalışabilirlik yüksek önemli olduğu.</span><span class="sxs-lookup"><span data-stu-id="ea360-159">The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</span></span> <span data-ttu-id="ea360-160">Bu Kodlayıcı okur ve standart SOAP 1.1/SOAP 1.2 metin iletileri ikili veriler için hiçbir özel işleme ile yazar.</span><span class="sxs-lookup"><span data-stu-id="ea360-160">This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</span></span> <span data-ttu-id="ea360-161">Varsa <xref:System.ServiceModel.Channels.MessageVersion> bir ileti kümesine `None`, SOAP Zarfı sarmalayıcı çıktısını atlanır ve yalnızca ileti gövdesi içeriği seri.</span><span class="sxs-lookup"><span data-stu-id="ea360-161">If the <xref:System.ServiceModel.Channels.MessageVersion> of a message is set to `None`, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</span></span>|  
|<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>|<span data-ttu-id="ea360-162">MTOM ileti Kodlayıcı ikili veriler için bir özel işleme uygulayan ve kesinlikle bir olay iyileştirme yardımcı olduğundan herhangi bir standart bağlamaları varsayılan olarak kullanılmayan bir metin Kodlayıcı ' dir.</span><span class="sxs-lookup"><span data-stu-id="ea360-162">The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</span></span> <span data-ttu-id="ea360-163">İletinin nerede MTOM kodlama bir avantajı verir bir eşiği aştığında ikili veri içeriyorsa, verileri ileti zarfı aşağıdaki MIME bölümüne externalized.</span><span class="sxs-lookup"><span data-stu-id="ea360-163">If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</span></span> <span data-ttu-id="ea360-164">Bu bölümde etkinleştirme MTOM bakın.</span><span class="sxs-lookup"><span data-stu-id="ea360-164">See Enabling MTOM later in this section.</span></span>|  
|<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>|<span data-ttu-id="ea360-165">Her iki iletişim kuran tarafların dayalı zaman ikili ileti Kodlayıcı Net \* bağlar ve uygun seçeneği için varsayılan kodlayıcı olduğuna [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span><span class="sxs-lookup"><span data-stu-id="ea360-165">The binary message encoder is the default encoder for the Net\* bindings and the appropriate choice whenever both communicating parties are based on [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span></span> <span data-ttu-id="ea360-166">İkili ileti Kodlayıcı .NET ikili XML biçimi, genellikle eşdeğer XML 1.0 gösterimi daha küçük bir yer verir ve ikili veri bayt olarak kodlar XML bilgi kümeleri (Infosets) Microsoft'a özgü ikili temsili kullanır Akış.</span><span class="sxs-lookup"><span data-stu-id="ea360-166">The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</span></span>|  
  
 <span data-ttu-id="ea360-167">İleti metni kodlama genellikle en iyi birlikte çalışabilirlik, herhangi bir iletişim yolu için en iyi seçenek iken ikili ileti kodlama gerektiren herhangi bir iletişim yolu için seçimdir.</span><span class="sxs-lookup"><span data-stu-id="ea360-167">Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</span></span> <span data-ttu-id="ea360-168">İkili ileti kodlama genellikle boyutları tek iletiyi ve aşamalı olarak daha küçük ileti metni boyutları iletişim oturumu süresince karşılaştırıldığında daha küçük ileti verir.</span><span class="sxs-lookup"><span data-stu-id="ea360-168">Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</span></span> <span data-ttu-id="ea360-169">Metin kodlaması, aksine ikili kodlama Örneğin, Base64 kullanarak ikili veriler için özel olarak işlenmesi kullanmak zorunda kalmazsınız ancak bayt bayt olarak temsil eder.</span><span class="sxs-lookup"><span data-stu-id="ea360-169">Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</span></span>  
  
 <span data-ttu-id="ea360-170">Çözümünüzü birlikte çalışabilirlik, gerektirmez, ancak hala HTTP aktarımı kullanmak istediğiniz, oluşturmak <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> kullanan özel bağlama içine <xref:System.ServiceModel.Channels.HttpTransportBindingElement> taşıma için sınıf.</span><span class="sxs-lookup"><span data-stu-id="ea360-170">If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> into a custom binding that uses the <xref:System.ServiceModel.Channels.HttpTransportBindingElement> class for the transport.</span></span> <span data-ttu-id="ea360-171">Hizmetinizi istemcilerde çeşitli birlikte çalışabilirlik gerekiyorsa, her etkin ilgili istemciler için uygun bir taşıma ve kodlama seçimi sahip paralel uç noktalarını kullanıma önerilir.</span><span class="sxs-lookup"><span data-stu-id="ea360-171">If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</span></span>  
  
### <a name="enabling-mtom"></a><span data-ttu-id="ea360-172">MTOM etkinleştirme</span><span class="sxs-lookup"><span data-stu-id="ea360-172">Enabling MTOM</span></span>  
 <span data-ttu-id="ea360-173">Ne zaman birlikte çalışabilirlik bir gereksinimdir ve büyük ikili veri gönderilmeyecek sonra ileti MTOM kodlama olduğundan üzerinde standart etkinleştirebilirsiniz stratejisi kodlama alternatif <xref:System.ServiceModel.BasicHttpBinding> veya <xref:System.ServiceModel.WSHttpBinding> ilgili ayarlayarak bağlamaları `MessageEncoding` özelliğine <xref:System.ServiceModel.WSMessageEncoding.Mtom> veya oluşturma <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> içine bir <xref:System.ServiceModel.Channels.CustomBinding>.</span><span class="sxs-lookup"><span data-stu-id="ea360-173">When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <xref:System.ServiceModel.BasicHttpBinding> or <xref:System.ServiceModel.WSHttpBinding> bindings by setting the respective `MessageEncoding` property to <xref:System.ServiceModel.WSMessageEncoding.Mtom> or by composing the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> into a <xref:System.ServiceModel.Channels.CustomBinding>.</span></span> <span data-ttu-id="ea360-174">Ayıklanan aşağıdaki kod örneği, [MTOM kodlama](../../../../docs/framework/wcf/samples/mtom-encoding.md) örnek yapılandırmada MTOM etkinleştirme gösterir.</span><span class="sxs-lookup"><span data-stu-id="ea360-174">The following example code, extracted from the [MTOM Encoding](../../../../docs/framework/wcf/samples/mtom-encoding.md) sample demonstrates how to enable MTOM in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <wsHttpBinding>  
        <binding name="ExampleBinding" messageEncoding="Mtom"/>  
      </wsHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="ea360-175">Daha önce belirtildiği gibi MTOM kodlama kullanmaya karar göndermekte olduğunuz veri biriminde bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="ea360-175">As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</span></span> <span data-ttu-id="ea360-176">Ayrıca, MTOM etkinleştirilmesi MTOM bağlama düzeyinde etkinleştirilmiş olduğundan, tüm işlemleri belirli bir noktadaki etkiler.</span><span class="sxs-lookup"><span data-stu-id="ea360-176">Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</span></span>  
  
 <span data-ttu-id="ea360-177">MTOM Kodlayıcısı her zaman ikili veri externalized yukarı olup sonlandırır bağımsız olarak MTOM kodlu MIME/çok-part iletisine yayar olduğundan, genellikle yalnızca MTOM birden çok 1 KB ikili veri iletilerle exchange uç noktalar için etkinleştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="ea360-177">Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</span></span> <span data-ttu-id="ea360-178">Ayrıca, MTOM etkin uç noktaları ile kullanılmak üzere tasarlanmış Hizmet sözleşmeleri mümkün olduğunda, bu tür veri aktarım işlemleri belirtmek için kısıtlı gerekir.</span><span class="sxs-lookup"><span data-stu-id="ea360-178">Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</span></span> <span data-ttu-id="ea360-179">İlgili denetim işlevselliği ayrı bir sözleşmesinde yer almalıdır.</span><span class="sxs-lookup"><span data-stu-id="ea360-179">Related control functionality should reside on a separate contract.</span></span> <span data-ttu-id="ea360-180">Yalnızca bir MTOM etkin uç noktası aracılığıyla gönderilen iletiler bu "Yalnızca MTOM" kuralının uygulanacağı; MTOM Kodlayıcısı kod çözme ve gelen MTOM olmayan iletileri de ayrıştırılamadı.</span><span class="sxs-lookup"><span data-stu-id="ea360-180">This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</span></span>  
  
 <span data-ttu-id="ea360-181">MTOM Kodlayıcısı kullanarak, uygun diğer tüm [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] özellikleri.</span><span class="sxs-lookup"><span data-stu-id="ea360-181">Using the MTOM encoder conforms with all other [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] features.</span></span> <span data-ttu-id="ea360-182">Bu kural oturum desteği gerekli olduğunda gibi tüm durumlarda izlemek mümkün olmayabilir olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="ea360-182">Note that it may not be possible to observe this rule in all cases, such as when session support is required.</span></span>  
  
### <a name="programming-model"></a><span data-ttu-id="ea360-183">Programlama Modeli</span><span class="sxs-lookup"><span data-stu-id="ea360-183">Programming Model</span></span>  
 <span data-ttu-id="ea360-184">Uygulamanızda kullanmak üç yerleşik kodlayıcılar bağımsız olarak, bir programlama deneyimi ikili veri aktarma göre aynıdır.</span><span class="sxs-lookup"><span data-stu-id="ea360-184">Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</span></span> <span data-ttu-id="ea360-185">Nasıl farktır [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] kendi veri türlerine bağlı verileri işler.</span><span class="sxs-lookup"><span data-stu-id="ea360-185">The difference is in how [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] handles the data based on their data types.</span></span>  
  
```  
[DataContract]  
class MyData  
{  
    [DataMember]  
    byte[] binaryBuffer;  
    [DataMember]  
    string someStringData;  
}   
```  
  
 <span data-ttu-id="ea360-186">MTOM kullanırken, önceki veri sözleşmesi aşağıdaki kurallara göre sıralanır:</span><span class="sxs-lookup"><span data-stu-id="ea360-186">When using MTOM, the preceding data contract is serialized according to the following rules:</span></span>  
  
-   <span data-ttu-id="ea360-187">Varsa `binaryBuffer` değil `null` ve tek tek MTOM externalization yükünü (MIME Üstbilgileri vb.) iki yana yaslamak için yeterli veri içeren Base64 karşılaştırıldığında kodlama, veriler externalized ve ikili bir MIME parçası olarak iletiyle taşınan.</span><span class="sxs-lookup"><span data-stu-id="ea360-187">If `binaryBuffer` is not `null` and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</span></span> <span data-ttu-id="ea360-188">Eşik aşılırsa değil, veriler Base64 kodlanmış.</span><span class="sxs-lookup"><span data-stu-id="ea360-188">If the threshold is not exceeded, the data is encoded as Base64.</span></span>  
  
-   <span data-ttu-id="ea360-189">Dize (ve ikili olmayan tüm diğer türleri) her zaman boyutu ne olursa olsun ileti gövdesi içinde bir dize olarak gösterilir.</span><span class="sxs-lookup"><span data-stu-id="ea360-189">The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</span></span>  
  
 <span data-ttu-id="ea360-190">MTOM kodlama aynı önceki örnekte gösterildiği gibi bir açık veri sözleşmesi kullanıp bir işlemde bir parametre listesi kullanın, iç içe veri sözleşmeleri veya bir veri sözleşmesi nesnesi bir koleksiyon içinde aktarım etkisidir.</span><span class="sxs-lookup"><span data-stu-id="ea360-190">The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</span></span> <span data-ttu-id="ea360-191">Bayt dizileri her zaman en iyi duruma getirme adaylar ve en iyi duruma getirme eşikleri karşılanıyorsa en iyi duruma getirilir.</span><span class="sxs-lookup"><span data-stu-id="ea360-191">Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ea360-192">Değil kullanarak <xref:System.IO.Stream?displayProperty=nameWithType> türetilmiş tür veri sözleşmeleri içinde.</span><span class="sxs-lookup"><span data-stu-id="ea360-192">You should not be using <xref:System.IO.Stream?displayProperty=nameWithType> derived types inside of data contracts.</span></span> <span data-ttu-id="ea360-193">Aşağıdaki "Veri akışı" bölümünde açıklanan akış modeli kullanarak veri akışı bildirilmesi.</span><span class="sxs-lookup"><span data-stu-id="ea360-193">Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</span></span>  
  
## <a name="streaming-data"></a><span data-ttu-id="ea360-194">Veri akışı</span><span class="sxs-lookup"><span data-stu-id="ea360-194">Streaming Data</span></span>  
 <span data-ttu-id="ea360-195">Büyük miktarda veri aktarmak için akış aktarım modunda olduğunda [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] arabelleğe alma ve tamamen bellekte iletileri işleme varsayılan davranışı için uygun bir alternatiftir.</span><span class="sxs-lookup"><span data-stu-id="ea360-195">When you have a large amount of data to transfer, the streaming transfer mode in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span>  
  
 <span data-ttu-id="ea360-196">Daha önce belirtildiği gibi yalnızca büyük iletiler (içerikle metin veya ikili) için ileti zamanında teslim edilmelidir, verileri, kesimlere olamaz veya aktarımı başlatıldığında verileri henüz tam olarak kullanılabilir değilse, akış etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="ea360-196">As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</span></span>  
  
### <a name="restrictions"></a><span data-ttu-id="ea360-197">Kısıtlamalar</span><span class="sxs-lookup"><span data-stu-id="ea360-197">Restrictions</span></span>  
 <span data-ttu-id="ea360-198">Çok sayıda kullanamazsınız [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] akış etkinleştirildiğinde özellikleri:</span><span class="sxs-lookup"><span data-stu-id="ea360-198">You cannot use a significant number of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] features when streaming is enabled:</span></span>  
  
-   <span data-ttu-id="ea360-199">Dijital imzalar ileti gövdesi için bir karma tüm ileti içeriği bilgi işlem gerektirdiğinden gerçekleştirilemiyor.</span><span class="sxs-lookup"><span data-stu-id="ea360-199">Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</span></span> <span data-ttu-id="ea360-200">Akış ile içerik ileti üstbilgilerini oluşturulan ve gönderilen ve bu nedenle, bir dijital imza hesaplanamıyor, tam olarak kullanılabilir değil.</span><span class="sxs-lookup"><span data-stu-id="ea360-200">With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</span></span>  
  
-   <span data-ttu-id="ea360-201">Şifreleme, verileri yeniden doğru yapılandırılmış olduğunu doğrulamak için dijital imzaları bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="ea360-201">Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</span></span>  
  
-   <span data-ttu-id="ea360-202">Güvenilir oturumlar bir ileti aktarımı kaybederseniz gönderilen ileti yeniden teslim için istemcisinde arabellek gerekir ve durumda iletileri alınan ileti sırası korumak için hizmet uygulaması için teslim etmeden önce hizmette iletileri tutun gerekir Çıkış sıra.</span><span class="sxs-lookup"><span data-stu-id="ea360-202">Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</span></span>  
  
 <span data-ttu-id="ea360-203">Bu işlev kısıtlamaları nedeniyle yalnızca aktarım düzeyinde güvenlik seçenekleri akış ve güvenilir oturumlar dışı bırakamazsınız kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ea360-203">Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</span></span> <span data-ttu-id="ea360-204">Akış yalnızca aşağıdaki sistem tarafından tanımlanan bağlamalarla kullanılabilir:</span><span class="sxs-lookup"><span data-stu-id="ea360-204">Streaming is only available with the following system-defined bindings:</span></span>  
  
-   <xref:System.ServiceModel.BasicHttpBinding>  
  
-   <xref:System.ServiceModel.NetTcpBinding>  
  
-   <xref:System.ServiceModel.NetNamedPipeBinding>  
  
-   <xref:System.ServiceModel.WebHttpBinding>  
  
 <span data-ttu-id="ea360-205">Çünkü, temel alınan taşımalarına <xref:System.ServiceModel.NetTcpBinding> ve <xref:System.ServiceModel.NetNamedPipeBinding> yapısında güvenilir teslim ve Destek, oturum bağlantısı tabanlı sahip HTTP, bu iki bağlamaları sağlamaları ile fazla ilgilenmez uygulamada bu kısıtlamaların etkilenir.</span><span class="sxs-lookup"><span data-stu-id="ea360-205">Because the underlying transports of <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</span></span>  
  
 <span data-ttu-id="ea360-206">Akış ile Message Queuing (MSMQ) aktarma kullanılamıyor ve bu nedenle kullanılamaz <xref:System.ServiceModel.NetMsmqBinding> veya <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="ea360-206">Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="ea360-207">Diğer tüm aktarımları çoğunluğu senaryoları için tüm pratik ileti boyut sınırı yoktur ancak Message Queuing aktarım yalnızca kısıtlı ileti boyutu ile arabelleğe alınan veri aktarımlarını destekler.</span><span class="sxs-lookup"><span data-stu-id="ea360-207">The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</span></span>  
  
 <span data-ttu-id="ea360-208">Akış değil de kullanılabilir eş kanal taşıma kullanan şekilde olmadığında bulunan <xref:System.ServiceModel.NetPeerTcpBinding>.</span><span class="sxs-lookup"><span data-stu-id="ea360-208">Streaming is also not available when using the Peer Channel transport, so is not available with the <xref:System.ServiceModel.NetPeerTcpBinding>.</span></span>  
  
#### <a name="streaming-and-sessions"></a><span data-ttu-id="ea360-209">Akış ve oturumlar</span><span class="sxs-lookup"><span data-stu-id="ea360-209">Streaming and Sessions</span></span>  
 <span data-ttu-id="ea360-210">Oturum tabanlı bir bağlamayla çağrıları akış sırasında beklenmeyen bir davranış elde edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ea360-210">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="ea360-211">Tüm akış çağrılar kullanılan bağlama oturumları kullanacak şekilde yapılandırılmış olsa bile, oturumlar desteklemeyen bir tek kanalı (veri birimi kanalı) yapılır.</span><span class="sxs-lookup"><span data-stu-id="ea360-211">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="ea360-212">Birden çok istemci aynı hizmet nesnesi akış çağrıları üzerinden oturum tabanlı bağlama yapmak ve hizmet nesnenin eşzamanlılık modu ayarlamak tek ve onun örnek bağlamı modu değeri PerSession olarak ayarlandığında, tüm çağrıları veri birimi kanalı ve bu nedenle yalnızca biri gitmeniz gerekir Çağrı aynı anda işlenir.</span><span class="sxs-lookup"><span data-stu-id="ea360-212">If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="ea360-213">Bir veya daha fazla istemciler daha sonra zaman aşımına olabilir. Bu sorunun geçici çözümü için ya da hizmet nesnenin örnek bağlamı modu PerCall veya birden çok eşzamanlılık ayarlayarak.</span><span class="sxs-lookup"><span data-stu-id="ea360-213">One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ea360-214">Kullanılabilir tek "oturumu" olduğundan MaxConcurrentSessions bu durumda etkisi yoktur.</span><span class="sxs-lookup"><span data-stu-id="ea360-214">MaxConcurrentSessions has no effect in this case because there is only one "session" available.</span></span>  
  
### <a name="enabling-streaming"></a><span data-ttu-id="ea360-215">Akış etkinleştirme</span><span class="sxs-lookup"><span data-stu-id="ea360-215">Enabling Streaming</span></span>  
 <span data-ttu-id="ea360-216">Aşağıdaki yollarla akış etkinleştirebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="ea360-216">You can enable streaming in the following ways:</span></span>  
  
-   <span data-ttu-id="ea360-217">Gönder ve akış modunda isteklerini kabul etmek ve kabul ve yanıtların arabelleğe alınan modunda dönmek (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span><span class="sxs-lookup"><span data-stu-id="ea360-217">Send and accept requests in streaming mode, and accept and return responses in buffered mode (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span></span>  
  
-   <span data-ttu-id="ea360-218">Gönderme ve arabelleğe alınan modunda isteklerini kabul etmek ve kabul etmek ve yanıtları akış modunda dönmek (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span><span class="sxs-lookup"><span data-stu-id="ea360-218">Send and accept requests in buffered mode, and accept and return responses in streamed mode (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span></span>  
  
-   <span data-ttu-id="ea360-219">Gönderir ve her iki yönde akış modunda isteklerini ve yanıtlarını alır.</span><span class="sxs-lookup"><span data-stu-id="ea360-219">Send and receive requests and responses in streamed mode in both directions.</span></span> <span data-ttu-id="ea360-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span><span class="sxs-lookup"><span data-stu-id="ea360-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span></span>  
  
 <span data-ttu-id="ea360-221">Aktarım modunu ayarlayarak akış devre dışı bırakabilirsiniz <xref:System.ServiceModel.TransferMode.Buffered>, tüm bağlamaları varsayılan ayarı olduğu.</span><span class="sxs-lookup"><span data-stu-id="ea360-221">You can disable streaming by setting the transfer mode to <xref:System.ServiceModel.TransferMode.Buffered>, which is the default setting on all bindings.</span></span> <span data-ttu-id="ea360-222">Aşağıdaki kod, yapılandırmada aktarım modu ayarlamak gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="ea360-222">The following code shows how to set the transfer mode in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <basicHttpBinding>  
        <binding name="ExampleBinding" transferMode="Streaming"/>  
      </basicHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="ea360-223">Kodda, bağlamanın örneğini, ilgili ayarlamalısınız `TransferMode` bağlama (veya özel bağlama oluşturuyorsanız aktarım bağlama öğesi) özelliğini yukarıda açıklanan değerlerden birine.</span><span class="sxs-lookup"><span data-stu-id="ea360-223">When you instantiate your binding in code, you must set the respective `TransferMode` property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</span></span>  
  
 <span data-ttu-id="ea360-224">Her iki yönünde bağımsız olarak her iki tarafında da iletişim kuran tarafların veya istekleri ve yanıtları için işlevselliği etkilemeden akışı kapatabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ea360-224">You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</span></span> <span data-ttu-id="ea360-225">Ancak, her zaman aktarılan veri boyutu akış etkinleştirme iletişimi sağlayan bir bağlantı üzerindeki her iki uç noktaları düzeltilir kadar önemli olduğunu varsayın.</span><span class="sxs-lookup"><span data-stu-id="ea360-225">However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</span></span> <span data-ttu-id="ea360-226">Burada uç noktalardan biri uygulanmadı ile platformlar arası iletişim için [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], akış kullanma yeteneğini platformun akış özelliklerine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="ea360-226">For cross-platform communication where one of the endpoints is not implemented with [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], the ability to use streaming depends on the platform's streaming capabilities.</span></span> <span data-ttu-id="ea360-227">Nadir başka bir özel durum, burada bir istemci veya hizmet kendi çalışma kümesinin en aza gerekir ve yalnızca küçük bir arabellek boyutu destekleyebilir senaryo tabanlı bir bellek tüketimi olabilir.</span><span class="sxs-lookup"><span data-stu-id="ea360-227">Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</span></span>  
  
### <a name="enabling-asynchronous-streaming"></a><span data-ttu-id="ea360-228">Zaman uyumsuz akış etkinleştirme</span><span class="sxs-lookup"><span data-stu-id="ea360-228">Enabling Asynchronous Streaming</span></span>  
 <span data-ttu-id="ea360-229">Zaman uyumsuz akışını etkinleştirmek için ekleme <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> uç noktası davranışı hizmeti ana bilgisayarı ve kümesi için kendi <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> özelliğine `true`.</span><span class="sxs-lookup"><span data-stu-id="ea360-229">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="ea360-230">Doğru zaman uyumsuz gönderme tarafında akış özelliği de ekledik.</span><span class="sxs-lookup"><span data-stu-id="ea360-230">We have also added the capability of true asynchronous streaming on the send side.</span></span> <span data-ttu-id="ea360-231">Bu, burada iletileri bazıları okumada Ağ Tıkanıklığı nedeni yavaş ya da hiç okuma olmayan birden çok istemciye akış senaryoları hizmetinde ölçeklenebilirliğini artırır.</span><span class="sxs-lookup"><span data-stu-id="ea360-231">This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</span></span> <span data-ttu-id="ea360-232">Bu senaryolarda biz şimdi istemci başına hizmet üzerinde tek tek iş parçacığı engellemez.</span><span class="sxs-lookup"><span data-stu-id="ea360-232">In these scenarios we now do not block individual threads on the service per client.</span></span> <span data-ttu-id="ea360-233">Bu hizmet böylece hizmet ölçeklenebilirliğini geliştirmek çok daha fazla istemci işleyebilmesi olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="ea360-233">This ensures that the service is able to process many more clients thereby improving the scalability of the service.</span></span>  
  
### <a name="programming-model-for-streamed-transfers"></a><span data-ttu-id="ea360-234">Akış aktarımları için programlama modeli</span><span class="sxs-lookup"><span data-stu-id="ea360-234">Programming Model for Streamed Transfers</span></span>  
 <span data-ttu-id="ea360-235">Akış için programlama modelini basittir.</span><span class="sxs-lookup"><span data-stu-id="ea360-235">The programming model for streaming is straightforward.</span></span> <span data-ttu-id="ea360-236">Akış veri almak için tek bir sahip bir işlem sözleşmesi belirtin <xref:System.IO.Stream> giriş parametresi belirtilmiş.</span><span class="sxs-lookup"><span data-stu-id="ea360-236">For receiving streamed data, specify an operation contract that has a single <xref:System.IO.Stream> typed input parameter.</span></span> <span data-ttu-id="ea360-237">Akış veri döndürmek için dönüş bir <xref:System.IO.Stream> başvuru.</span><span class="sxs-lookup"><span data-stu-id="ea360-237">For returning streamed data, return a <xref:System.IO.Stream> reference.</span></span>  
  
```  
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IStreamedService  
{  
    [OperationContract]  
    Stream Echo(Stream data);  
    [OperationContract]  
    Stream RequestInfo(string query);  
    [OperationContract(OneWay=true)]  
    void ProvideInfo(Stream data);  
}  
```  
  
 <span data-ttu-id="ea360-238">İşlemi `Echo` önceki örnekte alır ve bir akış döndürür ve bu nedenle sahip bir bağlama üzerinde kullanılmalıdır <xref:System.ServiceModel.TransferMode.Streamed>.</span><span class="sxs-lookup"><span data-stu-id="ea360-238">The operation `Echo` in the preceding example receives and returns a stream and should therefore be used on a binding with <xref:System.ServiceModel.TransferMode.Streamed>.</span></span> <span data-ttu-id="ea360-239">İşlem için `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> yalnızca döndürdüğünden en uygun olan bir <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="ea360-239">For the operation `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> is best suited, because it only returns a <xref:System.IO.Stream>.</span></span> <span data-ttu-id="ea360-240">Tek yönlü işlem için uygundur <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span><span class="sxs-lookup"><span data-stu-id="ea360-240">The one-way operation is best suited for <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span></span>  
  
 <span data-ttu-id="ea360-241">Bu ikinci bir parametresi şu şekilde ekleme Not `Echo` veya `ProvideInfo` işlemleri için arabelleğe alınan bir strateji geri dönmek ve akış çalışma zamanı serileştirme gösterimini kullanmak hizmet modeli neden olur.</span><span class="sxs-lookup"><span data-stu-id="ea360-241">Note that adding a second parameter to the following `Echo` or `ProvideInfo` operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</span></span> <span data-ttu-id="ea360-242">Yalnızca bir tek Giriş akışı parametresiyle işlemleri akış uçtan uca istekle uyumlu değildir.</span><span class="sxs-lookup"><span data-stu-id="ea360-242">Only operations with a single input stream parameter are compatible with end-to-end request streaming.</span></span>  
  
 <span data-ttu-id="ea360-243">Bu kural için ileti sözleşmeleri benzer şekilde uygular.</span><span class="sxs-lookup"><span data-stu-id="ea360-243">This rule similarly applies to message contracts.</span></span> <span data-ttu-id="ea360-244">Aşağıdaki ileti sözleşmede gösterildiği gibi bir akışı, ileti sözleşmesi yalnızca tek gövde üyesi olabilir.</span><span class="sxs-lookup"><span data-stu-id="ea360-244">As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</span></span> <span data-ttu-id="ea360-245">Ek bilgi akış ile iletişim kurmak istiyorsanız, bu bilgileri bir taşınan ileti üstbilgilerinde olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="ea360-245">If you want to communicate additional information with the stream, this information must be a carried in message headers.</span></span> <span data-ttu-id="ea360-246">İleti gövdesi akış içeriğini özel olarak ayrılmış.</span><span class="sxs-lookup"><span data-stu-id="ea360-246">The message body is exclusively reserved for the stream content.</span></span>  
  
```  
[MessageContract]  
public class UploadStreamMessage  
{  
   [MessageHeader]  
   public string appRef;  
   [MessageBodyMember]  
   public Stream data;  
}   
```  
  
 <span data-ttu-id="ea360-247">Akış dosya sonuna (EOF) ulaştığında akış aktarımları uç ve ileti kapatılır.</span><span class="sxs-lookup"><span data-stu-id="ea360-247">Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</span></span> <span data-ttu-id="ea360-248">İleti gönderilirken (değer döndürme veya bir işlem çağırma) geçirebilirsiniz bir <xref:System.IO.FileStream> ve [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] altyapı sonradan çeker tüm veriler bu akıştan akış tamamen okunan ve EOF sınırına kadar.</span><span class="sxs-lookup"><span data-stu-id="ea360-248">When sending a message (returning a value or invoking an operation), you can pass a <xref:System.IO.FileStream> and the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</span></span> <span data-ttu-id="ea360-249">Akış veri kaynağı için aktarmak için hiçbir tür önceden derlenmiş <xref:System.IO.Stream> türetilmiş sınıf mevcut, bu tür bir sınıf oluşturun, o sınıfın akış kaynağınız kaplama ve bağımsız değişkeni ya da dönüş değeri olarak kullanın.</span><span class="sxs-lookup"><span data-stu-id="ea360-249">To transfer streamed data for the source that no such pre-built <xref:System.IO.Stream> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</span></span>  
  
 <span data-ttu-id="ea360-250">Bir ileti alırken [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] yapıları Base64 ile kodlanmış ileti akışında bir gövde içerik (veya MTOM kullanıyorsanız ilgili MIME bölümü) ve akış içeriği okurken EOF eriştiğinde.</span><span class="sxs-lookup"><span data-stu-id="ea360-250">When receiving a message, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</span></span>  
  
 <span data-ttu-id="ea360-251">Aktarım düzeyinde akış ayrıca herhangi diğer ileti sözleşmesi türü (parametre listeleri, veri sözleşmesi bağımsız değişkenler ve açık ileti sözleşmesi) çalışır, ancak seri hale getirme ve seri durumdan çıkarma Bu tür iletileri yazdığınızdan seri hale getirici tarafından arabelleğe almayı gerektirir , bu tür sözleşme çeşitleri kullanarak önerilir değil.</span><span class="sxs-lookup"><span data-stu-id="ea360-251">Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</span></span>  
  
### <a name="special-security-considerations-for-large-data"></a><span data-ttu-id="ea360-252">Büyük veriler için özel güvenlik konuları</span><span class="sxs-lookup"><span data-stu-id="ea360-252">Special Security Considerations for Large Data</span></span>  
 <span data-ttu-id="ea360-253">Tüm bağlamaları, hizmet reddi saldırılarını önlemek için gelen ileti boyutunu sınırlamak izin verir.</span><span class="sxs-lookup"><span data-stu-id="ea360-253">All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</span></span> <span data-ttu-id="ea360-254"><xref:System.ServiceModel.BasicHttpBinding>, Örneğin, kullanıma sunan bir [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) gelen ileti boyutunu bounds ve bu nedenle de en çok erişilen bellek miktarını bounds özelliği ileti işleme sırasında.</span><span class="sxs-lookup"><span data-stu-id="ea360-254">The <xref:System.ServiceModel.BasicHttpBinding>, for example, exposes a [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</span></span> <span data-ttu-id="ea360-255">Bu birimi bayt 65,536 bayt varsayılan değerini ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="ea360-255">This unit is set in bytes with a default value of 65,536 bytes.</span></span>  
  
 <span data-ttu-id="ea360-256">Büyük veri akış senaryosu için özel bir güvenlik tehdidi alıcı akışını beklerken arabelleğe alınan verileri neden olan bir hizmet reddi provokes.</span><span class="sxs-lookup"><span data-stu-id="ea360-256">A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</span></span> <span data-ttu-id="ea360-257">Örneğin, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] her zaman bir iletinin SOAP üstbilgileri arabelleğe alır ve bir saldırgan arabelleğe alınan verileri zorlamak için tamamen üstbilgilerinin oluşan büyük bir kötü amaçlı iletisi oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="ea360-257">For example, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</span></span> <span data-ttu-id="ea360-258">Akış etkinleştirildiğinde `MaxReceivedMessageSize` alıcı hiçbir zaman bellek aynı anda arabelleğe alınan iletinin tamamını beklediği son derece büyük bir değere ayarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="ea360-258">When streaming is enabled, the `MaxReceivedMessageSize` may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</span></span> <span data-ttu-id="ea360-259">Varsa [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] bir bellek taşması oluşur ileti arabellek zorlanır.</span><span class="sxs-lookup"><span data-stu-id="ea360-259">If [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] is forced to buffer the message, a memory overflow occurs.</span></span>  
  
 <span data-ttu-id="ea360-260">Bu nedenle, en büyük gelen ileti boyutu sınırlama, bu durumda yeterli değil.</span><span class="sxs-lookup"><span data-stu-id="ea360-260">Therefore, restricting the maximum incoming message size is not enough in this case.</span></span> <span data-ttu-id="ea360-261">`MaxBufferSize` Özelliği bellek sınırlamak için gereklidir, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] arabellek.</span><span class="sxs-lookup"><span data-stu-id="ea360-261">The `MaxBufferSize` property is required to constrain the memory that [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] buffers.</span></span> <span data-ttu-id="ea360-262">Bu güvenli bir değere ayarlayın (veya varsayılan değer olarak saklamak) önemlidir akış olduğunda.</span><span class="sxs-lookup"><span data-stu-id="ea360-262">It is important to set this to a safe value (or keep it at the default value) when streaming.</span></span> <span data-ttu-id="ea360-263">Örneğin, hizmetiniz alması gerekir varsayalım en fazla 4 GB boyutunda dosyaları ve bunları yerel diskte depolar.</span><span class="sxs-lookup"><span data-stu-id="ea360-263">For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</span></span> <span data-ttu-id="ea360-264">Ayrıca, bellek, yalnızca 64 KB veri aynı anda arabellek şekilde kısıtlıdır varsayalım.</span><span class="sxs-lookup"><span data-stu-id="ea360-264">Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</span></span> <span data-ttu-id="ea360-265">Sonra da ayarlamanız gerekir `MaxReceivedMessageSize` 4 GB ve `MaxBufferSize` 64 KB.</span><span class="sxs-lookup"><span data-stu-id="ea360-265">Then you would set the `MaxReceivedMessageSize` to 4 GB and `MaxBufferSize` to 64 KB.</span></span> <span data-ttu-id="ea360-266">Ayrıca, hizmet uygulamanızda 64 KB öbek gelen akışta yalnızca okuma ve önceki bırakıldı önce sonraki öbek okunmaz sağlamanız gerekir. diske yazılan ve bellekten atıldı.</span><span class="sxs-lookup"><span data-stu-id="ea360-266">Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</span></span>  
  
 <span data-ttu-id="ea360-267">Gerçekleştirilir arabelleğe alma Bu kota yalnızca sınırlar anlaşılması önemlidir [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] ve tüm kendi hizmet veya istemci uygulamasında bunu arabelleğe karşı koruyamaz.</span><span class="sxs-lookup"><span data-stu-id="ea360-267">It is also important to understand that this quota only limits the buffering done by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] and cannot protect you against any buffering that you do in your own service or client implementation.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="ea360-268">ek güvenlik konuları Bkz [veriler için güvenlik konuları](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span><span class="sxs-lookup"><span data-stu-id="ea360-268"> additional security considerations, see [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ea360-269">Arabelleğe alınan veya akış aktarımları kullanmaya karar, uç noktanın yerel bir karardır.</span><span class="sxs-lookup"><span data-stu-id="ea360-269">The decision to use either buffered or streamed transfers is a local decision of the endpoint.</span></span> <span data-ttu-id="ea360-270">HTTP taşımaları için bir bağlantı üzerinden veya proxy sunucuları ve diğer aracılar için aktarım modunu dağıtılmaz.</span><span class="sxs-lookup"><span data-stu-id="ea360-270">For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</span></span> <span data-ttu-id="ea360-271">Aktarım modunu ayarlama hizmet arabirimi açıklamasında yansıtılmaz.</span><span class="sxs-lookup"><span data-stu-id="ea360-271">Setting the transfer mode is not reflected in the description of the service interface.</span></span> <span data-ttu-id="ea360-272">Oluşturma sonrasında bir [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] istemci bir hizmet ile akış aktarımları modu ayarlamak için kullanılması hedeflenen Hizmetleri için yapılandırma dosyasını düzenlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="ea360-272">After generating a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</span></span> <span data-ttu-id="ea360-273">TCP ve adlandırılmış kanal aktarımlar, aktarım modu İlkesi onaylama yayılır.</span><span class="sxs-lookup"><span data-stu-id="ea360-273">For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ea360-274">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="ea360-274">See Also</span></span>  
 [<span data-ttu-id="ea360-275">Nasıl yapılır: Akışı Etkinleştirme</span><span class="sxs-lookup"><span data-stu-id="ea360-275">How to: Enable Streaming</span></span>](../../../../docs/framework/wcf/feature-details/how-to-enable-streaming.md)

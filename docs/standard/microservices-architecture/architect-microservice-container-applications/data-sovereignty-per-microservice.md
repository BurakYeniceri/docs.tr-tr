---
title: Mikro hizmet başına veri egemenliği
description: Kapsayıcılı .NET uygulamaları için .NET mikro mimarisi | Mikro hizmet başına veri egemenliği
keywords: Docker, mikro, ASP.NET, kapsayıcı
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: f5d782a70123a66c1579a64a37bc612ccda9c1a4
ms.sourcegitcommit: 2e8acae16ae802f2d6d04e3ce0a6dbf04e476513
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/18/2018
---
# <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="b9a93-104">Mikro hizmet başına veri egemenliği</span><span class="sxs-lookup"><span data-stu-id="b9a93-104">Data sovereignty per microservice</span></span>

<span data-ttu-id="b9a93-105">Mikro mimarisi için önemli bir kuralı her mikro hizmet kendi etki alanı verileri ve mantığı ait olduğu ' dir.</span><span class="sxs-lookup"><span data-stu-id="b9a93-105">An important rule for microservices architecture is that each microservice must own its domain data and logic.</span></span> <span data-ttu-id="b9a93-106">Bu nedenle tam bir uygulama mantığı ve verileri yalnızca sahip olduğu gibi her mikro hizmet mantığı ve verileri mikro hizmet başına bağımsız dağıtımla otonom bir yaşam döngüsü altında sahip olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b9a93-106">Just as a full application owns its logic and data, so must each microservice own its logic and data under an autonomous lifecycle, with independent deployment per microservice.</span></span>

<span data-ttu-id="b9a93-107">Başka bir deyişle, etki alanının kavramsal model alt sistemleri veya mikro arasında farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="b9a93-107">This means that the conceptual model of the domain will differ between subsystems or microservices.</span></span> <span data-ttu-id="b9a93-108">Kuruluş uygulamaları Müşteri İlişkileri Yönetimi (CRM) uygulamaları, işlem benzersiz Müşteri varlık öznitelikleri ve verileri her çağrıda satın alma, alt sistemleri ve müşteri destek alt sistemleri ve her farklı bir kullanan burada göz önünde bulundurun Sınırlanmış bağlamı (BC).</span><span class="sxs-lookup"><span data-stu-id="b9a93-108">Consider enterprise applications, where customer relationship management (CRM) applications, transactional purchase subsystems, and customer support subsystems each call on unique customer entity attributes and data, and where each employs a different Bounded Context (BC).</span></span>

<span data-ttu-id="b9a93-109">Bu ilkeyi benzer [etki alanı Odaklı Tasarım (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), burada her [ilişkisindeki bağlam](https://martinfowler.com/bliki/BoundedContext.html) veya otonom alt sistemi veya hizmet kendi etki alanı modeli (verileri artı mantığı ve davranış) sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b9a93-109">This principle is similar in [Domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), where each [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html) or autonomous subsystem or service must own its domain model (data plus logic and behavior).</span></span> <span data-ttu-id="b9a93-110">İlişkisindeki her DDD bağlam karşılık gelen bir iş mikro (bir veya birkaç hizmet).</span><span class="sxs-lookup"><span data-stu-id="b9a93-110">Each DDD Bounded Context correlates to one business microservice (one or several services).</span></span> <span data-ttu-id="b9a93-111">(Biz bu noktasında sonraki bölümde ilişkisindeki bağlam desen hakkında genişletin.)</span><span class="sxs-lookup"><span data-stu-id="b9a93-111">(We expand on this point about the Bounded Context pattern in the next section.)</span></span>

<span data-ttu-id="b9a93-112">Öte yandan, birçok uygulamada kullanılan geleneksel (tek yapılı veri) tek bir merkezi veritabanı veya yalnızca birkaç veritabanlarına sahip yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="b9a93-112">On the other hand, the traditional (monolithic data) approach used in many applications is to have a single centralized database or just a few databases.</span></span> <span data-ttu-id="b9a93-113">Bu, tüm uygulama ve tüm kendi iç alt sistemleri, kullanılan normalleştirilmiş bir SQL veritabanı Şekil 4-7'de gösterildiği gibi görülür.</span><span class="sxs-lookup"><span data-stu-id="b9a93-113">This is often a normalized SQL database that is used for the whole application and all its internal subsystems, as shown in Figure 4-7.</span></span>

![](./media/image7.png)

<span data-ttu-id="b9a93-114">**Şekil 4-7**.</span><span class="sxs-lookup"><span data-stu-id="b9a93-114">**Figure 4-7**.</span></span> <span data-ttu-id="b9a93-115">Veri egemenliği karşılaştırması: tek yapılı veritabanı mikro karşılaştırması</span><span class="sxs-lookup"><span data-stu-id="b9a93-115">Data sovereignty comparison: monolithic database versus microservices</span></span>

<span data-ttu-id="b9a93-116">Merkezi veritabanı yaklaşım başlangıçta daha basit arar ve her şeyi tutarlı yapmak için farklı alt sistemleri varlıklarda kullanılmasını etkinleştirme gibi görünüyor.</span><span class="sxs-lookup"><span data-stu-id="b9a93-116">The centralized database approach initially looks simpler and seems to enable reuse of entities in different subsystems to make everything consistent.</span></span> <span data-ttu-id="b9a93-117">Ancak gerçekte, birçok farklı alt sistemleri hizmet eden ve çoğu durumda öznitelikleri ve gerekli olmayan sütunları içeren büyük tabloları şunun.</span><span class="sxs-lookup"><span data-stu-id="b9a93-117">But the reality is you end up with huge tables that serve many different subsystems, and that include attributes and columns that are not needed in most cases.</span></span> <span data-ttu-id="b9a93-118">Bu, aynı fiziksel eşlemesi kısa izi yürüyüş, bir gün uzun araba seyahat alma ve Coğrafya öğrenme kullanmaya çalışıyor gibi olur.</span><span class="sxs-lookup"><span data-stu-id="b9a93-118">it is like trying to use the same physical map for hiking a short trail, taking a day-long car trip, and learning geography.</span></span>

<span data-ttu-id="b9a93-119">Genellikle tek bir ilişkisel veritabanı tek yapılı bir uygulamayla iki önemli faydası vardır: [ACID işlemlerini](https://en.wikipedia.org/wiki/ACID) ve SQL dili, tüm tabloları ve uygulamanız ile ilgili veriler arasında her iki çalışma.</span><span class="sxs-lookup"><span data-stu-id="b9a93-119">A monolithic application with typically a single relational database has two important benefits: [ACID transactions](https://en.wikipedia.org/wiki/ACID) and the SQL language, both working across all the tables and data related to your application.</span></span> <span data-ttu-id="b9a93-120">Bu yaklaşım kolayca birden fazla tablolardaki verileri birleştiren bir sorgu yazmak için bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="b9a93-120">This approach provides a way to easily write a query that combines data from multiple tables.</span></span>

<span data-ttu-id="b9a93-121">Ancak, bir mikro mimarisi taşıdığınızda veri erişimi çok daha karmaşık hale gelir.</span><span class="sxs-lookup"><span data-stu-id="b9a93-121">However, data access becomes much more complex when you move to a microservices architecture.</span></span> <span data-ttu-id="b9a93-122">Ancak ACID işlemlerini olabilir veya bir mikro hizmet veya sınırlanmış bağlam içinde kullanılmalıdır olsa bile, her mikro hizmet tarafından ait verileri bu mikro hizmet özeldir ve yalnızca kendi mikro hizmet API üzerinden erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="b9a93-122">But even when ACID transactions can or should be used within a microservice or Bounded Context, the data owned by each microservice is private to that microservice and can only be accessed via its microservice API.</span></span> <span data-ttu-id="b9a93-123">Veri şifreleme mikro birbirine sıkı şekilde bağlı ve başka bağımsız olarak gelişmesi sağlar.</span><span class="sxs-lookup"><span data-stu-id="b9a93-123">Encapsulating the data ensures that the microservices are loosely coupled and can evolve independently of one another.</span></span> <span data-ttu-id="b9a93-124">Birden fazla hizmeti aynı verilere erişilirken, şema güncelleştirmeleri koordine güncelleştirmeleri tüm hizmetlere gerektirir.</span><span class="sxs-lookup"><span data-stu-id="b9a93-124">If multiple services were accessing the same data, schema updates would require coordinated updates to all the services.</span></span> <span data-ttu-id="b9a93-125">Bu mikro hizmet yaşam döngüsü otonomisi çalışmamasına neden.</span><span class="sxs-lookup"><span data-stu-id="b9a93-125">This would break the microservice lifecycle autonomy.</span></span> <span data-ttu-id="b9a93-126">Ancak mikro arasında tek bir ACID işlemi yapamazsınız Dağıtılmış veri yapılarını anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="b9a93-126">But distributed data structures mean that you cannot make a single ACID transaction across microservices.</span></span> <span data-ttu-id="b9a93-127">Bu sırayla bir iş sürecini birden çok mikro yayıldığında nihai tutarlılık kullanmalısınız anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="b9a93-127">This in turn means you must use eventual consistency when a business process spans multiple microservices.</span></span> <span data-ttu-id="b9a93-128">Bu basit SQL birleştirmeler uygulamak çok daha zordur; benzer şekilde, diğer birçok ilişkisel veritabanı özellikleri arasında birden çok mikro kullanılabilir değil.</span><span class="sxs-lookup"><span data-stu-id="b9a93-128">This is much harder to implement than simple SQL joins; similarly, many other relational database features are not available across multiple microservices.</span></span>

<span data-ttu-id="b9a93-129">Bile devam edilirse, farklı mikro genellikle farklı kullandığınız *tür* veritabanlarının.</span><span class="sxs-lookup"><span data-stu-id="b9a93-129">Going even further, different microservices often use different *kinds* of databases.</span></span> <span data-ttu-id="b9a93-130">Modern uygulamalar depolama ve işlem farklı veri türlerini ve ilişkisel veritabanı değil her zaman en iyi seçenek.</span><span class="sxs-lookup"><span data-stu-id="b9a93-130">Modern applications store and process diverse kinds of data, and a relational database is not always the best choice.</span></span> <span data-ttu-id="b9a93-131">Bazı için kullanım örnekleri, bir NoSQL veritabanı Azure DocumentDB veya MongoDB gibi daha kullanışlı bir veri modeline sahiptir ve daha iyi performans ve ölçeklenebilirlik SQL Server gibi bir SQL veritabanı ya da Azure SQL veritabanı sağlar.</span><span class="sxs-lookup"><span data-stu-id="b9a93-131">For some use cases, a NoSQL database such as Azure DocumentDB or MongoDB might have a more convenient data model and offer better performance and scalability than a SQL database like SQL Server or Azure SQL Database.</span></span> <span data-ttu-id="b9a93-132">Diğer durumlarda, bir ilişkisel veritabanı hala en iyi yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="b9a93-132">In other cases, a relational database is still the best approach.</span></span> <span data-ttu-id="b9a93-133">Bu nedenle, mikro tabanlı uygulamalar bazen olarak adlandırılan bir karışımını NoSQL ve SQL veritabanları, sık kullandığınız [polyglot kalıcılığı](https://martinfowler.com/bliki/PolyglotPersistence.html) yaklaşım.</span><span class="sxs-lookup"><span data-stu-id="b9a93-133">Therefore, microservices-based applications often use a mixture of SQL and NoSQL databases, which is sometimes called the [polyglot persistence](https://martinfowler.com/bliki/PolyglotPersistence.html) approach.</span></span>

<span data-ttu-id="b9a93-134">Veri depolama için bir bölümlenmiş, polyglot kalıcı mimarisini birçok avantaj vardır.</span><span class="sxs-lookup"><span data-stu-id="b9a93-134">A partitioned, polyglot-persistent architecture for data storage has many benefits.</span></span> <span data-ttu-id="b9a93-135">Bunlar, geniş bağlı hizmetleri ve daha iyi performans, ölçeklenebilirlik, maliyetleri ve yönetilebilirlik içerir.</span><span class="sxs-lookup"><span data-stu-id="b9a93-135">These include loosely coupled services and better performance, scalability, costs, and manageability.</span></span> <span data-ttu-id="b9a93-136">Ancak, biz de anlatılmıştır gibi bazı Dağıtılmış veri yönetimi zorluklar getirebilir "[etki alanı modeli sınırları tanımlama](#identifying-domain-model-boundaries-for-each-microservice)" Bu bölümde daha sonra.</span><span class="sxs-lookup"><span data-stu-id="b9a93-136">However, it can introduce some distributed data management challenges, as we will explain in “[Identifying domain-model boundaries](#identifying-domain-model-boundaries-for-each-microservice)” later in this chapter.</span></span>

## <a name="the-relationship-between-microservices-and-the-bounded-context-pattern"></a><span data-ttu-id="b9a93-137">Mikro ve sınırlanmış içerik düzeni arasındaki ilişki</span><span class="sxs-lookup"><span data-stu-id="b9a93-137">The relationship between microservices and the Bounded Context pattern</span></span>

<span data-ttu-id="b9a93-138">Mikro hizmet kavramını türetilen [ilişkisindeki bağlam (BC) deseni](https://martinfowler.com/bliki/BoundedContext.html) içinde [etki alanı Odaklı Tasarım (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span><span class="sxs-lookup"><span data-stu-id="b9a93-138">The concept of microservice derives from the [Bounded Context (BC) pattern](https://martinfowler.com/bliki/BoundedContext.html) in [domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span></span> <span data-ttu-id="b9a93-139">DDD birden çok BCs bölme ve bunların sınırlarını hakkında açık büyük modelleri ile ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="b9a93-139">DDD deals with large models by dividing them into multiple BCs and being explicit about their boundaries.</span></span> <span data-ttu-id="b9a93-140">Her BC kendi modeli ve veritabanı olmalıdır; benzer şekilde, her mikro hizmet ilgili verileri sahip olur.</span><span class="sxs-lookup"><span data-stu-id="b9a93-140">Each BC must have its own model and database; likewise, each microservice owns its related data.</span></span> <span data-ttu-id="b9a93-141">Ayrıca, her BC genellikle kendi sahip [bulunabilen dil](https://martinfowler.com/bliki/UbiquitousLanguage.html) yazılım geliştiricileri ve etki alanı uzmanlar arasındaki iletişimi yardımcı olacak.</span><span class="sxs-lookup"><span data-stu-id="b9a93-141">In addition, each BC usually has its own [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html) to help communication between software developers and domain experts.</span></span>

<span data-ttu-id="b9a93-142">Her yerden dilde ilgili koşullar (çoğunlukla etki alanı varlıklar) farklı ilişkisindeki bağlamlarda farklı adlara sahip, aynı kimliğe (depolama biriminden varlık okumak için kullanılan diğer bir deyişle, benzersiz kimliği) bile farklı etki alanı varlıkları paylaşın.</span><span class="sxs-lookup"><span data-stu-id="b9a93-142">Those terms (mainly domain entities) in the ubiquitous language can have different names in different Bounded Contexts, even when different domain entities share the same identity (that is, the unique ID that is used to read the entity from storage).</span></span> <span data-ttu-id="b9a93-143">Örneğin, sipariş ilişkisindeki bağlamda alıcı etki alanı varlığı ile kullanıcı profili sınırlanmış bir bağlamında, kullanıcı etki alanı varlığı kimlik paylaşabilen.</span><span class="sxs-lookup"><span data-stu-id="b9a93-143">For instance, in a user-profile Bounded Context, the User domain entity might share identity with the Buyer domain entity in the ordering Bounded Context.</span></span>

<span data-ttu-id="b9a93-144">Bir mikro hizmet bu nedenle bir sınırlanmış bağlamı gibi olmakla birlikte, aynı zamanda Dağıtılmış bir hizmet olduğunu belirtir.</span><span class="sxs-lookup"><span data-stu-id="b9a93-144">A microservice is therefore like a Bounded Context, but it also specifies that it is a distributed service.</span></span> <span data-ttu-id="b9a93-145">İlişkisindeki her bağlam için ayrı bir işlem olarak oluşturulur ve HTTP/HTTPS gibi WebSockets, daha önce not ettiğiniz dağıtılmış protokolleri kullanması gerekir veya [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span><span class="sxs-lookup"><span data-stu-id="b9a93-145">It is built as a separate process for each Bounded Context, and it must use the distributed protocols noted earlier, like HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span> <span data-ttu-id="b9a93-146">Sınırlanmış içerik düzeni ancak ilişkisindeki bağlam dağıtılmış bir hizmet olup olmadığı veya yalnızca mantıksal sınır (örneğin, bir genel alt sistemi) olup olmadığını dağıtım tek yapılı uygulama içinde belirtmiyor.</span><span class="sxs-lookup"><span data-stu-id="b9a93-146">The Bounded Context pattern, however, does not specify whether the Bounded Context is a distributed service or if it is simply a logical boundary (such as a generic subsystem) within a monolithic-deployment application.</span></span>

<span data-ttu-id="b9a93-147">İlişkisindeki her bağlam için bir hizmet tanımlama başlatmak için uygun bir yerdir, vurgulamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="b9a93-147">It is important to highlight that defining a service for each Bounded Context is a good place to start.</span></span> <span data-ttu-id="b9a93-148">Ancak ona tasarımınızı sınırlamak gerekmez.</span><span class="sxs-lookup"><span data-stu-id="b9a93-148">But you do not have to constrain your design to it.</span></span> <span data-ttu-id="b9a93-149">Bazen bir sınırlanmış bağlamı tasarlamanız gerekir veya iş mikro birkaç fiziksel hizmetlerinden oluşur.</span><span class="sxs-lookup"><span data-stu-id="b9a93-149">Sometimes you must design a Bounded Context or business microservice composed of several physical services.</span></span> <span data-ttu-id="b9a93-150">Ancak sonuç olarak, her iki desenleri — ilişkisindeki bağlamını ve mikro hizmet — yakından ilişkilidir.</span><span class="sxs-lookup"><span data-stu-id="b9a93-150">But ultimately, both patterns—Bounded Context and microservice—are closely related.</span></span>

<span data-ttu-id="b9a93-151">GGG, dağıtılmış mikro biçiminde gerçek sınırları alarak mikro fayda sağlar.</span><span class="sxs-lookup"><span data-stu-id="b9a93-151">DDD benefits from microservices by getting real boundaries in the form of distributed microservices.</span></span> <span data-ttu-id="b9a93-152">Ancak mikro arasında modeli paylaşmıyor gibi fikirleri ne de sınırlı bir bağlamda istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="b9a93-152">But ideas like not sharing the model between microservices are what you also want in a Bounded Context.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="b9a93-153">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="b9a93-153">Additional resources</span></span>

-   <span data-ttu-id="b9a93-154">**Chris Uludağ. Deseni: Her hizmet veritabanı**
    [*https://microservices.io/patterns/data/database-per-service.html*](https://microservices.io/patterns/data/database-per-service.html)</span><span class="sxs-lookup"><span data-stu-id="b9a93-154">**Chris Richardson. Pattern: Database per service**
[*https://microservices.io/patterns/data/database-per-service.html*](https://microservices.io/patterns/data/database-per-service.html)</span></span>

-   <span data-ttu-id="b9a93-155">**Martin Fowler. BoundedContext**
    [*https://martinfowler.com/bliki/BoundedContext.html*](https://martinfowler.com/bliki/BoundedContext.html)</span><span class="sxs-lookup"><span data-stu-id="b9a93-155">**Martin Fowler. BoundedContext**
[*https://martinfowler.com/bliki/BoundedContext.html*](https://martinfowler.com/bliki/BoundedContext.html)</span></span>

-   <span data-ttu-id="b9a93-156">**Martin Fowler. PolyglotPersistence**
    [*https://martinfowler.com/bliki/PolyglotPersistence.html*](https://martinfowler.com/bliki/PolyglotPersistence.html)</span><span class="sxs-lookup"><span data-stu-id="b9a93-156">**Martin Fowler. PolyglotPersistence**
[*https://martinfowler.com/bliki/PolyglotPersistence.html*](https://martinfowler.com/bliki/PolyglotPersistence.html)</span></span>

-   <span data-ttu-id="b9a93-157">**Adı Brandolini. Yönetilen bir bağlam eşleme ile tasarım stratejik etki alanı**
    [*https://www.infoq.com/articles/ddd-contextmapping*](https://www.infoq.com/articles/ddd-contextmapping)</span><span class="sxs-lookup"><span data-stu-id="b9a93-157">**Alberto Brandolini. Strategic Domain Driven Design with Context Mapping**
[*https://www.infoq.com/articles/ddd-contextmapping*](https://www.infoq.com/articles/ddd-contextmapping)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="b9a93-158">[Önceki] (mikro-architecture.md) [sonraki] (mantıksal-karşı-fiziksel-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="b9a93-158">[Previous] (microservices-architecture.md) [Next] (logical-versus-physical-architecture.md)</span></span>

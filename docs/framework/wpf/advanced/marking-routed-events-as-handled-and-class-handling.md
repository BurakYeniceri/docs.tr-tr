---
title: "Gönderilmiş Olayları İşlenmiş Olarak İşaretleme ve Sınıf İşlemesi"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
caps.latest.revision: "19"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: b2c9a550e1423acb37da9645d09cdb4ccefcea66
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 12/22/2017
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Gönderilmiş Olayları İşlenmiş Olarak İşaretleme ve Sınıf İşlemesi
Yönlendirilmiş olay işleyicileri içinde olay verilerini işlenen olay işaretleyebilirsiniz. Olay işleme rota etkili bir şekilde kısaltacak. Sınıf işleme yönlendirilmiş olaylar tarafından desteklenen programlama bir kavramdır. Sınıf işleyicisi sınıf düzeyinde sınıfının hiçbir örneği üzerinde herhangi bir örnek işleyicisini önce çağrılan bir işleyici ile belirli bir yönlendirilmiş olay işleme fırsatına sahip.  
  

  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Önkoşullar  
 Bu konuda sunulan kavramlarla ilgili elaborates [yönlendirilmiş olaylara genel bakış](../../../../docs/framework/wpf/advanced/routed-events-overview.md).  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Olayları işlenmiş olarak işaretlemek ne zaman  
 Değeri ayarlandığında <xref:System.Windows.RoutedEventArgs.Handled%2A> özelliğine `true` olay verileri yönlendirilmiş olay için bu olarak adlandırılır "işlenen olay işaretleme". Yönlendirilmiş olaylar işlenmiş olarak işaretlediğinizde mutlak bir kuralı, bir uygulama yazarı olarak ya da bir denetim olarak var olan yönlendirilmiş olaylara yanıt verir ya da yeni uygulayan Yazar yönlendirilmiş olaylar. Çoğunlukla, "yönlendirilmiş olayın olay verilerde taşınan gibi ele" kavramı sınırlı bir protokol olarak kendi uygulamanın yanıtlarını de sağlanmaktadır çeşitli yönlendirilmiş olaylar için kullanılması gereken [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] yönlendirilmiş herhangi bir özel olarak için olaylar. "İşlenmiş" sorunu dikkate alınması gereken başka bir kodunuzu yönlendirilmiş olay önemli ve görece eksiksiz bir şekilde yanıt, işlenen yönlendirilmiş olay genellikle işaretlemelisiniz yoludur. Genellikle, olmamalıdır ayrı işleyicisi uygulamaları için tek yönlendirilmiş olay olayı gerektirir birden çok önemli yanıt. Daha fazla yanıtları gerekirse, gerekli kodu tek bir işleyici içinde yerine yönlendirilmiş olay sistemi iletme için zincirleme uygulama mantığını aracılığıyla uygulanmalıdır. "Önemli" nedir kavramı da öznel ve kullanıcılarınızın bir uygulama veya kod bağlıdır. Genel bir yönerge olarak bazı "önemli yanıt" örnekler: odak ayarlama, genel durumu değiştirme, görsel gösterimi etkileyen özellikleri ayarlama ve diğer yeni olaylar oluşturma. Önemli olmayan yanıtları örnekler: özel durumu (hiçbir visual etkisi, veya programlama gösterimi ile) değiştirerek, olaylarını, veya bir olay bağımsız değişkenleri arama ve ona yanıt vermeyecek biçimde seçme.  
  
 Yönlendirilmiş olay sistem davranışını işleyicileri eklenen çünkü yönlendirilmiş olay işlenmiş durumunu kullanmak için bu "önemli yanıt" model eklenir [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] veya ortak imzası <xref:System.Windows.UIElement.AddHandler%2A> yönlendirilmiş bir olaya yanıt olarak çağrılmaz burada olay verileri zaten işlenmiş işaretlenir. Sahip bir işleyici ekleme ek çaba aracılığıyla gitmelidir `handledEventsToo` parametresi sürüm (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) rota olay önceki katılımcıları tarafından işlenmiş olarak işaretlenmiş yönlendirilmiş olayları işlemek için.  
  
 Bazı durumlarda, denetimleri kendilerini belirli yönlendirilmiş olaylar işlenmiş olarak işaretleyin. İşlenmiş yönlendirilmiş olay tarafından kararı temsil eden [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] kontrol denetim uygulaması ve olay parçası hiçbir daha fazla işleme gibi önemli veya tam denetim eylemleri yönlendirilmiş olaya yanıt olarak yazar. Genellikle bu olay için bir sınıf işleyicisi ekleme ya da bir taban sınıf üzerinde mevcut sınıfı işleyici sanalların biri geçersiz kılma gerçekleştirilir. Bu olay gerekirse işleme hala çalışabilir; bkz: [çalışma geçici denetimler tarafından olay bastırma](#WorkingAroundEventSuppressionByControls) bu konuda daha sonra.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>"Önizleme" (tünel) olayları vs. Olayların ve olay işleme tırmanmasını  
 Yönlendirilmiş önizleme olayları öğe ağacı üzerinden tünel yolu izleyin olaylardır. "Adlandırma kuralında ifade Önizleme" göstergesi Genel İlkesi giriş olayları (Tünelleme) önizleme yönlendirilmiş olaylar önce eşdeğer kabarcıklanma yönlendirilmiş olay oluşturulur. Ayrıca, bir tünel oluşturma ve kabarcıklanma çifti giriş yönlendirilmiş olayları ayrı işleme mantığı vardır. Tünel/yönlendirilmiş Önizleme olay bir olay dinleyicisi tarafından işlenmiş olarak işaretlenmişse, hatta tüm dinleyiciler kabarcıklanma yönlendirilmiş olay almadan önce onu sonra yönlendirilmiş olay işaretlenecek tırmanmasını işlenir. Tünel oluşturma ve kabarcıklanma yönlendirilmiş olaylar için teknik olarak ayrı olayları olsa da, bunlar kasıtlı olarak olay verisi bu davranışı etkinleştirmek için aynı kopyasını paylaştığında.  
  
 Tünel oluşturma ve kabarcıklanma yönlendirilmiş olaylar arasındaki bağlantıyı tarafından iç uygulanması herhangi nasıl verilen gerçekleştirilir [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] sınıf kendi bildirilen yönlendirilmiş olayları başlatır ve bu eşleştirilmiş giriş yönlendirilmiş olaylarını geçerlidir. Ancak bu sınıf düzeyi uygulama olmadığı sürece tünel yönlendirilmiş olay adlandırma şeması paylaşan kabarcıklanma yönlendirilmiş olay arasındaki bağlantı yoktur: Böyle uygulama olmadan bunlar iki tamamen ayrı yönlendirilmiş olay olacaktır ve değil olacaktır Olay verileri dizisi veya paylaşımı oluşturulur.  
  
 Özel bir sınıf içinde tünel/Kabarcık giriş yönlendirilmiş olay çiftlerini gerçekleştirme hakkında daha fazla bilgi için bkz: [özel yönlendirilmiş olay oluşturma](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Sınıf işleyicileri ve örnek işleyicileri  
 Yönlendirilmiş olaylar, iki farklı türde olay dinleyicileri göz önünde bulundurun: sınıf dinleyicileri ve örnek dinleyiciler. Sınıf dinleyicileri var türleri belirli bir adlı olduğundan <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, kendi statik oluşturucuda ya da bir sınıf işleyicisi sanal yönteminden öğesi ana sınıfı geçersiz. Örnek dinleyiciler öğeleridir belirli sınıf örnekleri/burada bir veya daha fazla işleyicileri, yönlendirilmiş olay için bir çağrı tarafından eklenmiş olan <xref:System.Windows.UIElement.AddHandler%2A>. Varolan [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] yönlendirilmiş olaylar olun çağrıları <xref:System.Windows.UIElement.AddHandler%2A> parçası olarak [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] olay sarmalayıcı ekleme {} ve {} uygulamaları nasıl olan olayın Kaldır basit [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mekanizması bir öznitelik aracılığıyla olay işleyicileri ekleme sözdizimi etkinleştirilir. Bu nedenle basit bile [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] kullanım sonuçta karşılık gelir için bir <xref:System.Windows.UIElement.AddHandler%2A> çağırın.  
  
 Görsel ağaç içinde öğelerin kayıtlı işleyici uygulamaları için denetlenir. Yönlendirilmiş olay yönlendirme stratejisi türünde devralınır sırada yol boyunca işleyicileri potansiyel olarak çağrılır. Örneğin, kabarcıklanma yönlendirilmiş olaylar ilk yönlendirilmiş olayı aynı öğeye bağlı bu işleyicilerini başlatacaktır. Ardından yönlendirilmiş olay vb. uygulama kök öğesi ulaşılana kadar sonraki üst öğeye "balonları".  
  
 Sınıf işleme veya herhangi bir öğeye yakın yönlendirilmiş olay kaynağı olarak işlenen, olay bağımsız işaretlemek işleyicileri çağırma varsa kabarcıklanma yolunun kök öğesinde perspektifinden sonra öğeleri çağrılamaz kök işleyicileri ve olay yönlendirme Bu kök öğesi ulaşmadan önce etkili bir şekilde kısaltılır. İşleyicileri işleyicisi sınıfı veya örneği işleyicisi yönlendirilmiş olay işlenmiş olarak işaretlenmiş olsa bile kullanıcılar hala çağrılması gerektiğini, özel bir koşullu kullanılarak eklenebilir olduğundan ancak, rota tamamen, durdurulur değil. Bu bölümünde açıklanır [ekleme örneği işleyicileri emin olan yükseltilmiş bile olduğunda olayları işaretli işlenir](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), bu konunun devamındaki.  
  
 Olay yolu daha derin bir düzeyinde de belirli bir sınıfın örneklerini üzerinde çalışan büyük olasılıkla birden çok sınıf işleyicileri vardır. Bu olduğu sınıf işleme modeli yönlendirilmiş olaylar için her bir sınıf hiyerarşideki tüm olası sınıfları sağladığından kaydetmeniz yönlendirilmiş her olay için kendi sınıf işleyicisi. Her sınıf işleyicisi bir iç depoya eklenir ve sınıf işleyicileri bir uygulama için olay yolu oluşturulduğunda, tüm olay rotaya eklenir. Sınıf işleyicileri yolu en çok türetilen sınıfı işleyici önce çağrılır ve sınıf işleyicileri art arda gelen her temel sınıfından sonraki çağrılır gibi eklenir. Genellikle, bunlar da ele zaten işaretlenen yönlendirilmiş olaylara yanıt şekilde sınıf işleyicileri kayıtlı değil. Bu nedenle, işleme mekanizması Bu sınıf bir iki seçenek sağlar:  
  
-   Türetilmiş sınıflar temel sınıf işleyicisi süre türetilmiş sınıf işleyicisi sonra çağrılacak bulunduğundan yönlendirilmiş olayı işlenmiş, işaretlemez bir işleyici ekleyerek temel sınıfından devralınan sınıf işleme destekleyebilirsiniz.  
  
-   Türetilen sınıflar yönlendirilmiş olayı işlenmiş işaretler sınıfı işleyici ekleyerek temel sınıfından işleme sınıfı değiştirebilirsiniz. Görsel görünümünü ve durum mantığı, giriş işleme ve komut işleme gibi alanlarda hedeflenen temel denetimi tasarım potansiyel olarak değişir olduğundan bu yaklaşımda, dikkatli olmanız gerekir.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Yönlendirilmiş olay işleme denetim temel sınıflar tarafından sınıfı  
 Bir olay rotadaki her verilen öğe düğümde sınıf dinleyicileri herhangi örnek dinleyici öğesi can önce yönlendirilmiş olay yanıt verecek şekilde fırsatınız. Bu nedenle, sınıf işleyicileri bazen belirli denetim sınıf uygulamasını daha fazla yayılması veya özel bir özelliktir sınıfının bu yönlendirilmiş olayı işlenmesini sağlamak için istemediğini yönlendirilmiş olaylar gizlemek için kullanılır. Örneğin, bir sınıf o sınıfın bağlamında bazı kullanıcı giriş koşulu anlamı hakkında daha fazla ayrıntı içeren kendi sınıfı özgü olay tetikleyebilir. Sınıf uygulamasını sonra işlenmiş olarak daha genel yönlendirilmiş olay işareti. Sınıf işleyicileri genellikle eklenir sağlayacak şekilde yönlendirilen için çağrılmaz burada paylaşılan olay verileri zaten işaretlenen olayları ele, ancak alışılmadık durumlarda yok ayrıca bir <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> bile yönlendirilmiş olaylar olduğunda çağrılacak sınıf işleyicileri kaydeder imza işlenmiş olarak işaretlenmiş.  
  
### <a name="class-handler-virtuals"></a>İşleyici sanalların sınıfı  
 Özellikle temel öğeleri gibi bazı öğeler <xref:System.Windows.UIElement>, sunmaya boş "üzerinde * olay" ve "OnPreview\*olay" kendi ortak yönlendirilmiş olaylar listesine karşılık gelen sanal yöntemleri. Yönlendirilmiş olay işleyicisi sınıfı uygulamak için bu sanal yöntemleri geçersiz kılınabilir. Her örneğin kendi sınıfı işleyicisi olayını kullanarak yönlendirilen gibi temel öğe sınıfları bu sanal yöntemler kaydetmek <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> daha önce açıklandığı gibi. On\*her tür için statik oluşturucular özel başlatma gerektirmeden olayları, yönlendirilmiş olay sanal yöntemler kolaylaştırır sınıfı için ilgili işleme uygulamak çok daha kolaydır. Sınıfı için işleme örneği için ekleyebilirsiniz <xref:System.Windows.UIElement.DragEnter> herhangi bir olay <xref:System.Windows.UIElement> kılarak türetilmiş sınıf <xref:System.Windows.UIElement.OnDragEnter%2A> sanal yöntemi. Geçersiz kılma içinde yönlendirilmiş olay işleme, diğer olayları yükseltmek, örnekleri veya bu eylemleri herhangi bir bileşimini öğesi özelliklerini değişebilir sınıfı özgü mantığı başlatmak. İşlenen olayı işaretlemek olsa bile bu tür geçersiz kılmaları temel uygulamasında genellikle çağırmanız gerekir. Sanal yöntemi temel sınıf üzerinde olduğundan temel uygulamayı çağırma önemle tavsiye edilir. Temel uygulamaları temelde her sanal çağırma standart korumalı sanal desenini yerini alır ve bir sınıf hiyerarşisindeki tüm sınıflar için sınıf işleyicileri aslına sınıfı yönlendirilmiş olay işleme için yerel bir benzer mekanizma parallels Çoğu türetilmiş sınıf işleyicisi ile başlayan ve temel sınıf işleyicisine etmeden tüm verilen örneğinde çağrılır. Sınıfınızda mantığı işleme temel sınıf değiştirmek için kasıtlı bir gereksinimi varsa yalnızca temel uygulamayı çağrısı atlayın. Önce veya sonra geçersiz kılma kodunuzu temel uygulamayı çağırması olup uygulamanızı doğasına bağlı olacaktır.  
  
#### <a name="input-event-class-handling"></a>Giriş olay işleme sınıfı  
 Yalnızca işlenmiş olduğu herhangi bir paylaşılan olay veri zaten işaretlenmemiş durumlarda çağrılır şekilde sınıfı işleyici sanal yöntemler tüm kaydedilir. Ayrıca, giriş olaylar için benzersiz olarak tünel oluşturma ve kabarcıklanma sürümleri genellikle sırayla gerçekleştirilen ve olay verilerini paylaşır. Bu, burada bir tünel sürüm ve diğer kabarcıklanma sürümü giriş olayların sınıf işleyicileri için bir verilen çifti hemen işlenen olayı işaretlemek istemeyebilirsiniz olduğunu kapsar. İşlenen olayı işaretlemek için sanal bir yöntem işleme tünel sınıfı uygularsanız, kabarcıklanma işleyicisi sınıfı (her iki tünel veya kabarcıklanma olayı için herhangi bir normalde kayıtlı örnek işleyicileri önleme yanı sıra çağrılmasını engeller. çağrılan).  
  
 Bir düğümde işleme sınıfı tamamlandıktan sonra örnek dinleyiciler olarak kabul edilir.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>İşlenen bile olayları işaretlendiğinde ortaya örneği işleyicileri ekleme  
 <xref:System.Windows.UIElement.AddHandler%2A> Yöntemi bir olay rota işleme öğesinde eriştiğinde başka bir işleyici zaten, işaretlemek için olay verilerini ayarladı olsa bile olay sistem tarafından çağrılan işleyicileri eklemenize olanak sağlayan belirli bir aşırı yüklemesini sağlar işlenmiş olarak olay. Bu genellikle belirtilmez. Genellikle, tüm alanları birden çok bitiş sonuçları istenen olsa bile bir öğe ağacında, burada yürütüldü bağımsız olarak bir olay tarafından etkilenebileceğinden uygulama kodu ayarlamak için işleyiciler yazılabilir. Ayrıca, genellikle yoktur gerçekten bu olaya yanıt vermesi yalnızca tek bir öğe ve uygun uygulama mantığını oldu. Ancak `handledEventsToo` aşırı yüklemesi, burada diğer öğesinde bir öğe ağaç veya denetim birleştirme zaten işaretledi bir olay işlenmiş gibi olağanüstü durumlarda, ancak daha yüksek veya düşük hala öğe ağacında (yol) bağlı olarak diğer öğeler için kullanılabilir çağrılan kendi işleyicileri olmasını istiyor.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>İşaretlemek ne zaman olaylar işlenmemiş olarak işlenen  
 Genellikle, işlenmiş olarak işaretlenmiş yönlendirilmiş olaylar işlenmemiş işaretlenmelidir değil (<xref:System.Windows.RoutedEventArgs.Handled%2A> döndürülmek `false`) bile hareket işleyiciler tarafından `handledEventsToo`. Ancak, bazı giriş olaylar konumunda bir ağaç ve alt düzey olay başka bir konuma, üst düzey olay görülen yükleyen binebilir üst düzey ve alt düzey olay Beyanları sahiptir. Örneğin, burada bir alt öğesi dinleyen bir üst düzey anahtar olayı gibi bir durum düşünün <xref:System.Windows.UIElement.TextInput> gibi bir üst öğesi bir alt düzey olayı dinleyen sırada <xref:System.Windows.UIElement.KeyDown>. Üst öğe alt düzey olayını işler, üst düzey olay bile olayını işlemek için ilk fırsat sezgisel olmalıdır alt öğesi gizlenebilir.  
  
 Bu durumlarda üst öğeler ve alt öğeleri için alt düzey olay işleyicileri eklemek gerekli olabilir. Alt öğe işleyicisi uygulamasına alt düzey olay işlenmiş, üst öğesi işleyicisi uygulamasına öğeleri ağaç (yanı sıra üst düzey olay) daha fazla yukarı böylece yeniden işlenmemiş kümesi yanıt fırsatı olabilir olarak işaretleyebilirsiniz. Bu durumda oldukça seyrek olmalıdır.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Giriş olayları denetim birleştirmesini için kasıtlı olarak gizleme  
 Giriş olayları ve bileşik denetimler yönlendirilmiş olayların sınıf işleme kullanıldığı ana senaryo içindir. Birden çok pratik denetimleri veya denetim temel sınıfları oluşan tanımına göre bir bileşik denetimdir. Denetim yazarı genellikle tüm olası giriş olaylar katıştırma istediği her alt bileşenler, tekil olay kaynağı olarak tüm denetim bildirmek üzere tetikleyebilir olduğunu. Bazı durumlarda denetim yazarı bileşenleri olayların tamamen gizlemek ya da daha fazla bilgi taşıyan veya daha fazla belirli bir davranışı olan bileşenle tanımlanan bir olayın yerine isteyebilir. Hiçbir bileşen yazarının hemen görülebilir kurallı örnek nasıl bir [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> tüm düğmeleri olduğunu sezgisel olay sonunda çözümleyecek herhangi fare olayını işler: bir <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olay.  
  
 <xref:System.Windows.Controls.Button> Temel sınıfı (<xref:System.Windows.Controls.Primitives.ButtonBase>) türetilen <xref:System.Windows.Controls.Control> hangi sırayla türetilen <xref:System.Windows.FrameworkElement> ve <xref:System.Windows.UIElement>ve denetim giriş işleme şu adresten edinilebilir için gereken olay altyapıyı çoğunu <xref:System.Windows.UIElement> düzeyi. Özellikle, <xref:System.Windows.UIElement> genel işler <xref:System.Windows.Input.Mouse> fare imleci sınırlarının içinde isabet testi işleyen ve en yaygın için ayrı olayları sağlar olayları düğmesini eylemler gibi <xref:System.Windows.UIElement.MouseLeftButtonDown>. <xref:System.Windows.UIElement>Ayrıca, boş bir sanal sağlar <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> için preregistered sınıfı işleyici olarak <xref:System.Windows.UIElement.MouseLeftButtonDown>, ve <xref:System.Windows.Controls.Primitives.ButtonBase> bunu geçersiz kılar. Benzer şekilde, <xref:System.Windows.Controls.Primitives.ButtonBase> kullandığı sınıf için işleyiciler <xref:System.Windows.UIElement.MouseLeftButtonUp>. Olay verileri iletilen, bir geçersiz kılma, uygulamaları, işaretlemek <xref:System.Windows.RoutedEventArgs> örnek ayarlanarak işlenmiş olarak <xref:System.Windows.RoutedEventArgs.Handled%2A> için `true`, ve aynı olay verilerini ne diğer sınıf işleyicileri rotaya geri kalanı boyunca devam eder ve örnek işleyicileri ya da olay ayarlayıcıları için. Ayrıca, <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> geçersiz kılma sonraki yükseltme <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olay. Çoğu dinleyiciler için sonuç olacaktır <xref:System.Windows.UIElement.MouseLeftButtonDown> ve <xref:System.Windows.UIElement.MouseLeftButtonUp> olayları "kayboluyor" ve bunun yerine değiştirilir <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, onu bu olay geldiğini true düğmesi ve olmayan bazı bilindiğinden daha fazla anlamı tutan bir olay Bileşik parçası düğmesinin veya başka bir öğenin tamamen.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Denetimleri tarafından olay bastırma çevresinde çalışma  
 Bazen bu olay gizleme davranış tek denetimleri içinde mantığı uygulamanız için işleme olayın daha genel bazı amaçları ile etkileyebilir. Örneğin, herhangi bir nedenden dolayı uygulamanız için bir işleyici sahip <xref:System.Windows.UIElement.MouseLeftButtonDown> uygulama kök öğede bulunan, size herhangi bir düğme fare tıklatıldığında değil çağıracaktır fark etmesi <xref:System.Windows.UIElement.MouseLeftButtonDown> veya <xref:System.Windows.UIElement.MouseLeftButtonUp> kök düzeyinde işleyicileri. Olay gerçekte yukarı Kabarcık (yeniden olay yollar gerçekten Sonlandırılmamış ancak işlenmiş işaretlenmiş sonra işleyicisi çağırma davranışlarını yönlendirilmiş olay sistem değişiklikleri). Yönlendirilmiş olay düğmesi erişildiğinde <xref:System.Windows.Controls.Primitives.ButtonBase> sınıf işleme işaretli <xref:System.Windows.UIElement.MouseLeftButtonDown> yerine onlardan çünkü işlenen <xref:System.Windows.Controls.Primitives.ButtonBase.Click> daha anlamlı olayla. Bu nedenle, herhangi bir standart <xref:System.Windows.UIElement.MouseLeftButtonDown> rota daha fazla işleyicisini değil çağrılabilir. Bu durumda, işleyicileri çağrıldığı emin olmak için kullanabileceğiniz iki tekniği vardır.  
  
 İşleyici kullanarak kasıtlı olarak eklemek için ilk tekniktir `handledEventsToo` imzası <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>. Bu yaklaşımın bir sınırlama olay işleyicisi iliştirmek için bu tekniği yalnızca kodundan, biçimlendirme değil, olası olmasıdır. Olay işleyicisi adı olay öznitelik değeri olarak belirtmenin basit sözdizimi [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] bu davranışı etkinleştirmez.  
  
 İkinci teknik yönlendirilmiş olay tünel oluşturma ve kabarcıklanma sürümleri burada eşleştirilmelidir yalnızca giriş olayları için çalışır. Bu yönlendirilmiş olaylar için bunun yerine Önizleme/tünel eşdeğer yönlendirilmiş işleyicileri olayı ekleyebilirsiniz. Yönlendirilmiş olay işleme kodunu button sınıfı, uygulamanın öğe ağacında üst öğe düzeyinde Önizleme işleyicisi bağlı pek fazla müdahale olmayan şekilde kökünden başlayarak rota üzerinden tünel oluşturur. Bu yaklaşımı kullanırsanız, işlenen herhangi Önizleme olay işaretleme hakkında dikkatli olun. İle verilen örneğin <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> olayı olarak işaretlenmiş durumunda Kök öğede işlenen <xref:System.Windows.RoutedEventArgs.Handled%2A> gerçekten bastırır işleyici uygulamasında <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olay. Bu genellikle tercih davranışı değil.  
  
## <a name="see-also"></a>Ayrıca Bkz.  
 <xref:System.Windows.EventManager>  
 [Önizleme Olayları](../../../../docs/framework/wpf/advanced/preview-events.md)  
 [Özel Yönlendirilmiş Olay Oluşturma](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)  
 [Yönlendirilmiş Olaylara Genel Bakış](../../../../docs/framework/wpf/advanced/routed-events-overview.md)

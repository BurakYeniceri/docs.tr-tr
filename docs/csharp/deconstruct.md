---
title: "Tanımlama grupları ve diğer türleri deconstructing"
description: "Tanımlama grupları ve diğer türleri deconstruct öğrenin."
keywords: .NET, .NET core, C#
author: rpetrusha
ms-author: ronpet
ms.date: 07/18/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 0b0c4b0f-4a47-4f66-9b8e-f5c63b195960
ms.openlocfilehash: e626eeb1f3de2716e1ffe4fcbec1c16558e5bf0e
ms.sourcegitcommit: a3ba258f7a8cab5c6d19a3743dd95e904ecebc44
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/27/2017
---
# <a name="deconstructing-tuples-and-other-types"></a><span data-ttu-id="9ca78-104">Tanımlama grupları ve diğer türleri deconstructing</span><span class="sxs-lookup"><span data-stu-id="9ca78-104">Deconstructing tuples and other types</span></span> #

<span data-ttu-id="9ca78-105">Bir tanımlama grubu hafif bir yöntem çağrısının birden çok değer almanıza olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="9ca78-105">A tuple provides a light-weight way to retrieve multiple values from a method call.</span></span> <span data-ttu-id="9ca78-106">Ancak tanımlama grubu almak sonra bireysel öğeleri işlemek vardır.</span><span class="sxs-lookup"><span data-stu-id="9ca78-106">But once you retrieve the tuple, you have to handle its individual elements.</span></span> <span data-ttu-id="9ca78-107">Bir öğe öğeli temelinde bunu aşağıdaki örnekte gösterildiği gibi uğraş.</span><span class="sxs-lookup"><span data-stu-id="9ca78-107">Doing this on an element-by-element basis is cumbersome, as the following example shows.</span></span> <span data-ttu-id="9ca78-108">`QueryCityData` Yöntemi 3-tanımlama grubu döndürür ve alt öğelerin her biri ayrı bir işlemde bir değişkene atanır.</span><span class="sxs-lookup"><span data-stu-id="9ca78-108">The `QueryCityData` method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation.</span></span>

[!code-csharp[WithoutDeconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]

<span data-ttu-id="9ca78-109">Bir nesneden birden çok alan ve özellik değerlerini alma eşit sıkıcı olabilir: bir alan veya özellik değeri bir üyesi tarafından üye temelinde bir değişkene atamış olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9ca78-109">Retrieving multiple field and property values from an object can be equally cumbersome: you have to assign a field or property value to a variable on a member-by-member basis.</span></span> 

<span data-ttu-id="9ca78-110">C# 7 ile başlayan, birden çok öğe tanımlama grubundan almak veya birden çok alan, özellik ve hesaplanan değerler tek bir nesneden almak *deconstruct* işlemi.</span><span class="sxs-lookup"><span data-stu-id="9ca78-110">Starting with C# 7, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single *deconstruct* operation.</span></span> <span data-ttu-id="9ca78-111">Bir tanımlama grubu deconstruct bağımsız değişkenlere öğeleri atayın.</span><span class="sxs-lookup"><span data-stu-id="9ca78-111">When you deconstruct a tuple, you assign its elements to individual variables.</span></span> <span data-ttu-id="9ca78-112">Bir nesne deconstruct bağımsız değişkenleri için seçilen değerler atayın.</span><span class="sxs-lookup"><span data-stu-id="9ca78-112">When you deconstruct an object, you assign selected values to individual variables.</span></span> 

## <a name="deconstructing-a-tuple"></a><span data-ttu-id="9ca78-113">Bir tanımlama grubu deconstructing</span><span class="sxs-lookup"><span data-stu-id="9ca78-113">Deconstructing a tuple</span></span>

<span data-ttu-id="9ca78-114">C# özellikleri yerleşik bir tanımlama grubu tek bir işlemde tüm öğelerde gitmeniz imkan tanıyan bir tanımlama grubu deconstructing için destek.</span><span class="sxs-lookup"><span data-stu-id="9ca78-114">C# features built-in support for deconstructing tuples, which lets you unpackage all the items in a tuple in a single operation.</span></span> <span data-ttu-id="9ca78-115">Bir tanımlama grubu deconstructing genel söz dizimi bir tanımlama söz dizimi benzerdir: her öğeye sahip olduğu parantez içinde Atama ifadesinin sol tarafındaki atanacak değişkenleri alın.</span><span class="sxs-lookup"><span data-stu-id="9ca78-115">The general syntax for deconstructing a tuple is similar to the syntax for defining one: you enclose the variables to which each element is to be assigned in parentheses in the left side of an assignment statement.</span></span> <span data-ttu-id="9ca78-116">Örneğin, aşağıdaki deyim, dört ayrı değişkenlere 4 bölütlü öğelerini atar:</span><span class="sxs-lookup"><span data-stu-id="9ca78-116">For example, the following statement assigns the elements of a 4-tuple to four separate variables:</span></span>

```csharp
var (name, address, city, zip) = contact.GetAddressInfo();
```

<span data-ttu-id="9ca78-117">Bir tanımlama grubu deconstruct üç yolu vardır:</span><span class="sxs-lookup"><span data-stu-id="9ca78-117">There are three ways to deconstruct a tuple:</span></span>

- <span data-ttu-id="9ca78-118">Parantez içindeki her bir alan türü açıkça bildirebilir.</span><span class="sxs-lookup"><span data-stu-id="9ca78-118">You can explicitly declare the type of each field inside parentheses.</span></span> <span data-ttu-id="9ca78-119">Aşağıdaki örnek, tarafından döndürülen 3-tanımlama grubu deconstruct için bu yaklaşımı kullanır `QueryCityData` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="9ca78-119">The following example uses this approach to deconstruct the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Explicit](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]

- <span data-ttu-id="9ca78-120">Kullanabileceğiniz `var` C# her bir değişken türü algılar anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="9ca78-120">You can use the `var` keyword so that C# infers the type of each variable.</span></span> <span data-ttu-id="9ca78-121">Yerleştirdiğiniz `var` anahtar sözcüğü parantez dışında.</span><span class="sxs-lookup"><span data-stu-id="9ca78-121">You place the `var` keyword outside of the parentheses.</span></span> <span data-ttu-id="9ca78-122">Aşağıdaki örnek tür çıkarımı tarafından döndürülen 3-tanımlama grubu deconstructing kullanır `QueryCityData` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="9ca78-122">The following example uses type inference when deconstructing the 3-tuple returned by the `QueryCityData` method.</span></span>
 
    [!code-csharp[Deconstruction-Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]

    <span data-ttu-id="9ca78-123">Aynı zamanda `var` ayrı ayrı veya tamamını parantez içinde değişken bildirimleri olan anahtar sözcük.</span><span class="sxs-lookup"><span data-stu-id="9ca78-123">You can also use the `var` keyword individually with any or all of the variable declarations inside the parentheses.</span></span> 

    [!code-csharp[Deconstruction-Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]

    <span data-ttu-id="9ca78-124">Bu sıkıcı ve önerilmez.</span><span class="sxs-lookup"><span data-stu-id="9ca78-124">This is cumbersome and is not recommended.</span></span>

- <span data-ttu-id="9ca78-125">Son olarak, tanımlama grubu zaten tanımlanmış değişkenleri deconstruct.</span><span class="sxs-lookup"><span data-stu-id="9ca78-125">Lastly, you may deconstruct the tuple into variables that have already been declared.</span></span>

    [!code-csharp[Deconstruction-Declared](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple5.cs#1)]

<span data-ttu-id="9ca78-126">Dizideki her alan aynı türde olsa bile belirli bir tür parantez dışında belirtemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="9ca78-126">Note that you cannot specify a specific type outside the parentheses even if every field in the tuple has the same type.</span></span> <span data-ttu-id="9ca78-127">Derleyici Hatası "Deconstruction 'var (...)' form 'var' için belirli bir tür izin vermez." CS8136 oluşturur.</span><span class="sxs-lookup"><span data-stu-id="9ca78-127">This generates compiler error CS8136, "Deconstruction 'var (...)' form disallows a specific type for 'var'.".</span></span>

<span data-ttu-id="9ca78-128">Not, ayrıca her bir tanımlama grubu öğesi bir değişkene atamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9ca78-128">Note that you must also assign each element of the tuple to a variable.</span></span> <span data-ttu-id="9ca78-129">Herhangi bir öğe atlarsanız, derleyici hatası "'x' öğelerini tanımlama grubu 'y' değişkenleri deconstruct yapılamıyor." CS8132 oluşturur.</span><span class="sxs-lookup"><span data-stu-id="9ca78-129">If you omit any elements, the compiler generates error CS8132, "Cannot deconstruct a tuple of 'x' elements into 'y' variables."</span></span>

<span data-ttu-id="9ca78-130">Bildirimler ve bir deconstruction sol taraftaki mevcut değişkenler için atamaları karıştıramazsınız unutmayın.</span><span class="sxs-lookup"><span data-stu-id="9ca78-130">Note that you cannot mix declarations and assignments to existing variables on the left-hand side of a deconstruction.</span></span> <span data-ttu-id="9ca78-131">Derleyici Hatası "bir deconstruction bildirimler ve sol-hand tarafı ifadeleri karıştıramazsınız." CS8184 oluşturur</span><span class="sxs-lookup"><span data-stu-id="9ca78-131">The compiler generates error CS8184, "a deconstruction cannot mix declarations and expressions on the left-hand-side."</span></span> <span data-ttu-id="9ca78-132">ne zaman üyeleri yeni bildirilen ve varolan değişkenleri içerir.</span><span class="sxs-lookup"><span data-stu-id="9ca78-132">when the members include newly declared and existing variables.</span></span>

## <a name="deconstructing-tuple-elements-with-discards"></a><span data-ttu-id="9ca78-133">Tuple öğeleriyle deconstructing atar</span><span class="sxs-lookup"><span data-stu-id="9ca78-133">Deconstructing tuple elements with discards</span></span>

<span data-ttu-id="9ca78-134">Genellikle bir tanımlama grubu deconstructing, yalnızca bazı öğeler değerlerde ilgilendiğiniz.</span><span class="sxs-lookup"><span data-stu-id="9ca78-134">Often when deconstructing a tuple, you're interested in the values of only some elements.</span></span> <span data-ttu-id="9ca78-135">C# 7 ile başlayan, C# ' nin desteğini yararlanabilirsiniz *atar*, değerleri yoksaymak için seçtiğiniz salt yazılır değişkenleri olduğu.</span><span class="sxs-lookup"><span data-stu-id="9ca78-135">Starting with C# 7, you can take advantage of C#'s support for *discards*, which are write-only variables whose values you've chosen to ignore.</span></span> <span data-ttu-id="9ca78-136">Bir atma bir alt çizgi karakteriyle belirlenmiş ("\_") bir atamayı.</span><span class="sxs-lookup"><span data-stu-id="9ca78-136">A discard is designated by an underscore character ("\_") in an assignment.</span></span> <span data-ttu-id="9ca78-137">İstediğiniz kadar çok değerle atabilirsiniz; tüm tek atma tarafından temsil edilen `_`.</span><span class="sxs-lookup"><span data-stu-id="9ca78-137">You can discard as many values as you like; all are represented by the single discard, `_`.</span></span>

<span data-ttu-id="9ca78-138">Aşağıdaki örnek iptali içeren başlık kullanımını göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="9ca78-138">The following example illustrates the use of tuples with discards.</span></span> <span data-ttu-id="9ca78-139">`QueryCityDataForYears` Yöntemi bir şehir, kendi alanı, bir yılın, o yıl, ikinci bir yıl ve bu ikinci yıl Şehir 's popülasyon Şehir 's popülasyon adıyla 6-tanımlama grubu döndürür.</span><span class="sxs-lookup"><span data-stu-id="9ca78-139">The `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="9ca78-140">Örnek popülasyondaki bu iki yıl arasında değişiklik gösterir.</span><span class="sxs-lookup"><span data-stu-id="9ca78-140">The example shows the change in population between those two years.</span></span> <span data-ttu-id="9ca78-141">Verileri tanımlama grubu bulunan, biz Şehir alanıyla unconcerned ve şehir adı ve tasarım zamanında iki tarih biliyoruz.</span><span class="sxs-lookup"><span data-stu-id="9ca78-141">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="9ca78-142">Sonuç olarak, biz yalnızca düzeninde depolanan iki popülasyon değerleri ilgileniyor ve onun kalan değerler iptali olarak işleyebilir.</span><span class="sxs-lookup"><span data-stu-id="9ca78-142">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="9ca78-143">Deconstructing kullanıcı tanımlı türler</span><span class="sxs-lookup"><span data-stu-id="9ca78-143">Deconstructing user-defined types</span></span>

<span data-ttu-id="9ca78-144">Olmayan tanımlama grubu türleri için yerleşik destek atar sağlamaz.</span><span class="sxs-lookup"><span data-stu-id="9ca78-144">Non-tuple types do not offer built-in support for discards.</span></span> <span data-ttu-id="9ca78-145">Ancak, bir sınıf, yapı veya arabirim yazarı, bir veya daha fazla uygulayarak deconstructed için türün örneklerinin izin verebilirsiniz `Deconstruct` yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="9ca78-145">However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more `Deconstruct` methods.</span></span> <span data-ttu-id="9ca78-146">Yöntem void döndürür ve deconstructed için her bir değeri tarafından belirtilen bir [çıkışı](language-reference/keywords/out-parameter-modifier.md) yöntem imzası parametresi.</span><span class="sxs-lookup"><span data-stu-id="9ca78-146">The method returns void, and each value to be deconstructed is indicated by an [out](language-reference/keywords/out-parameter-modifier.md) parameter in the method signature.</span></span> <span data-ttu-id="9ca78-147">Örneğin, aşağıdaki `Deconstruct` yöntemi bir `Person` sınıfı, Orta, adı ve Soyadı döndürür:</span><span class="sxs-lookup"><span data-stu-id="9ca78-147">For example, the following `Deconstruct` method of a `Person` class returns the first, middle, and last name:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]

<span data-ttu-id="9ca78-148">Ardından örneği deconstruct `Person` adlı sınıf `p` aşağıdaki gibi bir atama:</span><span class="sxs-lookup"><span data-stu-id="9ca78-148">You can then deconstruct an instance of the `Person` class named `p` with an assignment like the following:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]

<span data-ttu-id="9ca78-149">Aşağıdaki örnek aşırı `Deconstruct` özelliklerini çeşitli döndürülecek yöntemi bir `Person` nesnesi.</span><span class="sxs-lookup"><span data-stu-id="9ca78-149">The following example overloads the `Deconstruct` method to return various combinations of properties of a `Person` object.</span></span> <span data-ttu-id="9ca78-150">Tek tek aşırı döndürün:</span><span class="sxs-lookup"><span data-stu-id="9ca78-150">Individual overloads return:</span></span>

- <span data-ttu-id="9ca78-151">İlk ve son adı.</span><span class="sxs-lookup"><span data-stu-id="9ca78-151">A first and last name.</span></span>
- <span data-ttu-id="9ca78-152">İlk, son olarak ve ikinci adı.</span><span class="sxs-lookup"><span data-stu-id="9ca78-152">A first, last, and middle name.</span></span>
- <span data-ttu-id="9ca78-153">Ad, Soyadı, bir şehrin adı ve durum adı.</span><span class="sxs-lookup"><span data-stu-id="9ca78-153">A first name, a last name, a city name, and a state name.</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]

<span data-ttu-id="9ca78-154">Aşırı yüklenebilir olduğundan `Deconstruct` genellikle bir nesneden ayıklanır veri grupları yansıtacak şekilde yöntemi tanımlamak dikkatli olmalıdır `Deconstruct` ayırt edici ve anlaşılır imzaları yöntemleriyle.</span><span class="sxs-lookup"><span data-stu-id="9ca78-154">Because you can overload the `Deconstruct` method to reflect groups of data that are commonly extracted from an object, you should be careful to define `Deconstruct` methods with signatures that are distinctive and unambiguous.</span></span> <span data-ttu-id="9ca78-155">Birden çok `Deconstruct` aynı sayıda yöntemleri `out` parametreleri veya aynı sayı ve tür `out` farklı bir düzende parametreleri karışıklığa neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="9ca78-155">Multiple `Deconstruct` methods that have the same number of `out` parameters or the same number and type of `out` parameters in a different order can cause confusion.</span></span> 

<span data-ttu-id="9ca78-156">Aşırı yüklenmiş `Deconstruct` yöntemi aşağıdaki örnekte bir olası kaynak karışıklık göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="9ca78-156">The overloaded `Deconstruct` method in the following example illustrates one possible source of confusion.</span></span> <span data-ttu-id="9ca78-157">Ad, ikinci adı, Soyadı ve yaş ilk aşırı döndürür bir `Person` bu sırayla nesnesi.</span><span class="sxs-lookup"><span data-stu-id="9ca78-157">The first overload returns the first name, middle name, last name, and age of a `Person` object, in that order.</span></span> <span data-ttu-id="9ca78-158">İkinci aşırı yalnızca yıllık geliri yanı sıra adı bilgi verir, ancak, Orta, adı ve Soyadı farklı bir sırada olur.</span><span class="sxs-lookup"><span data-stu-id="9ca78-158">The second overload returns name information only along with annual income, but the first, middle, and last name are in a different order.</span></span> <span data-ttu-id="9ca78-159">Bu bağımsız değişkenler sırasını deconstructing zaman karıştırır kolaylaştırır bir `Person` örneği.</span><span class="sxs-lookup"><span data-stu-id="9ca78-159">This makes it easy to confuse the order of arguments when deconstructing a `Person` instance.</span></span>

[!code-csharp[Deconstruct-ambiguity](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-ambiguous.cs)]

## <a name="deconstructing-a-user-defined-type-with-discards"></a><span data-ttu-id="9ca78-160">Kullanıcı tanımlı bir tür ile deconstructing atar</span><span class="sxs-lookup"><span data-stu-id="9ca78-160">Deconstructing a user-defined type with discards</span></span>

<span data-ttu-id="9ca78-161">İle yapmak gibi [diziler](#deconstructing-tuple-elements-with-discards), iptali tarafından döndürülen seçilen öğeleri yoksaymak için kullanabileceğiniz bir `Deconstruct` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="9ca78-161">Just as you do with [tuples](#deconstructing-tuple-elements-with-discards), you can use discards to ignore selected items returned by a `Deconstruct` method.</span></span> <span data-ttu-id="9ca78-162">Her atma adlı bir değişkeni tarafından tanımlanan "\_", bir tek deconstruction işlemi birden çok iptali içerebilir.</span><span class="sxs-lookup"><span data-stu-id="9ca78-162">Each discard is defined by a variable named "\_", and a single deconstruction operation can include multiple discards.</span></span>

<span data-ttu-id="9ca78-163">Aşağıdaki örnek deconstructs bir `Person` dört dizeleri (ilk ve son adları, şehir ve durumu) nesnesine ancak son adı ve durum atar.</span><span class="sxs-lookup"><span data-stu-id="9ca78-163">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state) but discards the last name and the state.</span></span>

[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]

## <a name="deconstructing-a-user-defined-type-with-an-extension-method"></a><span data-ttu-id="9ca78-164">Kullanıcı tanımlı bir tür bir genişletme yöntemi ile deconstructing</span><span class="sxs-lookup"><span data-stu-id="9ca78-164">Deconstructing a user-defined type with an extension method</span></span>

<span data-ttu-id="9ca78-165">Bir sınıf, yapı veya arabirim kaydetmedi yazarsanız, hala bu tür nesneleri bir veya daha fazla uygulayarak deconstruct `Deconstruct` [genişletme yöntemleri](programming-guide/classes-and-structs/extension-methods.md) içinde ilgi değer döndürmek için.</span><span class="sxs-lookup"><span data-stu-id="9ca78-165">If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more `Deconstruct` [extension methods](programming-guide/classes-and-structs/extension-methods.md) to return the values in which you're interested.</span></span> 

<span data-ttu-id="9ca78-166">Aşağıdaki örnekte iki tanımlar `Deconstruct` için genişletme yöntemleri <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="9ca78-166">The following example defines two `Deconstruct` extension methods for the <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="9ca78-167">İlk statik olup, türü de dahil olmak üzere bu özelliği özelliklerini göstermek veya örnek değerleri, salt okunur olup ve olup dizine kümesini döndürür.</span><span class="sxs-lookup"><span data-stu-id="9ca78-167">The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed.</span></span> <span data-ttu-id="9ca78-168">İkinci özelliğin erişilebilirlik gösterir.</span><span class="sxs-lookup"><span data-stu-id="9ca78-168">The second indicates the property's accessibility.</span></span> <span data-ttu-id="9ca78-169">Çünkü get erişilebilirliğini ve set erişimcileri farklı, Boole değerleri gösteren özelliği ayrı olup alma ve ayarlama erişimcisi ve aynı erişilebilirlik olup, varsa.</span><span class="sxs-lookup"><span data-stu-id="9ca78-169">Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility.</span></span> <span data-ttu-id="9ca78-170">Yalnızca bir erişimci veya aynı erişilebilirlik, hem get hem de set erişimcisine sahip `access` değişkeni özelliği erişilebilirlik bir bütün olarak gösterir.</span><span class="sxs-lookup"><span data-stu-id="9ca78-170">If there is only one accessor or both the get and the set accessor have the same accessibility, the `access` variable indicates the accessibility of the property as a whole.</span></span> <span data-ttu-id="9ca78-171">Aksi halde, get erişilebilirliğini ve erişimciler accessaccessibility tarafından belirtilen kümesi tarafından belirtilir `getAccess` ve `setAccess` değişkenleri.</span><span class="sxs-lookup"><span data-stu-id="9ca78-171">Otherwise, the accessibility of the get and set accessors are indicated by the accessaccessibility is indicated by the `getAccess` and `setAccess` variables.</span></span>

[!code-csharp[Extension-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]
 
## <a name="see-also"></a><span data-ttu-id="9ca78-172">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="9ca78-172">See also</span></span>
<span data-ttu-id="9ca78-173">[Atar](discards.md) </span><span class="sxs-lookup"><span data-stu-id="9ca78-173">[Discards](discards.md) </span></span>  
[<span data-ttu-id="9ca78-174">Diziler</span><span class="sxs-lookup"><span data-stu-id="9ca78-174">Tuples</span></span>](tuples.md)  

---
title: 'Nasıl yapılır: Dizin Ağacı ile Yineleme (C# Programlama Kılavuzu)'
ms.date: 07/20/2015
helpviewer_keywords:
- iterating through folders [C#]
- file iteration [C#]
ms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7
ms.openlocfilehash: 8222985e803972fb8d19159cfeaad93c9b08954d
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33327479"
---
# <a name="how-to-iterate-through-a-directory-tree-c-programming-guide"></a><span data-ttu-id="92ff5-102">Nasıl yapılır: Dizin Ağacı ile Yineleme (C# Programlama Kılavuzu)</span><span class="sxs-lookup"><span data-stu-id="92ff5-102">How to: Iterate Through a Directory Tree (C# Programming Guide)</span></span>
<span data-ttu-id="92ff5-103">Her iç içe alt herhangi bir derinliğe bir belirtilen kök klasörü altında her dosyaya erişmek deyimi "dizin ağacı yinelemek" anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="92ff5-103">The phrase "iterate a directory tree" means to access each file in each nested subdirectory under a specified root folder, to any depth.</span></span> <span data-ttu-id="92ff5-104">Mutlaka her dosyayı açmak gerekmez.</span><span class="sxs-lookup"><span data-stu-id="92ff5-104">You do not necessarily have to open each file.</span></span> <span data-ttu-id="92ff5-105">Dosya veya alt dizini olarak adını alıp bir `string`, veya biçiminde ek bilgi almak bir <xref:System.IO.FileInfo?displayProperty=nameWithType> veya <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> nesne.</span><span class="sxs-lookup"><span data-stu-id="92ff5-105">You can just retrieve the name of the file or subdirectory as a `string`, or you can retrieve additional information in the form of a <xref:System.IO.FileInfo?displayProperty=nameWithType> or <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="92ff5-106">Windows'da koşulları "dizin" ve "klasörü" birbirlerinin yerine kullanılır.</span><span class="sxs-lookup"><span data-stu-id="92ff5-106">In Windows, the terms "directory" and "folder" are used interchangeably.</span></span> <span data-ttu-id="92ff5-107">Çoğu belgeleri ve kullanıcı arabirimi metin "klasörü," terimini kullanır ancak [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] sınıf kitaplığı "directory" terimini kullanır</span><span class="sxs-lookup"><span data-stu-id="92ff5-107">Most documentation and user interface text uses the term "folder," but the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] class library uses the term "directory."</span></span>  
  
 <span data-ttu-id="92ff5-108">En basit durumda, bildiğiniz belirli belirtilen kökü altındaki tüm dizinler için erişim izinlerine sahip kullanabileceğiniz `System.IO.SearchOption.AllDirectories` bayrağı.</span><span class="sxs-lookup"><span data-stu-id="92ff5-108">In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the `System.IO.SearchOption.AllDirectories` flag.</span></span> <span data-ttu-id="92ff5-109">Bu bayrak belirtilen desenle eşleşen tüm iç içe alt dizinleri döndürür.</span><span class="sxs-lookup"><span data-stu-id="92ff5-109">This flag returns all the nested subdirectories that match the specified pattern.</span></span> <span data-ttu-id="92ff5-110">Aşağıdaki örnekte bu bayrak kullanmayı gösterir.</span><span class="sxs-lookup"><span data-stu-id="92ff5-110">The following example shows how to use this flag.</span></span>  
  
```csharp  
root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);  
```  
  
 <span data-ttu-id="92ff5-111">Belirtilen kök dizinler herhangi biri neden olursa olan Bu yaklaşımda zayıflık bir <xref:System.IO.DirectoryNotFoundException> veya <xref:System.UnauthorizedAccessException>, tüm yöntemi başarısız olur ve hiçbir dizinleri döndürür.</span><span class="sxs-lookup"><span data-stu-id="92ff5-111">The weakness in this approach is that if any one of the subdirectories under the specified root causes a <xref:System.IO.DirectoryNotFoundException> or <xref:System.UnauthorizedAccessException>, the whole method fails and returns no directories.</span></span> <span data-ttu-id="92ff5-112">Kullandığınızda, aynı durum geçerlidir <xref:System.IO.DirectoryInfo.GetFiles%2A> yöntemi.</span><span class="sxs-lookup"><span data-stu-id="92ff5-112">The same is true when you use the <xref:System.IO.DirectoryInfo.GetFiles%2A> method.</span></span> <span data-ttu-id="92ff5-113">Belirli alt klasörlerdeki bu özel durumları işlemek varsa, el ile dizin ağacında, aşağıdaki örneklerde gösterildiği gibi yol gerekir.</span><span class="sxs-lookup"><span data-stu-id="92ff5-113">If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.</span></span>  
  
 <span data-ttu-id="92ff5-114">El ile bir dizin ağacında yol olduğunda, ilk alt dizinleri işlemek (*öncesi sipariş geçişi*), veya dosyaları ilk (*sonrası sipariş geçişi*).</span><span class="sxs-lookup"><span data-stu-id="92ff5-114">When you manually walk a directory tree, you can handle the subdirectories first (*pre-order traversal*), or the files first (*post-order traversal*).</span></span> <span data-ttu-id="92ff5-115">Ön sipariş geçişi gerçekleştirirseniz, ağacın tamamı geçerli klasörün altında doğrudan bu klasörde kendisini dosyaları üzerinden yineleme önce yol.</span><span class="sxs-lookup"><span data-stu-id="92ff5-115">If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself.</span></span> <span data-ttu-id="92ff5-116">Daha sonra bu belgedeki örneklerde sonrası sipariş geçişi gerçekleştirmek, ancak bunları öncesi sipariş geçişi gerçekleştirmek için kolayca değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="92ff5-116">The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.</span></span>  
  
 <span data-ttu-id="92ff5-117">Başka bir yineleme veya yığın tabanlı geçişi kullanıp kullanmayacağınızı seçenektir.</span><span class="sxs-lookup"><span data-stu-id="92ff5-117">Another option is whether to use recursion or a stack-based traversal.</span></span> <span data-ttu-id="92ff5-118">Bu belgenin sonraki bölümlerinde örnekler, her iki yaklaşımın gösterir.</span><span class="sxs-lookup"><span data-stu-id="92ff5-118">The examples later in this document show both approaches.</span></span>  
  
 <span data-ttu-id="92ff5-119">Çeşitli dosyalar ve klasörler üzerinde işlem gerçekleştirmek varsa, yeniden düzenleme işlemi tek bir temsilci kullanarak çağırabileceği ayrı işlevler halinde tarafından bu örnekler modülarize etmek.</span><span class="sxs-lookup"><span data-stu-id="92ff5-119">If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="92ff5-120">NTFS dosya sistemleri içerebilir *yeniden ayrıştırma noktalarını* biçiminde *birleşim noktaları*, *sembolik bağlantılar*, ve *sabit bağlantıları*.</span><span class="sxs-lookup"><span data-stu-id="92ff5-120">NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*.</span></span> <span data-ttu-id="92ff5-121">.NET Framework yöntemlerini gibi <xref:System.IO.DirectoryInfo.GetFiles%2A> ve <xref:System.IO.DirectoryInfo.GetDirectories%2A> bir yeniden inceleme noktası altında herhangi bir alt dizine döndürmez.</span><span class="sxs-lookup"><span data-stu-id="92ff5-121">The .NET Framework methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point.</span></span> <span data-ttu-id="92ff5-122">Bu davranış, iki yeniden ayrıştırma noktaları birbirine başvurduğunuzda sonsuz bir döngüde girerek riski karşı korur.</span><span class="sxs-lookup"><span data-stu-id="92ff5-122">This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other.</span></span> <span data-ttu-id="92ff5-123">Genel olarak, size değil kasıtsız olarak değiştirin veya dosyaları silin emin olmak için yeniden ayrıştırma noktaları ile dağıttığınızda onaylamadığından çok dikkatli kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="92ff5-123">In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files.</span></span> <span data-ttu-id="92ff5-124">Yeniden ayrıştırma noktaları üzerinden kesin bir denetim gerektiriyorsa, platform çağırma kullanma ya da uygun Win32 dosya sistemi yöntemleri doğrudan çağırmak için yerel kodu.</span><span class="sxs-lookup"><span data-stu-id="92ff5-124">If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="92ff5-125">Örnek</span><span class="sxs-lookup"><span data-stu-id="92ff5-125">Example</span></span>  
 <span data-ttu-id="92ff5-126">Aşağıdaki örnek, bir dizin ağacında özyineleme kullanarak yol gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="92ff5-126">The following example shows how to walk a directory tree by using recursion.</span></span> <span data-ttu-id="92ff5-127">Özyinelemeli yaklaşım Zarif ancak dizin ağacında büyük ve iç içe ise bir yığın taşması özel durumu neden olma olasılığı vardır.</span><span class="sxs-lookup"><span data-stu-id="92ff5-127">The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.</span></span>  
  
 <span data-ttu-id="92ff5-128">İşlenen belirli özel durumları ve her dosya veya klasör, gerçekleştirilen belirli eylemleri yalnızca örnektir.</span><span class="sxs-lookup"><span data-stu-id="92ff5-128">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="92ff5-129">Belirli gereksinimlerinizi karşılamak için bu kodu değiştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="92ff5-129">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="92ff5-130">Daha fazla bilgi için kod yer alan yorumlara bakın.</span><span class="sxs-lookup"><span data-stu-id="92ff5-130">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#1](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_1.cs)]  
  
## <a name="example"></a><span data-ttu-id="92ff5-131">Örnek</span><span class="sxs-lookup"><span data-stu-id="92ff5-131">Example</span></span>  
 <span data-ttu-id="92ff5-132">Aşağıdaki örnek, dosya ve klasörlerin bir dizin ağacında özyineleme kullanmadan yinelemek gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="92ff5-132">The following example shows how to iterate through files and folders in a directory tree without using recursion.</span></span> <span data-ttu-id="92ff5-133">Bu teknik genel kullanan <xref:System.Collections.Generic.Stack%601> son giren ilk çıkar (LIFO) yığınında olan koleksiyon türü.</span><span class="sxs-lookup"><span data-stu-id="92ff5-133">This technique uses the generic <xref:System.Collections.Generic.Stack%601> collection type, which is a last in first out (LIFO) stack.</span></span>  
  
 <span data-ttu-id="92ff5-134">İşlenen belirli özel durumları ve her dosya veya klasör, gerçekleştirilen belirli eylemleri yalnızca örnektir.</span><span class="sxs-lookup"><span data-stu-id="92ff5-134">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="92ff5-135">Belirli gereksinimlerinizi karşılamak için bu kodu değiştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="92ff5-135">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="92ff5-136">Daha fazla bilgi için kod yer alan yorumlara bakın.</span><span class="sxs-lookup"><span data-stu-id="92ff5-136">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#2](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_2.cs)]  
  
 <span data-ttu-id="92ff5-137">Genellikle, her klasör uygulamanızı açmak için izni olup olmadığını belirlemek için test etmek çok zaman alır.</span><span class="sxs-lookup"><span data-stu-id="92ff5-137">It is generally too time-consuming to test every folder to determine whether your application has permission to open it.</span></span> <span data-ttu-id="92ff5-138">Bu nedenle, kod örneğinde işlemde kısmı yalnızca kapsayan bir `try/catch` bloğu.</span><span class="sxs-lookup"><span data-stu-id="92ff5-138">Therefore, the code example just encloses that part of the operation in a `try/catch` block.</span></span> <span data-ttu-id="92ff5-139">Değiştirebileceğiniz `catch` böylece bir klasöre erişmesi reddedildiğinde, izinlerinizi yükseltmek ve yeniden erişmek çalıştığınızda engelleme.</span><span class="sxs-lookup"><span data-stu-id="92ff5-139">You can modify the `catch` block so that when you are denied access to a folder, you try to elevate your permissions and then access it again.</span></span> <span data-ttu-id="92ff5-140">Bir kural olarak, yalnızca bilinmeyen bir durumda, uygulamanızın ayrılmadan işleyebilir bu özel durumları yakalar.</span><span class="sxs-lookup"><span data-stu-id="92ff5-140">As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.</span></span>  
  
 <span data-ttu-id="92ff5-141">Bellek veya disk üzerindeki bir dizin ağacında içeriğini depolamanız gerekir, yalnızca depolamak için en iyi seçenek olan <xref:System.IO.FileSystemInfo.FullName%2A> özelliği (tür `string`) her dosya için.</span><span class="sxs-lookup"><span data-stu-id="92ff5-141">If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <xref:System.IO.FileSystemInfo.FullName%2A> property (of type `string`) for each file.</span></span> <span data-ttu-id="92ff5-142">Yeni bir oluşturmak için bu dizeyi ardından kullanabilirsiniz <xref:System.IO.FileInfo> veya <xref:System.IO.DirectoryInfo> nesne gerektiğinde veya ek işleme gerektiren herhangi bir dosyayı açın.</span><span class="sxs-lookup"><span data-stu-id="92ff5-142">You can then use this string to create a new <xref:System.IO.FileInfo> or <xref:System.IO.DirectoryInfo> object as necessary, or open any file that requires additional processing.</span></span>  
  
## <a name="robust-programming"></a><span data-ttu-id="92ff5-143">Güçlü Programlama</span><span class="sxs-lookup"><span data-stu-id="92ff5-143">Robust Programming</span></span>  
 <span data-ttu-id="92ff5-144">Sağlam dosya yineleme kodu dosya sisteminin birçok karmaşıklık dikkate almanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="92ff5-144">Robust file iteration code must take into account many complexities of the file system.</span></span> <span data-ttu-id="92ff5-145">Windows dosya sistemi ile ilgili daha fazla bilgi için bkz: [NTFS teknik başvuru](https://technet.microsoft.com/library/81cc8a8a-bd32-4786-a849-03245d68d8e4).</span><span class="sxs-lookup"><span data-stu-id="92ff5-145">For more information on the Windows file system, see [NTFS Technical Reference](https://technet.microsoft.com/library/81cc8a8a-bd32-4786-a849-03245d68d8e4).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="92ff5-146">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="92ff5-146">See Also</span></span>  
 <xref:System.IO>  
 [<span data-ttu-id="92ff5-147">LINQ ve Dosya Dizinleri</span><span class="sxs-lookup"><span data-stu-id="92ff5-147">LINQ and File Directories</span></span>](../../../csharp/programming-guide/concepts/linq/linq-and-file-directories.md)  
 [<span data-ttu-id="92ff5-148">Dosya sistemi ve kayıt defteri (C# programlama Kılavuzu)</span><span class="sxs-lookup"><span data-stu-id="92ff5-148">File System and the Registry (C# Programming Guide)</span></span>](../../../csharp/programming-guide/file-system/index.md)

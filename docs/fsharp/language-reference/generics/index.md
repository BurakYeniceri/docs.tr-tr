---
title: Genel Türler (F#)
description: 'F # genel işlevler ve çeşitli türleri kod yinelenen olmadan çalışan kod yazmanıza olanak sağlayan türleri kullanmayı öğrenin.'
ms.date: 05/16/2016
ms.openlocfilehash: 332e42dd53689440757da04727b69eb3d85ca0fa
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33565506"
---
# <a name="generics"></a><span data-ttu-id="10a89-103">Genel Türler</span><span class="sxs-lookup"><span data-stu-id="10a89-103">Generics</span></span>

<span data-ttu-id="10a89-104">F # işlevi değerleri, yöntemler, özellikler ve sınıflar gibi toplama türleri kaydeder ve ayrılmış birleşimler olabilir *genel*.</span><span class="sxs-lookup"><span data-stu-id="10a89-104">F# function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be *generic*.</span></span> <span data-ttu-id="10a89-105">Genel yapılar genellikle genel yapı kullanıcı tarafından sağlanan en az bir tür parametresi içerir.</span><span class="sxs-lookup"><span data-stu-id="10a89-105">Generic constructs contain at least one type parameter, which is usually supplied by the user of the generic construct.</span></span> <span data-ttu-id="10a89-106">Genel işlevler ve türleri, kodu her türü için yinelenen olmadan çeşitli türleri ile çalışır kod yazmanıza olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="10a89-106">Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</span></span> <span data-ttu-id="10a89-107">Genellikle, kodunuzu örtük olarak genel olarak derleyicinin tür çıkarımı ve otomatik Genelleştirme mekanizmaları tarafından algılanır için kodunuzu genel yapılması F #'ta basit olabilir.</span><span class="sxs-lookup"><span data-stu-id="10a89-107">Making your code generic can be simple in F#, because often your code is implicitly inferred to be generic by the compiler's type inference and automatic generalization mechanisms.</span></span>


## <a name="syntax"></a><span data-ttu-id="10a89-108">Sözdizimi</span><span class="sxs-lookup"><span data-stu-id="10a89-108">Syntax</span></span>

```fsharp
// Explicitly generic function.
let function-name<type-parameters> parameter-list =
function-body

// Explicitly generic method.
[ static ] member object-identifer.method-name<type-parameters> parameter-list [ return-type ] =
method-body

// Explicitly generic class, record, interface, structure,
// or discriminated union.
type type-name<type-parameters> type-definition
```

## <a name="remarks"></a><span data-ttu-id="10a89-109">Açıklamalar</span><span class="sxs-lookup"><span data-stu-id="10a89-109">Remarks</span></span>
<span data-ttu-id="10a89-110">Bir açıkça genel işlevi ya da türü bildirimi genel olmayan işlevi veya tür parametrelerinde köşeli işlevi veya tür adından sonra belirtimi (ve kullanım) dışında türü benzer.</span><span class="sxs-lookup"><span data-stu-id="10a89-110">The declaration of an explicitly generic function or type is much like that of a non-generic function or type, except for the specification (and use) of the type parameters, in angle brackets after the function or type name.</span></span>

<span data-ttu-id="10a89-111">Bildirimleri genellikle örtük olarak geneldir.</span><span class="sxs-lookup"><span data-stu-id="10a89-111">Declarations are often implicitly generic.</span></span> <span data-ttu-id="10a89-112">Tam olarak bir işlevi veya türü oluşturmak için kullanılan her parametrenin türü belirtmezseniz, derleyici her parametre, değer ve değişken yazdığınız kodun türünü Infer dener.</span><span class="sxs-lookup"><span data-stu-id="10a89-112">If you do not fully specify the type of every parameter that is used to compose a function or type, the compiler attempts to infer the type of each parameter, value, and variable from the code you write.</span></span> <span data-ttu-id="10a89-113">Daha fazla bilgi için bkz: [tür çıkarımı](../type-inference.md).</span><span class="sxs-lookup"><span data-stu-id="10a89-113">For more information, see [Type Inference](../type-inference.md).</span></span> <span data-ttu-id="10a89-114">Kod türünü veya işlevi için parametre türlerini aksi kısıtlamaz, işlev veya türü örtük olarak genel olur.</span><span class="sxs-lookup"><span data-stu-id="10a89-114">If the code for your type or function does not otherwise constrain the types of parameters, the function or type is implicitly generic.</span></span> <span data-ttu-id="10a89-115">Bu işlem adlı *otomatik Genelleştirme*.</span><span class="sxs-lookup"><span data-stu-id="10a89-115">This process is named *automatic generalization*.</span></span> <span data-ttu-id="10a89-116">Otomatik Genelleştirme üzerinde bazı sınırlamalar vardır.</span><span class="sxs-lookup"><span data-stu-id="10a89-116">There are some limits on automatic generalization.</span></span> <span data-ttu-id="10a89-117">Örneğin, F # derleyici genel bir yapı için türlerini anlamak kaydedemediği derleyici adlı bir kısıtlama başvuran bir hata bildirir *değer kısıtlaması*.</span><span class="sxs-lookup"><span data-stu-id="10a89-117">For example, if the F# compiler is unable to infer the types for a generic construct, the compiler reports an error that refers to a restriction called the *value restriction*.</span></span> <span data-ttu-id="10a89-118">Bu durumda, bazı tür ek açıklamaları eklemek zorunda kalabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="10a89-118">In that case, you may have to add some type annotations.</span></span> <span data-ttu-id="10a89-119">Otomatik Genelleştirme ve değer kısıtlama ve sorunu gidermek için kodunuzu değiştirme hakkında daha fazla bilgi için bkz: [otomatik Genelleştirme](automatic-generalization.md).</span><span class="sxs-lookup"><span data-stu-id="10a89-119">For more information about automatic generalization and the value restriction, and how to change your code to address the problem, see [Automatic Generalization](automatic-generalization.md).</span></span>

<span data-ttu-id="10a89-120">Önceki sözdiziminde *tür parametreleri* her biri daha fazla ne türleri olabilir sınırlayan isteğe bağlı olarak bir kısıtlama yan tümcesi ile tek tırnak işareti ile başlayan bir virgülle ayrılmış listesi bilinmeyen türleri temsil eden parametreleri Bu tür parametresi için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="10a89-120">In the previous syntax, *type-parameters* is a comma-separated list of parameters that represent unknown types, each of which starts with a single quotation mark, optionally with a constraint clause that further limits what types may be used for that type parameter.</span></span> <span data-ttu-id="10a89-121">Sözdizimi kısıtlaması yan tümceleri çeşitli türleri ve kısıtlamalar hakkında diğer bilgi için bkz: [kısıtlamaları](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="10a89-121">For the syntax for constraint clauses of various kinds and other information about constraints, see [Constraints](constraints.md).</span></span>

<span data-ttu-id="10a89-122">*Tür tanımı* sözdiziminde genel olmayan bir tür için tür tanımı ile aynıdır.</span><span class="sxs-lookup"><span data-stu-id="10a89-122">The *type-definition* in the syntax is the same as the type definition for a non-generic type.</span></span> <span data-ttu-id="10a89-123">İsteğe bağlı bir sınıf türü için Oluşturucusu parametreleri içeren `as` yan tümcesi, eşit simgesi, kayıt alanları `inherit` yan tümcesi, ayrılmış bir birleşim seçenekleri `let` ve `do` bağlamaları, üye tanımları ve başka bir şey genel olmayan tür tanımında izin verilir.</span><span class="sxs-lookup"><span data-stu-id="10a89-123">It includes the constructor parameters for a class type, an optional `as` clause, the equal symbol, the record fields, the `inherit` clause, the choices for a discriminated union, `let` and `do` bindings, member definitions, and anything else permitted in a non-generic type definition.</span></span>

<span data-ttu-id="10a89-124">Bir söz dizimi öğeleri genel olmayan işlevleri ve türler için aynıdır.</span><span class="sxs-lookup"><span data-stu-id="10a89-124">The other syntax elements are the same as those for non-generic functions and types.</span></span> <span data-ttu-id="10a89-125">Örneğin, *nesne tanımlayıcısı* içeren nesneyi temsil eden bir tanımlayıcıdır.</span><span class="sxs-lookup"><span data-stu-id="10a89-125">For example, *object-identifier* is an identifier that represents the containing object itself.</span></span>

<span data-ttu-id="10a89-126">Özellikler, alanlar ve oluşturucular kendilerini kapsayan türle daha fazla genel olamaz.</span><span class="sxs-lookup"><span data-stu-id="10a89-126">Properties, fields, and constructors cannot be more generic than the enclosing type.</span></span> <span data-ttu-id="10a89-127">Ayrıca, bir modül değerlerde genel olamaz.</span><span class="sxs-lookup"><span data-stu-id="10a89-127">Also, values in a module cannot be generic.</span></span>


## <a name="implicitly-generic-constructs"></a><span data-ttu-id="10a89-128">Örtük olarak genel yapılar</span><span class="sxs-lookup"><span data-stu-id="10a89-128">Implicitly Generic Constructs</span></span>
<span data-ttu-id="10a89-129">F # derleyici kodunuzu türlerinde oluşturur, genel olarak genel herhangi bir işlev otomatik olarak algılar.</span><span class="sxs-lookup"><span data-stu-id="10a89-129">When the F# compiler infers the types in your code, it automatically treats any function that can be generic as generic.</span></span> <span data-ttu-id="10a89-130">Bir tür parametre türü gibi açıkça belirtirseniz otomatik Genelleştirme engeller.</span><span class="sxs-lookup"><span data-stu-id="10a89-130">If you specify a type explicitly, such as a parameter type, you prevent automatic generalization.</span></span>

<span data-ttu-id="10a89-131">Aşağıdaki kod örneğinde, `makeList` rağmen ne parametreleri açıkça olarak genel bildirilir geneldir.</span><span class="sxs-lookup"><span data-stu-id="10a89-131">In the following code example, `makeList` is generic, even though neither it nor its parameters are explicitly declared as generic.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1700.fs)]

<span data-ttu-id="10a89-132">İşlev imzası olmasını çıkarımı yapılan `'a -> 'a -> 'a list`.</span><span class="sxs-lookup"><span data-stu-id="10a89-132">The signature of the function is inferred to be `'a -> 'a -> 'a list`.</span></span> <span data-ttu-id="10a89-133">Unutmayın `a` ve `b` Bu örnekte, aynı türe sahip algılanır.</span><span class="sxs-lookup"><span data-stu-id="10a89-133">Note that `a` and `b` in this example are inferred to have the same type.</span></span> <span data-ttu-id="10a89-134">Bu listedeki birlikte bulunur ve listesini tüm öğeleri aynı türde olmalıdır çünkü.</span><span class="sxs-lookup"><span data-stu-id="10a89-134">This is because they are included in a list together, and all elements of a list must be of the same type.</span></span>

<span data-ttu-id="10a89-135">Ayrıca bir işlev parametre türü bir genel tür parametresi olduğunu belirtmek için bir tür açıklama içinde tek tırnak işareti sözdizimini kullanarak genel yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="10a89-135">You can also make a function generic by using the single quotation mark syntax in a type annotation to indicate that a parameter type is a generic type parameter.</span></span> <span data-ttu-id="10a89-136">Aşağıdaki kodda, `function1` türü parametreleri olarak bildirilen parametreleri bu şekilde, çünkü geneldir.</span><span class="sxs-lookup"><span data-stu-id="10a89-136">In the following code, `function1` is generic because its parameters are declared in this manner, as type parameters.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1701.fs)]
    
## <a name="explicitly-generic-constructs"></a><span data-ttu-id="10a89-137">Açıkça genel yapılar</span><span class="sxs-lookup"><span data-stu-id="10a89-137">Explicitly Generic Constructs</span></span>
<span data-ttu-id="10a89-138">Ayrıca bir işlev türü parametrelerinin köşeli ayraç içinde açıkça bildirerek genel yapabilirsiniz (`<type-parameter>`).</span><span class="sxs-lookup"><span data-stu-id="10a89-138">You can also make a function generic by explicitly declaring its type parameters in angle brackets (`<type-parameter>`).</span></span> <span data-ttu-id="10a89-139">Aşağıdaki kod bunu göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="10a89-139">The following code illustrates this.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1703.fs)]
    
## <a name="using-generic-constructs"></a><span data-ttu-id="10a89-140">Genel kullanarak oluşturur</span><span class="sxs-lookup"><span data-stu-id="10a89-140">Using Generic Constructs</span></span>
<span data-ttu-id="10a89-141">Genel işlevler veya yöntemler kullandığınızda, tür bağımsız değişkenleri belirtmek sahip olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="10a89-141">When you use generic functions or methods, you might not have to specify the type arguments.</span></span> <span data-ttu-id="10a89-142">Derleyici tür çıkarımı uygun tür bağımsız değişkenleri anlamak için kullanır.</span><span class="sxs-lookup"><span data-stu-id="10a89-142">The compiler uses type inference to infer the appropriate type arguments.</span></span> <span data-ttu-id="10a89-143">Hala bir belirsizlik ise, tür bağımsız değişkenleri köşeli parantez içinde birden çok tür bağımsız değişkenleri virgül ile ayırarak sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="10a89-143">If there is still an ambiguity, you can supply type arguments in angle brackets, separating multiple type arguments with commas.</span></span>

<span data-ttu-id="10a89-144">Aşağıdaki kod önceki bölümlerde tanımlanan işlevler kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="10a89-144">The following code shows the use of the functions that are defined in the previous sections.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1702.fs)]
    
>[!NOTE]
<span data-ttu-id="10a89-145">Genel bir tür adıyla başvurmak için iki yolu vardır.</span><span class="sxs-lookup"><span data-stu-id="10a89-145">There are two ways to refer to a generic type by name.</span></span> <span data-ttu-id="10a89-146">Örneğin, `list<int>` ve `int list` genel bir tür başvurmak iki şekilde yapabilirsiniz `list` tek tür bağımsız değişkeni olan `int`.</span><span class="sxs-lookup"><span data-stu-id="10a89-146">For example, `list<int>` and `int list` are two ways to refer to a generic type `list` that has a single type argument `int`.</span></span> <span data-ttu-id="10a89-147">İkinci form işleme, genel yalnızca yerleşik F # türleri ile aşağıdaki gibi kullanılır `list` ve `option`.</span><span class="sxs-lookup"><span data-stu-id="10a89-147">The latter form is conventionally used only with built-in F# types such as `list` and `option`.</span></span> <span data-ttu-id="10a89-148">Birden çok tür bağımsız değişkeni varsa, söz dizimi normalde kullandığınız `Dictionary<int, string>` sözdizimini de kullanabilirsiniz, ancak `(int, string) Dictionary`.</span><span class="sxs-lookup"><span data-stu-id="10a89-148">If there are multiple type arguments, you normally use the syntax `Dictionary<int, string>` but you can also use the syntax `(int, string) Dictionary`.</span></span>

## <a name="wildcards-as-type-arguments"></a><span data-ttu-id="10a89-149">Tür bağımsız değişkenleri olarak joker karakterler</span><span class="sxs-lookup"><span data-stu-id="10a89-149">Wildcards as Type Arguments</span></span>
<span data-ttu-id="10a89-150">Tür bağımsız değişkeni derleyici tarafından çıkarılmamalıdır belirtmek için alt çizgi veya joker karakter sembolünü kullanabilirsiniz (`_`), adlandırılmış tür bağımsız değişkeni yerine.</span><span class="sxs-lookup"><span data-stu-id="10a89-150">To specify that a type argument should be inferred by the compiler, you can use the underscore, or wildcard symbol (`_`), instead of a named type argument.</span></span> <span data-ttu-id="10a89-151">Bu aşağıdaki kodda gösterilir.</span><span class="sxs-lookup"><span data-stu-id="10a89-151">This is shown in the following code.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1704.fs)]
    
## <a name="constraints-in-generic-types-and-functions"></a><span data-ttu-id="10a89-152">Genel türler ve İşlevler kısıtlamaları</span><span class="sxs-lookup"><span data-stu-id="10a89-152">Constraints in Generic Types and Functions</span></span>
<span data-ttu-id="10a89-153">Genel tür veya işlev tanımı genel tür parametresi kullanılabilir olması için bilinen yapıları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="10a89-153">In a generic type or function definition, you can use only those constructs that are known to be available on the generic type parameter.</span></span> <span data-ttu-id="10a89-154">Bu işlev ve yöntem çağrıları doğrulama derleme zamanında etkinleştirmek için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="10a89-154">This is required to enable the verification of function and method calls at compile time.</span></span> <span data-ttu-id="10a89-155">Tür parametreleri açıkça bildirirseniz derleyici belirli yöntemler ve işlevleri kullanılabilir olduğunu bildirmek için genel tür parametresi açık bir kısıtlaması uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="10a89-155">If you declare your type parameters explicitly, you can apply an explicit constraint to a generic type parameter to notify the compiler that certain methods and functions are available.</span></span> <span data-ttu-id="10a89-156">Genel parametre türleri anlamak F # derleyici izin verirseniz, ancak bunu uygun kısıtlamaları sizin için belirler.</span><span class="sxs-lookup"><span data-stu-id="10a89-156">However, if you allow the F# compiler to infer your generic parameter types, it will determine the appropriate constraints for you.</span></span> <span data-ttu-id="10a89-157">Daha fazla bilgi için bkz: [kısıtlamaları](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="10a89-157">For more information, see [Constraints](constraints.md).</span></span>


## <a name="statically-resolved-type-parameters"></a><span data-ttu-id="10a89-158">Statik Olarak Çözümlenmiş Tür Parametreleri</span><span class="sxs-lookup"><span data-stu-id="10a89-158">Statically Resolved Type Parameters</span></span>
<span data-ttu-id="10a89-159">F # programlarında kullanılabilir tür parametreleri iki tür vardır.</span><span class="sxs-lookup"><span data-stu-id="10a89-159">There are two kinds of type parameters that can be used in F# programs.</span></span> <span data-ttu-id="10a89-160">Genel tür parametreleri önceki bölümlerde açıklanan tür ilk var.</span><span class="sxs-lookup"><span data-stu-id="10a89-160">The first are generic type parameters of the kind described in the previous sections.</span></span> <span data-ttu-id="10a89-161">Tür parametresi ilk bu tür, Visual Basic ve C# gibi dillerde kullanılan genel tür parametreleri eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="10a89-161">This first kind of type parameter is equivalent to the generic type parameters that are used in languages such as Visual Basic and C#.</span></span> <span data-ttu-id="10a89-162">Tür parametresi başka bir tür F # için özel ve olarak adlandırılır bir *statik olarak çözümlenmiş tür parametresi*.</span><span class="sxs-lookup"><span data-stu-id="10a89-162">Another kind of type parameter is specific to F# and is referred to as a *statically resolved type parameter*.</span></span> <span data-ttu-id="10a89-163">Bu yapılar hakkında daha fazla bilgi için bkz: [statik olarak çözümlenmiş tür parametreleri](statically-resolved-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="10a89-163">For information about these constructs, see [Statically Resolved Type Parameters](statically-resolved-type-parameters.md).</span></span>


## <a name="examples"></a><span data-ttu-id="10a89-164">Örnekler</span><span class="sxs-lookup"><span data-stu-id="10a89-164">Examples</span></span>
[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1705.fs)]
    
## <a name="see-also"></a><span data-ttu-id="10a89-165">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="10a89-165">See Also</span></span>
[<span data-ttu-id="10a89-166">Dil Başvurusu</span><span class="sxs-lookup"><span data-stu-id="10a89-166">Language Reference</span></span>](../index.md)

[<span data-ttu-id="10a89-167">Türler</span><span class="sxs-lookup"><span data-stu-id="10a89-167">Types</span></span>](../fsharp-types.md)

[<span data-ttu-id="10a89-168">Statik Olarak Çözümlenmiş Tür Parametreleri</span><span class="sxs-lookup"><span data-stu-id="10a89-168">Statically Resolved Type Parameters</span></span>](statically-resolved-type-parameters.md)

[<span data-ttu-id="10a89-169">.NET Framework'te genel türler</span><span class="sxs-lookup"><span data-stu-id="10a89-169">Generics in the .NET Framework</span></span>](~/docs/standard/generics/index.md)

[<span data-ttu-id="10a89-170">Otomatik Genelleştirme</span><span class="sxs-lookup"><span data-stu-id="10a89-170">Automatic Generalization</span></span>](automatic-generalization.md)

[<span data-ttu-id="10a89-171">Kısıtlamalar</span><span class="sxs-lookup"><span data-stu-id="10a89-171">Constraints</span></span>](constraints.md)

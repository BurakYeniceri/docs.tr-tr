---
title: "Desen eşleştirme C# Kılavuzu"
description: "C# ' ifadelerin eşleşen kalıbı hakkında bilgi edinin"
keywords: .NET, .NET core, C#
ms.date: 01/24/2017
ms.author: wiwagn
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 0c77c3c3da9983d20cdd86db18f60f83b86b07ea
ms.sourcegitcommit: 281070dee88db86ec3bb4634d5f558d1a4e159dd
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/11/2017
---
# <a name="pattern-matching"></a><span data-ttu-id="31a27-104">Desen Eşleştirme</span><span class="sxs-lookup"><span data-stu-id="31a27-104">Pattern Matching</span></span> #

<span data-ttu-id="31a27-105">Desenler test değerine belirli bir sahip *şekil*ve *ayıklamak* eşleşen şekil olduğunda değeri bilgileri.</span><span class="sxs-lookup"><span data-stu-id="31a27-105">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="31a27-106">Desen eşleştirme zaten günümüzde kullandığınız algoritmalar için daha az sözdizimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="31a27-106">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="31a27-107">Zaten varolan sözdizimini kullanarak algoritmaları eşleşen kalıbı oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="31a27-107">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="31a27-108">Yazdığınız `if` veya `switch` test değerleri deyimleri.</span><span class="sxs-lookup"><span data-stu-id="31a27-108">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="31a27-109">Ardından, bu deyimleri eşleştiğinde, ayıklayın ve bu değeri bilgileri kullanın.</span><span class="sxs-lookup"><span data-stu-id="31a27-109">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="31a27-110">Yeni söz dizimi öğeleri, zaten aşina deyimleri uzantıları: `is` ve `switch`.</span><span class="sxs-lookup"><span data-stu-id="31a27-110">The new syntax elements are extensions to statements you are already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="31a27-111">Bu yeni uzantılar bir değer test etme ve bu bilgileri ayıklama birleştirin.</span><span class="sxs-lookup"><span data-stu-id="31a27-111">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="31a27-112">Bu konuda, biz nasıl okunabilir, kısa kod etkinleştirir göstermek için yeni sözdizimine göreceğiz.</span><span class="sxs-lookup"><span data-stu-id="31a27-112">In this topic, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="31a27-113">Desen eşleştirme burada veri ve kod, burada veri ve üzerlerinde değişiklik yöntemleri sıkı şekilde bağlı nesne yönelimli tasarımları ayrılır deyimleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="31a27-113">Pattern matching enables idioms where data and the code are separated, unlike object oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="31a27-114">Bu yeni deyimleri göstermek için şimdi deyimleri eşleşen kalıbı kullanarak geometrik şekiller temsil eden yapılar ile çalışır.</span><span class="sxs-lookup"><span data-stu-id="31a27-114">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="31a27-115">Sınıf hiyerarşileri oluşturma ve oluşturma ile biliyor [sanal ve geçersiz kılınan yöntemleri](methods.md#inherited) nesne çalışma zamanı türüne göre nesne davranışını özelleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="31a27-115">You are probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="31a27-116">Bu teknikler sınıf hiyerarşisinde yapılandırılmaz veri mümkün değil.</span><span class="sxs-lookup"><span data-stu-id="31a27-116">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="31a27-117">Veri ve yöntemleri farklı olduğunda, diğer araçlar gerekir.</span><span class="sxs-lookup"><span data-stu-id="31a27-117">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="31a27-118">Yeni *desen eşleştirme* yapıları verileri incelemek ve bu verilerin herhangi bir koşula dayalı akış denetimi işlemek temizleyici sözdizimi etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="31a27-118">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="31a27-119">Zaten yazma `if` deyimleri ve `switch` bir değişkenin değeri sınayın.</span><span class="sxs-lookup"><span data-stu-id="31a27-119">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="31a27-120">Yazdığınız `is` bir değişken türü test deyimleri.</span><span class="sxs-lookup"><span data-stu-id="31a27-120">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="31a27-121">*Desen eşleştirme* bu deyimleri için yeni özellikleri ekler.</span><span class="sxs-lookup"><span data-stu-id="31a27-121">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="31a27-122">Bu konuda, farklı geometrik şekiller alanını hesaplar bir yöntem yapı.</span><span class="sxs-lookup"><span data-stu-id="31a27-122">In this topic, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="31a27-123">Ancak, nesne yönelimli teknikleri yeniden ayırma ve farklı şekiller için sınıf hiyerarşisi oluşturmak olmadan gerçekleştirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="31a27-123">But, you'll do it without resorting to object oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="31a27-124">Kullanacağınız *desen eşleştirme* yerine.</span><span class="sxs-lookup"><span data-stu-id="31a27-124">You'll use *pattern matching* instead.</span></span> <span data-ttu-id="31a27-125">Devralma kullanmıyorsanız, her şekli hale getireceğiz daha fazla vurgulamak için bir `struct` yerine bir sınıf.</span><span class="sxs-lookup"><span data-stu-id="31a27-125">To further emphasize that we're not using inheritance, you'll make each shape a `struct` instead of a class.</span></span> <span data-ttu-id="31a27-126">Bu farklı Not `struct` türleri, ortak bir kullanıcı tanımlı temel türü, böylece devralma olası tasarım belirtemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="31a27-126">Note that different `struct` types cannot specify a common user defined base type, so inheritance is not a possible design.</span></span>
<span data-ttu-id="31a27-127">Bu örnek geçerken bu kodu nasıl, bir nesne hiyerarşisi yapılandırılmış olması ile karşılaştırın.</span><span class="sxs-lookup"><span data-stu-id="31a27-127">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="31a27-128">Desen eşleştirme işlemek ve gereken sorgu veri sınıf hiyerarşisinin olmadığı durumlarda, çok Zarif tasarımları sağlar.</span><span class="sxs-lookup"><span data-stu-id="31a27-128">When the data you must query and manipulate is not a class hierarchy, pattern matching enables very elegant designs.</span></span>

<span data-ttu-id="31a27-129">Bir Özet şekli tanımıyla başlatma ve farklı belirli şekil sınıfları ekleme yerine, bunun yerine basit verilerle tanımları geometrik şekillerin her biri için yalnızca başlayalım:</span><span class="sxs-lookup"><span data-stu-id="31a27-129">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="31a27-130">Bu yapıları, bazı şekil alanı hesaplar bir yöntem yazalım.</span><span class="sxs-lookup"><span data-stu-id="31a27-130">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="31a27-131">`is` Deseni ifadesi yazın</span><span class="sxs-lookup"><span data-stu-id="31a27-131">The `is` type pattern expression</span></span>

<span data-ttu-id="31a27-132">C# 7 önce her tür bir dizi test gerekir `if` ve `is` deyimleri:</span><span class="sxs-lookup"><span data-stu-id="31a27-132">Before C# 7, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="31a27-133">Yukarıdaki kod klasik bir ifade olduğunu *türü düzeni*: türünü ve bu türüne göre farklı bir eylem getirmeden belirlemek için bir değişken test ettiğiniz.</span><span class="sxs-lookup"><span data-stu-id="31a27-133">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="31a27-134">Bu kodu daha basit hale uzantıları kullanarak `is` ifadesi bir değişken IF test atamak için başarılı olur:</span><span class="sxs-lookup"><span data-stu-id="31a27-134">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="31a27-135">Bu güncelleştirilmiş sürüm `is` ifade değişkeni testleri hem uygun türde yeni bir değişkene atar.</span><span class="sxs-lookup"><span data-stu-id="31a27-135">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="31a27-136">Ayrıca, bu sürüm içeren bildirim `Rectangle` türü olan bir `struct`.</span><span class="sxs-lookup"><span data-stu-id="31a27-136">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="31a27-137">Yeni `is` ifadesi başvuru türleri yanı sıra değer türleri ile çalışır.</span><span class="sxs-lookup"><span data-stu-id="31a27-137">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="31a27-138">Desen eşleştirme ifadeler için dil kuralları bir eşleşme ifadesi sonuçlarını kötüye önlemenize yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="31a27-138">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="31a27-139">Değişkenleri yukarıdaki örnekte `s`, `c`, ve `r` yalnızca kapsamındaki ve ilgili desen eşleşme ifadeleri olduğunda kesinlikle atanan `true` sonuçları.</span><span class="sxs-lookup"><span data-stu-id="31a27-139">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="31a27-140">Başka bir konumda ya da değişken kullanmayı denerseniz, kodunuzu derleyici hataları oluşturur.</span><span class="sxs-lookup"><span data-stu-id="31a27-140">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="31a27-141">Ayrıntılı kapsam ile başlayarak, bu kuralların her ikisi de inceleyelim.</span><span class="sxs-lookup"><span data-stu-id="31a27-141">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="31a27-142">Değişkeni `c` kapsamında olup yalnızca `else` ilk dalı `if` deyimi.</span><span class="sxs-lookup"><span data-stu-id="31a27-142">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="31a27-143">Değişkeni `s` yöntemi kapsamında yer `ComputeArea`.</span><span class="sxs-lookup"><span data-stu-id="31a27-143">The variable `s` is in scope in the method `ComputeArea`.</span></span> <span data-ttu-id="31a27-144">Çünkü her dalı bir `if` deyimi değişkenleri için ayrı bir kapsam oluşturur.</span><span class="sxs-lookup"><span data-stu-id="31a27-144">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="31a27-145">Ancak, `if` deyimi kendisini desteklemez.</span><span class="sxs-lookup"><span data-stu-id="31a27-145">However, the `if` statement itself does not.</span></span> <span data-ttu-id="31a27-146">İçinde bildirilen değişkenlerin anlamına `if` deyimi aynı kapsamı olan `if` deyimi (Bu durumda yöntemi.) Bu davranış desen eşleştirme için özel değildir ancak değişken kapsamlar için tanımlanmış bir davranıştır ve `if` ve `else` deyimleri.</span><span class="sxs-lookup"><span data-stu-id="31a27-146">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior is not specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="31a27-147">Değişkenleri `c` ve `s` ne zaman atanmış olan ilgili `if` deyimleri true nedeniyle kesinlikle atanan zaman true mekanizması.</span><span class="sxs-lookup"><span data-stu-id="31a27-147">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="31a27-148">Bu konudaki örnekler önerilen yapı Desen eşleştirmesi kullanın `is` ifade kesinlikle eşleşme değişkeninde atar `true` dalı `if` deyimi.</span><span class="sxs-lookup"><span data-stu-id="31a27-148">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="31a27-149">Mantığı tarafından bildiren tersine çevirebilir `if (!(shape is Square s))` değişkeni `s` kesinlikle yalnızca atanmış olur `false` dal.</span><span class="sxs-lookup"><span data-stu-id="31a27-149">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="31a27-150">Bu geçerli bir C# olmakla birlikte, mantığı izlenecek daha karmaşık olduğu için önerilmez.</span><span class="sxs-lookup"><span data-stu-id="31a27-150">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="31a27-151">Bu kurallar bu desene karşılanmadığı yanlışlıkla bir desen eşleştirme ifadesi sonucu erişmeye olası anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="31a27-151">These rules mean that you are unlikely to accidentally access the result of a pattern match expression when that pattern was not met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="31a27-152">Desen eşleştirme kullanılarak `switch` deyimleri</span><span class="sxs-lookup"><span data-stu-id="31a27-152">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="31a27-153">Zaman gibi diğer şekil türlerini desteklemek gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="31a27-153">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="31a27-154">Test ettiğiniz koşullar sayısı arttıkça, kullanmanın bulabilirsiniz `is` ifadeleri eşleşen kalıbı sıkıcı dönüşebilir.</span><span class="sxs-lookup"><span data-stu-id="31a27-154">As the number of conditions you are testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="31a27-155">Gerektiren ek olarak `if` denetlemek istediğiniz her türündeki deyimleri `is` ifadeleri giriş tek bir türü eşleşirse test sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="31a27-155">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="31a27-156">Bu durumda, bulacaksınız `switch` desen eşleştirme ifadeleri daha iyi bir seçim haline gelir.</span><span class="sxs-lookup"><span data-stu-id="31a27-156">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="31a27-157">Geleneksel `switch` deyimi olan bir desen ifadesini: sabit düzeni desteklenir.</span><span class="sxs-lookup"><span data-stu-id="31a27-157">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="31a27-158">Kullanılan sabit bir değişkene karşılaştırmak bir `case` deyimi:</span><span class="sxs-lookup"><span data-stu-id="31a27-158">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="31a27-159">Tarafından desteklenen tek düzeni `switch` deyimi sabit düzeni oluştu.</span><span class="sxs-lookup"><span data-stu-id="31a27-159">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="31a27-160">Daha fazla sınırlı sayısal türler oluştu ve `string` türü.</span><span class="sxs-lookup"><span data-stu-id="31a27-160">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="31a27-161">Bu kısıtlamaları kaldırıldı ve artık yazabilirsiniz bir `switch` türü desenini kullanarak deyimi:</span><span class="sxs-lookup"><span data-stu-id="31a27-161">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="31a27-162">Desen eşleştirme `switch` deyimini kullanan geleneksel C tarzı kullanmış olan geliştiricilere bilinen sözdizimini `switch` deyimi.</span><span class="sxs-lookup"><span data-stu-id="31a27-162">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="31a27-163">Her `case` değerlendirilir ve kod giriş değişkeni eşleşen koşul altında yürütülür.</span><span class="sxs-lookup"><span data-stu-id="31a27-163">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="31a27-164">Kod yürütmeyi "bir servis talebi ifadesinden sonraki geçemez"; söz dizimi `case` deyimi gerektirir, her `case` sonunda bir `break`, `return`, veya `goto`.</span><span class="sxs-lookup"><span data-stu-id="31a27-164">Code execution cannot "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="31a27-165">`goto` Başka bir etiket için atlamak için deyimleri yalnızca sabit düzeni için Klasik switch deyimi geçerli.</span><span class="sxs-lookup"><span data-stu-id="31a27-165">The `goto` statements to jump to another label are valid only for the constant pattern, the classic switch statement.</span></span>

<span data-ttu-id="31a27-166">Yöneten önemli yeni kurallar vardır `switch` deyimi.</span><span class="sxs-lookup"><span data-stu-id="31a27-166">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="31a27-167">Değişken türü kısıtlamalar `switch` ifadesi kaldırıldı.</span><span class="sxs-lookup"><span data-stu-id="31a27-167">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="31a27-168">Gibi herhangi türdeki `object` Bu örnekte, kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="31a27-168">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="31a27-169">Case ifadeleri artık sabit değerleri için sınırlı değildir.</span><span class="sxs-lookup"><span data-stu-id="31a27-169">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="31a27-170">Bu sınırlama kaldırılması anlamına gelir, yeniden sıralama `switch` bölümler, programın davranışını değişebilir.</span><span class="sxs-lookup"><span data-stu-id="31a27-170">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="31a27-171">Birden fazla sabit değerleri için sınırlı olduğunda `case` etiket değeri eşleşebilecek `switch` ifade.</span><span class="sxs-lookup"><span data-stu-id="31a27-171">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="31a27-172">Kuralla birleştirmek, her `switch` bölüm gerekir değil atlayabilir sonraki bölüme ve, ardından `switch` bölümleri düzenlenmeyecek herhangi bir sırada davranışı etkilemeden.</span><span class="sxs-lookup"><span data-stu-id="31a27-172">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="31a27-173">Şimdi, genelleştirilmiş daha fazla ile `switch` ifadeleri, her bölüm sırası önemlidir.</span><span class="sxs-lookup"><span data-stu-id="31a27-173">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="31a27-174">`switch` İfadeleri metinsel sırayla değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="31a27-174">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="31a27-175">Yürütme aktarır ilk `switch` eşleşen etiket `switch` ifade.</span><span class="sxs-lookup"><span data-stu-id="31a27-175">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="31a27-176">Unutmayın `default` durumda, yalnızca diğer durum etiketi eşleşiyorsa yürütülür.</span><span class="sxs-lookup"><span data-stu-id="31a27-176">Note that the `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="31a27-177">`default` Durumda son olarak, kendi metinsel sipariş bağımsız olarak değerlendirildi.</span><span class="sxs-lookup"><span data-stu-id="31a27-177">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="31a27-178">Varsa hiçbir `default` çalışması ve diğer hiçbiri `case` deyimleri eşleşmesi, deyimi aşağıdaki yürütülmeye `switch` deyimi.</span><span class="sxs-lookup"><span data-stu-id="31a27-178">If there is no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="31a27-179">Hiçbiri `case` etiketleri kod gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="31a27-179">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="31a27-180">`when`yan tümcelerinde `case` ifadeleri</span><span class="sxs-lookup"><span data-stu-id="31a27-180">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="31a27-181">Özel durumlar kullanarak 0 alanı olan bu şekiller için yapabileceğiniz bir `when` yan tümcesi `case` etiketi.</span><span class="sxs-lookup"><span data-stu-id="31a27-181">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="31a27-182">Bir kare yan uzunluğu 0 ile ya da RADIUS 0 olan bir daire 0 bir alana sahip.</span><span class="sxs-lookup"><span data-stu-id="31a27-182">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="31a27-183">Bu koşul kullanarak belirttiğiniz bir `when` yan tümcesi `case` etiketi:</span><span class="sxs-lookup"><span data-stu-id="31a27-183">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="31a27-184">Bu değişiklik birkaç önemli noktaları yeni söz dizimi hakkında gösterir.</span><span class="sxs-lookup"><span data-stu-id="31a27-184">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="31a27-185">İlk olarak, çoklu `case` etiketleri için uygulanabilir `switch` bölümü.</span><span class="sxs-lookup"><span data-stu-id="31a27-185">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="31a27-186">İfade bloğu yürütülen etiketlerin hiçbirinde olduğunda `true`.</span><span class="sxs-lookup"><span data-stu-id="31a27-186">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="31a27-187">Bu örnekte, `switch` ifadesi bir daire veya kare 0 alan ile yöntem sabiti 0 döndürür.</span><span class="sxs-lookup"><span data-stu-id="31a27-187">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="31a27-188">Bu örnek iki iki farklı değişkenleri tanıtır `case` ilk kez etiketleri `switch` bloğu.</span><span class="sxs-lookup"><span data-stu-id="31a27-188">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="31a27-189">Dikkat bu deyimlerinde `switch` bloğu ya da değişkenleri kullanmayın `c` (için daire) veya `s` (için kare).</span><span class="sxs-lookup"><span data-stu-id="31a27-189">Notice that the statements in this `switch` block do not use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="31a27-190">Bu değişkenleri hiçbiri kesinlikle bu atanan `switch` bloğu.</span><span class="sxs-lookup"><span data-stu-id="31a27-190">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="31a27-191">Bu durumların herhangi birini eşleşiyorsa değişkenleri açıkça birini atanmıştır.</span><span class="sxs-lookup"><span data-stu-id="31a27-191">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="31a27-192">Ancak, bildirmek mümkün değildir *hangi* derleme zamanında, her iki durumda çalışma zamanında eşleştiğinden atanmıştır.</span><span class="sxs-lookup"><span data-stu-id="31a27-192">However, it is impossible to tell *which* has been assigned at compile-time, because either case could match at runtime.</span></span> <span data-ttu-id="31a27-193">Bu nedenle, çoğu kez kullandığınızda, birden çok `case` etiketleri aynı bloğu için yeni bir değişkende tanıtmak olmaz `case` deyimi veya yalnızca kullanacağınız değişkende `when` yan tümcesi.</span><span class="sxs-lookup"><span data-stu-id="31a27-193">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you will only use the variable in the `when` clause.</span></span>

<span data-ttu-id="31a27-194">Bu şekiller 0 alan ile eklenir birkaç daha fazla şekil türleri ekleyelim: dikdörtgen ve bir üçgen:</span><span class="sxs-lookup"><span data-stu-id="31a27-194">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="31a27-195">Bu değişiklik kümesini ekler `case` bozuk durumda, etiketleri ve etiketleri ve her yeni şekiller blokları.</span><span class="sxs-lookup"><span data-stu-id="31a27-195">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="31a27-196">Son olarak, ekleyebileceğiniz bir `null` bağımsız değişken değil emin olmak için durum `null`:</span><span class="sxs-lookup"><span data-stu-id="31a27-196">Finally, you can add a `null` case to ensure the argument is not `null`:</span></span>

[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="31a27-197">İçin özel bir davranış `null` düzeni ilginç çünkü sabiti `null` desende bir türe sahip değil, ancak herhangi bir başvuru türü veya boş değer atanabilir tür dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="31a27-197">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern does not have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="31a27-198">Yerine Dönüştür bir `null` herhangi bir türü için dili tanımlayan bir `null` değer değişkenin derleme zamanı türünden bağımsız olarak herhangi bir tür modeliyle eşleşmez.</span><span class="sxs-lookup"><span data-stu-id="31a27-198">Rather than convert a `null` to any type, the language defines that a `null` value will not match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="31a27-199">Bu davranış yeni yapar `switch` türü desenine ile tutarlı `is` deyimi: `is` deyimleri her zaman geri `false` denetlenen değer olduğunda `null`.</span><span class="sxs-lookup"><span data-stu-id="31a27-199">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="31a27-200">Ayrıca basittir: türü işaretlendiğinde, ek bir null denetimi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="31a27-200">It's also simpler: once you have checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="31a27-201">Hiçbir null bulunmasına yukarıdaki örnekleri servis talebi bloklarını hiçbirinde denetler görebilirsiniz: boş olmayan bir değer türü desen eşleştirme garanti beri gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="31a27-201">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they are not necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="31a27-202">`var`bildirimlerinde `case` ifadeleri</span><span class="sxs-lookup"><span data-stu-id="31a27-202">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="31a27-203">Giriş `var` gibi bir eşleşme ifadeleri desen eşleştirme yeni kurallar tanıtır.</span><span class="sxs-lookup"><span data-stu-id="31a27-203">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="31a27-204">İlk kural olan `var` bildirimini normal türü çıkarım kuralları izler: türü anahtar ifadesi statik türünde olmasını algılanır.</span><span class="sxs-lookup"><span data-stu-id="31a27-204">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="31a27-205">Bu kuraldan türü her zaman eşleşir.</span><span class="sxs-lookup"><span data-stu-id="31a27-205">From that rule, the type always matches.</span></span>

<span data-ttu-id="31a27-206">İkinci kuralı olan bir `var` bildirimi diğer tür düzeni ifadeler içeren null denetimi sahip değil.</span><span class="sxs-lookup"><span data-stu-id="31a27-206">The second rule is that a `var` declaration does not have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="31a27-207">Bu değişken null olabilir ve bu durumda null denetimi gereklidir anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="31a27-207">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="31a27-208">Bu iki kural çoğu durumda, diğer bir deyişle bir `var` bildiriminde bir `case` ifadeyle eşleşen aynı koşullarda bir `default` ifade.</span><span class="sxs-lookup"><span data-stu-id="31a27-208">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="31a27-209">Herhangi bir varsayılan olmayan durumu için tercih edilen olduğundan `default` durumda `default` durumu hiçbir zaman yürütülecek.</span><span class="sxs-lookup"><span data-stu-id="31a27-209">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="31a27-210">Derleyici Uyarısı bu durumlarda yayma değil burada bir `default` durumda yazıldı, ancak hiçbir zaman yürütülür.</span><span class="sxs-lookup"><span data-stu-id="31a27-210">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="31a27-211">Bu tutarlıdır geçerli `switch` burada tüm olası durumların listelenen deyimi davranışı.</span><span class="sxs-lookup"><span data-stu-id="31a27-211">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="31a27-212">Üçüncü kural kullanır tanıtır burada bir `var` durumda yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="31a27-212">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="31a27-213">Burada, Giriş bir dize ve bilinen komut değerlerini aradığınız bir desen eşleştirmesi yaptıklarını düşünün.</span><span class="sxs-lookup"><span data-stu-id="31a27-213">Imagine that you are doing a pattern match where the input is a string and you are searching for known command values.</span></span> <span data-ttu-id="31a27-214">Şöyle yazabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="31a27-214">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="31a27-215">`var` Durumda eşleşmeleri `null`, boş dize veya yalnızca boşluk içeren herhangi bir dize.</span><span class="sxs-lookup"><span data-stu-id="31a27-215">The `var` case matches `null`, the empty string, or any string that contains only whitespace.</span></span> <span data-ttu-id="31a27-216">Önceki kod kullanan bildirimi `?.` onu değil yanlışlıkla throw emin olmak için işleci bir <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="31a27-216">Notice that the preceding code uses the `?.` operator to ensure that it does not accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="31a27-217">`default` Durumunu işler bu komutu ayrıştırıcı tarafından anlaşılmayan herhangi bir dize değeri.</span><span class="sxs-lookup"><span data-stu-id="31a27-217">The `default` case handles any other string values that are not understood by this command parser.</span></span>

<span data-ttu-id="31a27-218">Bu bir yere göz önünde bulundurun isteyebilirsiniz örnektir bir `var` durumda farklıdır ifade bir `default` ifade.</span><span class="sxs-lookup"><span data-stu-id="31a27-218">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="31a27-219">Sonuçları</span><span class="sxs-lookup"><span data-stu-id="31a27-219">Conclusions</span></span>

<span data-ttu-id="31a27-220">*Desen eşleştirme yapıları* denetim akışı farklı değişkenleri ve devralma hiyerarşisi tarafından ilgili olmayan türleri arasında kolayca yönetmenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="31a27-220">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that are not related by an inheritance hierarchy.</span></span> <span data-ttu-id="31a27-221">Değişkeni test herhangi bir koşul kullanmak için mantığı de denetleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="31a27-221">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="31a27-222">Desenleri ve veri ve bu verileri işlemek yöntemleri ayrı nerede daha dağıtılmış uygulamalar oluşturmak daha sık gerekir deyimleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="31a27-222">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="31a27-223">Bu örnekte kullanılan şekli yapılar herhangi bir yöntem içermiyor fark edeceksiniz yalnızca salt okunur özellikler.</span><span class="sxs-lookup"><span data-stu-id="31a27-223">You'll notice that the shape structs used in this sample do not contain any methods, just read-only properties.</span></span>
<span data-ttu-id="31a27-224">Desen eşleştirme herhangi bir veri türü ile çalışır.</span><span class="sxs-lookup"><span data-stu-id="31a27-224">Pattern Matching works with any data type.</span></span> <span data-ttu-id="31a27-225">Nesne inceleyin ifadeleri yazmak ve bu koşullara göre denetim akışı kararlar.</span><span class="sxs-lookup"><span data-stu-id="31a27-225">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="31a27-226">Bu örnek için bir Özet sınıf hiyerarşisi oluşturma izlersiniz tasarım ile koddan karşılaştırmak `Shape` ve türetilmiş özel şekiller her alanını hesaplamak için sanal bir yöntem, kendi uygulama.</span><span class="sxs-lookup"><span data-stu-id="31a27-226">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="31a27-227">Desen eşleştirme ifadeleri verilerle çalışmak ve veri depolama sorunları davranışı kaygılarını ayırmak istediğiniz zaman çok kullanışlı bir aracı olabilir genellikle bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="31a27-227">You'll often find that pattern matching expressions can be a very useful tool when you are working with data and want to separate the data storage concerns from the behavior concerns.</span></span>


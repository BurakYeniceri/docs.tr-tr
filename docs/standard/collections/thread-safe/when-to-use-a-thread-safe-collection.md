---
title: "Bir İş Parçacığı Koleksiyonunun Ne Zaman Kullanılacağı"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- thread-safe collections, when to upgrade
ms.assetid: a9babe97-e457-4ff3-b528-a1bc940d5320
caps.latest.revision: 
author: mairaw
ms.author: mairaw
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 61444afd5afe52cbcb0f64074ec4479bd6252358
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 12/23/2017
---
# <a name="when-to-use-a-thread-safe-collection"></a><span data-ttu-id="7870f-102">Bir İş Parçacığı Koleksiyonunun Ne Zaman Kullanılacağı</span><span class="sxs-lookup"><span data-stu-id="7870f-102">When to Use a Thread-Safe Collection</span></span>
<span data-ttu-id="7870f-103">[!INCLUDE[net_v40_long](../../../../includes/net-v40-long-md.md)] Desteklemek için özellikle tasarlanmış beş yeni koleksiyon türleri tanıtır çok iş parçacıklı ekleme ve kaldırma işlemleri.</span><span class="sxs-lookup"><span data-stu-id="7870f-103">The [!INCLUDE[net_v40_long](../../../../includes/net-v40-long-md.md)] introduces five new collection types that are specially designed to support multi-threaded add and remove operations.</span></span> <span data-ttu-id="7870f-104">İş parçacığı güvenliği elde etmek için bu yeni tür verimli kilitleme ve kilidi serbest eşitleme mekanizmaları çeşitli kullanın.</span><span class="sxs-lookup"><span data-stu-id="7870f-104">To achieve thread-safety, these new types use various kinds of efficient locking and lock-free synchronization mechanisms.</span></span> <span data-ttu-id="7870f-105">Eşitleme için bir işlem yükü ekler.</span><span class="sxs-lookup"><span data-stu-id="7870f-105">Synchronization adds overhead to an operation.</span></span> <span data-ttu-id="7870f-106">Ek yük miktarı kullanılan eşitleme türü, gerçekleştirilen işlemleri türünü ve koleksiyon eşzamanlı olarak erişmeye çalıştığınız iş parçacığı sayısı gibi diğer faktörlere bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="7870f-106">The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</span></span>  
  
 <span data-ttu-id="7870f-107">Bazı senaryolarda eşitleme ek yükü olduğu düşünülerek ve önemli ölçüde daha hızlı gerçekleştirmek ve bir dış kilidi ile korumalı iş parçacığı güvenli olmayan eşdeğer daha çok daha iyi ölçeklendirme çok iş parçacıklı türü etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="7870f-107">In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</span></span> <span data-ttu-id="7870f-108">Diğer senaryolarda yükü gerçekleştirmek ve aynı hakkında veya türü dışarıdan kilitli, iş parçacığı güvenli sürümünden daha da yavaş ölçeklemek iş parçacığı türü neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="7870f-108">In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</span></span>  
  
 <span data-ttu-id="7870f-109">Aşağıdaki bölümler, ne zaman bir iş parçacığı koleksiyonunun bir kullanıcı tarafından sağlanan kilidi kendi okuma geçici olan iş parçacığı güvenli olmayan karşılığını karşı kullanın ve yazma işlemleri hakkında genel kılavuzluk sağlar.</span><span class="sxs-lookup"><span data-stu-id="7870f-109">The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</span></span> <span data-ttu-id="7870f-110">Performans birçok faktöre bağlı olarak farklılık gösterebileceğinden, yönerge özgü değildir ve her koşulda mutlaka geçerli değil.</span><span class="sxs-lookup"><span data-stu-id="7870f-110">Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</span></span> <span data-ttu-id="7870f-111">Performans çok önemliyse, daha sonra kullanmak için hangi koleksiyon türü belirlemek için en iyi temsilcisi bilgisayar yapılandırmalarını ve yükleri dayanarak performansı ölçmek için yoludur.</span><span class="sxs-lookup"><span data-stu-id="7870f-111">If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</span></span> <span data-ttu-id="7870f-112">Bu belge aşağıdaki terimler kullanılır:</span><span class="sxs-lookup"><span data-stu-id="7870f-112">This document uses the following terms:</span></span>  
  
 <span data-ttu-id="7870f-113">*Saf üretici-tüketici senaryosu*</span><span class="sxs-lookup"><span data-stu-id="7870f-113">*Pure producer-consumer scenario*</span></span>  
 <span data-ttu-id="7870f-114">Belirli bir iş parçacığı ekleme veya öğeleri, ancak ikisini kaldırılıyor.</span><span class="sxs-lookup"><span data-stu-id="7870f-114">Any given thread is either adding or removing elements, but not both.</span></span>  
  
 <span data-ttu-id="7870f-115">*Karma üretici-tüketici senaryosu*</span><span class="sxs-lookup"><span data-stu-id="7870f-115">*Mixed producer-consumer scenario*</span></span>  
 <span data-ttu-id="7870f-116">Belirli bir iş parçacığı hem ekleme ve öğe kaldırma.</span><span class="sxs-lookup"><span data-stu-id="7870f-116">Any given thread is both adding and removing elements.</span></span>  
  
 <span data-ttu-id="7870f-117">*Speedup*</span><span class="sxs-lookup"><span data-stu-id="7870f-117">*Speedup*</span></span>  
 <span data-ttu-id="7870f-118">Daha hızlı algoritmik performans aynı senaryoda başka bir türüne göre.</span><span class="sxs-lookup"><span data-stu-id="7870f-118">Faster algorithmic performance relative to another type in the same scenario.</span></span>  
  
 <span data-ttu-id="7870f-119">*Ölçeklenebilirlik*</span><span class="sxs-lookup"><span data-stu-id="7870f-119">*Scalability*</span></span>  
 <span data-ttu-id="7870f-120">Bilgisayarda çekirdek sayısı orantılıdır performansını artırma.</span><span class="sxs-lookup"><span data-stu-id="7870f-120">The increase in performance that is proportional to the number of cores on the computer.</span></span> <span data-ttu-id="7870f-121">Üzerinde iki çekirdeği makinelerinden ölçeklendirir bir algoritma üzerinde sekiz çekirdeği daha hızlı gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="7870f-121">An algorithm that scales performs faster on eight cores than it does on two cores.</span></span>  
  
## <a name="concurrentqueuet-vs-queuet"></a><span data-ttu-id="7870f-122">ConcurrentQueue(T) vs. Queue(T)</span><span class="sxs-lookup"><span data-stu-id="7870f-122">ConcurrentQueue(T) vs. Queue(T)</span></span>  
 <span data-ttu-id="7870f-123">Her öğe için işleme süresini olduğu çok küçük saf üretici-tüketici senaryolarda, (birkaç yönergeler), ardından <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> uygun performans avantajı üzerinden sunabileceği bir <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> bir dış kilit sahip.</span><span class="sxs-lookup"><span data-stu-id="7870f-123">In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> can offer modest performance benefits over a <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> that has an external lock.</span></span> <span data-ttu-id="7870f-124">Bu senaryoda, <xref:System.Collections.Concurrent.ConcurrentQueue%601> tek bir adanmış iş parçacığı queuing ve tek bir adanmış iş parçacığı çıkarılması olduğunda en iyi şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="7870f-124">In this scenario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</span></span> <span data-ttu-id="7870f-125">Bu kural, ardından zorlamaz varsa <xref:System.Collections.Generic.Queue%601> bile gerçekleştirebileceğiniz biraz daha hızlı <xref:System.Collections.Concurrent.ConcurrentQueue%601> birden çok çekirdeğe sahip bilgisayarlarda.</span><span class="sxs-lookup"><span data-stu-id="7870f-125">If you do not enforce this rule, then <xref:System.Collections.Generic.Queue%601> might even perform slightly faster than <xref:System.Collections.Concurrent.ConcurrentQueue%601> on computers that have multiple cores.</span></span>  
  
 <span data-ttu-id="7870f-126">İşleme zamanı yaklaşık 500 FLOPS (kayan nokta işlemleri) veya daha sonra iki iş parçacığı kural uygulanmaz olduğunda <xref:System.Collections.Concurrent.ConcurrentQueue%601>, çok iyi ölçeklenebilirlik, daha sonra sahiptir.</span><span class="sxs-lookup"><span data-stu-id="7870f-126">When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <xref:System.Collections.Concurrent.ConcurrentQueue%601>, which then has very good scalability.</span></span> <span data-ttu-id="7870f-127"><xref:System.Collections.Generic.Queue%601>Bu senaryoda iyi ölçeklenmez.</span><span class="sxs-lookup"><span data-stu-id="7870f-127"><xref:System.Collections.Generic.Queue%601> does not scale well in this scenario.</span></span>  
  
 <span data-ttu-id="7870f-128">İşlem süresi çok az olduğunda, üretici-tüketici senaryoları, karma bir <xref:System.Collections.Generic.Queue%601> bir dış olan kilit daha iyi ölçeklenir <xref:System.Collections.Concurrent.ConcurrentQueue%601> yapar.</span><span class="sxs-lookup"><span data-stu-id="7870f-128">In mixed producer-consumer scenarios, when the processing time is very small, a <xref:System.Collections.Generic.Queue%601> that has an external lock scales better than <xref:System.Collections.Concurrent.ConcurrentQueue%601> does.</span></span> <span data-ttu-id="7870f-129">Ancak, işlem süresi olduğunda yaklaşık 500 FLOPS veya daha fazla sonra <xref:System.Collections.Concurrent.ConcurrentQueue%601> daha iyi ölçeklenir.</span><span class="sxs-lookup"><span data-stu-id="7870f-129">However, when processing time is around 500 FLOPS or more, then the <xref:System.Collections.Concurrent.ConcurrentQueue%601> scales better.</span></span>  
  
## <a name="concurrentstack-vs-stack"></a><span data-ttu-id="7870f-130">ConcurrentStack vs. Yığın</span><span class="sxs-lookup"><span data-stu-id="7870f-130">ConcurrentStack vs. Stack</span></span>  
 <span data-ttu-id="7870f-131">Saf üretici-tüketici senaryolarda işleme süresi sonra çok küçük olduğunda <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> ve <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> bir dış olan kilit hakkında bir adanmış koymadan iş parçacığı ve tek bir adanmış pencerelerinin iş parçacığı ile aynı büyük olasılıkla gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="7870f-131">In pure producer-consumer scenarios, when processing time is very small, then <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</span></span> <span data-ttu-id="7870f-132">Ancak, iş parçacığı sayısı arttıkça sayısı olarak, her iki tür artan çakışma nedeniyle yavaşlayabilir ve <xref:System.Collections.Generic.Stack%601> gerçekleştirebileceğiniz daha iyi <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span><span class="sxs-lookup"><span data-stu-id="7870f-132">However, as the number of threads increases, both types slow down because of increased contention, and <xref:System.Collections.Generic.Stack%601> might perform better than <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span></span> <span data-ttu-id="7870f-133">İşlem süresi yaklaşık 500 FLOPS olduğunda veya daha fazla ve ardından her iki türleri ölçekte aynı oranı hakkında.</span><span class="sxs-lookup"><span data-stu-id="7870f-133">When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</span></span>  
  
 <span data-ttu-id="7870f-134">Üretici-tüketici senaryoları, karma içinde <xref:System.Collections.Concurrent.ConcurrentStack%601> küçük ve büyük iş yükleri için daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="7870f-134">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentStack%601> is faster for both small and large workloads.</span></span>  
  
 <span data-ttu-id="7870f-135">Kullanımını <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> ve <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> erişim zamanları büyük ölçüde hızlandırabilir.</span><span class="sxs-lookup"><span data-stu-id="7870f-135">The use of the <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> and <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> may greatly speed up access times.</span></span>  
  
## <a name="concurrentdictionary-vs-dictionary"></a><span data-ttu-id="7870f-136">ConcurrentDictionary vs. Sözlük</span><span class="sxs-lookup"><span data-stu-id="7870f-136">ConcurrentDictionary vs. Dictionary</span></span>  
 <span data-ttu-id="7870f-137">Genel olarak, kullanan bir <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> Burada, ekleme ve anahtarları veya aynı anda birden çok iş parçacığı değerleri güncelleştirme herhangi bir senaryoda.</span><span class="sxs-lookup"><span data-stu-id="7870f-137">In general, use a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</span></span> <span data-ttu-id="7870f-138">Sık güncelleştirmeler ve nispeten az okuma içeren senaryolarda <xref:System.Collections.Concurrent.ConcurrentDictionary%602> genellikle uygun avantajları sunar.</span><span class="sxs-lookup"><span data-stu-id="7870f-138">In scenarios that involve frequent updates and relatively few reads, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally offers modest benefits.</span></span> <span data-ttu-id="7870f-139">Birçok okur ve çok sayıda güncelleştirme içeren senaryolarda <xref:System.Collections.Concurrent.ConcurrentDictionary%602> genellikle önemli ölçüde herhangi bir sayıda çekirdek olan bilgisayarlarda daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="7870f-139">In scenarios that involve many reads and many updates, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally is significantly faster on computers that have any number of cores.</span></span>  
  
 <span data-ttu-id="7870f-140">Sık güncelleştirmeler içeren senaryolarda eşzamanlılık derecesini artırabilir <xref:System.Collections.Concurrent.ConcurrentDictionary%602> ve performansı daha fazla sayıda çekirdek olan bilgisayarlarda artırır olup olmadığını görmek için ölçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="7870f-140">In scenarios that involve frequent updates, you can increase the degree of concurrency in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and then measure to see whether performance increases on computers that have more cores.</span></span> <span data-ttu-id="7870f-141">Eşzamanlılık düzeyi değiştirirseniz, genel işlemlerini mümkün olduğunca kaçının.</span><span class="sxs-lookup"><span data-stu-id="7870f-141">If you change the concurrency level, avoid global operations as much as possible.</span></span>  
  
 <span data-ttu-id="7870f-142">Anahtar veya değer yalnızca okuyorsanız <xref:System.Collections.Generic.Dictionary%602> sözlük tüm iş parçacıkları tarafından değiştirilmeyen eşitleme gereklidir çünkü daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="7870f-142">If you are only reading key or values, the <xref:System.Collections.Generic.Dictionary%602> is faster because no synchronization is required if the dictionary is not being modified by any threads.</span></span>  
  
## <a name="concurrentbag"></a><span data-ttu-id="7870f-143">ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="7870f-143">ConcurrentBag</span></span>  
 <span data-ttu-id="7870f-144">Saf üretici-tüketici senaryolarda <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> büyük olasılıkla daha diğer eş zamanlı koleksiyon türleri daha yavaş çalışır.</span><span class="sxs-lookup"><span data-stu-id="7870f-144">In pure producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> will probably perform more slowly than the other concurrent collection types.</span></span>  
  
 <span data-ttu-id="7870f-145">Üretici-tüketici senaryoları, karma içinde <xref:System.Collections.Concurrent.ConcurrentBag%601> genellikle çok daha hızlı ve daha ölçeklenebilir daha küçük ve büyük iş yükleri için başka bir eşzamanlı koleksiyon türü.</span><span class="sxs-lookup"><span data-stu-id="7870f-145">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</span></span>  
  
## <a name="blockingcollection"></a><span data-ttu-id="7870f-146">BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="7870f-146">BlockingCollection</span></span>  
 <span data-ttu-id="7870f-147">Sınırlama ve engelleme semantiği gerekli olduğunda <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> büyük olasılıkla herhangi bir özel uygulaması daha hızlı gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="7870f-147">When bounding and blocking semantics are required, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> will probably perform faster than any custom implementation.</span></span> <span data-ttu-id="7870f-148">Zengin iptal, numaralandırma ve özel durum işleme da destekler.</span><span class="sxs-lookup"><span data-stu-id="7870f-148">It also supports rich cancellation, enumeration, and exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7870f-149">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="7870f-149">See Also</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>  
 [<span data-ttu-id="7870f-150">İş Parçacığı Güvenli Koleksiyonları</span><span class="sxs-lookup"><span data-stu-id="7870f-150">Thread-Safe Collections</span></span>](../../../../docs/standard/collections/thread-safe/index.md)  
 [<span data-ttu-id="7870f-151">Paralel Programlama</span><span class="sxs-lookup"><span data-stu-id="7870f-151">Parallel Programming</span></span>](../../../../docs/standard/parallel-programming/index.md)

---
title: Sınıflar (F#)
description: 'F # sınıflarının özellikleri, yöntemleri ve olayları sahip nesneleri temsil eden türlerin nasıl olduğunu öğrenin.'
ms.date: 05/16/2016
ms.openlocfilehash: 67164bd9f91c14f465bf05630259ad70cb8d90e5
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/04/2018
ms.locfileid: "33565892"
---
# <a name="classes"></a><span data-ttu-id="9aef7-103">Sınıflar</span><span class="sxs-lookup"><span data-stu-id="9aef7-103">Classes</span></span>

<span data-ttu-id="9aef7-104">*Sınıfları* özellikleri, yöntemleri ve olayları sahip nesneleri temsil türleridir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-104">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>


## <a name="syntax"></a><span data-ttu-id="9aef7-105">Sözdizimi</span><span class="sxs-lookup"><span data-stu-id="9aef7-105">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="9aef7-106">Açıklamalar</span><span class="sxs-lookup"><span data-stu-id="9aef7-106">Remarks</span></span>
<span data-ttu-id="9aef7-107">Sınıfları .NET nesne türlerini temel açıklamasını temsil eder; sınıf nesne odaklı programlama F #'de destekleyen birincil tür kavramdır.</span><span class="sxs-lookup"><span data-stu-id="9aef7-107">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="9aef7-108">Yukarıdaki söz diziminde `type-name` geçerli bir tanımlayıcı değil.</span><span class="sxs-lookup"><span data-stu-id="9aef7-108">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="9aef7-109">`type-params` İsteğe bağlı genel tür parametreleri açıklar.</span><span class="sxs-lookup"><span data-stu-id="9aef7-109">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="9aef7-110">Tür parametre adları ve kısıtlamalar açılı ayraç oluşur (`<` ve `>`).</span><span class="sxs-lookup"><span data-stu-id="9aef7-110">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="9aef7-111">Daha fazla bilgi için bkz: [genel türler](generics/index.md) ve [kısıtlamaları](generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="9aef7-111">For more information, see [Generics](generics/index.md) and [Constraints](generics/constraints.md).</span></span> <span data-ttu-id="9aef7-112">`parameter-list` Oluşturucu parametreleri açıklar.</span><span class="sxs-lookup"><span data-stu-id="9aef7-112">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="9aef7-113">İlk erişim değiştiricisi türü için geçerlidir; ikinci birincil oluşturucuya ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-113">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="9aef7-114">Her iki durumda da, varsayılan değer `public`.</span><span class="sxs-lookup"><span data-stu-id="9aef7-114">In both cases, the default is `public`.</span></span>

<span data-ttu-id="9aef7-115">Kullanarak bir sınıf için taban sınıf belirtin `inherit` anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="9aef7-115">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="9aef7-116">Taban sınıf oluşturucu için ayraç içinde bağımsız değişken sağlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-116">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="9aef7-117">Alanları bildirme veya işlevini kullanarak sınıfı için yerel olan değerleri `let` bağlamalar ve için genel kurallar uymalıdır `let` bağlar.</span><span class="sxs-lookup"><span data-stu-id="9aef7-117">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="9aef7-118">`do-bindings` Bölüm nesne oluşturması yürütülmek üzere kod içerir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-118">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="9aef7-119">`member-list` Ek Oluşturucular, örneği ve statik yöntem bildirimleri, arabirimi bildirimleri, soyut bağlamalar ve özelliğe ve olaya bildirimleri oluşur.</span><span class="sxs-lookup"><span data-stu-id="9aef7-119">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="9aef7-120">Bunlar [üyeleri](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="9aef7-120">These are described in [Members](members/index.md).</span></span>

<span data-ttu-id="9aef7-121">`identifier` Kullanılan isteğe bağlı WITH `as` anahtar sözcüğü örnek değişkeni veya tür tanımında türü örneğine başvuru yapmak için kullanılan kendi kendine tanımlayıcı bir ad sağlar.</span><span class="sxs-lookup"><span data-stu-id="9aef7-121">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="9aef7-122">Daha fazla bilgi için bu konunun ilerleyen bölümlerinde Self tanımlayıcıları bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="9aef7-122">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="9aef7-123">Anahtar sözcükler `class` ve `end` başlangıç işaretleyin ve tanımının bitiş isteğe bağlı.</span><span class="sxs-lookup"><span data-stu-id="9aef7-123">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="9aef7-124">Birbirine başvuru türleri olan özyinelemeli türleri ile birlikte birbirini katılan `and` karşılıklı özyinelemeli işlevler olarak yalnızca anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="9aef7-124">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="9aef7-125">Örneğin, karşılıklı özyinelemeli türleri bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="9aef7-125">For an example, see the section Mutually Recursive Types.</span></span>


## <a name="constructors"></a><span data-ttu-id="9aef7-126">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="9aef7-126">Constructors</span></span>
<span data-ttu-id="9aef7-127">Oluşturucusu sınıf türünün bir örneği oluşturan kodudur.</span><span class="sxs-lookup"><span data-stu-id="9aef7-127">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="9aef7-128">Diğer .NET dilleri göründüklerinden oluşturucuları sınıfları için biraz farklı F #'de çalışır.</span><span class="sxs-lookup"><span data-stu-id="9aef7-128">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="9aef7-129">Bir F # sınıfında yok her zaman olan bağımsız değişkenler bölümünde açıklanmıştır birincil Oluşturucusu `parameter-list` tür adı ve, gövde oluşur izleyen `let` (ve `let rec`) sınıf bildirimi ve başlangıcındabağlamaları`do`izleyin bağlar.</span><span class="sxs-lookup"><span data-stu-id="9aef7-129">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="9aef7-130">Sınıf bildirimi boyunca kapsamdaki birincil Oluşturucunun bağımsız değişkenler.</span><span class="sxs-lookup"><span data-stu-id="9aef7-130">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="9aef7-131">Kullanarak ek oluşturucular ekleyebilirsiniz `new` anahtar şu şekilde bir üye eklemek için:</span><span class="sxs-lookup"><span data-stu-id="9aef7-131">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="9aef7-132">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="9aef7-132">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="9aef7-133">Yeni Oluşturucusu gövdesi sınıf bildiriminin en üstünde belirtilen birincil oluşturucuyu çağırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-133">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="9aef7-134">Aşağıdaki örnekte bu kavramı gösterir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-134">The following example illustrates this concept.</span></span> <span data-ttu-id="9aef7-135">Aşağıdaki kodda, `MyClass` iki Oluşturucusu vardır, iki bağımsız değişkenleri ve başka bir oluşturucuyu alan bir birincil oluşturucu bağımsız değişken almayan.</span><span class="sxs-lookup"><span data-stu-id="9aef7-135">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]
    
## <a name="let-and-do-bindings"></a><span data-ttu-id="9aef7-136">let ve do bağlamaları</span><span class="sxs-lookup"><span data-stu-id="9aef7-136">let and do Bindings</span></span>

<span data-ttu-id="9aef7-137">`let` Ve `do` bağlamaları sınıf tanımında form birincil sınıf oluşturucu gövdesi ve bu nedenle çalıştıkları her bir sınıf örneği oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="9aef7-137">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="9aef7-138">Varsa bir `let` bağlama bir işlevi olan sonra üyesi derlenir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-138">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="9aef7-139">Varsa `let` bağlama herhangi bir işlev veya üye kullanılmayan bir değerdir ve ardından onu oluşturucuya yerel bir değişken derlenir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-139">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="9aef7-140">Aksi takdirde, bu sınıfın bir alana derlenir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-140">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="9aef7-141">`do` İzleyin ifadeleri birincil oluşturucuya derlenir ve her örneği için başlatma kodunu yürütün.</span><span class="sxs-lookup"><span data-stu-id="9aef7-141">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="9aef7-142">Tüm ek oluşturucular her zaman birincil Oluşturucusu çağırması nedeniyle `let` bağlamalar ve `do` bağlamaları her zaman yürütme bağımsız olarak Oluşturucusu çağrılır.</span><span class="sxs-lookup"><span data-stu-id="9aef7-142">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="9aef7-143">Tarafından oluşturulan alanları `let` bağlamaları erişilebilir sınıfının özelliklerini ve yöntemlerini; statik yöntemler bir örnek değişkeni bir parametre olarak geçirmesine olsa bile ancak, bunlar statik yöntemleri, erişilemez.</span><span class="sxs-lookup"><span data-stu-id="9aef7-143">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="9aef7-144">Varsa, kendi kendine tanımlayıcısı kullanılarak erişilemez.</span><span class="sxs-lookup"><span data-stu-id="9aef7-144">They cannot be accessed by using the self identifier, if one exists.</span></span>


## <a name="self-identifiers"></a><span data-ttu-id="9aef7-145">Kendine yönelik tanımlayıcılar</span><span class="sxs-lookup"><span data-stu-id="9aef7-145">Self Identifiers</span></span>

<span data-ttu-id="9aef7-146">A *kendini tanımlayıcı* geçerli örneği temsil eden bir addır.</span><span class="sxs-lookup"><span data-stu-id="9aef7-146">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="9aef7-147">Kendine yönelik tanımlayıcılar benzer `this` C# ya da C++ anahtar sözcük veya `Me` Visual Basic'te.</span><span class="sxs-lookup"><span data-stu-id="9aef7-147">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="9aef7-148">Kapsamdaki tüm sınıf tanımını veya yalnızca tek bir yöntemi olması için kendi kendine tanımlayıcısı mi istediğinize bağlı olarak, iki farklı yolla kendini tanımlayıcı tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9aef7-148">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="9aef7-149">Tüm sınıfı için kendi kendine bir tanımlayıcı tanımlamak için `as` ayraç Oluşturucusu parametresinin sonra anahtar sözcüğü listelemek ve tanımlayıcı adı belirtin.</span><span class="sxs-lookup"><span data-stu-id="9aef7-149">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="9aef7-150">Yalnızca bir yöntem için kendi kendine bir tanımlayıcı tanımlamak için hemen önce yöntem adını ve ayırıcı olarak bir nokta (.) üye bildirimi kendini tanımlayıcıda sağlar.</span><span class="sxs-lookup"><span data-stu-id="9aef7-150">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="9aef7-151">Aşağıdaki kod örneğinde bir kendi kendini tanımlayıcı oluşturmanın iki yolu gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-151">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="9aef7-152">İlk satırdaki `as` anahtar sözcüğü kendini tanımlayıcı tanımlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="9aef7-152">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="9aef7-153">Beşinci satır tanımlayıcısı olarak `this` kapsamını yöntemi kısıtlıdır self bir tanımlayıcı tanımlamak için kullanılan `PrintMessage`.</span><span class="sxs-lookup"><span data-stu-id="9aef7-153">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="9aef7-154">Ancak, istediğiniz aksine diğer .NET dilleri, kendi kendine tanımlayıcı adı verebilirsiniz; adları gibi sınırlı değildir `self`, `Me`, veya `this`.</span><span class="sxs-lookup"><span data-stu-id="9aef7-154">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="9aef7-155">İle bildirilen kendini tanımlayıcı `as` kadar anahtar sözcüğü başlatılmadı sonra `let` bağlamaları çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="9aef7-155">The self identifier that is declared with the `as` keyword is not initialized until after the `let` bindings are executed.</span></span> <span data-ttu-id="9aef7-156">Bu nedenle, onu kullanılamaz `let` bağlar.</span><span class="sxs-lookup"><span data-stu-id="9aef7-156">Therefore, it cannot be used in the `let` bindings.</span></span> <span data-ttu-id="9aef7-157">Kendi kendine tanımlayıcıda kullanabilirsiniz `do` bağlamaları bölümü.</span><span class="sxs-lookup"><span data-stu-id="9aef7-157">You can use the self identifier in the `do` bindings section.</span></span>


## <a name="generic-type-parameters"></a><span data-ttu-id="9aef7-158">Genel Tür Parametreleri</span><span class="sxs-lookup"><span data-stu-id="9aef7-158">Generic Type Parameters</span></span>

<span data-ttu-id="9aef7-159">Genel tür parametreleri açılı ayraçları içinde belirtilen (`<` ve `>`), ardından bir tanımlayıcısını tek tırnak işareti biçiminde.</span><span class="sxs-lookup"><span data-stu-id="9aef7-159">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="9aef7-160">Birden fazla genel tür parametreleri virgülle ayrılır.</span><span class="sxs-lookup"><span data-stu-id="9aef7-160">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="9aef7-161">Genel tür parametresi kapsam bildirimi boyunca kullanılıyor.</span><span class="sxs-lookup"><span data-stu-id="9aef7-161">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="9aef7-162">Aşağıdaki kod örneğinde, genel tür parametreleri belirtin gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-162">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="9aef7-163">Tür bağımsız değişkenleri türü kullanıldığında algılanır.</span><span class="sxs-lookup"><span data-stu-id="9aef7-163">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="9aef7-164">Aşağıdaki kodda çıkarılan türü başlık bir dizidir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-164">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]
    
## <a name="specifying-inheritance"></a><span data-ttu-id="9aef7-165">Devralma belirtme</span><span class="sxs-lookup"><span data-stu-id="9aef7-165">Specifying Inheritance</span></span>

<span data-ttu-id="9aef7-166">`inherit` Yan tümcesi varsa doğrudan temel sınıf tanımlar.</span><span class="sxs-lookup"><span data-stu-id="9aef7-166">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="9aef7-167">F #'ta doğrudan yalnızca bir temel sınıf izin verilir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-167">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="9aef7-168">Bir sınıf uygular arabirimleri temel sınıflar olarak kabul edilmez.</span><span class="sxs-lookup"><span data-stu-id="9aef7-168">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="9aef7-169">Arabirimler içinde ele alınmıştır [arabirimleri](Interfaces.md) konu.</span><span class="sxs-lookup"><span data-stu-id="9aef7-169">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="9aef7-170">Dil anahtar sözcüğünü kullanarak türetilmiş sınıftan temel sınıfının özelliklerini ve yöntemlerini erişebilirsiniz `base` bir tanımlayıcı olarak ve ardından bir nokta (.) ve üyenin adını tarafından.</span><span class="sxs-lookup"><span data-stu-id="9aef7-170">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="9aef7-171">Daha fazla bilgi için bkz: [devralma](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="9aef7-171">For more information, see [Inheritance](inheritance.md).</span></span>


## <a name="members-section"></a><span data-ttu-id="9aef7-172">Üyeler bölümü</span><span class="sxs-lookup"><span data-stu-id="9aef7-172">Members Section</span></span>
<span data-ttu-id="9aef7-173">Bu bölümde, statik veya örnek yöntemler, özellikler, arabirim uygulamaları, soyut üyelerini, olay bildirimleri ve ek oluşturucular tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9aef7-173">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="9aef7-174">Bu bölümde bağlamaları bulunamaz yapın ve sağlar.</span><span class="sxs-lookup"><span data-stu-id="9aef7-174">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="9aef7-175">F # türleri sınıfları yanı sıra çeşitli üyeleri eklenebilir olduğundan, ayrı bir konuda ele alınan [üyeleri](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="9aef7-175">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](members/index.md).</span></span>


## <a name="mutually-recursive-types"></a><span data-ttu-id="9aef7-176">Karşılıklı özyinelemeli türleri</span><span class="sxs-lookup"><span data-stu-id="9aef7-176">Mutually Recursive Types</span></span>
<span data-ttu-id="9aef7-177">Döngüsel bir şekilde birbirine başvuru türleri tanımladığınızda, birlikte tür tanımları kullanarak dize `and` anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="9aef7-177">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="9aef7-178">`and` Anahtar sözcüğü değiştirir `type` şekilde ilk tanım dışında tüm anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="9aef7-178">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="9aef7-179">Çıkış, geçerli dizindeki tüm dosyaları listesidir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-179">The output is a list of all the files in the current directory.</span></span>


## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="9aef7-180">Sınıfları, birleşimler, kaydeder ve yapıları ne zaman kullanılacağını</span><span class="sxs-lookup"><span data-stu-id="9aef7-180">When to Use Classes, Unions, Records, and Structures</span></span>
<span data-ttu-id="9aef7-181">Aralarından seçim yapabileceğiniz türleri çeşitli verildiğinde, ne her türü için belirli bir durum için uygun türü seçmek için tasarlanmıştır, iyi anlamış olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-181">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="9aef7-182">Sınıfları, nesne odaklı programlama bağlamlarda kullanmak için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="9aef7-182">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="9aef7-183">Nesne odaklı programlama için .NET Framework yazılmış uygulamalarda kullanılan baskın örnektir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-183">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="9aef7-184">F # kod .NET Framework veya başka bir nesne yönelimli kitaplığı ile yakından çalışmaya varsa ve özellikle kullanıcı Arabirimi kitaplığı gibi bir nesne yönelimli türü sisteminden genişletmek varsa, büyük olasılıkla uygun sınıflarıdır.</span><span class="sxs-lookup"><span data-stu-id="9aef7-184">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="9aef7-185">Yakından nesne yönelimli kod ile birlikte çalışma değil ya da kendi içinde bulunan ve bu nedenle, nesne yönelimli kod sık etkileşim karşı korumalıdır kod yazıyorsanız, kayıtları kullanmayı düşünmeniz gerekir ve birleşimler.</span><span class="sxs-lookup"><span data-stu-id="9aef7-185">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="9aef7-186">Tek bir iyi düşünce – çıkış kodu, eşleşen uygun düzeni ile birlikte ayrılmış birleşim genellikle bir nesne hiyerarşisi için daha basit bir alternatif olarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-186">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="9aef7-187">Ayrılmış birleşimler hakkında daha fazla bilgi için bkz: [ayrılmış birleşimler](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="9aef7-187">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="9aef7-188">Kayıtları sınıfları basit olma avantajına sahiptir, ancak bir türü taleplerini ile bunların Basitlik gerçekleştirilebilir aştıklarında kayıtları uygun değildir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-188">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="9aef7-189">Değerleri, özel eylemleri gerçekleştirebilirsiniz ayrı Oluşturucular, gizli alanlar, olmadan ve devralma veya arabirim uygulamaları temelde basit toplamalar kayıtlarıdır.</span><span class="sxs-lookup"><span data-stu-id="9aef7-189">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="9aef7-190">Üye özellikleri ve yöntemleri gibi davranışlarını daha karmaşık hale kayıtlara eklenebilir karşın, bir kayıtta depolanan hala değerlerin basit bir toplama alanlardır.</span><span class="sxs-lookup"><span data-stu-id="9aef7-190">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="9aef7-191">Kayıt hakkında daha fazla bilgi için bkz: [kayıtları](records.md).</span><span class="sxs-lookup"><span data-stu-id="9aef7-191">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="9aef7-192">Yapıları ayrıca veri küçük Toplamalar için yararlı olan, ancak .NET değer türleri olduklarından, sınıflar ve kayıtları bunların farklı.</span><span class="sxs-lookup"><span data-stu-id="9aef7-192">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="9aef7-193">Sınıfları ve kayıtları .NET başvurusu türleridir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-193">Classes and records are .NET reference types.</span></span> <span data-ttu-id="9aef7-194">Değer türleri değeri tarafından geçirilen değer türleri ve başvuru türleri semantiği farklı bir seçenektir.</span><span class="sxs-lookup"><span data-stu-id="9aef7-194">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="9aef7-195">Kopyalanan sanal yani bir parametre olarak geçirilen veya bir işlevinden döndürülen bitini bit.</span><span class="sxs-lookup"><span data-stu-id="9aef7-195">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="9aef7-196">Bunlar ayrıca yığında depolanan veya, yerine üst nesnenin içinde katıştırılmış bir alan olarak kullanılıyorsa yığın ayrı kendi konumunda depolanır.</span><span class="sxs-lookup"><span data-stu-id="9aef7-196">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="9aef7-197">Bu nedenle, öbek erişme yükünü bir sorun olduğunda yapıları sık erişilen veriler için uygundur.</span><span class="sxs-lookup"><span data-stu-id="9aef7-197">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="9aef7-198">Yapılar hakkında daha fazla bilgi için bkz: [yapıları](structures.md).</span><span class="sxs-lookup"><span data-stu-id="9aef7-198">For more information about structures, see [Structures](structures.md).</span></span>


## <a name="see-also"></a><span data-ttu-id="9aef7-199">Ayrıca Bkz.</span><span class="sxs-lookup"><span data-stu-id="9aef7-199">See Also</span></span>
[<span data-ttu-id="9aef7-200">F# Dili Başvurusu</span><span class="sxs-lookup"><span data-stu-id="9aef7-200">F# Language Reference</span></span>](index.md)

[<span data-ttu-id="9aef7-201">Üyeler</span><span class="sxs-lookup"><span data-stu-id="9aef7-201">Members</span></span>](members/index.md)

[<span data-ttu-id="9aef7-202">Devralma</span><span class="sxs-lookup"><span data-stu-id="9aef7-202">Inheritance</span></span>](inheritance.md)

[<span data-ttu-id="9aef7-203">Arabirimler</span><span class="sxs-lookup"><span data-stu-id="9aef7-203">Interfaces</span></span>](interfaces.md)


---
title: Mikro hizmet mimarisinde iletişim
description: Kapsayıcılı .NET uygulamaları için .NET mikro hizmet mimarisi | Bir mikro hizmet mimarisi mimarileri iletişim
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.openlocfilehash: 827d28adda90403d866e7bc13d9eae99fe47c137
ms.sourcegitcommit: 2eceb05f1a5bb261291a1f6a91c5153727ac1c19
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/04/2018
ms.locfileid: "43534682"
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="b1a3c-103">Mikro hizmet mimarisinde iletişim</span><span class="sxs-lookup"><span data-stu-id="b1a3c-103">Communication in a microservice architecture</span></span>

<span data-ttu-id="b1a3c-104">Tek bir işlemde çalışan tek parçalı bir uygulamada dil düzeyi yöntemi veya işlev çağrıları kullanarak birbirine bileşenleri çağırma.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-104">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="b1a3c-105">Nesneleri koduyla oluşturuyorsanız, bu kesin eşleştirilmek (örneğin, `new ClassName()`), veya somut bir nesne örneği yerine soyutlama başvurarak bağımlılık ekleme kullanıyorsanız, ayrılmış bir şekilde çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-105">These can be strongly coupled if you are creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you are using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="b1a3c-106">Her iki durumda da, nesneleri aynı işlem içinde çalışır.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-106">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="b1a3c-107">Bir mikro hizmet tabanlı uygulama için tek parça bir uygulamayı değiştirirken en büyük güçlük iletişim mekanizması değiştirmekle arasındadır.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-107">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="b1a3c-108">RPC çağrıları hizmetlerine işlem içi yöntemi çağrılarını doğrudan dönüştürme bir geveze neden olur ve ortamları da buna gerçekleştirmez değil verimli bir iletişim dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-108">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that will not perform well in distributed environments.</span></span> <span data-ttu-id="b1a3c-109">Dağıtılmış sisteme düzgün şekilde tasarlamanın zorluklarını olduğunu bile olarak bilinen bir canon yeterince iyi bilinen [dağıtılan bilgi işlem hataları](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) geliştiriciler genellikle tek parçalı gelen taşırken olun varsayımlar listeler Dağıtılmış tasarımları için.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-109">The challenges of designing distributed system properly are well enough known that there is even a canon known as the [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="b1a3c-110">Bir çözüm değildir, ancak birkaç yoktur.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-110">There is not one solution, but several.</span></span> <span data-ttu-id="b1a3c-111">Bir çözümü mümkün olduğunca iş mikro Hizmetleri ayırma içerir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-111">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="b1a3c-112">Daha sonra iç mikro hizmetler arasında zaman uyumsuz iletişim kullanın ve işlem içi iletişimi sertifikalarıdır kaba iletişimle nesneler arasındaki normal ayrıntılı iletişimine değiştirin.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-112">You then use asynchronous communication between the internal microservices and replace fine-grained communication that is typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="b1a3c-113">Çağrıları gruplandırma ve toplayan istemciye birden çok iç çağrı sonucunu veriyor bunu yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-113">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="b1a3c-114">Mikro hizmet tabanlı bir uygulama, birden çok işlemler veya hizmetler, birden fazla sunucu veya ana bilgisayar genellikle çift çalışan dağıtılmış bir sistemdir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-114">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="b1a3c-115">Her hizmet örneği, genellikle bir işlemdir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-115">Each service instance is typically a process.</span></span> <span data-ttu-id="b1a3c-116">Bu nedenle, hizmetler, örneğin HTTP, AMQP veya ikili bir protokol, TCP gibi her hizmetin doğasına bağlı olarak bir işlemler arası iletişim protokolünü kullanarak etkileşim kurmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-116">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="b1a3c-117">Mikro hizmet topluluk felsefesini yükseltir "[akıllı uç noktaları ve dumb kanallar](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)."</span><span class="sxs-lookup"><span data-stu-id="b1a3c-117">The microservice community promotes the philosophy of “[smart endpoints and dumb pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes).”</span></span> <span data-ttu-id="b1a3c-118">Bu sloganı mikro hizmetler arasında olabildiğince ve tek bir mikro hizmet içinde mümkün olduğunca cohesive gibi ayrılmış bir tasarımı teşvik eder.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-118">This slogan encourages a design that is as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="b1a3c-119">Daha önce açıklandığı gibi her bir mikro hizmet kendi verilerini ve kendi etki alanı mantığı sahip olur.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-119">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="b1a3c-120">Ancak mikro hizmetlerin uçtan uca uygulama oluşturma genellikle yalnızca REST iletişimleri yerine WS - gibi karmaşık protokoller kullanarak choreographed\* ve Merkezi yerine esnek olay tabanlı iletişim İş-işlem-düzenleyiciler.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-120">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="b1a3c-121">HTTP istek/yanıt kaynak (tüm çoğunu sorgulanırken) API'leri ile iki yaygın olarak kullanılan protokol olan ve basit zaman uyumsuz iletişim kurarken Mesajlaşma birden fazla mikro hizmetler arasında güncelleştirir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-121">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="b1a3c-122">Bunlar aşağıdaki bölümlerde daha ayrıntılı açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-122">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="b1a3c-123">İletişim türleri</span><span class="sxs-lookup"><span data-stu-id="b1a3c-123">Communication types</span></span>

<span data-ttu-id="b1a3c-124">İstemci ve hizmet iletişimi, her biri farklı bir senaryo ve hedefler hedefleyen birçok farklı türde iletişim kurabilir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-124">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="b1a3c-125">Başlangıçta, bu tür iletişimler iki eksenleri sınıflandırılabilir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-125">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="b1a3c-126">Protokol, zaman uyumlu veya zaman uyumsuz olması durumunda ilk ekseni tanımlanıyor:</span><span class="sxs-lookup"><span data-stu-id="b1a3c-126">The first axis is defining if the protocol is synchronous or asynchronous:</span></span>

-   <span data-ttu-id="b1a3c-127">Zaman uyumlu protokolü.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-127">Synchronous protocol.</span></span> <span data-ttu-id="b1a3c-128">Zaman uyumlu bir protokol HTTP'dir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-128">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="b1a3c-129">İstemci bir istek gönderir ve hizmetten bir yanıt bekler.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-129">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="b1a3c-130">Zaman uyumlu istemci kodu yürütülmesini bağımsız olan (iş parçacığı engellendi) veya zaman uyumsuz (iş parçacığı engellenmez ve yanıt bir geri çağırma yukarısına).</span><span class="sxs-lookup"><span data-stu-id="b1a3c-130">That is independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread is not blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="b1a3c-131">Burada önemli olan nokta, protokol (HTTP/HTTPS) zaman uyumlu ve HTTP sunucu yanıtı aldığında istemci kodu yalnızca görevini devam ' dir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-131">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

-   <span data-ttu-id="b1a3c-132">Zaman uyumsuz protokolü.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-132">Asynchronous protocol.</span></span> <span data-ttu-id="b1a3c-133">AMQP (çok sayıda işletim sistemleri ve bulut ortamları tarafından desteklenen bir Protokolü) gibi diğer protokoller, zaman uyumsuz iletileri kullanın.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-133">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="b1a3c-134">İstemci kodu veya ileti gönderen, genellikle yanıt beklemez.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-134">The client code or message sender usually does not wait for a response.</span></span> <span data-ttu-id="b1a3c-135">Yalnızca iletiyi RabbitMQ kuyruk ya da herhangi bir ileti aracısı için bir ileti gönderirken, gönderir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-135">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="b1a3c-136">Tek bir alıcı ya da birden çok alıcı iletişimi varsa, ikinci bir eksen tanımlanıyor:</span><span class="sxs-lookup"><span data-stu-id="b1a3c-136">The second axis is defining if the communication has a single receiver or multiple receivers:</span></span>

-   <span data-ttu-id="b1a3c-137">Tek bir alıcı.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-137">Single receiver.</span></span> <span data-ttu-id="b1a3c-138">Her istek tam olarak bir alıcı veya hizmet tarafından işlenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-138">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="b1a3c-139">Bu iletişim örneğidir [komut deseni](https://en.wikipedia.org/wiki/Command_pattern).</span><span class="sxs-lookup"><span data-stu-id="b1a3c-139">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

-   <span data-ttu-id="b1a3c-140">Birden çok alıcı.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-140">Multiple receivers.</span></span> <span data-ttu-id="b1a3c-141">Her istek, sıfır olarak birden çok alıcılar tarafından işlenebilir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-141">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="b1a3c-142">Bu tür bir iletişim zaman uyumsuz olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-142">This type of communication must be asynchronous.</span></span> <span data-ttu-id="b1a3c-143">Bir örnek [yayımlama/abone olma](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) desenleri gibi kullanılan mekanizma [olay denetimli mimari](https://microservices.io/patterns/data/event-driven-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="b1a3c-143">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](https://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="b1a3c-144">Bu olaylar ile birden çok mikro hizmetler arasında veri güncelleştirmelerini yayma, bir olay veri yolu arabirimi ya da ileti Aracısı dayanır; genellikle bir service bus veya gibi benzer yapıya aracılığıyla uygulanır [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) kullanarak [konuları ve abonelikleri](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="b1a3c-144">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it is usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="b1a3c-145">Mikro hizmet tabanlı bir uygulama genellikle bu iletişim stilleri bir birleşimini kullanır.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-145">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="b1a3c-146">En yaygın türü tek bir alıcı gibi HTTP/HTTPS zaman uyumlu bir protokol olan normal bir Web API HTTP hizmeti çağrılırken iletişimdir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-146">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="b1a3c-147">Mikro hizmetler, mikro hizmetler arasında zaman uyumsuz iletişim için ayrıca genellikle Mesajlaşma protokolleri kullanın.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-147">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="b1a3c-148">Bu eksenleri iyi netlik olası iletişim mekanizmalarına sahip, ancak bunlar önemli endişelere yer bırakmadan mikro hizmetler oluştururken değil bilmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-148">These axes are good to know so you have clarity on the possible communication mechanisms, but they are not the important concerns when building microservices.</span></span> <span data-ttu-id="b1a3c-149">Ne zaman uyumsuz istemci iş parçacığı yürütme yapısını ne de seçilen protokol zaman uyumsuz yapısını bazı önemli noktalar mikro Hizmetleri Tümleştirme.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-149">Neither the asynchronous nature of client thread execution nor the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="b1a3c-150">Hangi *olduğu* önemli mikro hizmetlerin zaman uyumsuz olarak bağımsızlığı, mikro hizmetler, korurken aşağıdaki bölümde açıklandığı gibi tümleştirebilir yapılıyor.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-150">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="b1a3c-151">Zaman uyumsuz bir mikro hizmet tümleştirmesi mikro hizmet'ın bağımsız çalışma sınırı uygular.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-151">Asynchronous microservice integration enforces microservice’s autonomy</span></span>

<span data-ttu-id="b1a3c-152">Belirtildiği gibi bir mikro hizmet tabanlı uygulama oluştururken önemli olan nokta, mikro hizmetler tümleştirme yoludur.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-152">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="b1a3c-153">İdeal olarak, iç mikro hizmetler arasındaki iletişimin en aza indirmeyi denemelisiniz.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-153">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="b1a3c-154">Daha az arasındaki iletişim mikro hizmetler, iyi olur.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-154">The less communications between microservices, the better.</span></span> <span data-ttu-id="b1a3c-155">Ancak, çoğu durumda, mikro hizmetler şekilde tümleştirmek gerekir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-155">But of course, in many cases you will have to somehow integrate the microservices.</span></span> <span data-ttu-id="b1a3c-156">Bunu yapmak, ihtiyacınız olduğunda, kritik kuralı buraya mikro hizmetler arasındaki iletişimi zaman uyumsuz olması gerekliliğidir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-156">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="b1a3c-157">Bu, belirli bir Protokolü (örneğin, zaman uyumsuz zaman uyumlu HTTP ileti) kullanmak zorunda gelmez.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-157">That does not mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="b1a3c-158">Yalnızca mikro hizmetler arasındaki iletişimi yalnızca verileri zaman uyumsuz olarak yayma tarafından yapılması gerekir, ancak diğer iç mikro hizmetler üzerinde ilk hizmetin HTTP istek/yanıt işleminin bir parçası bağımlı olmadan deneyin anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-158">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service’s HTTP request/response operation.</span></span>

<span data-ttu-id="b1a3c-159">Mümkünse, hiçbir zaman bile sorgular için birden fazla mikro hizmetler arasında zaman uyumlu iletişim (istek/yanıt) bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-159">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="b1a3c-160">Her mikro hizmet hedefi aşağı veya sağlıksız uçtan uca uygulamanın parçası olan diğer hizmetler olsa bile, otonom ve istemci tüketici için kullanılabilir olacak.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-160">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="b1a3c-161">İçinde bir mikro hizmet bir çağrıdan (bir HTTP isteği için bir veri sorgusu gerçekleştirmek) gibi diğer mikro hizmetler için yapmanız gereken düşünüyorsanız, bir istemci uygulamanın yanıt sağlamak için sipariş, bazı durumlarda dayanıklı olmayacak bir mimari sahip mikro hizmetler başarısız.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-161">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) in order to be able to provide a response to a client application, you have an architecture that will not be resilient when some microservices fail.</span></span>

<span data-ttu-id="b1a3c-162">Ayrıca, uzun oluştururken, HTTP istek/yanıt döngüleriyle zincirleri, Şekil 4 ',-15, ilk bölümde gösterildiği gibi istek gibi mikro hizmetler arasındaki HTTP bağımlılıklarına sahip değil yalnızca mikro hizmetlerin değil otonom sağlar ancak Ayrıca, performansı Bu zincirdeki hizmetlerden biri de gerçekleştirmiyor hemen sonra etkilenmiş.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-162">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain is not performing well.</span></span> 

<span data-ttu-id="b1a3c-163">Sorgu istekleri gibi bir mikro hizmetler arasında zaman uyumlu bağımlılıkları daha eklemeniz, istemci uygulamaları için yarışacağından genel yanıt süresini alır.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-163">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![](./media/image15.png)

<span data-ttu-id="b1a3c-164">**Şekil 4-15**.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-164">**Figure 4-15**.</span></span> <span data-ttu-id="b1a3c-165">Anti-desenleri ve mikro hizmetler arasındaki iletişimi desenleri</span><span class="sxs-lookup"><span data-stu-id="b1a3c-165">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="b1a3c-166">Başka bir işlem başka bir mikro hizmet içinde yükseltmek, mikro hizmet gerekiyorsa, mümkünse, bu eylem zaman uyumlu ve özgün mikro hizmet istek ve yanıt işleminin parçası olarak gerçekleştirme.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-166">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="b1a3c-167">Bunun yerine, bunu zaman uyumsuz olarak (kullanarak zaman uyumsuz Mesajlaşma veya tümleştirme olayları, kuyruklar vb.).</span><span class="sxs-lookup"><span data-stu-id="b1a3c-167">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="b1a3c-168">Ancak, mümkün olan en kısa kadar özgün eşzamanlı istek ve yanıt işleminin parçası olarak zaman uyumlu olarak eylemin çağırma kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-168">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="b1a3c-169">Son olarak (ve bu sorunların çoğu, mikro hizmetler oluştururken burada ortaya), ilk, mikro hizmet başlangıçta diğer mikro hizmetler tarafından sahip olunan veri gerekiyorsa, bu veriler için zaman uyumlu istekleri yapan güvenmeyin.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-169">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that is originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="b1a3c-170">Bunun yerine, çoğaltma veya nihai tutarlılık (genellikle tümleştirme olayları, sonraki bölümlerde açıklandığı gibi) kullanarak bu verileri (yalnızca gereksinim duyduğunuz öznitelikleri) ilk hizmetin veritabanına yayar.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-170">Instead, replicate or propagate that data (only the attributes you need) into the initial service’s database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="b1a3c-171">Önceki bölümde belirtildiği gibi [her mikro hizmet için etki alanı modeli sınırlarını tanımlama](#identifying-domain-model-boundaries-for-each-microservice), birden fazla mikro hizmetler arasında veri çoğaltma hatalı bir tasarım değildir — tam, ne zaman, yapılması Çevir verileri belirli bir dil veya ek etki alanı veya içerik sınırlanmış koşulları.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-171">As noted earlier in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice), duplicating some data across several microservices is not an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="b1a3c-172">Örneğin, [hizmetine](https://aka.ms/MicroservicesArchitecture) sahip olduğunuz kullanıcı adında bir varlıkla kullanıcının verilerin çoğu sorumlu olan identity.api adlı bir mikro hizmet uygulama.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-172">For instance, in the [eShopOnContainers](https://aka.ms/MicroservicesArchitecture) application you have a microservice named identity.api that is in charge of most of the user’s data with an entity named User.</span></span> <span data-ttu-id="b1a3c-173">Kullanıcı sıralama mikro hizmet içinde ilgili verileri depolamak gerekir, ancak, bunu alıcı adlı farklı bir varlık olarak saklayın.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-173">However, when you need to store data about the user within the Ordering microservice, you store it as a different entity named Buyer.</span></span> <span data-ttu-id="b1a3c-174">Alıcı varlık özgün kullanıcı varlığı ile aynı kimliği paylaşıyor, ancak yalnızca sıralama etki alanı ve tam kullanıcı profili gereken birkaç özniteliklere sahip.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-174">The Buyer entity shares the same identity with the original User entity, but it might have only the few attributes needed by the Ordering domain, and not the whole user profile.</span></span>

<span data-ttu-id="b1a3c-175">İletişim ve veri nihai tutarlılığa sahip olmak için mikro hizmetler arasında zaman uyumsuz olarak yaymak için herhangi bir protokolünü kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-175">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="b1a3c-176">Belirtildiği gibi bir olay veri yolu veya ileti aracısı veya hatta HTTP diğer hizmetleri yoklayarak kullanabilirsiniz kullanarak tümleştirme olayları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-176">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="b1a3c-177">Bu önemli değildir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-177">It does not matter.</span></span> <span data-ttu-id="b1a3c-178">Önemli, mikro hizmetler arasında zaman uyumlu bağımlılıkları oluşturmamayı kuralıdır.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-178">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="b1a3c-179">Aşağıdaki bölümlerde mikro hizmet tabanlı bir uygulama kullanmayı birden fazla iletişim stilleri açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-179">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="b1a3c-180">İletişim stilleri</span><span class="sxs-lookup"><span data-stu-id="b1a3c-180">Communication styles</span></span>

<span data-ttu-id="b1a3c-181">Birçok protokolleri ve kullanmak istediğiniz iletişim türüne bağlı olarak, iletişimi için kullanabileceğiniz seçenekleri vardır.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-181">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="b1a3c-182">Bir eş zamanlı istek/yanıt tabanlı iletişim mekanizması kullanıyorsanız, özellikle hizmetleriniz Docker konağı veya mikro hizmet küme dışındaki yayımlıyorsanız HTTP ve diğer yaklaşımlar gibi en yaygın kurallarıdır.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-182">If you are using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you are publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="b1a3c-183">Dahili olarak (Docker konağı veya mikro hizmetler kümeniz içindeki) hizmetler arasında kurarken ikili biçimi (Service Fabric uzaktan iletişimini veya TCP ve ikili biçimi kullanarak WCF gibi) iletişim mekanizmasını kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-183">If you are communicating between services internally (within your Docker host or microservices cluster) you might also want to use binary format communication mechanisms (like Service Fabric remoting or WCF using TCP and binary format).</span></span> <span data-ttu-id="b1a3c-184">Alternatif olarak, zaman uyumsuz, ileti tabanlı iletişim mekanizmasını AMQP gibi kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-184">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="b1a3c-185">Vardır da JSON veya XML gibi birden çok ileti formatları veya bile ikili biçimden daha verimli olabilir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-185">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="b1a3c-186">Seçilen bir ikili biçimi standart değilse, bu biçimi kullanarak kendi hizmetlerinizi herkese açık şekilde yayımlamak için iyi bir fikirdir olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-186">If your chosen binary format is not a standard, it is probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="b1a3c-187">Mikro hizmetlerin dahili iletişim için standart bir biçim kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-187">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="b1a3c-188">Docker konağı veya mikro hizmet kümenizi (Docker düzenleyiciler veya Azure Service Fabric) veya konuşma mikro hizmetler için özel istemci uygulamaları için mikro hizmetler arasında iletişim kurarken bunu yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-188">You might do this when communicating between microservices within your Docker host or microservice cluster (Docker orchestrators or Azure Service Fabric), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="b1a3c-189">HTTP ve REST ile istek/yanıt iletişim</span><span class="sxs-lookup"><span data-stu-id="b1a3c-189">Request/response communication with HTTP and REST</span></span> 

<span data-ttu-id="b1a3c-190">Bir istemci istek/yanıt iletişim kullandığında, istek bir hizmet, hizmet işlemleri için bir istek gönderir ve bir yanıtı geri gönderir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-190">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="b1a3c-191">İstek/yanıt iletişimi, özellikle de istemci uygulamalardan gelen gerçek zamanlı bir kullanıcı Arabirimi (dinamik kullanıcı arabirimi) için veri sorgulama için uygundur.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-191">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="b1a3c-192">Bu nedenle, bir mikro hizmet mimarisinde büyük olasılıkla bu iletişim mekanizması sorguların çoğu, Şekil 4-16 gösterildiği gibi kullanın.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-192">Therefore, in a microservice architecture you will probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![](./media/image16.png)

<span data-ttu-id="b1a3c-193">**Şekil 4-16**.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-193">**Figure 4-16**.</span></span> <span data-ttu-id="b1a3c-194">HTTP istek/yanıt iletişimi (zaman uyumlu veya zaman uyumsuz) kullanma</span><span class="sxs-lookup"><span data-stu-id="b1a3c-194">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="b1a3c-195">Bir istemci istek/yanıt iletişim kullandığında, yanıt kısa bir süre içinde genellikle bir saniyeden az veya birkaç saniye en fazla ulaşır olduğunu varsayar.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-195">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="b1a3c-196">Gecikmeli yanıtlar için göre zaman uyumsuz iletişim uygulamak gereken [Mesajlaşma desenleri](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) ve [teknolojileri Mesajlaşma](https://en.wikipedia.org/wiki/Message-oriented_middleware), biz sonraki bölümde açıklanmaktadır ve farklı bir yaklaşım olan.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-196">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="b1a3c-197">İstek/yanıt iletişim için popüler bir mimari stil olan [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span><span class="sxs-lookup"><span data-stu-id="b1a3c-197">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="b1a3c-198">Bu yaklaşım için açık ve sıkı eşleşmiş tabanlı [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protokolü, HTTP fiilleri gibi GET, POST, benimsemenin ve yerleştirin.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-198">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="b1a3c-199">REST en sık kullanılan mimari iletişim hizmetleri oluştururken bir yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-199">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="b1a3c-200">ASP.NET Core Web API Hizmetleri geliştirirken REST Hizmetleri uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-200">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="b1a3c-201">HTTP REST Hizmetleri, arabirim tanımı dili olarak kullanılırken ek değer yoktur.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-201">There is additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="b1a3c-202">Örneğin, kullanırsanız [Swagger meta verileri](https://swagger.io/) hizmet API'nizi açıklamak için doğrudan bulabilir ve hizmetlerinizi kullanan istemci saptamalar Oluştur araçları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-202">For instance, if you use [Swagger metadata](https://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="b1a3c-203">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="b1a3c-203">Additional resources</span></span>

-   <span data-ttu-id="b1a3c-204">**Martin Fowler. Uludağ Kapasite Olgunlaştırma Model.**</span><span class="sxs-lookup"><span data-stu-id="b1a3c-204">**Martin Fowler. Richardson Maturity Model.**</span></span> <span data-ttu-id="b1a3c-205">REST modelin açıklaması.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-205">A description of the REST model.</span></span>
    [*https://martinfowler.com/articles/richardsonMaturityModel.html*](https://martinfowler.com/articles/richardsonMaturityModel.html)

-   <span data-ttu-id="b1a3c-206">**Swagger.**</span><span class="sxs-lookup"><span data-stu-id="b1a3c-206">**Swagger.**</span></span> <span data-ttu-id="b1a3c-207">Resmi sitesi.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-207">The official site.</span></span>
    [*https://swagger.io/*](https://swagger.io/)

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="b1a3c-208">Anında iletme ve HTTP tabanlı gerçek zamanlı iletişim</span><span class="sxs-lookup"><span data-stu-id="b1a3c-208">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="b1a3c-209">Başka bir (genellikle farklı dışındaki amaçlarla REST) bir olasılıktır üst düzey çerçeveleri ile gerçek zamanlı ve bire çok bir iletişim gibi [ASP.NET SignalR](https://www.asp.net/signalr) ve protokoller gibi [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span><span class="sxs-lookup"><span data-stu-id="b1a3c-209">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="b1a3c-210">Şekil 4-17 gösterildiği gibi HTTP iletişimi için gerçek zamanlı yeni veri istemek bir istemci için bekleyin sunucusuna sahip olmak yerine veri kullanılabilir olduğunda içeriği bağlı istemcilere göndermek sunucu kodu olabilir anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-210">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![](./media/image17.png)

<span data-ttu-id="b1a3c-211">**Şekil 4-17**.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-211">**Figure 4-17**.</span></span> <span data-ttu-id="b1a3c-212">Gerçek zamanlı bire bir zaman uyumsuz ileti iletişimi</span><span class="sxs-lookup"><span data-stu-id="b1a3c-212">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="b1a3c-213">Gerçek zamanlı olarak iletişim olduğundan, istemci uygulamaları değişiklikleri neredeyse anında gösterir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-213">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="b1a3c-214">Bu genellikle birçok WebSockets bağlantıları (istemci başına bir adet) kullanarak, WebSockets gibi bir protokol tarafından işlenir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-214">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="b1a3c-215">Aynı anda çok sayıda istemci web Apps'e Spor oyunu puanı değişikliği hizmet iletişim kurduğunda, tipik bir örnektir.</span><span class="sxs-lookup"><span data-stu-id="b1a3c-215">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="b1a3c-216">[Önceki](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
[İleri](asynchronous-message-based-communication.md)</span><span class="sxs-lookup"><span data-stu-id="b1a3c-216">[Previous](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
[Next](asynchronous-message-based-communication.md)</span></span>

---
title: Değer türleri ile başvuru semantiği
description: Kopyalama yapıları güvenli bir şekilde en aza dil özelliklerini anlama
ms.date: 11/10/2017
ms.custom: mvc
ms.openlocfilehash: f241219994d7a03192a4aea69b912bf1ac5ed29c
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/01/2018
ms.locfileid: "43422672"
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="addee-103">Değer türleri ile başvuru semantiği</span><span class="sxs-lookup"><span data-stu-id="addee-103">Reference semantics with value types</span></span>

<span data-ttu-id="addee-104">Değer türleri kullanmanın bir avantajı, bunlar genellikle yığın ayırmaları önlemek ' dir.</span><span class="sxs-lookup"><span data-stu-id="addee-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="addee-105">Olumsuz yönüyse, değere göre kopyalanır ' dir.</span><span class="sxs-lookup"><span data-stu-id="addee-105">The disadvantage is that they are copied by value.</span></span> <span data-ttu-id="addee-106">Bu bir tradeoff, büyük miktarlarda veri çalışan algoritmalar iyileştirmek zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="addee-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="addee-107">Yeni C# 7.2 dil özellikleri etkinleştiren değer türleri ile başvuru ile geçişi semantiği mekanizmaları sağlar.</span><span class="sxs-lookup"><span data-stu-id="addee-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="addee-108">Bu özellikler hem ayırmaların en aza indirmek ve kopyalama işlemlerini akıllıca kullanın.</span><span class="sxs-lookup"><span data-stu-id="addee-108">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="addee-109">Bu makalede, bu yeni özellikleri keşfediyor.</span><span class="sxs-lookup"><span data-stu-id="addee-109">This article explores those new features.</span></span>

<span data-ttu-id="addee-110">Bu makaledeki örnek kodun çoğu C# 7.2 eklenen özellikleri gösterir.</span><span class="sxs-lookup"><span data-stu-id="addee-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="addee-111">Bu özellikleri kullanmak için projenizin C# 7.2 veya üzeri kullanmak için yapılandırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="addee-111">In order to use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="addee-112">Dil sürümü hakkında daha fazla bilgi için bkz. [dil sürümü yapılandırma](language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="addee-112">For more information on setting the language version see [configure the language version](language-reference/configure-language-version.md).</span></span>

## <a name="passing-arguments-by-readonly-reference"></a><span data-ttu-id="addee-113">Salt okunur başvuruya göre bağımsız değişkenleri geçirme</span><span class="sxs-lookup"><span data-stu-id="addee-113">Passing arguments by readonly reference</span></span>

<span data-ttu-id="addee-114">C# 7.2 ekler `in` varolan tamamlamak üzere anahtar sözcüğü `ref` ve `out` başvuruya göre bağımsız değişkenleri geçirmek için anahtar sözcükler.</span><span class="sxs-lookup"><span data-stu-id="addee-114">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="addee-115">`in` Anahtar sözcüğü, bağımsız değişkenini başvuruya göre geçirme belirtir, ancak çağrılan yöntem değerini değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="addee-115">The `in` keyword specifies passing the argument by reference, but the called method does not modify the value.</span></span> 

<span data-ttu-id="addee-116">Bu ayrıca, tasarım hedefi ifade etmek için tam bir kelime sağlar.</span><span class="sxs-lookup"><span data-stu-id="addee-116">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="addee-117">Değer türleri Yöntem imzasında aşağıdaki değiştiriciler hiçbirini belirtmezseniz, çağrılan bir yönteme geçildiğinde kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="addee-117">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="addee-118">Bu değiştiriciler, her bir değer türü başvuruya göre kopyalama önleme geçirilen belirtir.</span><span class="sxs-lookup"><span data-stu-id="addee-118">Each of these modifiers specifies that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="addee-119">Her değiştiricisi, farklı bir hedefi ifade eder:</span><span class="sxs-lookup"><span data-stu-id="addee-119">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="addee-120">`out`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkenin değerini ayarlar.</span><span class="sxs-lookup"><span data-stu-id="addee-120">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="addee-121">`ref`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkeninin değerini ayarlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="addee-121">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="addee-122">`in`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkeninin değerini değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="addee-122">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="addee-123">Ekleme `in` başvuruya göre bağımsız değişken geçirin ve gereksiz şekilde kopyalamama olanağı, başvuruya göre bağımsız değişkenleri geçirmek için tasarım amacınızla bildirmek üzere değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="addee-123">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="addee-124">Bu bağımsız değişken olarak kullanılan nesneyi değiştirmek istemediğiniz.</span><span class="sxs-lookup"><span data-stu-id="addee-124">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="addee-125">Aşağıdaki kod örneği, 3B alanda iki nokta arasındaki uzaklığı hesaplar bir yöntemin gösterir.</span><span class="sxs-lookup"><span data-stu-id="addee-125">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="addee-126">Her üç çiftten içeren iki yapıları bağımsız değişkenler.</span><span class="sxs-lookup"><span data-stu-id="addee-126">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="addee-127">Bir çift 8 bayt olduğundan her bağımsız değişken 24 bayttır.</span><span class="sxs-lookup"><span data-stu-id="addee-127">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="addee-128">Belirterek `in` makine mimarisine bağlı olarak bu bağımsız değişken bir 4 baytlık veya 8 bayt başvuru geçirdiğiniz değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="addee-128">By specifying the `in` modifier, you pass a 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="addee-129">Boyutu fark küçüktür, ancak uygulamanız bu yöntemi kullanarak birçok farklı değerler sıkı bir döngüde çağırdığında, hızlı bir şekilde toplanabilir.</span><span class="sxs-lookup"><span data-stu-id="addee-129">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="addee-130">`in` Değiştiricisi destekleyici `out` ve `ref` başka yöntemler de.</span><span class="sxs-lookup"><span data-stu-id="addee-130">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="addee-131">Yalnızca içinde varken, farklı bir yöntem aşırı yüklemeleri oluşturulamıyor `in`, `out`, veya `ref`.</span><span class="sxs-lookup"><span data-stu-id="addee-131">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="addee-132">Bu yeni kurallar her zaman için tanımlanmış aynı davranışı genişletmek `out` ve `ref` parametreleri.</span><span class="sxs-lookup"><span data-stu-id="addee-132">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="addee-133">`in` Değiştiricisi parametre almayan herhangi bir üyeye uygulanan: yöntemleri, temsilciler, lambda ifadeleri, yerel İşlevler, Dizinleyicileri, işleçleri.</span><span class="sxs-lookup"><span data-stu-id="addee-133">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="addee-134">Farklı `ref` ve `out` bağımsız değişkenler kullanabilirsiniz değişmez değerler veya sabitler bağımsız değişkeni için bir `in` parametresi.</span><span class="sxs-lookup"><span data-stu-id="addee-134">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="addee-135">Ayrıca, farklı bir `ref` veya `out` parametresi, geçerli gerekmeyen `in` çağrı sitesinde değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="addee-135">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="addee-136">Aşağıdaki kod çağırmanın iki örnek gösterir `CalculateDistance` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="addee-136">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="addee-137">İlk iki yerel değişkenini başvuruya göre geçirilen kullanır.</span><span class="sxs-lookup"><span data-stu-id="addee-137">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="addee-138">İkinci yöntem çağrısının bir parçası olarak oluşturulan geçici bir değişken içerir.</span><span class="sxs-lookup"><span data-stu-id="addee-138">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="addee-139">Hangi derleyici sağlar, salt okunur yapısını birkaç şekilde bir `in` bağımsız değişken zorlanır.</span><span class="sxs-lookup"><span data-stu-id="addee-139">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="addee-140">İlk olarak çağrılan yöntem doğrudan atayamazsınız bir `in` parametresi.</span><span class="sxs-lookup"><span data-stu-id="addee-140">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="addee-141">Herhangi bir alan için doğrudan atanamaz bir `in` değeri olduğunda parametresi bir `struct` türü.</span><span class="sxs-lookup"><span data-stu-id="addee-141">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="addee-142">Ayrıca, geçirilemez bir `in` kullanarak herhangi bir yöntem için parametre `ref` veya `out` değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="addee-142">In addition, you cannot pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="addee-143">Bu kurallar herhangi bir alan için geçerli bir `in` parametre, sağlanan alan bir `struct` türü ve parametre bir `struct` türü.</span><span class="sxs-lookup"><span data-stu-id="addee-143">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="addee-144">Üye erişimi tüm düzeylerinde türleri birden çok üye erişimi katmanı sağlanan bu kurallar aslında uygulanmasını `structs`.</span><span class="sxs-lookup"><span data-stu-id="addee-144">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span> <span data-ttu-id="addee-145">Derleyici, zorlar `struct` türleri olarak geçirildi `in` bağımsız değişkenleri ve bunların `struct` üyesi olan diğer yöntemlerinin bağımsız değişkenleri olarak kullanılan salt okunur değişkenler.</span><span class="sxs-lookup"><span data-stu-id="addee-145">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="addee-146">Kullanımını `in` parametreleri kopyalarının olası performans maliyetini ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="addee-146">The use of `in` parameters avoids the potential performance costs of making copies.</span></span> <span data-ttu-id="addee-147">Herhangi bir yöntem çağrısının semantiği değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="addee-147">It does not change the semantics of any method call.</span></span> <span data-ttu-id="addee-148">Bu nedenle, belirtmeniz gerekmez `in` çağrı sitesinde değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="addee-148">Therefore, you do not need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="addee-149">Ancak, atlama `in` değiştiricisi çağrı sitesinde derleyici bağımsız değişkeni aşağıdaki nedenlerle bir kopyasını izni olduğunu bildirir:</span><span class="sxs-lookup"><span data-stu-id="addee-149">However, omitting the `in` modifier at the call site informs the compiler that it is allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="addee-150">Örtük bir dönüştürme ancak olmayan bir kimlik dönüştürme bağımsız değişken türü parametre türü yoktur.</span><span class="sxs-lookup"><span data-stu-id="addee-150">There is an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="addee-151">Bağımsız değişken ifade ancak bilinen depolama değişkeni yok.</span><span class="sxs-lookup"><span data-stu-id="addee-151">The argument is an expression but does not have a known storage variable.</span></span>
- <span data-ttu-id="addee-152">Mevcut bir aşırı yükleme olan varlığı veya yokluğu ile farklı `in`.</span><span class="sxs-lookup"><span data-stu-id="addee-152">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="addee-153">Bu durumda, değere göre aşırı daha iyi bir eşleşmedir.</span><span class="sxs-lookup"><span data-stu-id="addee-153">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="addee-154">Bu kurallar, mevcut kodu salt okunur başvuru bağımsız değişkenleri kullanın güncelleştirmelerden yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="addee-154">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="addee-155">Çağrılan yöntemde, değer parametreleri kullanan herhangi bir örnek yöntemi çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="addee-155">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="addee-156">Bu durumlarda, bir kopyasını `in` parametre oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="addee-156">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="addee-157">Derleyici için geçici değişken oluşturabildiğinden `in` parametresi varsayılan değerler için belirtebilirsiniz `in` parametresi.</span><span class="sxs-lookup"><span data-stu-id="addee-157">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="addee-158">Aşağıdaki kod, ikinci noktası için varsayılan değer olarak (noktası 0,0) kaynak belirtir:</span><span class="sxs-lookup"><span data-stu-id="addee-158">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="addee-159">Yalnızca okuma bağımsız değişkenleri başvuruya göre geçiren zorlamak için bu seçeneği belirtin `in` modifer çağrı sitesinde aşağıdaki kodda gösterildiği gibi bağımsız değişkenlerde:</span><span class="sxs-lookup"><span data-stu-id="addee-159">To force the compiler to pass read only arguments by reference, specify the `in` modifer on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="addee-160">Bu davranışı benimsemeye kolaylaştırır `in` parametreleri zaman içinde büyük kod tabanlarında nerede performans artışı mümkündür.</span><span class="sxs-lookup"><span data-stu-id="addee-160">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="addee-161">Eklediğiniz `in` değiştirici yöntem imzaları için ilk.</span><span class="sxs-lookup"><span data-stu-id="addee-161">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="addee-162">Daha sonra ekleyebilirsiniz `in` değiştiricisi callsites adresindeki oluşturup `readonly struct` savunma kopyası oluşturmaktan kaçınmak derleyicinin etkinleştirmek için türleri `in` daha fazla konumda parametreleri.</span><span class="sxs-lookup"><span data-stu-id="addee-162">Then, you can add the `in` modifier at callsites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="addee-163">`in` Parametresi ataması, de başvuru türleri veya sayısal değerleri ile kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="addee-163">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="addee-164">Ancak, varsa minimum avantajlarından her iki durumda değildir.</span><span class="sxs-lookup"><span data-stu-id="addee-164">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="addee-165">`ref readonly` döndürür</span><span class="sxs-lookup"><span data-stu-id="addee-165">`ref readonly` returns</span></span>

<span data-ttu-id="addee-166">Bir değer türü başvuru ile döndürülen, ancak bu değeri değiştirmek gelen arayan engellemek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="addee-166">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="addee-167">Kullanım `ref readonly` bu tasarım hedefi ifade etmek için değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="addee-167">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="addee-168">Okuyucular, mevcut verileri bir başvuru döndürerek, ancak değiştirilmesine izin vermiyor olduğunu bildirir.</span><span class="sxs-lookup"><span data-stu-id="addee-168">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="addee-169">Derleyici, çağırana başvurusu değiştirilemez zorlar.</span><span class="sxs-lookup"><span data-stu-id="addee-169">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="addee-170">Denemeleri değeri doğrudan atamak için bir derleme zamanı hatası oluşturur.</span><span class="sxs-lookup"><span data-stu-id="addee-170">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="addee-171">Ancak, derleyici, herhangi bir üye yöntemi yapı durumunu değiştirirse bilemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="addee-171">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="addee-172">Nesne değiştirilmez emin olmak için derleyici bir kopyasını oluşturur ve bu kopyayı kullanarak başvuruları üye arar.</span><span class="sxs-lookup"><span data-stu-id="addee-172">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="addee-173">Herhangi bir değişiklik için savunma kopyası var.</span><span class="sxs-lookup"><span data-stu-id="addee-173">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="addee-174">Büyük olasılıkla bu kitaplığı kullanarak `Point3D` genellikle kaynak kod genelindeki kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="addee-174">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="addee-175">Her örnek, yığın üzerinde yeni bir nesne oluşturur.</span><span class="sxs-lookup"><span data-stu-id="addee-175">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="addee-176">Bir sabit oluşturmak ve başvuru ile döndürülen için yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="addee-176">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="addee-177">Ancak, iç depolama alanına bir başvuru döndürmeyi ise çağıranın başvurulan depolama değiştiremezsiniz zorlamak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="addee-177">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="addee-178">Aşağıdaki kod döndüren bir salt okunur özelliği tanımlar. bir `readonly ref` için bir `Point3D` kaynağını belirtir.</span><span class="sxs-lookup"><span data-stu-id="addee-178">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="addee-179">Bir ref salt okunur bir kopyasını dönüş oluşturmak kolaydır: yalnızca bildirilen olmayan bir değişkene atayın `ref readonly` değiştiricisi.</span><span class="sxs-lookup"><span data-stu-id="addee-179">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="addee-180">Derleyici, atama bir parçası olarak nesneyi kopyalamak için kod oluşturur.</span><span class="sxs-lookup"><span data-stu-id="addee-180">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="addee-181">Bir değişkene atadığınızda bir `ref readonly return`, belirtebilirsiniz bir `ref readonly` değişkeni veya bir değere göre kopyalama salt okunur başvuru:</span><span class="sxs-lookup"><span data-stu-id="addee-181">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the read-only reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="addee-182">Önceki kodda ilk atama bir kopyasını oluşturur `Origin` sabit ve kopyalama atar.</span><span class="sxs-lookup"><span data-stu-id="addee-182">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="addee-183">İkinci bir başvuru atar.</span><span class="sxs-lookup"><span data-stu-id="addee-183">The second assigns a reference.</span></span> <span data-ttu-id="addee-184">Dikkat `readonly` değiştiricisi değişkenin bildirimi bir parçası olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="addee-184">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="addee-185">Başvurduğu başvurusu değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="addee-185">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="addee-186">Bunu denediğinizde bir derleme zamanı hatasına neden.</span><span class="sxs-lookup"><span data-stu-id="addee-186">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="addee-187">`readonly struct` Türü</span><span class="sxs-lookup"><span data-stu-id="addee-187">`readonly struct` type</span></span>

<span data-ttu-id="addee-188">Uygulama `ref readonly` yapı trafiği yüksek kullanımları için yeterli olabilir.</span><span class="sxs-lookup"><span data-stu-id="addee-188">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="addee-189">Diğer durumlarda, sabit bir yapı oluşturmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="addee-189">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="addee-190">Ardından, her zaman salt okunur başvuru ile geçirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="addee-190">Then you can always pass by read-only reference.</span></span> <span data-ttu-id="addee-191">Yöntemleri olarak kullanılan bir yapının eriştiğinde uygulama savunma kaldırır meydana kopyalar bir `in` parametresi.</span><span class="sxs-lookup"><span data-stu-id="addee-191">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="addee-192">Oluşturarak bunu yapabilirsiniz bir `readonly struct` türü.</span><span class="sxs-lookup"><span data-stu-id="addee-192">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="addee-193">Ekleyebileceğiniz `readonly` değiştiricisi için yapı bildirimi.</span><span class="sxs-lookup"><span data-stu-id="addee-193">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="addee-194">Derleyici yapının tüm örnek üyeleri olduğunu zorlar `readonly`; `struct` sabit olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="addee-194">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="addee-195">Diğer iyileştirmeler için vardır bir `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="addee-195">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="addee-196">Kullanabileceğiniz `in` her konumda değiştiricisi burada bir `readonly struct` bir bağımsız değişken.</span><span class="sxs-lookup"><span data-stu-id="addee-196">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="addee-197">Ayrıca, döndürebilir bir `readonly struct` olarak bir `ref return` ne zaman, döndürüyor bir nesne ömürlerinin genişletir nesnesi döndüren yöntem kapsamı dışındadır.</span><span class="sxs-lookup"><span data-stu-id="addee-197">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="addee-198">Son olarak, derleyici üyeleri çağırdığınızda daha verimli kod oluşturur bir `readonly struct`: `this` başvuru, alıcı bir kopyasını yerine, her zaman bir `in` parametresine geçirilen başvuruyla üye yöntemi.</span><span class="sxs-lookup"><span data-stu-id="addee-198">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="addee-199">Bu iyileştirme kullanırken daha fazla kopyalama kaydeder bir `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="addee-199">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="addee-200">`Point3D` Bu değişikliği için mükemmel bir adaydır.</span><span class="sxs-lookup"><span data-stu-id="addee-200">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="addee-201">Aşağıdaki kod güncelleştirilmiş gösterir `ReadonlyPoint3D` yapısı:</span><span class="sxs-lookup"><span data-stu-id="addee-201">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="addee-202">`ref struct` Türü</span><span class="sxs-lookup"><span data-stu-id="addee-202">`ref struct` type</span></span>

<span data-ttu-id="addee-203">İlgili dil özelliği başka bir yığın ayrılmış olması gereken bir değer türü bildirmek için yeteneğidir.</span><span class="sxs-lookup"><span data-stu-id="addee-203">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="addee-204">Diğer bir deyişle, bu tür asla yığın üzerinde başka bir sınıf üyesi olarak oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="addee-204">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="addee-205">Bu özellik için birincil motivasyon olan <xref:System.Span%601> ve ilişkili yapıları.</span><span class="sxs-lookup"><span data-stu-id="addee-205">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="addee-206"><xref:System.Span%601> yönetilen bir işaretçiyi kendi üyelerinden biri olarak diğer aralık uzunluğu olan içerebilir.</span><span class="sxs-lookup"><span data-stu-id="addee-206"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="addee-207">C# güvenli olmayan bir bağlam dışında yönetilen bellek işaretçileri desteklemediği için biraz farklı şekilde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="addee-207">It's implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="addee-208">İşaretçiyi ve uzunluğunu değiştiren herhangi bir yazma atomik olması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="addee-208">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="addee-209">Yani bir <xref:System.Span%601> , sınırlı değildir tek yığın çerçevesi için diğer tür güvenlik ihlallerini olan ya da yetersiz aralık hatalarında tabi olacaktır.</span><span class="sxs-lookup"><span data-stu-id="addee-209">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="addee-210">Ayrıca, Yönetilen işaretçi GC yığınında genellikle koyarak JIT zaman kilitleniyor.</span><span class="sxs-lookup"><span data-stu-id="addee-210">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="addee-211">Kullanılarak oluşturulan bellek ile çalışmaya benzer gereksinimlerine sahip olabilir [ `stackalloc` ](language-reference/keywords/stackalloc.md) veya Interop API'leri bellekten kullanırken.</span><span class="sxs-lookup"><span data-stu-id="addee-211">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="addee-212">Kendi tanımlayabilirsiniz `ref struct` türleri bu ihtiyaçları için.</span><span class="sxs-lookup"><span data-stu-id="addee-212">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="addee-213">Bu makalede, gördüğünüz kullanan örnekler `Span<T>` kolaylık sağlamak için.</span><span class="sxs-lookup"><span data-stu-id="addee-213">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="addee-214">`ref struct` Bildirimi bildirir yığında bu tür bir yapı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="addee-214">The `ref struct` declaration declares a struct of this type must be on the stack.</span></span> <span data-ttu-id="addee-215">Dil kuralları, bu tür güvenli kullanımı emin olun.</span><span class="sxs-lookup"><span data-stu-id="addee-215">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="addee-216">Diğer türleri olarak bildirilen `ref struct` dahil <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="addee-216">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="addee-217">Amacı tutarken, bir `ref struct` yazın, tüm derleyici zorlayan çeşitli kurallar bir yığın ayırma değişken tanıtan `ref struct` türleri.</span><span class="sxs-lookup"><span data-stu-id="addee-217">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="addee-218">Kutusunda edilemez bir `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="addee-218">You can't box a `ref struct`.</span></span> <span data-ttu-id="addee-219">Atama yapılamaz bir `ref struct` türünde bir değişkene `object`, `dynamic`, veya herhangi bir arabirim türü.</span><span class="sxs-lookup"><span data-stu-id="addee-219">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="addee-220">Bildirip bir `ref struct` bir sınıf veya normal yapı üyesi olarak.</span><span class="sxs-lookup"><span data-stu-id="addee-220">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="addee-221">Yerel değişkenler bildiremezsiniz `ref struct` zaman uyumsuz yöntemlerde türleri.</span><span class="sxs-lookup"><span data-stu-id="addee-221">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="addee-222">Döndüren zaman uyumlu yöntemleri bildirebilirsiniz `Task`, `Task<T>` veya görev benzeri türü.</span><span class="sxs-lookup"><span data-stu-id="addee-222">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="addee-223">Bildirip `ref struct` yineleyiciler yerel değişkenler.</span><span class="sxs-lookup"><span data-stu-id="addee-223">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="addee-224">Yakalama gerçekleştiremez `ref struct` değişkenleri lambda ifadeleri veya yerel işlevler.</span><span class="sxs-lookup"><span data-stu-id="addee-224">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="addee-225">Bu kısıtlamalar, yanlışlıkla kullanmayın emin olun. bir `ref struct` bir şekilde yönetilen yığınla Yükselt.</span><span class="sxs-lookup"><span data-stu-id="addee-225">These restrictions ensure you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="addee-226">`readonly ref struct` Türü</span><span class="sxs-lookup"><span data-stu-id="addee-226">`readonly ref struct` type</span></span>

<span data-ttu-id="addee-227">Bir yapı olarak bildirme `readonly ref` avantajları ve kısıtlamaları birleştirir `ref struct` ve `readonly struct` bildirimleri.</span><span class="sxs-lookup"><span data-stu-id="addee-227">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> 

<span data-ttu-id="addee-228">Aşağıdaki örnek, bildirimi gösterir `readonly ref struct`.</span><span class="sxs-lookup"><span data-stu-id="addee-228">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="addee-229">Sonuçları</span><span class="sxs-lookup"><span data-stu-id="addee-229">Conclusions</span></span>

<span data-ttu-id="addee-230">Bu geliştirmeler C# diline burada bellek ayırmaları gerekli performansı elde etmek için kritik olabilir performans kritik algoritmalar için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="addee-230">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="addee-231">Yazdığınız kod bu özellikleri sık kullanmadığınız bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="addee-231">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="addee-232">Ancak, bu geliştirmeler, .NET Framework'teki farklı konumlarda uyarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="addee-232">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="addee-233">Giderek daha fazla API yaparken bu özelliklerini kullanmak, kendi uygulamalarınıza performansını artırma görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="addee-233">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
